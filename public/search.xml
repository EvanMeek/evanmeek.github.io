<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何用hexo+github-pages搭建博客]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章. 为何选择hexo hexo博客框架的网上资料较多，技术较为成熟. hexo使用Makrdown进行渲染. hexo只需几部就可部署博客. hexo具有丰富的主题/插件可选. 安装hexo安装Nodejs,Git要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。 大部分发行版自带Git,Nodejs只需要一条命令: apt 1$ sudo apt install nodejs npm pacman 1$ sudo pacman -S nodejs npm 配置Nodejs安装完成Nodejs和Git后还需要设置npm的软件源. 在任意目录下执行如下命令: 1$ npm config set registry https://registry.npm.taobao.org 执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功): 1$ npm config get registry 配置Git注册Github注册Github 创建仓库创建Github仓库 注意: 仓库名必须是name.github.io 例如我的 evanmeek.github.io 需要设置两点: Git身份标识 12$ git config --global user.email "你的邮箱"$ git config --global user.name "你的名字" 推荐把邮箱和名字设置为Github上的邮箱和名字相同 SSH密钥 如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看: 1$ ls ~/.ssh 若没有则创建新的密钥 1$ ssh-keygen -t rsa -C "你的邮箱" 创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。 创建完成后，你会在~/.ssh内看到两个文件 分别是私钥(id_rsa),公钥(id_rsa.pub) 下一步则是需要在Github中添加刚刚生成的密钥 首先登陆Github,打开设置. 如图所示： 下一步找到SSH选项 如图所示： 下一步导入公钥 复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名 1$ cat ~/.ssh/id_rsa.pub 安装hexo前面安装完Nodejs和Git之后可以通过一条命令安装hexo 要使用sudo提权 执行如下命令: 1$ npm install -g hexo-cli 看到Done!之后则为安装成功. 开始搭建初始化hexo博客使用如下命令初始化博客 1$ hexo init &lt;目录&gt; 初始化完成之后目录结构大概是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 下面分别讲下这些文件或目录分别存放了些什么。 主配置文件: _config.yml 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件. 插件信息: package.json 包含了当前hexo博客中安装了哪些插件. 模板目录: scaffolds/ 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染. 资源目录: source/ 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下. 主题目录: themes/ 主题目录，所有的主题都丢在这里。 生成博客执行如下命令创建一篇博文: 1$ hexo n "文章名" hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了! 这一步用于生成静态文件(就是把md转为html的操作) 要在网站目录(就是初始化的目录下)下执行 1$ hexo generate 这个命令可以简化，并且还可以带两个参数 简化+参数:123$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)$ hexo g -w # 可以监视有哪些文件被生成了 配置hexo这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同. 下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。 找到deploy项 修改为: 部署博客部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署 本地部署 执行如下命令: 1$ hexo s 执行完后可以通过localhost:4000进行查看. 部署到Github 1$ hexo d 这样就可以部署到Github了，通过https://你的Github用户名.github.io访问 寻找主题Hexo主题 把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。 使用体验还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客文章插入图片]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。 如何安装安装此插件很简单，你只需要在你的hexo目录下执行如下命令: 1$ npm install hexo-asset-image --save 如果安装速度很慢可以把npm源改为国内源。 点击打开npm源改为国内源的方法 在设置镜像源-&gt;npm国内源下 如何使用第一步首先，我们得先设置主目录(博客目录)下的 _config.yml 文件. 找到 post_asset_folder: 项，将其修改为 true 第二步使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。 然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。 栗子12$ hexo n "test"$ mv test.jpg source/_posts/test 插入图片 123![图片alt](图片地址)# ![test](./test/test.jpng)]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数探幽]]></title>
    <url>%2F2019%2F04%2F24%2FC-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD%2F</url>
    <content type="text"><![CDATA[本章内容 内联函数 引用变量 如何按引用传递函数参数 默认参数 函数重载 函数模板 函数模板具体化 本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步． C++内联函数 说明 内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部． 那么，我们现在就深入到程序内部． 首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成． 当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令． 执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处． 那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销． 所以 C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来． 相当于编译器将使用相应的函数代码替换函数调用． 对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销． 但是 虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快． 结论 我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间． 另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大． _除非_ :该函数被经常调用 使用 使用内联函数只需要做到以下两点即可： 在函数声明前加上关键字inline; 在函数定义前加上关键字inline; 通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方． 可能遇到的问题 在我们编写函数为内联函数时，编译器不一定满足这种要求． 编译器认为该函数过大或识别到函数调用了自己 (内联函数不能递归) . 有些编译器没有启动或实现这种特性． 案例 12345678910111213141516#include &lt;iostream&gt;using namespace std;inline double square(double x) &#123; return x * x; &#125;int main() &#123; double a(2.0), b(5.0), c(0); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; " \tc=" &lt;&lt; c &lt;&lt; endl; square(a); b = square(b); c = square(7 + 1); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; "\tc=" &lt;&lt; c &lt;&lt; endl; return 0;&#125; 该程序的输出为: 12此时a=2 b=5 c=0此时a=4 b=25 c=64 看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的． 也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递. 这使得C++的内联功能远远胜过C语言的宏定义 尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型. 这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参 内联与宏inline是C++新增的特性. C语言使用预处理语句#define来提供宏－－内联代码的原始实现． 例如下面这个例子. 12345#define SQUARE(X) X*Xa = SQUARE(2.0);b = SQUARE(3.2++);c = SQUARE(1+2.3); 上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的． 引用变量引用变量是C++新增的一种复合类型. 引用是为已定义的变量创建了一个别名． 例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同. 引用变量通常的使用场景是作为函数的形参． 通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径． 创建引用变量C++使用 &amp; 用于声明引用，但是它还有另外一个作用：地址运算符。 当&amp;为声明引用时可有这样的一个例子: 12int a;int &amp; b = a; 是否感觉跟指针有点相像呢？ 是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。 上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。 下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int a=1; int &amp; b = a; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; b = 2; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;"b-address:"&lt;&lt;&amp;b&lt;&lt;endl; return 0;&#125; 输出结果为: 123456a:1b:1a:2b:2a-address:0x7ffdd4c4ae74b-address:0x7ffdd4c4ae74 首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。 然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。 再然后，我们输出的不是a和b的值了而是输出它们的地址: 1cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; 此时的&amp;代表的就是地址运算符。 经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a,*p; int b,*p2(&amp;b); *p = a; return 0;&#125; 上述代码是可以编译通过的。 指针在声明时编译器允许不为其进行初始化值 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int a,&amp;b; b = a; return 0;&#125; 如果代码是这样，那么则编译不通过。 我们可以把引用看成cosnt指针，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。 也就是说： 1int a,&amp;b(a); 仅在表示上等同于 12int a;const int *p(&amp;a); 上面提到“仅在表示上等同于“为什么呢，请看下面的例子。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int a(10),&amp;b(a); cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; int c(20); b = c; cout&lt;&lt;"c:"&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; return 0;&#125; 输出结果为: 12345a:10b:10c:20a:20b:20 可以看到最初b引用的是a，但随后b作为c的引用： 1b = c; 这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的. 我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于: 1a = c; 也就是说，这意味着”将c变量的值赋给a变量“。 简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 下面有一段有趣的代码，你们可以看看。 12345int a(10);int *p =&amp;a;int &amp;b = *p;int c(20);*p = &amp;c; 上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinux的安装过程]]></title>
    <url>%2F2019%2F04%2F23%2FManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[获取镜像ManjaroLinux官方提供了多个桌面环境的镜像，分别是: XFCE 特点 系统资源低耗，快速 KDE 特点 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+ GNOME 特点 简单易用，可定制化，美化较为简单，内存占用大 并且ManjaroLinux在国内有4个镜像源可选，分别是: 清华大学 中科大 华为 浙江大学 我们也可以直接使用官方的镜像源获取镜像Manjaro 选择好自己要使用的桌面环境就可以开始制作启动盘了。 制作启动盘Windows: 推荐使用Rufus进行制作启动盘。 下载好后直接选择镜像和要进行制作的U盘，选择开始。 开始时会让你勾选制作方式请选择dd模式 Linux: 只需要执行这几条命令 1$ sudo lsblk #列出系统上的所有磁盘 找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是sdb或sda 如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载. 1$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名， 取消挂载之后就可以进行格式化了. 1$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名. 格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘. 1$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda 如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。 开始安装最好是在网络稳定的环境下进行 第一步如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到: keytable————设置键盘布局 通常默认即可 lang————设置语言 设置为zh_CN，代表汉语 driver————设置使用的驱动是开源的还是不开源的 笔记本双显卡，想省电可以用free。 台式机单显卡，推荐nofree。 Boot————选择这个就开始安装了 第二步等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统) 这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。 标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。 点击后还可以设置一次语言，默认为中文了 然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。 下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。 再下一步就是分区了，这一步是挺重要的，请认真看。 默认情况下有两种选项: 抹除磁盘 将磁盘全部数据清除，分区是Manjaro自动帮你分配的. 这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。 手动分区 选择手动分区之后，你将看到: 如果你是单硬盘(也就是只有一个硬盘,mdzz) 那比较简单(就算有多个也没啥) 点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…) 然后就可以看到有一个空闲空间，选中它，然后可以看到创建按钮可以点击了 然后你就点击吧… 你就可以看到创建分区的窗口，我们要创建的分区是根目录,主目录，引导 引导的挂载点: /boot/efi 记得标记点为:boot 和 esp 根目录的挂载点: / 记得标记点为:root 主目录的挂载点: /home 如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。 要注意的是主目录要选择扩展分区。 下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。 用户名首字母不要大写 密码不要太简单 下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。 静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。 设置镜像源选择一个好的源是使用Linux体验是否良好的一个重要因素。 官方软件包源12$ sudo pacman-mirrors -i -c China -m rank$ sudo pacman -Syu 随便选一个就好，推荐中科大的(USTC). Aur软件包源123$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi$ sudo pacman -Syu 在最后一行输入: 12[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装签名 1$ sudo pacman -S archlinuxcn-keyring npm国内源首先你得先下载npm和nodejs 1$ sudo pacman -S npm nodejs 打开终端输入: 1$ npm config set registry https://registry.npm.taobao.org 测试是否成功: 1$ npm config get registry 如果看到上面这个链接就对了 pip国内源修改~/.pip/pip.conf (没有则创建) 修改为:1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com 你也可以使用其他的源 清华 阿里云 中国科技大学 豆瓣 安装软件首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库 Install Yay 1$ sudo pacman -S yay 安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8 Install Vim 1$ sudo pacman -S Vim Install VSCode 1$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制 Install OracleJDK8 1$ yay -S jdk8 #这里就是由第三方打包了的 Install 搜狗输入法 1$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin 再编辑配置文件~/.xprofile(若没有创建即可) 修改为: 12345export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 注销后就能使用搜狗输入法了 Install IDEA 12$ yay -S intellij-idea-community-edition #社区版 IDEA$ yay -S intellij-idea-ultimate-edition #付费版 IDEA Install CLion 1$ yay -S CLion Install 网易云音乐 1$ sudo pacman -S netease-cloud-music Install Chrome 1$ sudo pacman -S google-chrome 这样就能完成基本的日常使用啦~ 使用体验总结稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux 最终还是选择了Manjaro-kde 非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。 这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>折腾</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
</search>
