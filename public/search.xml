<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux-文件和目录操作命令-1]]></title>
    <url>%2F2019%2F06%2F16%2FLinux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-1%2F</url>
    <content type="text"><![CDATA[2.1 pwd命令 print working diretory 查看当前路径使用pwd命令 例子: 1[evanmeek@EvanLinux ~]$ pwd 输出结果 1/home/evanmeek 选项 说明 -L 显示当前目录的逻辑路径(忽略软链接文件) -P 显示当前目录的物理路径(若有软链接则显示源文件地址) 所谓的软链接相当于快捷方式，例如~/test.txt是/test.txt的软链接，那么我们操作~/test.txt等同于操作/test.txt，详细的软链接将会在后面的ln命令讲解。 2.2 cd 切换目录 change directory 进入某个目录使用cd命令 例子: 123[evanmeek@EvanLinux ~]$ pwd[evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/[evanmeek@EvanLinux /etc/sysctl.d/]$ pwd 输出结果 12/home/evanmeek//etc/sysctl.d/ 选项 说明 -P 进入目录的物理路径 -L 进入目录的逻辑路径 - 进入上次的目录 ~ 进入系统环境变量的HOME目录路径，即当前登录用户的家目录` .. 进入父目录 cd 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录. 例子: 12345678[evanmeek@EvanLinux ~]$ cd Desktop[evanmeek@EvanLinux ~/Desktop]$ pwd[evanmeek@EvanLinux ~]$ cd -[evanmeek@EvanLinux ~]$ pwd[evanmeek@EvanLinux ~]$ cd /etc/systemd/[evanmeek@EvanLinux /etc/systemd/]$ pwd[evanmeek@EvanLinux /etc/systemd/]$ cd ..[evanmeek@EvanLinux /etc/]$ pwd 输出结果 1234~/Desktop/~/etc/systemd//etc/ 2.3 tree以树形结构显示目录下的内容 树形结构可以很清晰的显示出目录的父子级关系。 例子: 1[evanmeek@EvanLinux ~/test]$ tree -L 1 输出结果 123456789.├── dir1│ ├── dir1_1│ └── dir2_2└── dir2 ├── dir1_1 └── dir2_26 directories, 0 files 选项 说明 -a 显示所有文件包括隐藏文件 -d 只显示目录! -f 显示每个文件的绝对路径 -i 不显示树枝 -L levelNum 显示遍历目录的层级，levelNum为层级(数字) -F 显示时根据不同文件类型在文件名结尾处显示不同的符号 例子: 显示隐藏文件 12#假设此目录下有隐藏文件[evanmeek@EvanLinux ~/tmp]$ tree -a 输出结果 1234567891011.├── dir1│ ├── dir1_1│ └── dir2_2├── dir2│ ├── dir1_1│ └── dir2_2├── .file1└── .file26 directories, 2 files 例子: 显示1级层文件完整路径，并不显示树枝 1[evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi . 输出结果 123../dir1./dir2 2.4 mkdir创建目录]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Linux命令行简介-man命令]]></title>
    <url>%2F2019%2F06%2F15%2FLinux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-man%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。 1.2.1 使用man获取命令帮助信息man命令的作用: 查看命令的使用帮助 查看软件服务配置文件 查看系统调用信息 查看C库函数帮助信息 man命令的使用: 1man 参数选项 命令/文件 man命令可选参数: 参数 英文说明 中文说明 1 User Commands 用户命令相关 2 System Calls 系统调用相关 3 C Library Functions C的库函数相关 4 Devices and Special Files 设备与特殊文件相关 5 File Formats and Conventions 文件格式和规则 6 Games et. Al. 游戏及其他 7 Miscellanea 宏，包及其他杂项 8 System Admin tools and Deamons 系统管理员命令和进程 例子: 1234# 查看cp命令的使用帮助man cp# 查看C语言printf函数的使用帮助man 3 printf man命令信息的格式 标签 说明(!表示重点) NAME 命令说明及介绍! SYNOPSIS 命令的基本使用语法! DESCRIPTION 命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS! OPTIONS 命令参数选项说明 COMMANDS 执行某个软件时可附加的软件的命令 FILES 程序涉及的相关文件 EXAMPLES 命令的例子! SEE ALSO 命令相关信息的说明 BUGS(REPORTING BUGS) 命令对应缺陷问题的描述 COPYRIGHT 版权信息相关声明 AUTHOR 作者介绍 man命令信息操作键 操作键 功能说明 Page Down 向下翻页 Page Up 向上翻页 Home 跳转到第一页 End 跳转到最后一页 / 向下查找某个字符 ? 向上查找某个字符 n,N 当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反 q 结束本次man帮助 1.2.2 使用–help参数获取命令帮助信息 例子: 1[evanmeek@EvanLinux ~]$ ls --help 输出如下: 123456789用法：ls [选项]... [文件]...列出给定文件（默认为当前目录）的信息。如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。必选参数对长短选项同时适用。-a, --all 不隐藏任何以. 开始的项目-A, --almost-all 列出除. 及.. 以外的任何项目 --author 与-l 同时使用时列出每个文件的作者-b, --escape 以八进制溢出序列表示不可打印的字符 1.2.3 使用help命令获取命令帮助信息 例子: 1[evanmeek@EvanLinux ~]$ help cd 输出如下: 123456789101112cd: cd [-L|[-P [-e]] [-@]] [目录] 改变 shell 工作目录。 改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME 的值。 变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。 一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH 不会用上变量。 如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个 变量名。如果该变量有值，则它的值被当作 DIR 目录。 1.2.4 使用info获取帮助信息 例子: 1[evanmeek@EvanLinux ~]$ info cd 即可打开cd的文档信息，操作跟man的使用方式相似。 1.2.5 从互联网搜索获取命令帮助信息 Google Bing Github StackOverFlow]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Linux命令行简介-0]]></title>
    <url>%2F2019%2F06%2F15%2FLinux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-0%2F</url>
    <content type="text"><![CDATA[1.1 Linux命令行概述1.1.1 Linux命令行的作用与意义 Linux命令行相比图形界面操作的优点: 快速 批量 自动化 智能化管理 1.1.2 Linux命令行介绍 大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图: 1.1.3 Linux命令行的开启及退出 主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。 12user login:_password:_ 等待你输入用户名密码，密码输入时是不会显示的。 使用exit,logout或者Ctrl+d快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。 1.1.4 Linux命令行提示符介绍 Linux命令提示符分为两种，分别是: $普通用户 #超级管理员(root) 例子: 12[evanmeek@EvanLinux ~]$:_[root@EvanLinux ~]#:_ 其中@前面的为当前登录的用户名(username),@后面的为主机名(hostname)，主机名后面的~为路径，代表了home目录，而$或#分别代表了用户的是超级管理员还是普通用户。 超级管理员从此以后本系列都以root代表。 root与普通用户的区别： root 拥有管理整个系统的权限。 普通用户 权限较少，通常只有查看系统文件的权限，以及管理自身home目录下所有文件的权限。 查看当前登录的用户名:使用whoami查询查看主机名:使用hostname查询 额外技巧: Linux命令提示符由PS1环境变量控制，通过修改PS1环境变量，可以让提示符发生变化，例子如下: 12[evanmeek@EvanLinux ~]$ set|grep PS1PS1='[\u@\h \W]\$' PS1有特殊的变量可供选择，我们可以设置全局配置文件/etc/bashrc或/etc/profile`进行按需配置。 1.1.5 Linux命令行常用快捷键 企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: SecureCRT和XShell,以下快捷键可在此两款软件中使用。 记住常用的快捷键有利于提高效率，常用快捷键由!标注 快捷键 功能说明(!为常用) 最有用的快捷键 tab 命令或路径的补全键，Linux最有用的快捷键! 移动光标快捷键 Ctrl+a 移动光标至行首! Ctrl+e 移动光标至行尾! Ctrl+f 光标向右移动一个字符(等价与方向键右键) Ctrl+b 光标向左移动一个字符(同上) 剪切、粘贴、清楚快捷键 Ctrl+Insert 复制命令行内容! Shift+Insert 粘贴命令行内容! Ctrl+k 剪切(删除)光标处至行尾的字符! Ctrl+u 剪切(删除)光标处至行首的字符! Ctrl+w 剪切(删除)光标前一个单词! Ctrl+y 粘贴上面三个剪切(删除)的字符 Ctrl+c 终止终端正在执行的任务或删除整行字符! Ctrl+h 删除光标前一个字符(等同于Backspace)! 重复执行命令快捷键 Ctrl+d 退出当前Shell命令行! Ctrl+r 搜索命令历史记录! Ctrl+g 退出搜索命令历史记录 控制快捷键 Ctrl+l 清屏(等同于clear命令)! Ctrl+s 锁定终端，使之无法输入 Ctrl+q 解锁锁定终端 Ctrl+z 暂停执行终端运行中的任务! !开头的快捷键命令 !! 执行上一条命令 !pw 执行最近一次以pw开头的命令! !pw:p 打印输出最近以pwd开头的命令，不执行 !num 执行历史命令列表的第num(数字)条命令! !$ 上一条命令的最后一个参数，等同于Esc+. ESC相关 Esc+. 获取上一条命令的最后部分! Esc+b 移动到当前单词的开头 Esc+f 移动到当前单词的结尾 1.2 在Linux命令行下查看命令帮助 man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。 由于篇幅较大，请点击链接单独查看本章附录man命令。 点击访问 1.3 Linux关机、重启、注销命令 关机或重启命令:shutdown 参数选项 说明 -r 重启机器 -P 关闭机器电源(默认) -H 暂停机器，CPU停止工作但不断电 -h 等效-P，除非使用了-H -k 只发送关机提示,不做任何操作 -c 取消关机 例子: 12345678# 立即关机[evanmeek@EvanLinux ~]$ shutdown -h now# 立即重启 [evanmeek@EvanLinux ~]$ shutdonw -r now# 5分钟后关机[evanmeek@EvanLinux ~]$ shutdown -h +5# 1分钟后重启[evanmeek@EvanLinux ~]$ shutdown -r +1 重启或关机命令:halt/poweroff/reboot halt和poweroff都是reboot的链接而已。 reboot和shutdown都是systemctl的链接 本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fctix5安装与配置]]></title>
    <url>%2F2019%2F06%2F14%2Ffcitx5%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。 所需安装的软件包: fcitx5-git 输入法基础框架主程序 fcitx5-chinese-addons-git 简体中文输入的支持，云拼音 fcitx5-gtk-git gtk 程序的支持 fcitx5-qt4-git qt4 的支持 fcitx5-qt5-git qt5 的支持可能还需要： kcm-fcitx5-git 如果你用的是 KDE ，请装这个 fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎 如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法: 否则将改配置文件~/.config/fcitx5/profile 12345678910111213141516171819202122[Groups/0]# Group NameName=Default# LayoutDefault Layout=us# Default Input MethodDefaultIM=pinyin[Groups/0/Items/0]# NameName=keyboard-us# LayoutLayout=[Groups/0/Items/1]# NameName=pinyin# LayoutLayout=[GroupOrder]0=Default 若没有fcitx5这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。 由于fcitx5不能自动启动，我们需要添加环境变量 将如下内容添加到~/.xprofile 1fcitx5 &amp; 然后再将如下内容添加到~/.pam_environment`，没有则创建 123GTK_IM_MODULE=fcitx5XMODIFIERS=@im=fcitxQT_IM_MODULE=fcitx5 KDE用户可以直接在系统设置模块-自动启动设置 默认的皮肤很丑，我们可以使用这个fcitx5-simple-theme 然后你就可以把fcitx4给删了…]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>fcitx5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-Qt模块简介]]></title>
    <url>%2F2019%2F06%2F12%2FLearn-Qt5-Qt%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Qt5分为两个大的模块，分别是Qt Essentials以及Qt Add-Ons以及一些额外的模块和工具． Qt EssentialsQt Essentials是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件． 模块 简述 Qt Core 其他非图形类模块所使用的核心, Qt GUI 图形界面组件的基类，包括了OpenGL. Qt Multimedia 音频，视频，广播和摄像头相关功能. Qt Network 提供跨平台的网络能力． Qt Qml 提供QML使用的C++API. Qt Quick 允许在Qt/C++程序中嵌入 Qt Quick Qt SQL 允许使用SQL访问数据库 Qt Test 提供Qt程序的单元测试能力｜ Qt Webkit 基于WebKit2的实现以及一套全新的QML API Qt Add-OnsQt Add-Ons是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人． 模块 简述 Qt 3D 提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜ Qt Bluetooth 提供用于访问蓝牙无线设备的C++和QML API. Qt Contacts 用于访问地址薄或联系人数据库的C++和QML API. Qt D-Bus Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互 Qt Graphical Effects 提供一系列用于实现图像特效的类 Qt Image Formats 支持图片格式的一系列插件 Qt JS Backend 为V8 JavaScript引擎的移植，仅供QtQML模块内部使用 Qt Location 方便在Qt应用程序中使用OpenGL，保留于Qt4 Qt Organize 使用QML和C++API访问组织事件｜ Qt Print Support 提供对打印功能的支持｜ Qt Publish and Subscribe 为应用程序提供对项目值的读取，导航，订阅等功能. Qt Quick 1 从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容 Qt Script 提供脚本化机制，为了与Qt5兼容 Qt Script Tools 为了使用Qt Script模块的应用程序提供的额外的组件 Qt Sensors 提供访问各类传感器的QML和C++接口. Qt Service Framework 提供客户端发现其他设备的服务. Qt SVF 提供渲染和创建SVG文件的功能． Qt System Info 提供一套API，用于发现系统相关的信息. Qt Tools 提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools. Qt Versit 提供了对Versit API的支持． Qt Wayland 仅用于Linux平台，用户替代QWS Qt WebKit 从Qt4 一直来的基于WebKit1和QWidget的API Qt Widgets 使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框 Qt XML SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer Qt XML Patterns 提供对XPath,XQuery,XSLT和XML Schema验证的支持．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C_++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-自定义信号槽]]></title>
    <url>%2F2019%2F06%2F11%2FLearn-Qt5-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性． 我们通过一个新闻和订阅者的例子讲解典型的观察者模式． 有一个报纸类Newspaper，有一个订阅者类Subscriber，Subscriber可订阅Newspaper，订阅后若Newspaper有了新内容，那么Subscriber则会立即得到通知． 上面这个案例的观察者是Subscriber，被观察者则是Newspaper．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者． 下面，我们将用Qt的信号槽实现上面的的案例． 12345678910111213141516171819202122232425262728293031323334353637383940414243//newspaper.h#include &lt;QObject&gt;class NewsPaper : public QObject &#123; Q_OBJECTpublic: NewsPaper(const QString &amp;name) : m_name(name) &#123;&#125; void send() &#123; emit newPaper(m_name); &#125;signals: void newPaper(const QString &amp;name);private: QString m_name;&#125;;//reader.h#include &lt;QObject&gt;class Reader : public QObject &#123; Q_OBJECTpublic: void receiverNewsPaper(const QString &amp;name)&#123; qDebug()&lt;&lt;"Newpaper:"&lt;&lt;name; &#125;&#125;;//main.cpp#include &lt;QCoreApplication&gt;#include &lt;newspaper.h&gt;#include &lt;reader.h&gt;int main(int argc, char *argv[]) &#123; QCoreApplication a(argc, argv); NewsPaper paper("xx与xxx结婚了!"); Reader reader; QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader, &amp;Reader::receiverNewsPaper); paper.send(); return a.exec();&#125; 运行结果: 1Newpaper:xx与xxx结婚了! 我们看到Reader类和Newspaper类都继承了QObject 类，在Qt中，只有继承了QObject类的类才具有信号槽的能力．凡是Object类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上Q_OBJECT．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内． 再看Newspaper类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据. Newspaper类的send()函数比较简单，只有一条语句emit newPaper(m_name);. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出newPaper()信号．如果有接受者关注这个信号， 那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字m_name以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移． Reader类是接受信号的，所以我们也需要继承QObject，并且添加Q_OBJECT宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义． main函数中，我们首先创建了Newspaper和Reader两个独享，然后使用QObject::connect()函数．这个然后我们调用Newspaper的send()函数．这个函数只有一个语句：发出信号．由于我们将Newspaper的信号和Reader的槽函数进行了连接，当这个信号发出时，那么将会自动调用Reader的槽函数． 总结自定义信号槽需要注意的事项: 发送者和接收者都需要的是QObject的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外． 使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码； 使用emit发送信号 使用QObject::connect()函数连接信号和槽.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-信号槽]]></title>
    <url>%2F2019%2F06%2F10%2FLearn-Qt5-%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一. 信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号. 但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号． 简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发． 下面看代码: 123456789101112#include &lt;QApplication&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); QPushButton button("Quit"); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit); button.show(); return a.exec();&#125; 编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序． 下面我们分析一下QObject::connect这个函数. 首先它拥有以下几种重载 123456789101112131415161718QMetaObject::Connection connect(const QObject *, const char *, const QObject *, const char *, Qt::ConnectionType);QMetaObject::Connection connect(const QObject *, const QMetaMethod &amp;, const QObject *, const QMetaMethod &amp;, Qt::ConnectionType);QMetaObject::Connection connect(const QObject *, const char *, const char *, Qt::ConnectionType) const;QMetaObject::Connection connect(const QObject *, PointerToMemberFunction, const QObject *, PointerToMemberFunction, Qt::ConnectionType)QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor); 每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法: 1connect(sender,signal,receiver,slot); connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数． 简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数． 根据这个常用的形式，我们可以依次分析connect的重载． 第一种 sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理． 第二种 sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较 第三种 sender仍为const Object，而signal和slot则是const char，这里的reveiver被省略了，它由this指针代替. 第四种 sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针． 第五种 注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式. 经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别． 信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年的规划]]></title>
    <url>%2F2019%2F06%2F09%2F2019%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。 书籍《标准C++入门与编程实践》————————————————————已读完《Linux系统管理完全手册》————————————————————在读《Vim实用技巧》——————————————————————————————未读《计算机网络教程》———————————————————————————未读《Qt5编程入门》——————————————————————————————在读 想学但未学Adobe PhotoshopAdobe AfterEffectsAdobe Primiere 生活想多拿起相机拍拍美好的世界， 想找个女朋友， 想减肥， 想写操作系统….]]></content>
      <categories>
        <category>分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-HelloWorld]]></title>
    <url>%2F2019%2F06%2F08%2FLearn-Qt5-HelloWorld%2F</url>
    <content type="text"><![CDATA[当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选． 那么就让我们从Qt5的HelloWorld开始吧! 第一步先创建一个项目 可以使用快捷键 Ctrl+N 即可呼出创建项目的菜单 创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分 HelloWorld.pro: Qt的工程文件，由qmake处理 main.cpp: 里面就是main函数 mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。 至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。 现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。 修改main.cpp文件 1234567891011#include &lt;QApplication&gt;#include &lt;QLabel&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QLabel label("HelloWorld"); label.show(); return a.exec();&#125; 再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的命名空间与作用域]]></title>
    <url>%2F2019%2F05%2F30%2FC-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决． 命名空间 也称为名字空间，可以解决多模块同名冲突的问题 命名空间的作用在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突． 解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间． 定义命名空间定义命名空间很简单只需要使用namespace关键字即可 我们可以定义一个命名空间将自己的类，函数或对象包括起来: 123456789101112131415namespace myspace&#123; class Test&#123; public: int a; Test(int a):this-&gt;a(a)&#123;&#125; &#125;; Test t(10);&#125;int main()&#123; using namespace myspace; Test t(20); cout&lt;&lt;t.a&lt;&lt;endl;&#125; 与类的成员类似，这些对象，函数，类，被称为名字空间的成员． using声明 using namespace 命名空间名; 在前面的内容中，已经不知不觉地使用上了名字空间，例如: 12using namespace std;cout&lt;&lt;"hello"&lt;&lt;endl; using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl. using指令倘若我们只需要使用std命名空间中的cout和endl成员，那么可以通过using指令指定待使用的命名空间的成员. 123using std::cout;using std::endl;cout&lt;&lt;"hello"&lt;&lt;endl; using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点. 命名空间的别名如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分. 123namespace myStd = std;myStd::cout&lt;&lt;"hello"&lt;&lt;myStd::endl; 其中myStd作为std命名空间的别名． 作用域 可以简称为域,是指对象的可见性问题 C++目前支持3种作用域: 局部作用域(local scope); 名字作用域(namespace scope); 类域(calss scope); 局部作用域在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用． 例如，函数体，循环体都是局部作用域: 12345void foo()&#123; int a(10);&#125;//error a超过了作用域，访问不到foo()函数内部的a变量cout&lt;&lt;a&lt;&lt;endl; 12345for(int i=0;i&lt;100;i++)&#123; cout&lt;&lt;i&lt;&lt;endl;&#125;//error i超过了for的作用域，i是for的局部变量cout&lt;&lt;i&lt;&lt;endl; 提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错. 下面再看一个case语句块的作用域 1234567891011int choose(-1);cin&gt;&gt;choose;switch(choose)&#123; case 0: string str; break; case 1: //error:重定义了str string str; break;&#125; 若不用{}将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下: 123456789101112131415int choose(-1);cin&gt;&gt;choose;switch(choose)&#123; case 0: &#123; string str; break; &#125; case 1: &#123; //error:重定义了str string str; break; &#125;&#125; 我们通过加上{}使得给每个case块加上了不同的作用域，也就解决了重定义的问题． 函数的作用域函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问． 函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制． 123456void foo(int i)&#123; //正常访问i变量 cout&lt;&lt;i&lt;&lt;endl;&#125;//error 未声明i变量cout&lt;&lt;i&lt;&lt;endl; 当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的 123456void foo(int i)&#123; cout&lt;&lt;i&lt;&lt;endl; if(i&gt;0)&#123; foo(i/2); &#125;&#125; 局部变量的存储类型你可能听说过:自动存储类型，静态存储类型，但是你听过寄存器存储类型么? 不同的存储类型，决定了C++编译器存储这些属性的空间和方式. 自动存储类型在默认情况下，我们定义的变量就属于自动存储类型 1234void foo()&#123; int a(10); cout&lt;&lt;a&lt;&lt;endl;&#125; 在foo()函数体执行完毕后a变量将会自动释放，我们也可以换种写法: 1234void foo()&#123; auto int a(10); cout&lt;&lt;a&lt;&lt;endl;&#125; 这样做只不过为了显式的说明这个是个自动存储类型的变量 我们还可以使用类函数观测自动存储类型的销毁时间: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Test &#123;public: int a; Test(int a); ~Test();&#125;;Test::Test(int a) : a(a) &#123; cout &lt;&lt; "创建[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl;&#125;Test::~Test() &#123; cout &lt;&lt; "销毁[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl;&#125;int main() &#123; Test t(10); Test t1(20); return 0;&#125; 输出结果 123456创建[0x7fff82f501c0]创建[0x7fff82f501c4]销毁[0x7fff82f501c4]销毁[0x7fff82f501c0]Process finished with exit code 0 以上代码就可观测到自动存储类型变量的自动销毁过程． 注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义． 1234void *foo()&#123; auto Test t(10); return &amp;t;&#125; 寄存器存储类型寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量． 12345void foo()&#123; for (register int i = 0; i &lt; 10000; ++i) &#123; cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上register仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效． 静态存储类型静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁． 请看下面的代码: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Test &#123; int _a;public: Test(int a) : _a(a) &#123; cout &lt;&lt; "创建[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; "销毁[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl; &#125;&#125;;void foo() &#123; //静态变量 static Test t(10); cout &lt;&lt; "t对象已销毁" &lt;&lt; endl;&#125;int main() &#123; //调用第一次 foo(); //调用第二次 foo(); return 0;&#125; 输出结果: 1234创建[0x5645e7afa19c]t对象已销毁t对象已销毁销毁[0x5645e7afa19c] 可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量t依然存在! 常见用法 程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据. 12345678910111213141516#include &lt;iostream&gt;using namespace std;void foo() &#123; static int i(0); i++; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "次调用foo()" &lt;&lt; endl;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) &#123; foo(); &#125; return 0;&#125; 输出结果 12345第1次调用foo()第2次调用foo()第3次调用foo()Process finished with exit code 0 今天就先写到这里，继续学习了. 命名空间域全局域123456789101112131415161718//全局作用域下的varAint varA=100;void foo1()&#123; varA++;&#125;void foo2()&#123; int varA=200; ::varA++; //输出内部作用域的varA cout&lt;&lt;varA&lt;&lt;endl; //输出全局作用域的varA cout&lt;&lt;::varA&lt;&lt;endl;&#125;int main() &#123; foo1(); foo2(); return 0;&#125; 输出结果 1234200102Process finished with exit code 0 最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。 我们使用域操作符”::”来显式的指定作用域。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法-1]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来. 常用算法 本页理解几个常用的算法 冒泡排序冒泡排序是一种稳定的排序算法 稳定即是，如果相邻的元素相同，不会再去进行调换位置 冒排的运作是(从后往前)。 我们操作数组来进行演示。 我们首先定义一个整型数组里面存储几个整型数据 12//待排序的数列int[] nums = &#123;9,6,4,3,10,25&#125;; 基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。 每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。 我们尝试先用大脑来演示排序的过程12345678//未排序时9 6 4 3 10 256 9 3 4 10 25 //第一轮 调换了2次6 3 4 9 10 //第二轮 调换了2次3 4 6 9 //第三轮 调换了2次3 4 6 //第四轮 调换了0次3 4 //第五轮 调换了0次 我们可以看到我们这组数据只需要排序三轮就可以排序成功，排序轮数是数组长度-1轮，调换次数是看数组相邻元素的大小关系，这个我们不用知道，我们只需要记住，排序轮数是数组长度-1就好。 那么在代码中我们要如何将其进行调换呢？ 有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。 了解了基本思路，我们直接进行代码编写吧！ 123456789101112131415161718192021222324252627public class Demo&#123; public static void main(String args[])&#123; //待排序的数列 int[] nums = &#123;9,6,4,3,10,25&#125;; //临时变量，用于调换位置 int temp; //第一层循环，控制轮数 for(int i = 0;i &lt;nums.length;i++)&#123; //第二层，控制每轮要进行排序的元素数量 for(int j = 0;j&lt;nums.length-1-i;j++)&#123; //如果当前元素比后一个元素大那么则调换元素值 if(nums[j]&gt;nums[j+1])&#123; //我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖 temp = nums[j+1]; //把当前元素的值覆盖后一个元素 nums[j+1] = nums[j]; //再把当前元素存入后一个元素的值(刚刚保存在temp变量里的) nums[j] = temp; &#125; &#125; &#125; //遍历输出 for(int num:nums)&#123; System.out.println(num); &#125; &#125;&#125; 刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。 引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码 123456789101112131415161718/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*///这个if不用加，我只是让你们知道是哪些代码if(nums[j]&gt;nums[j+1])&#123; //当前元素的值是与后一个元素值的和 nums[j] = nums[j]+nums[j+1]; //上一行代码等同于 nums[j] = 9 + 6 //执行完上一行代码，nums[j] = 15; //执行完此行代码nums[j+1] = 9 //等价于 nums[j+1]= 15 - 6 nums[j+1] = nums[j]-nums[j+1]; //执行完此行代码nums[j] = 6 //等价于 nums[j] = 15 - 9 nums[j] = nums[j] - nums[j+1];&#125; 第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！ 下一记: 选择排序算法 选择排序算法 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。 上面这个引用是网上随便抄的一个思路。 这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。 我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。 下面我们直接看代码 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; //需要排序的数组 int[] nums = &#123;6, 9, 4, 4, 25, 10&#125;; //记录每轮排序时最小元素的下标 int minIndex; //第一层循环控制轮数 for (int i = 0; i &lt; nums.length - 1; i++) &#123; minIndex = i;//假设当前轮最小元素下标为i //内层循环要记录出当前轮最小元素的下标 for (int j = i + 1; j &lt; nums.length; j++) &#123; //比较两个相邻元素的大小 if (nums[minIndex] &gt; nums[j]) &#123; //由于找到新的最小值，所以记录一下 minIndex = j; &#125; &#125; //如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置 if (minIndex != i) &#123; //下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大 nums[minIndex] += nums[i]; nums[i] = nums[minIndex] - nums[i]; nums[minIndex] -= nums[i]; &#125; &#125; //遍历输出排序后的结果 for (int num : nums) &#123; System.out.println(num); &#125; &#125;&#125; 小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。 下一节，二分查找算法 二分查找法 这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。 二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是: 定义起始查找位，结束查找位 求得数组长度中间值都 如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。 如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。 如果要查找的值等于中间值，那么直接返回中间值的下标即可 如果都没找到，那么返回-1. 看了这个概念，我们还得注意几点 需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。 好了，我们直接看代码吧！ 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; int nums[] = &#123;1,3,5,78,90,100,300&#125;; System.out.println(binarySearch(nums,1)); &#125; /** * 二分查找法 * @param nums 要查找的数列 * @param key 要查找的值 * @return */ static int binarySearch(int[] nums,int key)&#123; //起始下标 int start = 0; //结束下标 int end = nums.length-1; //起始查询的下标不能超过结束下标 while(start&lt;=end)&#123; //中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值 int middle = (start+end)/2; //如果中间下标的值比要查找的值大 if(nums[middle]&gt;key)&#123; //要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找 end = middle-1; &#125;else if(nums[middle]&lt;key)&#123; //二分的右边开始查找 start = middle+1; &#125;else&#123; //如果要查找的值就是二分下标的值，那么直接返回即可 return middle; &#125; &#125; //如果没有查找到那么则返回-1代表没有查找到 return -1; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何自学编程?]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。 今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到， 为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。 0x0 制定目标这个目标最好是十分远大的，并且必须是准确的。 例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。 制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。 0x1 选择方向你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。 当然，我这里是推荐学习C++，虽然它曾经被我的偶像Linus Torvalds臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种hack玩法。 0x2 学习过程在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。 0x21学习心态我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。 0x22学习方法不要问，去调试，去反编译 这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。 多写代码，多讨论，尝试新想法 多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。 多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。 尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。 0x3 充分利用互联网虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。 不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下原子弹制作从入门到精通。这边推荐一个更好的利用搜索引擎的文章点击访问 0x4 读书在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。 推荐书籍以后会写。 0x5 推荐学习C++视频教程 C++书籍 Git视频教程 0x6 其他如果你是Windows系统，那么推荐Visual Studio作为你的编程工具。 如果你是Linux系统，那么推荐CLion作为你的编程工具。 如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。 推荐学习资源:点击访问 0x7 讨论群组]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++读写文件]]></title>
    <url>%2F2019%2F05%2F22%2FC-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一些简单的读写文件的操作。 本篇文章使用C++fstream头文件提供的库函数进行读写操作 请引入#include \&lt;fstream>进行下面的操作。 写入写入文件步骤如下: 实例化ofstream对象，或者fstream对象. ofstream ofs; 打开文件流 ofs.open(const std::string &amp;s,ios_base::openmode=ios_base::out); 写入文件 ofs&lt;&lt;; 关闭文件流 ofs.close(); 注意打开文件流函数的参数分别为路径和打开方式. 常用的打开方式如下: 模式标识 适用对象 描述 ios::int ifstream,fstream 打开输入,默认用于ifstream和fstream ios::out ofstream,fstream 打开输出，默认用于ofstream和fstream ios::trunc ofstream 打开输入，默认用户ofstream ios::ate ifstream 打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错 ios::app ostream,fstream 打开输出，并且将数据输出至文件末尾，相当与追加 iso::binary ifstream,ofstream,fstream 以二进制的方式打开文件，进行输入或输出 以上所有的打开方式可以通过或|运算符进行联合使用，例如: 12//以二进制的方式打开输出ofstream ofs(path,ios::out|ios::binary); 不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作 好的，下面可以看例子了，我们将写入一些数据到一个文件内。 以文本写入 下面将读取两种不同类型的文件以作为案例进行讲解。 1234567891011121314151617181920/** * 写入文件 * @param path 文件路径 * @param context 内容 */void writeFile(string path,string context)&#123; //实例化写入对象 ofstream ofs; //打开输出 ofs.open(path,ios::out); //向文件写入数据 ofs&lt;&lt;context&lt;&lt;endl; //关闭输出 ofs.close();&#125;int main()&#123; //调用 writeFile("./test.txt","测试");&#125; 这样我们就将测试这个段文本信息，写入到当前目录下test.txt文件内了. 以二进制文件写入以二进制文件方式写入，C++提供了write()库函数,它的函数原型是: write(const _CharT* __s, streamsize __n); 其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。 123456789101112131415161718192021222324252627282930class Student &#123;private: char name[64]; int age;public: Student(char name[64], int age) &#123; for (int i = 0; i &lt; sizeof(name); ++i) this-&gt;name[i] = name[i]; this-&gt;age = age; &#125;&#125;;`/** * 写入二进制文件 * @param path */void writeFileByBinary(string path) &#123; //创建输出流对象，并且指定路径和文件打开方式 ofstream ofs(path, ios::out | ios::binary); Student *student = new Student("张三", 18); //写入文件 ofs.write((const char *) student, sizeof(Student)); ofs.close(); delete (student);&#125;int main()&#123; writeFileByBinary("student.bin");&#125; 这里我们将类成员属性的值以二进制的方式写入进一个文件内。 最终文件内的内容人类是看不大懂的。 注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码. 读取 下面将读取两种不同类型的文件以作为案例进行讲解。 以文本文件读取读取有很多种方式，下面将会演示三种，分别是: 逐行读取 逐词读取 逐字符读取 逐字符读取(不推荐)逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。 123456789101112131415161718/** * 逐字符读取 * @param path 路径 */void readFile04(string path) &#123; //实例化读取操作对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //数据存储变量 char cbuffer; //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾. while ((cbuffer = ifs.get()) != EOF) &#123; cout &lt;&lt; cbuffer &lt;&lt; endl; &#125; //关闭文件 ifs.close();&#125; EOF代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。 逐行读取(有两种方式，但都是逐行读取)第一种： 123456789101112131415161718/** * 逐行读取 * @param path 路径 */void readFile02(string path) &#123; //实例化 fstream fs; //打开文件 fs.open(path, ios::in); //用字符数组进行缓存 char buffer[1024] = &#123;0&#125;; //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数) while (fs.getline(buffer, sizeof(buffer))) &#123; cout &lt;&lt; buffer &lt;&lt; endl; &#125; //关闭文件 fs.close();&#125; 使用字符数组作为数据存储容器，用fstream对象的getline()函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用sizeof()是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。 第二种: 123456789101112131415161718/** * 逐行读取 * @param path 路径 */void readFile03(string path) &#123; //实例化读取操作对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //数据存储容器 string buffer; //使用全局函数getline(输入流，可存储的容器)进行逐行读取 while (getline(ifs, buffer)) &#123; cout &lt;&lt; buffer &lt;&lt; endl; &#125; //关闭文件 ifs.close();&#125; 与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数getline(输入对象,数据存储容器),它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。 逐词读取(以空格区分)逐词读取，将会已空格进行区分每个词汇，再读取。 12345678910111213141516171819202122/** * 逐词读取文件 * @param path 文件路径 */void readFile01(string path) &#123; //实例化读取文件对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //判断文件是否能打开 if (!ifs.is_open()) &#123; cout &lt;&lt; "文件打开失败!" &lt;&lt; endl; return; &#125; //字符数组缓存 char buffer[1024] = &#123;0&#125;; //将读取的数据放入缓存区 while (ifs &gt;&gt; buffer) cout &lt;&lt; buffer &lt;&lt; endl; //关闭文件 ifs.close();&#125; 这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。 这种逐词读取的方式是读取对象通过右移运算符把读取的数据存入容器之中，但是是以空格区分每个词汇。 以二进制的方式读取前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。 1234567891011121314/** * 以二进制的方式读取文件 * @param path 路径 */void readFileByBinary(string path) &#123; //创建输入流对象，并且指定路径和文件打开方式 ifstream ifs(path, ios::in | ios::binary); char * c = new char[64]; ifs.read(c, sizeof(c)); cout&lt;&lt;c&lt;&lt;endl;&#125;int main()&#123; readFileByBinary("Student.smi");&#125; 输出结果: 123张三Process finished with exit code 0 这里我们将Student.smi这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。 总结读取文件创建ifstream对象,写入文件创建ofstream对象，fstream对象既可以读又可以写。 操作文件得先打开文件 操作文件完毕得关闭文件 二进制文件读取需要读取二进制格式的文件]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我儿子的博客]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%88%91%E5%84%BF%E5%AD%90%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。 随便截取一个片段，这哥们咋那么傻的可爱。 想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。 PS:痔疮，你看到了别打我 EvanShady的博客]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>欢乐时光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决KDE下部分应用不能使用fcitx中文输入法的问题]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%A7%A3%E5%86%B3KDE%E4%B8%8B%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8fctix%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。 *** 本教程使用fcitx输入法框架。** 第一步首先安装一些必要的软件: 1$ sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin 第二步安装完成后编辑:/etc/environment文件，加上如下内容: 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 第三步注销当前会话，配置输入法为googlepinyin即可使用。 本文参考]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>KDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2F2019%2F05%2F17%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。 什么是友元？友元可以访问类中私有的成员。 它的使用场景又如下几种: 全局函数作友元 类作友元 成员函数做友元 实例下面将通过几个案例，分别演示不同场景下，友元的使用方式。 全局函数作友元本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//先声明Person类，防止下面报错class Person;//声明showPrivateVar函数，防止报错.void showPrivateVar();//定义Person类class Person&#123;private: //私有属性，money,showPrivateVar函数访问的就是这个 double money;public: //声明构造函数 Person();&#125;;//类外定义构造函数Person::Person()&#123; this-&gt;money = 10;&#125;/** * 访问私有成员 */void showPrivateVar()&#123; //实例化Person类对象 Person p; //访问Person对象的私有成员 cout&lt;&lt;"尝试访问Person类的私有属性:"&lt;&lt;p.money&lt;&lt;endl;&#125;int main()&#123; //调用访问私有成员函数 showPrivateVar(); return 0;&#125; 显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。 12345678910class Person&#123; //使showPrivateVar函数作为Person类的友元 friend void showPrivateVar();private: //私有属性，money,showPrivateVar函数访问的就是这个 double money;public: //声明构造函数 Person();&#125;; 运行结果: 123尝试访问Person类的私有属性:10Process finished with exit code 0 我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员. 那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。 类作类的友元这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;//声明类，防止报错class Build;/** * Build类的好朋友类，可以访问它的私有属性 */class FriendForBuild&#123; Build * b;public: //声明构造函数 FriendForBuild(); //声明visit函数 void visit();&#125;;//定义Build类class Build&#123; friend FriendForBuild;private: //私有房间 string privateRoom;public: //公共房间 string publicRoom; /** * 构造函数 */ Build()&#123; this-&gt;privateRoom = "私人卧室"; this-&gt;publicRoom = "公共客厅"; &#125;&#125;;FriendForBuild::FriendForBuild() &#123; b = new Build();&#125;/** * 访问Build类对象的所有成员，包括私有成员 */void FriendForBuild::visit()&#123; cout&lt;&lt;"我正在访问Build类对象的publicRoom成员:"&lt;&lt;b-&gt;publicRoom&lt;&lt;endl; cout&lt;&lt;"我正在访问Build类对象的privateRoom成员:"&lt;&lt;b-&gt;privateRoom&lt;&lt;endl;&#125;int main()&#123; FriendForBuild friendForBuild; friendForBuild.visit(); return 0;&#125; 输出结果: 1234我正在访问Build类对象的publicRoom成员:公共客厅我正在访问Build类对象的privateRoom成员:私人卧室Process finished with exit code 0 可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。 成员函数做友元上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;//声明类，防止报错class Build;/** * Build类的好朋友类，可以访问它的私有属性 */class FriendForBuild&#123; Build * b;public: //声明构造函数 FriendForBuild(); //声明visit函数 void visit();&#125;;//定义Build类class Build&#123; friend void FriendForBuild::visit();private: //私有房间 string privateRoom;public: //公共房间 string publicRoom; /** * 构造函数 */ Build()&#123; this-&gt;privateRoom = "私人卧室"; this-&gt;publicRoom = "公共客厅"; &#125;&#125;;FriendForBuild::FriendForBuild() &#123; b = new Build();&#125;/** * 访问Build类对象的所有成员，包括私有成员 */void FriendForBuild::visit()&#123; cout&lt;&lt;"我正在访问Build类对象的publicRoom成员:"&lt;&lt;b-&gt;publicRoom&lt;&lt;endl; cout&lt;&lt;"我正在访问Build类对象的privateRoom成员:"&lt;&lt;b-&gt;privateRoom&lt;&lt;endl;&#125;int main()&#123; FriendForBuild friendForBuild; friendForBuild.visit(); return 0;&#125; 总结友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinuxTG讨论群组]]></title>
    <url>%2F2019%2F05%2F16%2FManjaroLinuxTG%E8%AE%A8%E8%AE%BA%E7%BE%A4%E7%BB%84%2F</url>
    <content type="text"><![CDATA[创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。 点击加入]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Telegram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux之路]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法. 先说说一些题外话 我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。 第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。 我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢? 某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了…. 好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。 身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。 终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。 自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞! 下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。 说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验） 我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。 我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。 下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了! 解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。 但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。 总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝和浅拷贝的区别]]></title>
    <url>%2F2019%2F05%2F14%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。 浅拷贝我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。 那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。 那什么是拷贝构造函数呢? 拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象 下面看个例子: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; age = f_age; cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //析构函数 ~Human() &#123; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt; h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt; h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 1234567Human有参构造函数调用.李四的年龄为:18李四的年龄为:18Human析构函数调用.Human析构函数调用.Process finished with exit code 0 根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。 浅拷贝的具体代码实现是怎样的呢？请看下面的代码: 12345//默认的拷贝构造函数Human(const Human &amp; h)&#123; name = h.name; age = h.age;&#125; 可与看出，它只是简单的将对象属性的值，进行拷贝。 大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？ 答案是否定的，下面看下深拷贝。 深拷贝什么是深拷贝? 深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景. 下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int *age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; //动态分配内存空间，将age的数据存入堆区 age = new int(f_age); cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //析构函数 ~Human() &#123; //如果age指针变量是空，则释放 if(age !=NULL)&#123; delete age; //防止指针变量成为野指针 age = NULL; &#125; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt;*h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt;*h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 1234567free(): double free detected in tcache 2Human有参构造函数调用.李四的年龄为:18李四的年龄为:18Human析构函数调用.Process finished with exit code 134 (interrupted by signal 6: SIGABRT) 通过输出结果，我们发现，程序发生了错误。 因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。 上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。 由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。 然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。 既然问题找到了，我们就需要进行修改，将这个问题解决。 下面通过深拷贝的方式，让这个bug被修复: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int *age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; //动态分配内存空间，将age的数据存入堆区 age = new int(f_age); cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //拷贝构造函数 Human(const Human &amp; h)&#123; name = h.name; //新开辟内存空间到堆区，存放age所指向的数据。 age = new int(*h.age); cout&lt;&lt;"Human拷贝构造函数调用."&lt;&lt;endl; &#125; //析构函数 ~Human() &#123; //如果age指针变量是空，则释放 if(age !=NULL)&#123; delete age; //防止指针变量成为野指针 age = NULL; &#125; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt;*h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt;*h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 12345678Human有参构造函数调用.李四的年龄为:18Human拷贝构造函数调用.李四的年龄为:18Human析构函数调用.Human析构函数调用.Process finished with exit code 0 程序没有报错，说明我们的bug成功解决了。 上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。 深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。 为什么能避免？ 原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。 两者该如何选择?说得绝对点： 若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。 这时需要使用深拷贝。 说的不那么绝对: 若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经典案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2008年5月12日14时28分04秒]]></title>
    <url>%2F2019%2F05%2F12%2F2008%E5%B9%B45%E6%9C%8812%E6%97%A514%E6%97%B628%E5%88%8604%E7%A7%92%2F</url>
    <content type="text"><![CDATA[图为汶川大地震时某部队空降救灾 0x005·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。 此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。 伤亡人数：69227人遇难，374643人受伤，17923人失踪。 以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。 0x01每年的这个时刻，我都不由自主的想起这个事情。 2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。 那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课， 突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。 这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！ 跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。 宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。 因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。 大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。 晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。 学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。 天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。 0x022008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。 我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。 两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。 这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。 这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。 谷歌当时的博文说道： “当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。” 几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。 全世界的中华儿女在这三分钟连在了一起。 0x03在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。 大家那时候就只有一个身份，就叫中国人。 那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。 况且古往今来，历史诚不欺我。 知乎 ———— 小小白告 汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。 打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。 最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。 多年过去，讲起这个故事，仍旧热泪盈眶。 知乎 ———— 匿名用户 昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。 她给我看她们初中的学校。 我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。 我听了这句话瞬间眼睛红了，那年她初二，今年她研二。 活着，本身就意味着一切。 知乎 ———— 匿名用户 推荐25分钟纪录片:《为了生命》。 本篇文章转载于：阅读原文作者：纯洁的微笑(一个有故事的程序员)]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>社会事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之代码区与全局区]]></title>
    <url>%2F2019%2F05%2F11%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[其实这一篇应该是作为”C++内存四区”的第一篇的。 0x00 内存分区模型C++程序在执行时，内存大方向的可划分为 *四个区域** 代码区: 存放代码的二进制代码，由操作系统进行管理。 全局区: 存放全局变量和静态变量以及常量。 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 内存四区的意义:不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。 0x01 程序运行前在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域 代码区: 存放CPU执行的机器指令 共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。 只读的，为了防止程序意外修改代码的指令，所以有了只读。 如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中, 而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之堆区]]></title>
    <url>%2F2019%2F05%2F10%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[什么是堆区由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收． 如何将数据放在堆区在C++中由new关键字在堆区中开辟内存。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int* func()&#123; //创建局部指针变量，但是数据是存放在堆区的。 int *a_p= new int(10); return a_p;&#125; int main()&#123; int *p = func(); cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出结果为: 110 看到上述代码的创建局部指针变量，但数据存放在栈区是什么意思呢? 其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。 也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之栈区]]></title>
    <url>%2F2019%2F05%2F10%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E6%A0%88%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[什么是栈区栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等.. 操作栈区的注意事项在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址． 因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错． 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int *func()&#123; //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放． int a = 10; //尝试返回局部变量的地址 return &amp;a;&#125;int main()&#123; //接受func的返回值 int *p = func(); //输出p cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出结果: 1Process finished with exit code 139 (interrupted by signal 11: SIGSEGV) 上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题． 其他问题可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端多窗口神器——Screen]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%BB%88%E7%AB%AF%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Screen%2F</url>
    <content type="text"><![CDATA[曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。 曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。 有了Screen,你就可以获得更好的使用终端多窗口的体验。 我想你肯定遇到以下几种情况: ftp传输 系统备份 长时间运行任务 好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。 凶手 SIGHUP 信号 以下资料来自维基百科 SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。 简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。 发送信号在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。 Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。 Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。 Ctrl-\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。 前因后果相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。 更多有关SIGHUP信号的资料，我会在后面的文章进行更新。 开始使用Screen先简单说说什么是Screen: Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。 Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。 1.创建一个screen窗口 1[evanmeek@Evan-PC]# screen 这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。 2.创建窗口+执行命令 1[evanmeek@Evan-PC]# screen vim screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。 3.一个窗口中再有一个窗口中再有一个窗口中… 你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。 4.screen的暂时断开(detach)和重新链接(attach) 比如在screen窗口下用vim编辑C++源文件 1[evanmeek@Evan-PC]# screen vim test.cpp 但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached). 当你做完其他事你就可以找回该会话，进行重新连接: 找到会话 12345[evanmeek@Evan-PC]# screen -lsThere are screens on: 17944.pts-4.EvanLinux (Detached) 14290.server (Detached)2 Sockets in /run/screens/S-evanmeek. 重新连接 1[evanmeek＠Evan-PC]# screen- r 17944 这样就可以恢复pts这个会话的窗口了． 配置你的Screen前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符. 可通过如下键绑定查看所有键绑定． C-a ? 常用的键绑定有： 键绑定 描述 C-a ? 显示所有键绑定信息 C-a w 显示所有窗口列表 C-a C-a 切换到之前显示的窗口 C-a c 创建一个新的运行shell的窗口并切换到该窗口 C-a n 切换到下一个窗口 C-a p 切换到前一个窗口 C-a 0~9 切换到0~9窗口 C-a a 发送C-a到当前窗口 C-a d 暂时断开screen会话 C-a k 杀掉当前窗口 C-a [ 进入拷贝/回滚模式 我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a; ; 我们可以修改它，通过如下格式: -exy x:命令字符 y:转义字符 1[evanmeek@Evan-PC]# screen -e^oo 这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>软件折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的解压与压缩]]></title>
    <url>%2F2019%2F05%2F08%2FLinux%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。 在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。 Linux下有三种主流常用的解压压缩软件可选: gzip (GNUzip) bz2 (bzip2) xz (xzutils) 三个软件的参数相同，只是命令不同: 1$ gzip [参数] &lt;文件名&gt; 1$ bzip2 [参数] &lt;文件名&gt; 1$ xz [参数] &lt;文件名&gt; 可选参数 参数名 作用 -d 解压 -k 压缩时不删除源文件 -r 递归查找目录下的文件，并且压缩 -v 显示详细信息 -t 测试压缩包是否完整 -l 显示压缩包信息 -c 写入标准输出，保持原始文件不变 -1~9 压缩等级 示例: 压缩test.txt，并删除. 1$ gzip test.txt 压缩test.txt，不删除原文件，并且显示信息. 1$ gzip -vk test.txt 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz 1$ gzip -9cvk test.txt test2.txt &gt; test.gz 解压test.gz 1$ gzip -d test.gz 介绍完上面的几种压缩软件，下面介绍一个打包软件tar 我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。 压缩这里注意第一个参数，它们分别代表使用什么压缩软件。 bz21$ tar -jcvf test.tar.bz test/ xz1$ tar -Jcvf test.tar.xz test/ gzip1$ tar -zcvf test.tar.gz test/ 解压只需要看文件名的后缀，然后把参数c改为x即可.x代表解压. 1$ tar -Jxvf test.tar.xz test/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针[基础02]]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[C++指针和数组的操作。 C++中访问数组元素可以使用如下示例进行访问: 123int arr[3]=&#123;0,1,2&#125;;cout&lt;&lt;"第2个元素为:"&lt;&lt;arr[1]&lt;&lt;endl; 想必大家都知道输出的值为:1 那么我们现在可以使用指针进行访问数组元素 数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。 12345int arr[3]=&#123;0,1,2&#125;;int *p = arr;cout&lt;&lt;"p:"&lt;&lt;*p&lt;&lt;endl; 输出结果为: 1p:0 提问: 为什么指针可以指向数组名，而不需要使用引用符(&amp;)？ 疑惑解答: 那是因为在C++中，数组其实就是一块内存空间，然而里面的每个元素也就组成了一块连续的内存空间，而数组名就当任了数组的首地址的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。 通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1]; 12345678int arr[3]=&#123;0,1,2&#125;;int *p = arr;//对指针进行位偏移p++;cout&lt;&lt;"p:"; 输出结果: 1p: 1 上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。 最后利用指针遍历输出数组内的元素 1234567int arr[3] = &#123;0,1,2&#125;;int *p = arr;for(int i = 0;i &lt;3;i++,p++)&#123; std::cout&lt;&lt;*p&lt;&lt;std::endl;&#125; 输出结果: 123012]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针[基础01]]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[开始写C++中比较难理解的几个知识点的笔记。 0x00 空指针用途:给指针初始化值。 特性:空指针不可访问。 为什么不可访问? 因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。 报错例子 12345//定义空指针int *p = NULL;//尝试修改空指针所指向的空间的值,报错!*p = 2; 常用情景 1234567//定义空指针int *p = NULL;int a = 10;//使指针重新指向内存空间,可行!p = &amp;a; 小结 空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。 0x01 野指针说明:指针指向的是非法的内存空间叫做野指针 异常:读取访问权限错误 报错例子: 12345//使指针指向一个未知空间int *p = (int*)0x1010;//尝试修改指向的空间的值,报错!*p = 10; 小结 我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃! 0x02 const修饰指针const修饰指针分为三种场景 const修饰指针————常量指针 const修饰常量————指针常量 const既修饰指针又修饰常量 常量指针 12345678910int a=10,b=20;//定义常量指针const int *p = &amp;a;//尝试修改指针所指向空间的值,报错!*p = 20;//指针重新指向新的空间,可行!p = &amp;b; 看上面的案例，可以得出，常量指针是不能修改所指向的空间的值，但可重新指向新的空间,并且定义时，const关键字是放在指针的左侧的。 指针常量 12345678910int a=10,b=20;//定义指针常量int * const p = &amp;a;//修改指针所指向空间的值,可行!*p=20;//尝试为指针重新指向新的空间，报错!p = &amp;b; 看上面的案例，可以得出，常量指针可修改所指向的空间的值，但不可重新指向新的空间,并且定义时，const关键字是放在指针的右侧的。 既修饰指针又修饰常量 123456789101112int a=10,b=20;//定义同时const修饰指针常量的指针const int * cosnt p = &amp;a;//尝试修改指针所指向的空间的值，报错!*p = 20;//尝试为指针重新指向新的空间，报错!p = &amp;b; 看上面的案例，可以得出，如果指针和常量都被const修饰，那么就和const 引用非常类似了。 小结 常量指针 不可修改所指向的空间的值 可重新指向新的空间 指针常量 可修改所指向的空间的值 不可重新指向新的空间 指针和常量都被const所修饰 不可修改所指向的空间的值 不可重新指向新的空间 小技巧 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>学习笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next插入网易云音乐]]></title>
    <url>%2F2019%2F04%2F30%2Fhexo-next%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[让大爷们在阅读博客时能优哉游哉的听着歌看文章。 获取外链打开网易云音乐官网 找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。 可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧! 插入外链如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的. 如果是想插入到侧边栏 需要编辑next/layout/_macro/sidebar.swig文件 此时我们就需要使用开发者工具插入到自己合适的位置下 可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用hexo+github-pages搭建博客]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章. 为何选择hexo hexo博客框架的网上资料较多，技术较为成熟. hexo使用Makrdown进行渲染. hexo只需几步就可部署博客. hexo具有丰富的主题/插件可选. 安装hexo安装Nodejs,Git要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。 大部分发行版自带Git,Nodejs只需要一条命令: apt 1$ sudo apt install nodejs npm pacman 1$ sudo pacman -S nodejs npm 配置Nodejs安装完成Nodejs和Git后还需要设置npm的软件源. 在任意目录下执行如下命令: 1$ npm config set registry https://registry.npm.taobao.org 执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功): 1$ npm config get registry 配置Git注册Github注册Github 创建仓库创建Github仓库 注意: 仓库名必须是name.github.io 例如我的 evanmeek.github.io 需要设置两点: Git身份标识 12$ git config --global user.email "你的邮箱"$ git config --global user.name "你的名字" 推荐把邮箱和名字设置为Github上的邮箱和名字相同 SSH密钥 如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看: 1$ ls ~/.ssh 若没有则创建新的密钥 1$ ssh-keygen -t rsa -C "你的邮箱" 创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。 创建完成后，你会在~/.ssh内看到两个文件 分别是私钥(id_rsa),公钥(id_rsa.pub) 下一步则是需要在Github中添加刚刚生成的密钥 首先登陆Github,打开设置. 如图所示： 下一步找到SSH选项 如图所示： 下一步导入公钥 复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名 1$ cat ~/.ssh/id_rsa.pub 安装hexo前面安装完Nodejs和Git之后可以通过一条命令安装hexo 要使用sudo提权 执行如下命令: 1$ npm install -g hexo-cli 看到Done!之后则为安装成功. 开始搭建初始化hexo博客使用如下命令初始化博客 1$ hexo init &lt;目录&gt; 初始化完成之后目录结构大概是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 下面分别讲下这些文件或目录分别存放了些什么。 主配置文件: _config.yml 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件. 插件信息: package.json 包含了当前hexo博客中安装了哪些插件. 模板目录: scaffolds/ 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染. 资源目录: source/ 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下. 主题目录: themes/ 主题目录，所有的主题都丢在这里。 生成博客执行如下命令创建一篇博文: 1$ hexo n "文章名" hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了! 这一步用于生成静态文件(就是把md转为html的操作) 要在网站目录(就是初始化的目录下)下执行 1$ hexo generate 这个命令可以简化，并且还可以带两个参数 简化+参数:123$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)$ hexo g -w # 可以监视有哪些文件被生成了 配置hexo这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同. 下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。 找到deploy项 修改为: type为git不能为大写 部署博客部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署 本地部署 执行如下命令:1$ npm install hexo-deployer-git --save 1$ hexo s 执行完后可以通过localhost:4000进行查看. 部署到Github 1$ hexo d 这样就可以部署到Github了，通过https://你的Github用户名.github.io访问 寻找主题Hexo主题 把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。 使用体验还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客文章插入图片]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。 如何安装安装此插件很简单，你只需要在你的hexo目录下执行如下命令: 1$ npm install hexo-asset-image --save 如果安装速度很慢可以把npm源改为国内源。 点击打开npm源改为国内源的方法 在设置镜像源-&gt;npm国内源下 如何使用第一步首先，我们得先设置主目录(博客目录)下的 _config.yml 文件. 找到 post_asset_folder: 项，将其修改为 true 第二步使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。 然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。 栗子12$ hexo n "test"$ mv test.jpg source/_posts/test 插入图片 123![图片alt](图片地址)# ![test](./test/test.jpng)]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数探幽]]></title>
    <url>%2F2019%2F04%2F24%2FC-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD%2F</url>
    <content type="text"><![CDATA[本章内容 内联函数 引用变量 如何按引用传递函数参数 默认参数 函数重载 函数模板 函数模板具体化 本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步． C++内联函数 说明 内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部． 那么，我们现在就深入到程序内部． 首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成． 当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令． 执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处． 那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销． 所以 C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来． 相当于编译器将使用相应的函数代码替换函数调用． 对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销． 但是 虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快． 结论 我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间． 另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大． _除非_ :该函数被经常调用 使用 使用内联函数只需要做到以下两点即可： 在函数声明前加上关键字inline; 在函数定义前加上关键字inline; 通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方． 可能遇到的问题 在我们编写函数为内联函数时，编译器不一定满足这种要求． 编译器认为该函数过大或识别到函数调用了自己 (内联函数不能递归) . 有些编译器没有启动或实现这种特性． 案例 12345678910111213141516#include &lt;iostream&gt;using namespace std;inline double square(double x) &#123; return x * x; &#125;int main() &#123; double a(2.0), b(5.0), c(0); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; " \tc=" &lt;&lt; c &lt;&lt; endl; square(a); b = square(b); c = square(7 + 1); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; "\tc=" &lt;&lt; c &lt;&lt; endl; return 0;&#125; 该程序的输出为: 12此时a=2 b=5 c=0此时a=4 b=25 c=64 看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的． 也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递. 这使得C++的内联功能远远胜过C语言的宏定义 尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型. 这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参 内联与宏inline是C++新增的特性. C语言使用预处理语句#define来提供宏－－内联代码的原始实现． 例如下面这个例子. 12345#define SQUARE(X) X*Xa = SQUARE(2.0);b = SQUARE(3.2++);c = SQUARE(1+2.3); 上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的． 引用变量引用变量是C++新增的一种复合类型. 引用是为已定义的变量创建了一个别名． 例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同. 引用变量通常的使用场景是作为函数的形参． 通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径． 创建引用变量C++使用 &amp; 用于声明引用，但是它还有另外一个作用：地址运算符。 当&amp;为声明引用时可有这样的一个例子: 12int a;int &amp; b = a; 是否感觉跟指针有点相像呢？ 是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。 上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。 下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int a=1; int &amp; b = a; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; b = 2; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;"b-address:"&lt;&lt;&amp;b&lt;&lt;endl; return 0;&#125; 输出结果为: 123456a:1b:1a:2b:2a-address:0x7ffdd4c4ae74b-address:0x7ffdd4c4ae74 首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。 然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。 再然后，我们输出的不是a和b的值了而是输出它们的地址: 1cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; 此时的&amp;代表的就是地址运算符。 经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a,*p; int b,*p2(&amp;b); *p = a; return 0;&#125; 上述代码是可以编译通过的。 指针在声明时编译器允许不为其进行初始化值 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int a,&amp;b; b = a; return 0;&#125; 如果代码是这样，那么则编译不通过。 我们可以把引用看成cosnt指针，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。 也就是说： 1int a,&amp;b(a); 仅在表示上等同于 12int a;const int *p(&amp;a); 上面提到“仅在表示上等同于“为什么呢，请看下面的例子。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int a(10),&amp;b(a); cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; int c(20); b = c; cout&lt;&lt;"c:"&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; return 0;&#125; 输出结果为: 12345a:10b:10c:20a:20b:20 可以看到最初b引用的是a，但随后b作为c的引用： 1b = c; 这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的. 我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于: 1a = c; 也就是说，这意味着”将c变量的值赋给a变量“。 简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 下面有一段有趣的代码，你们可以看看。 12345int a(10);int *p =&amp;a;int &amp;b = *p;int c(20);*p = &amp;c; 上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。 将]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinux的安装过程]]></title>
    <url>%2F2019%2F04%2F23%2FManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[获取镜像ManjaroLinux官方提供了多个桌面环境的镜像，分别是: XFCE 特点 系统资源低耗，快速 KDE 特点 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+ GNOME 特点 简单易用，可定制化，美化较为简单，内存占用大 并且ManjaroLinux在国内有4个镜像源可选，分别是: 清华大学 中科大 华为 浙江大学 我们也可以直接使用官方的镜像源获取镜像Manjaro 选择好自己要使用的桌面环境就可以开始制作启动盘了。 制作启动盘Windows: 推荐使用Rufus进行制作启动盘。 下载好后直接选择镜像和要进行制作的U盘，选择开始。 开始时会让你勾选制作方式请选择dd模式 Linux: 只需要执行这几条命令 1$ sudo lsblk #列出系统上的所有磁盘 找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是sdb或sda 如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载. 1$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名， 取消挂载之后就可以进行格式化了. 1$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名. 格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘. 1$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda 如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。 开始安装最好是在网络稳定的环境下进行 第一步如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到: keytable————设置键盘布局 通常默认即可 lang————设置语言 设置为zh_CN，代表汉语 driver————设置使用的驱动是开源的还是不开源的 笔记本双显卡，想省电可以用free。 台式机单显卡，推荐nofree。 Boot————选择这个就开始安装了 第二步等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统) 这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。 标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。 点击后还可以设置一次语言，默认为中文了 然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。 下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。 再下一步就是分区了，这一步是挺重要的，请认真看。 默认情况下有两种选项: 抹除磁盘 将磁盘全部数据清除，分区是Manjaro自动帮你分配的. 这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。 手动分区 选择手动分区之后，你将看到: 如果你是单硬盘(也就是只有一个硬盘,mdzz) 那比较简单(就算有多个也没啥) 点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…) 然后就可以看到有一个空闲空间，选中它，然后可以看到创建按钮可以点击了 然后你就点击吧… 你就可以看到创建分区的窗口，我们要创建的分区是根目录,主目录，引导 引导的挂载点: /boot/efi 记得标记点为:boot 和 esp 根目录的挂载点: / 记得标记点为:root 主目录的挂载点: /home 如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。 要注意的是主目录要选择扩展分区。 下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。 用户名首字母不要大写 密码不要太简单 下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。 静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。 设置镜像源选择一个好的源是使用Linux体验是否良好的一个重要因素。 官方软件包源12$ sudo pacman-mirrors -i -c China -m rank$ sudo pacman -Syu 随便选一个就好，推荐中科大的(USTC). Aur软件包源123$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi$ sudo pacman -Syu 在最后一行输入: 12[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装签名 1$ sudo pacman -S archlinuxcn-keyring npm国内源首先你得先下载npm和nodejs 1$ sudo pacman -S npm nodejs 打开终端输入: 1$ npm config set registry https://registry.npm.taobao.org 测试是否成功: 1$ npm config get registry 如果看到上面这个链接就对了 pip国内源修改~/.pip/pip.conf (没有则创建) 修改为:1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com 你也可以使用其他的源 清华 阿里云 中国科技大学 豆瓣 安装软件首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库 Install Yay 1$ sudo pacman -S yay 安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8 Install Vim 1$ sudo pacman -S Vim Install VSCode 1$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制 Install OracleJDK8 1$ yay -S jdk8 #这里就是由第三方打包了的 Install 搜狗输入法 1$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin 再编辑配置文件~/.xprofile(若没有创建即可) 修改为: 12345export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 注销后就能使用搜狗输入法了 Install IDEA 12$ yay -S intellij-idea-community-edition #社区版 IDEA$ yay -S intellij-idea-ultimate-edition #付费版 IDEA Install CLion 1$ yay -S CLion Install 网易云音乐 1$ sudo pacman -S netease-cloud-music Install Chrome 1$ sudo pacman -S google-chrome 这样就能完成基本的日常使用啦~ 使用体验总结稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux 最终还是选择了Manjaro-kde 非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。 这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>折腾</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
</search>
