<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的Linux之路</title>
      <link href="/2019/05/15/%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/05/15/%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.</p><a id="more"></a><p>先说说一些题外话</p><p>我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。</p><p>第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。</p><p>我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了….</p><p>好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。</p><p>身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。</p><p>终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。</p><p>自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!</p><p>下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。</p><p>说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）</p><p>我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。</p><p>我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。</p><p>下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!</p><p>解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。</p><p>但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。</p><p>总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。</p>]]></content>
      
      
      <categories>
          
          <category> 个人感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝的区别</title>
      <link href="/2019/05/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/05/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。</p><a id="more"></a><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。</p><p><strong>那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。</strong></p><p>那什么是拷贝构造函数呢?</p><p><strong>拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象</strong></p><p>下面看个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human默认构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Human(<span class="built_in">string</span> f_name, <span class="keyword">int</span> f_age) &#123;</span><br><span class="line">        name = f_name;</span><br><span class="line">        age = f_age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human有参构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human析构函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">h1</span><span class="params">(<span class="string">"李四"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt; h1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class="line">    <span class="function">Human <span class="title">h2</span><span class="params">(h1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h2.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt; h2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Human有参构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human析构函数调用.</span><br><span class="line">Human析构函数调用.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，<strong>这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。</strong></p><p>浅拷贝的具体代码实现是怎样的呢？请看下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的拷贝构造函数</span></span><br><span class="line">Human(<span class="keyword">const</span> Human &amp; h)&#123;</span><br><span class="line">    name = h.name;</span><br><span class="line">    age = h.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可与看出，它只是简单的将对象属性的值，进行拷贝。</p><p>大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？</p><p>答案是否定的，下面看下深拷贝。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>什么是深拷贝?</p><p><strong>深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.</strong></p><p>下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> *age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human默认构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Human(<span class="built_in">string</span> f_name, <span class="keyword">int</span> f_age) &#123;</span><br><span class="line">        name = f_name;</span><br><span class="line">        <span class="comment">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class="line">        age = <span class="keyword">new</span> <span class="keyword">int</span>(f_age);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human有参构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Human() &#123;</span><br><span class="line">        <span class="comment">//如果age指针变量是空，则释放</span></span><br><span class="line">        <span class="keyword">if</span>(age !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> age;</span><br><span class="line">            <span class="comment">//防止指针变量成为野指针</span></span><br><span class="line">            age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human析构函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">h1</span><span class="params">(<span class="string">"李四"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class="line">    <span class="function">Human <span class="title">h2</span><span class="params">(h1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h2.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free(): double free detected in tcache 2</span><br><span class="line">Human有参构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human析构函数调用.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></table></figure><p>通过输出结果，我们发现，程序发生了错误。</p><p>因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。</p><p>上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。</p><p>由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。</p><p>然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。</p><p>既然问题找到了，我们就需要进行修改，将这个问题解决。</p><p>下面通过深拷贝的方式，让这个bug被修复:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> *age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human默认构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Human(<span class="built_in">string</span> f_name, <span class="keyword">int</span> f_age) &#123;</span><br><span class="line">        name = f_name;</span><br><span class="line">        <span class="comment">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class="line">        age = <span class="keyword">new</span> <span class="keyword">int</span>(f_age);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human有参构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    Human(<span class="keyword">const</span> Human &amp; h)&#123;</span><br><span class="line">        name = h.name;</span><br><span class="line">        <span class="comment">//新开辟内存空间到堆区，存放age所指向的数据。</span></span><br><span class="line">        age = <span class="keyword">new</span> <span class="keyword">int</span>(*h.age);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Human拷贝构造函数调用."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Human() &#123;</span><br><span class="line">        <span class="comment">//如果age指针变量是空，则释放</span></span><br><span class="line">        <span class="keyword">if</span>(age !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> age;</span><br><span class="line">            <span class="comment">//防止指针变量成为野指针</span></span><br><span class="line">            age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human析构函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">h1</span><span class="params">(<span class="string">"李四"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class="line">    <span class="function">Human <span class="title">h2</span><span class="params">(h1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h2.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Human有参构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human拷贝构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human析构函数调用.</span><br><span class="line">Human析构函数调用.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>程序没有报错，说明我们的bug成功解决了。</p><p>上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。</p><p>深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。</p><p>为什么能避免？</p><p>原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。</p><h1 id="两者该如何选择"><a href="#两者该如何选择" class="headerlink" title="两者该如何选择?"></a>两者该如何选择?</h1><p><strong>说得绝对点：</strong></p><p>若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。</p><p>这时需要使用深拷贝。</p><p><strong>说的不那么绝对:</strong></p><p>若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 经典案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2008年5月12日14时28分04秒</title>
      <link href="/2019/05/12/2008%E5%B9%B45%E6%9C%8812%E6%97%A514%E6%97%B628%E5%88%8604%E7%A7%92/"/>
      <url>/2019/05/12/2008%E5%B9%B45%E6%9C%8812%E6%97%A514%E6%97%B628%E5%88%8604%E7%A7%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/12/2008年5月12日14时28分04秒/空降.webp" alt="空降"></p><p>  图为汶川大地震时某部队空降救灾  </p><a id="more"></a><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。</p><p>此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。</p><p>伤亡人数：69227人遇难，374643人受伤，17923人失踪。</p><p>以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。</p><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>每年的这个时刻，我都不由自主的想起这个事情。</p><p>2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。</p><p>那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，</p><p>突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。</p><p>这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！</p><p>跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。</p><p>宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。</p><p>因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。</p><p>大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。</p><p>晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。</p><p>学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。</p><p>天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。</p><p><img src="/2019/05/12/2008年5月12日14时28分04秒/操场.webp" alt="操场"></p><h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。</p><p>我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。</p><p>两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。</p><p><img src="/2019/05/12/2008年5月12日14时28分04秒/流量图.webp" alt="流量"></p><p>这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。</p><p>这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。</p><p>谷歌当时的博文说道：</p><p>“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”</p><p>几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。</p><p>全世界的中华儿女在这三分钟连在了一起。</p><h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。</p><p>大家那时候就只有一个身份，就叫中国人。</p><p>那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。</p><p>   况且古往今来，历史诚不欺我。   </p><blockquote><p>知乎 ———— 小小白告</p></blockquote><p>汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。</p><p>打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。</p><p>最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。</p><p>  多年过去，讲起这个故事，仍旧热泪盈眶。  </p><blockquote><p>知乎 ———— 匿名用户</p></blockquote><p>昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。</p><p>她给我看她们初中的学校。</p><p>我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。</p><p>我听了这句话瞬间眼睛红了，那年她初二，今年她研二。</p><p>   活着，本身就意味着一切。   </p><blockquote><p>知乎 ———— 匿名用户</p></blockquote><p>推荐25分钟纪录片:《为了生命》。</p><hr><p>本篇文章转载于：<a href="https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##" target="_blank" rel="noopener">阅读原文</a><br>作者：纯洁的微笑(一个有故事的程序员)</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存四区之代码区与全局区</title>
      <link href="/2019/05/11/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8C%BA/"/>
      <url>/2019/05/11/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p><a id="more"></a><h1 id="0x00-内存分区模型"><a href="#0x00-内存分区模型" class="headerlink" title="0x00 内存分区模型"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p><ul><li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p></li><li><p>全局区: 存放全局变量和静态变量以及常量。</p></li><li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p></li><li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p></li></ul><h2 id="内存四区的意义"><a href="#内存四区的意义" class="headerlink" title="内存四区的意义:"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p><h1 id="0x01-程序运行前"><a href="#0x01-程序运行前" class="headerlink" title="0x01 程序运行前"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p><p>代码区:</p><p>   存放CPU执行的机器指令</p><p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p><p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p><p><img src="/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png" alt="代码区示意图"></p><p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p><p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存四区之堆区</title>
      <link href="/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA/"/>
      <url>/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是堆区"><a href="#什么是堆区" class="headerlink" title="什么是堆区"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p><h1 id="如何将数据放在堆区"><a href="#如何将数据放在堆区" class="headerlink" title="如何将数据放在堆区"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class="line">    <span class="keyword">int</span> *a_p= <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a_p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p><p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p><p><img src="/2019/05/10/C-内存四区之堆区/test.png" alt="堆区"></p><p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存四区之栈区</title>
      <link href="/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E6%A0%88%E5%8C%BA/"/>
      <url>/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E6%A0%88%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是栈区"><a href="#什么是栈区" class="headerlink" title="什么是栈区"></a>什么是栈区</h1><p>栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..</p><h1 id="操作栈区的注意事项"><a href="#操作栈区的注意事项" class="headerlink" title="操作栈区的注意事项"></a>操作栈区的注意事项</h1><p>在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．</p><p>因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试返回局部变量的地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//接受func的返回值</span></span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line">    <span class="comment">//输出p</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure><p>上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端多窗口神器——Screen</title>
      <link href="/2019/05/09/%E7%BB%88%E7%AB%AF%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Screen/"/>
      <url>/2019/05/09/%E7%BB%88%E7%AB%AF%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Screen/</url>
      
        <content type="html"><![CDATA[<p>曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。</p><p>曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。</p><p>有了Screen,你就可以获得更好的使用终端多窗口的体验。</p><a id="more"></a><p>我想你肯定遇到以下几种情况:</p><ul><li><p>ftp传输</p></li><li><p>系统备份</p></li><li><p>长时间运行任务</p></li></ul><p>好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。</p><h1 id="凶手-SIGHUP-信号"><a href="#凶手-SIGHUP-信号" class="headerlink" title="凶手 SIGHUP 信号"></a>凶手 SIGHUP 信号</h1><blockquote><p>以下资料来自维基百科 </p><blockquote><p>SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p></blockquote></blockquote><p>简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。</p><ul><li><p>Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。</p></li><li><p>Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。</p></li><li><p>Ctrl-\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。</p></li></ul><h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。</p><p><strong>更多有关SIGHUP信号的资料，我会在后面的文章进行更新。</strong></p><hr><h1 id="开始使用Screen"><a href="#开始使用Screen" class="headerlink" title="开始使用Screen"></a>开始使用Screen</h1><p>先简单说说什么是Screen:</p><p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。</p><p>Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。</p><p><strong>1.创建一个screen窗口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen</span><br></pre></td></tr></table></figure><p>这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。</p><p><strong>2.创建窗口+执行命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen vim</span><br></pre></td></tr></table></figure><p>screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。</p><p><strong>3.一个窗口中再有一个窗口中再有一个窗口中…</strong></p><p>你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。</p><p><strong>4.screen的暂时断开(detach)和重新链接(attach)</strong></p><p>比如在screen窗口下用vim编辑C++源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen vim test.cpp</span><br></pre></td></tr></table></figure><p>但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).</p><p><img src="/2019/05/09/终端多窗口神器——Screen/detachedInfo.png" alt="挂起提示"></p><p>当你做完其他事你就可以找回该会话，进行重新连接:</p><p>找到会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen -ls</span><br><span class="line">There are screens on:</span><br><span class="line">        17944.pts-4.EvanLinux   (Detached)</span><br><span class="line">        14290.server    (Detached)</span><br><span class="line">2 Sockets in /run/screens/S-evanmeek.</span><br></pre></td></tr></table></figure><p>重新连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek＠Evan-PC]# screen- r 17944</span><br></pre></td></tr></table></figure><p>这样就可以恢复pts这个会话的窗口了．</p><hr><h1 id="配置你的Screen"><a href="#配置你的Screen" class="headerlink" title="配置你的Screen"></a>配置你的Screen</h1><p>前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.</p><p>可通过如下键绑定查看所有键绑定．</p><p><strong>C-a ?</strong></p><p>常用的键绑定有：</p><table><thead><tr><th style="text-align:center">键绑定</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">C-a ?</td><td style="text-align:center">显示所有键绑定信息</td></tr><tr><td style="text-align:center">C-a w</td><td style="text-align:center">显示所有窗口列表</td></tr><tr><td style="text-align:center">C-a C-a</td><td style="text-align:center">切换到之前显示的窗口</td></tr><tr><td style="text-align:center">C-a c</td><td style="text-align:center">创建一个新的运行shell的窗口并切换到该窗口</td></tr><tr><td style="text-align:center">C-a n</td><td style="text-align:center">切换到下一个窗口</td></tr><tr><td style="text-align:center">C-a p</td><td style="text-align:center">切换到前一个窗口</td></tr><tr><td style="text-align:center">C-a 0~9</td><td style="text-align:center">切换到0~9窗口</td></tr><tr><td style="text-align:center">C-a a</td><td style="text-align:center">发送C-a到当前窗口</td></tr><tr><td style="text-align:center">C-a d</td><td style="text-align:center">暂时断开screen会话</td></tr><tr><td style="text-align:center">C-a k</td><td style="text-align:center">杀掉当前窗口</td></tr><tr><td style="text-align:center">C-a [</td><td style="text-align:center">进入拷贝/回滚模式</td></tr></tbody></table><p>我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;</p><p><img src="/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png" alt="默认的命令字符">;</p><p>我们可以修改它，通过如下格式:</p><p><strong>-exy</strong></p><p>x:命令字符</p><p>y:转义字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen -e^oo</span><br></pre></td></tr></table></figure><p>这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．</p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件折腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的解压与压缩</title>
      <link href="/2019/05/08/Linux%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9/"/>
      <url>/2019/05/08/Linux%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<p>当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。</p><a id="more"></a><p>在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。</p><p>Linux下有三种主流常用的解压压缩软件可选:</p><ul><li><p>gzip (GNUzip)</p></li><li><p>bz2 (bzip2)</p></li><li><p>xz (xzutils)</p></li></ul><p>三个软件的参数相同，只是命令不同:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bzip2 [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> xz [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure><blockquote><p>可选参数</p></blockquote><table><thead><tr><th></th><th style="text-align:center">参数名</th><th>作用</th></tr></thead><tbody><tr><td></td><td style="text-align:center">-d</td><td>解压</td><td></td></tr><tr><td></td><td style="text-align:center">-k</td><td>压缩时不删除源文件</td><td></td></tr><tr><td></td><td style="text-align:center">-r</td><td>递归查找目录下的文件，并且压缩</td><td></td></tr><tr><td></td><td style="text-align:center">-v</td><td>显示详细信息</td><td></td></tr><tr><td></td><td style="text-align:center">-t</td><td>测试压缩包是否完整</td><td></td></tr><tr><td></td><td style="text-align:center">-l</td><td>显示压缩包信息</td><td></td></tr><tr><td></td><td style="text-align:center">-c</td><td>写入标准输出，保持原始文件不变</td><td></td></tr><tr><td></td><td style="text-align:center">-1~9</td><td>压缩等级</td><td></td></tr></tbody></table><p><strong>示例:</strong></p><blockquote><p>压缩test.txt，并删除.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip test.txt</span><br></pre></td></tr></table></figure><blockquote><p>压缩test.txt，不删除原文件，并且显示信息.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip -vk test.txt</span><br></pre></td></tr></table></figure><blockquote><p>以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip -9cvk test.txt test2.txt &gt; test.gz</span><br></pre></td></tr></table></figure><blockquote><p>解压test.gz</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip -d test.gz</span><br></pre></td></tr></table></figure><hr><p>介绍完上面的几种压缩软件，下面介绍一个打包软件<strong>tar</strong></p><p>我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。</p><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>这里注意第一个参数，它们分别代表使用什么压缩软件。</p><blockquote><p>bz2<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -jcvf test.tar.bz test/</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>xz<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -Jcvf test.tar.xz test/</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>gzip<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -zcvf test.tar.gz test/</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -Jxvf test.tar.xz test/</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针[基础02]</title>
      <link href="/2019/05/06/C-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8002/"/>
      <url>/2019/05/06/C-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8002/</url>
      
        <content type="html"><![CDATA[<p>C++指针和数组的操作。</p><a id="more"></a><p>C++中访问数组元素可以使用如下示例进行访问:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第2个元素为:"</span>&lt;&lt;arr[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>想必大家都知道输出的值为:1</p><hr><p>那么我们现在可以使用指针进行访问数组元素</p><p>数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"p:"</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:0</span><br></pre></td></tr></table></figure><p><strong>提问:</strong></p><p>为什么指针可以指向数组名，而不需要使用引用符(&amp;)？</p><p><strong>疑惑解答:</strong></p><p>那是因为在C++中，数组其实就是一块内存空间，然而里面的<strong>每个元素也就组成了一块连续的内存空间</strong>，而<strong>数组名就当任了数组的首地址</strong>的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。</p><hr><p>通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对指针进行位偏移</span></span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"p:"</span>;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p: 1</span><br></pre></td></tr></table></figure><p>上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。</p><p><img src="/2019/05/06/C-指针-基础02/指针位偏移.png" alt="位偏移"></p><hr><p>最后利用指针遍历输出数组内的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;<span class="number">3</span>;i++,p++)&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针[基础01]</title>
      <link href="/2019/05/06/C-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8001/"/>
      <url>/2019/05/06/C-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8001/</url>
      
        <content type="html"><![CDATA[<p>开始写C++中比较难理解的几个知识点的笔记。</p><a id="more"></a><h1 id="0x00-空指针"><a href="#0x00-空指针" class="headerlink" title="0x00 空指针"></a>0x00 <strong>空指针</strong></h1><p><strong>用途:给指针初始化值。</strong></p><p><strong>特性:空指针不可访问。</strong></p><p>为什么不可访问?</p><p>因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。</p><p><strong>报错例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义空指针</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改空指针所指向的空间的值,报错!</span></span><br><span class="line">*p = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>常用情景</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义空指针</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使指针重新指向内存空间,可行!</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。</p><h1 id="0x01-野指针"><a href="#0x01-野指针" class="headerlink" title="0x01 野指针"></a>0x01 <strong>野指针</strong></h1><p><strong>说明:指针指向的是非法的内存空间叫做野指针</strong></p><p><strong>异常:读取访问权限错误</strong></p><p><strong>报错例子:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使指针指向一个未知空间</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="number">0x1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改指向的空间的值,报错!</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!</p><h1 id="0x02-const修饰指针"><a href="#0x02-const修饰指针" class="headerlink" title="0x02 const修饰指针"></a>0x02 <strong>const修饰指针</strong></h1><p>const修饰指针分为三种场景</p><ul><li><p>const修饰指针————常量指针</p></li><li><p>const修饰常量————指针常量</p></li><li><p>const既修饰指针又修饰常量</p></li></ul><blockquote><p>常量指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改指针所指向空间的值,报错!</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针重新指向新的空间,可行!</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>看上面的案例，可以得出，<strong>常量指针是不能修改所指向的空间的值，但可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的左侧的</strong>。</p><hr><blockquote><p>指针常量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针常量</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指针所指向空间的值,可行!</span></span><br><span class="line">*p=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试为指针重新指向新的空间，报错!</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>看上面的案例，可以得出，<strong>常量指针可修改所指向的空间的值，但不可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的右侧的</strong>。</p><hr><blockquote><p>既修饰指针又修饰常量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义同时const修饰指针常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * cosnt p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改指针所指向的空间的值，报错!</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试为指针重新指向新的空间，报错!</span></span><br><span class="line"></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>看上面的案例，可以得出，<strong>如果指针和常量都被const修饰，那么就和const 引用非常类似了</strong>。</p><hr><p><strong>小结</strong></p><p>常量指针</p><ul><li>不可修改所指向的空间的值</li><li>可重新指向新的空间</li></ul><p>指针常量</p><ul><li>可修改所指向的空间的值</li><li>不可重新指向新的空间</li></ul><p>指针和常量都被const所修饰</p><ul><li>不可修改所指向的空间的值</li><li>不可重新指向新的空间</li></ul><p><strong>小技巧</strong></p><blockquote><p>辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+next插入网易云音乐</title>
      <link href="/2019/04/30/hexo-next%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
      <url>/2019/04/30/hexo-next%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>让大爷们在阅读博客时能优哉游哉的听着歌看文章。</p><a id="more"></a><h1 id="获取外链"><a href="#获取外链" class="headerlink" title="获取外链"></a>获取外链</h1><p>打开<a href="https://music.163.com" target="_blank" rel="noopener">网易云音乐</a>官网</p><p>找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。</p><p><img src="/2019/04/30/hexo-next插入网易云音乐/01.png" alt="01"></p><p>可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!</p><h1 id="插入外链"><a href="#插入外链" class="headerlink" title="插入外链"></a>插入外链</h1><p><strong>如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.</strong></p><p><strong>如果是想插入到侧边栏</strong></p><p>需要编辑next/layout/_macro/sidebar.swig文件</p><p>此时我们就需要使用开发者工具插入到自己合适的位置下</p><p><img src="/2019/04/30/hexo-next插入网易云音乐/插哪.png" alt="插哪"></p><p>可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 网易云音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用hexo+github-pages搭建博客</title>
      <link href="/2019/04/29/%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/04/29/%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</p><a id="more"></a><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg" alt="逆光"></p><h1 id="为何选择hexo"><a href="#为何选择hexo" class="headerlink" title="为何选择hexo"></a>为何选择hexo</h1><ul><li><p>hexo博客框架的网上资料较多，技术较为成熟.</p></li><li><p>hexo使用Makrdown进行渲染.</p></li><li><p>hexo只需几步就可部署博客.</p></li><li><p>hexo具有丰富的主题/插件可选.</p></li></ul><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><h2 id="安装Nodejs-Git"><a href="#安装Nodejs-Git" class="headerlink" title="安装Nodejs,Git"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p><p>大部分发行版自带Git,Nodejs只需要一条命令:</p><p><strong>apt</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure><p><strong>pacman</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure><h2 id="配置Nodejs"><a href="#配置Nodejs" class="headerlink" title="配置Nodejs"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p><p>在任意目录下执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm config get registry</span><br></pre></td></tr></table></figure><h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><h3 id="注册Github"><a href="#注册Github" class="headerlink" title="注册Github"></a><strong>注册Github</strong></h3><p><a href="https://github.com/join" target="_blank" rel="noopener">注册Github</a></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a><strong>创建仓库</strong></h3><p><a href="https://github.com/new" target="_blank" rel="noopener">创建Github仓库</a></p><p>注意: 仓库名必须是<strong>name.github.io</strong></p><p>例如我的 evanmeek.github.io</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png" alt="创建Github仓库"></p><p>需要设置两点:</p><ul><li>Git身份标识</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.email "你的邮箱"</span><br><span class="line"><span class="meta">$</span> git config --global user.name "你的名字"</span><br></pre></td></tr></table></figure><p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p><ul><li>SSH密钥</li></ul><p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure><p>若没有则创建新的密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "你的邮箱"</span><br></pre></td></tr></table></figure><p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p><p>创建完成后，你会在~/.ssh内看到两个文件</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png" alt="ssh目录"></p><p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p><p>下一步则是需要在Github中添加刚刚生成的密钥</p><p>首先登陆Github,打开设置.</p><p>如图所示：</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png" alt="登陆Github"></p><p>下一步找到SSH选项</p><p>如图所示：</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png" alt="设置SSH"></p><p>下一步导入公钥</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png" alt="导入密钥"></p><p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="安装hexo-1"><a href="#安装hexo-1" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p><p><strong>要使用sudo提权</strong></p><p>执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>看到Done!之后则为安装成功.</p><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="初始化hexo博客"><a href="#初始化hexo博客" class="headerlink" title="初始化hexo博客"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png" alt="hexoinit"></p><p>初始化完成之后目录结构大概是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>下面分别讲下这些文件或目录分别存放了些什么。</p><p>主配置文件: <strong>_config.yml</strong></p><blockquote><p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p></blockquote><p>插件信息: <strong>package.json</strong></p><blockquote><p>包含了当前hexo博客中安装了哪些插件.</p></blockquote><p>模板目录: <strong>scaffolds/</strong></p><blockquote><p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p></blockquote><p>资源目录: <strong>source/</strong></p><blockquote><p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p></blockquote><p>主题目录: <strong>themes/</strong></p><blockquote><p>主题目录，所有的主题都丢在这里。</p></blockquote><hr><h2 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo n "文章名"</span><br></pre></td></tr></table></figure><p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p><p>这一步用于生成静态文件(就是把md转为html的操作)</p><p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo generate</span><br></pre></td></tr></table></figure><p>这个命令可以简化，并且还可以带两个参数</p><p>简化+参数:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p><hr><h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p><p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p><p>找到deploy项</p><p>修改为:</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png" alt="deploy"></p><p><strong>type为git不能为大写</strong></p><hr><h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p><p><strong>本地部署</strong></p><p>执行如下命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo s</span><br></pre></td></tr></table></figure><p>执行完后可以通过localhost:4000进行<a href="localhost:4000" target="_blank" rel="noopener">查看</a>.</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png" alt="本地部署"></p><p><strong>部署到Github</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo d</span><br></pre></td></tr></table></figure><p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p><h1 id="寻找主题"><a href="#寻找主题" class="headerlink" title="寻找主题"></a>寻找主题</h1><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题</a></p><p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href="mailto:the_lty_mail@foxmail.com" target="_blank" rel="noopener">the_lty_mail@foxmail.com</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客文章插入图片</title>
      <link href="/2019/04/29/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2019/04/29/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p><a id="more"></a><h1 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>如果安装速度很慢可以把npm源改为国内源。</p><p><a href="https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/">点击打开npm源改为国内源的方法</a></p><p>在设置镜像源-&gt;npm国内源下</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p><p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p><p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo n "test"</span><br><span class="line"><span class="meta">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure><p>插入图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址)</span><br><span class="line"></span><br><span class="line"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数探幽</title>
      <link href="/2019/04/24/C-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/"/>
      <url>/2019/04/24/C-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/</url>
      
        <content type="html"><![CDATA[<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66"></iframe>--><a id="more"></a><p><strong>本章内容</strong></p><ul><li>内联函数</li><li>引用变量</li><li>如何按引用传递函数参数</li><li>默认参数</li><li>函数重载</li><li>函数模板</li><li>函数模板具体化</li></ul><p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p><hr><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3></blockquote><p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p><p>那么，我们现在就深入到程序内部．</p><p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p><p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p><p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p><p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p><p><strong>所以</strong></p><p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p><p>相当于编译器将使用相应的函数代码替换函数调用．</p><p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p><p><strong>但是</strong></p><p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p><p><strong>结论</strong></p><p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p><p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p><p>_除非_　:该函数被经常调用</p><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3></blockquote><p>使用内联函数只需要做到以下两点即可：</p><ul><li><p>在函数声明前加上关键字<strong>inline</strong>;</p></li><li><p>在函数定义前加上关键字<strong>inline</strong>;</p></li></ul><p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p><p><strong>可能遇到的问题</strong></p><p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p><ul><li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p></li><li><p>有些编译器没有启动或实现这种特性．</p></li></ul><blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    double a(2.0), b(5.0), c(0);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">" \tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    square(a);</span><br><span class="line">    b = square(b);</span><br><span class="line">    c = square(<span class="number">7</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时a=2b=5c=0</span><br><span class="line">此时a=4b=25c=64</span><br></pre></td></tr></table></figure><p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p><p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p><p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p><p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p><p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p><h3 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h3><p>inline是C++新增的特性.</p><p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p><p>例如下面这个例子.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line">a = SQUARE(<span class="number">2.0</span>);</span><br><span class="line">b = SQUARE(<span class="number">3.2</span>++);</span><br><span class="line">c = SQUARE(<span class="number">1</span>+<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure><p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p><hr><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p><p>引用是为已定义的变量创建了一个别名．</p><p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p><p>引用变量通常的使用场景是作为函数的形参．</p><p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p><hr><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p><p>当&amp;为声明引用时可有这样的一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure><p>是否感觉跟指针有点相像呢？</p><p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p><p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p><p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"a-address:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b-address:"</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:1</span><br><span class="line">b:1</span><br><span class="line">a:2</span><br><span class="line">b:2</span><br><span class="line">a-address:0x7ffdd4c4ae74</span><br><span class="line">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure><p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p><p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p><p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a-address:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此时的&amp;代表的就是地址运算符。</p><p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,*p;</span><br><span class="line"><span class="keyword">int</span> b,*p2(&amp;b);</span><br><span class="line">*p = a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以编译通过的。</p><p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,&amp;b;</span><br><span class="line">    b = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码是这样，那么则编译不通过。</p><p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p><p>也就是说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure><p><strong>仅在表示上等同于</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">p</span><span class="params">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure><p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">int a(10),&amp;b(a);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">b = c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"c:"</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:10</span><br><span class="line">b:10</span><br><span class="line">c:20</span><br><span class="line">a:20</span><br><span class="line">b:20</span><br></pre></td></tr></table></figure><p>可以看到最初b引用的是a，但随后b作为c的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br></pre></td></tr></table></figure><p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p><p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = c;</span><br></pre></td></tr></table></figure><p>也就是说，这意味着”将c变量的值赋给a变量“。</p><p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p><p>下面有一段有趣的代码，你们可以看看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p =&amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;b = *p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">*p = &amp;c;</span><br></pre></td></tr></table></figure><p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p><h3 id="将"><a href="#将" class="headerlink" title="将"></a>将</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ManjaroLinux的安装过程</title>
      <link href="/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/23/ManjaroLinux的安装过程/桌面.png" alt="桌面"></p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p><ul><li>XFCE </li></ul><p>特点</p><blockquote><p>系统资源低耗，快速</p></blockquote><ul><li>KDE</li></ul><p>特点</p><blockquote><p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p></blockquote><ul><li>GNOME</li></ul><p>特点</p><blockquote><p>简单易用，可定制化，美化较为简单，内存占用大</p></blockquote><p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/" target="_blank" rel="noopener">清华大学</a></li><li><a href="http://mirrors.ustc.edu.cn/manjaro-cd/" target="_blank" rel="noopener">中科大</a></li><li><a href="https://mirrors.huaweicloud.com/manjaro-cd/" target="_blank" rel="noopener">华为</a></li><li><a href="http://mirrors.zju.edu.cn/manjaro/" target="_blank" rel="noopener">浙江大学</a></li></ul><p>我们也可以直接使用官方的镜像源获取镜像<a href="https://manjaro.org/get-manjaro/" target="_blank" rel="noopener">Manjaro</a></p><p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p><strong>Windows:</strong></p><p>推荐使用<a href="https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe" target="_blank" rel="noopener">Rufus</a>进行制作启动盘。</p><p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p><p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p><hr><p><strong>Linux:</strong></p><p>只需要执行这几条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure><p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p><p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure><p>取消挂载之后就可以进行格式化了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure><p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure><p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png" alt="安装选择界面"></p><p><strong>keytable</strong>————设置键盘布局</p><p>通常默认即可</p><p><strong>lang</strong>————设置语言</p><p>设置为zh_CN，代表汉语</p><p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p><p>笔记本双显卡，想省电可以用free。</p><p>台式机单显卡，推荐nofree。</p><p><strong>Boot</strong>————选择这个就开始安装了</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/开始安装.png" alt="开始安装-01"></p><p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p><p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p><p>点击后还可以设置一次语言，默认为中文了</p><p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p><p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p><p>再下一步就是分区了，这一步是挺重要的，请认真看。</p><p>默认情况下有两种选项:</p><p><strong>抹除磁盘</strong></p><p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p><p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p><p><strong>手动分区</strong></p><p>选择手动分区之后，你将看到:</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/分区.png" alt="分区"></p><p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p><p>那比较简单(就算有多个也没啥)</p><p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p><p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p><p>然后你就点击吧…</p><p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p><blockquote><p>引导的挂载点: /boot/efi</p></blockquote><p>记得标记点为:boot 和 esp</p><blockquote><p>根目录的挂载点: /</p></blockquote><p>记得标记点为:root</p><blockquote><p>主目录的挂载点: /home</p></blockquote><p><img src="/2019/04/23/ManjaroLinux的安装过程/分区标识.png" alt="分区标识"></p><p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p><p>要注意的是主目录要选择扩展分区。</p><p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p><ul><li><p>用户名首字母不要大写</p></li><li><p>密码不要太简单</p></li></ul><p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/摘要.png" alt="摘要"></p><p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p><h2 id="设置镜像源"><a href="#设置镜像源" class="headerlink" title="设置镜像源"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p><h3 id="官方软件包源"><a href="#官方软件包源" class="headerlink" title="官方软件包源"></a>官方软件包源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class="line"><span class="meta">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>随便选一个就好，推荐中科大的(USTC).</p><h3 id="Aur软件包源"><a href="#Aur软件包源" class="headerlink" title="Aur软件包源"></a>Aur软件包源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>在最后一行输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>安装签名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><h3 id="npm国内源"><a href="#npm国内源" class="headerlink" title="npm国内源"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure><p>打开终端输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>测试是否成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure><p>如果看到上面这个链接就对了</p><h3 id="pip国内源"><a href="#pip国内源" class="headerlink" title="pip国内源"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p><p>(没有则创建)</p><p>修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p><p>你也可以使用其他的源</p><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">清华</a></p><p><a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">阿里云</a></p><p><a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">中国科技大学</a></p><p><a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">豆瓣</a></p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p><p>Install Yay</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure><p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p><p>Install Vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure><p>Install VSCode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure><p>Install OracleJDK8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure><p>Install 搜狗输入法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>再编辑配置文件~/.xprofile(若没有创建即可)</p><p>修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure><p>注销后就能使用搜狗输入法了</p><p>Install IDEA</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class="line"><span class="meta">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure><p>Install CLion</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S CLion</span><br></pre></td></tr></table></figure><p>Install 网易云音乐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure><p>Install Chrome</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><p>这样就能完成基本的日常使用啦~</p><h2 id="使用体验总结"><a href="#使用体验总结" class="headerlink" title="使用体验总结"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p><p>最终还是选择了Manjaro-kde</p><p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p><p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png" alt="Manjaro安装过程编写文章时截图"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 折腾 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
