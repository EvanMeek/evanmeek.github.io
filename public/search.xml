<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Do you know Linux?]]></title>
    <url>%2F2019%2F07%2F17%2FDo-you-know-Linux%2F</url>
    <content type="text"><![CDATA[I have been using Linux for about a year and a half.This article let’s talk about Linux. &emsp;Linux is an operating system kernel,In addition to some experts,most Linux users are uing Linux dirtributions.The Linux dirtributions is preintegrated with the Linux operating system and various application software for users. &emsp;The Linux kernel was first released by Linus Trovars on October 5,1999.Although the Linux kernel is develpoed,it does not have the tools included in an operating system,but there is a GNU tool that can be used as a system tool for Linux,so Linux is also called GNU/Linux.Currently,Linux can be used on large computers,supercomputers,mobile phones,tables,routers,televisions,game consoleds and computers,Such as,the Android operating system is based on the Linux kernel. &emsp;You maybe ask,can Linux be used as an operating system for everyday use? I will answer you with certainty,Linux Can do it.This article was broin in Arch Linux,I can do entertainment and work on Linux. &emsp;I love Linux,forever.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is Vim?]]></title>
    <url>%2F2019%2F07%2F14%2FWhat-is-Vim%2F</url>
    <content type="text"><![CDATA[The editor I use every day is VIM.This article introduces the hirstory of the VIM. &emsp;Bram Miller purchased hisr Amiga computer in the late 1980s,At this time,there is no editor vi on his computer. So he started with an open source vi repilica version of Stevie，developed version 1.0 of Vim.The initial goal was to completely copy the function of vi. &emsp;After that,Vim has added countless new features. As the first milestone.version 3.0 of 1944 joined the split window mode,It can edit multiple files simultanesouly in the same terminal. &emsp;At 1996 released Vim 4.0 in 1996 using the version of the GUI.1998 Vim 5.0 version added syntax highlighting.2001 Vim 6.0 version added Code floding,Plugin,Multi-anguage support ,Vertical segmentation window etc.The Vim 7.0 release was released in May 2006 added Spell check,Context-sensitice completion,Tab editing etc. &emsp;The latest version of Vim is now Vim8]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平铺式桌面-从入门到入坟]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%B9%B3%E9%93%BA%E5%BC%8F%E6%A1%8C%E9%9D%A2-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F%2F</url>
    <content type="text"><![CDATA[本文章详细地介绍了我目前的桌面.通过此文章，你可以做到让i3成为你的一把利刃。 首先上图，我的i3桌面. 0x0 i3一、安装i3安装i3很简单，我们直接输入下面这条命令即可 1&gt; sudo pacman -S i3 compton polybar 此时你可能会看到i3-gaps和i3-wm，选择哪个都可以，推荐i3-gpas，但如果你想拥有一个没有配置过的i3，那么你就直接安装i3-wm即可 二、配置i3配置i3通过编辑~/.config/i3/config这个文件进行配置。 我这里已经有配置好的i3，你们可以直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195# i3 config file (v4)## Please see https://i3wm.org/docs/userguide.html for a complete reference!## This config file uses keycodes (bindsym) and was written for the QWERTY# layout.## To get a config file with the same key positions, but for your current# layout, use the i3-config-wizard## Font for window titles. Will also be used by the bar unless a different font# is used in the bar &#123;&#125; block below.font pango:monospace 8# This font is widely installed, provides lots of unicode glyphs, right-to-left# text rendering and scalability on retina/hidpi displays (thanks to pango).#font pango:DejaVu Sans Mono 8# Before i3 v4.8, we used to recommend this one as the default:# font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1# The font above is very space-efficient, that is, it looks good, sharp and# clear in small sizes. However, its unicode glyph coverage is limited, the old# X core fonts rendering does not support right-to-left and this being a bitmap# font, it doesn&apos;t scale on retina/hidpi displays.# use these keys for focus, movement, and resize directions when reaching for# the arrows is not convenientset $up lset $down kset $left jset $right semicolon# use Mouse+Mod1 to drag floating windows to their wanted positionfloating_modifier Mod1# start a terminalbindsym Mod1+Return exec i3-sensible-terminal# kill focused windowbindsym Mod1+Shift+q kill# start dmenu (a program launcher)bindsym Mod1+d exec dmenu_run# There also is the (new) i3-dmenu-desktop which only displays applications# shipping a .desktop file. It is a wrapper around dmenu, so you need that# installed.# bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop# change focusbindsym Mod1+$left focus leftbindsym Mod1+$down focus downbindsym Mod1+$up focus upbindsym Mod1+$right focus right# alternatively, you can use the cursor keys:bindsym Mod1+Left focus leftbindsym Mod1+Down focus downbindsym Mod1+Up focus upbindsym Mod1+Right focus right# move focused windowbindsym Mod1+Shift+$left move leftbindsym Mod1+Shift+$down move downbindsym Mod1+Shift+$up move upbindsym Mod1+Shift+$right move right# alternatively, you can use the cursor keys:bindsym Mod1+Shift+Left move leftbindsym Mod1+Shift+Down move downbindsym Mod1+Shift+Up move upbindsym Mod1+Shift+Right move right# split in horizontal orientationbindsym Mod1+h split h# split in vertical orientationbindsym Mod1+v split v# enter fullscreen mode for the focused containerbindsym Mod1+f fullscreen toggle# change container layout (stacked, tabbed, toggle split)bindsym Mod1+s layout stackingbindsym Mod1+w layout tabbedbindsym Mod1+e layout toggle split# toggle tiling / floatingbindsym Mod1+Shift+space floating toggle# change focus between tiling / floating windowsbindsym Mod1+space focus mode_toggle# focus the parent containerbindsym Mod1+a focus parent# focus the child container#bindsym Mod1+d focus child# move the currently focused window to the scratchpadbindsym Mod1+Shift+minus move scratchpad# Show the next scratchpad window or hide the focused scratchpad window.# If there are multiple scratchpad windows, this command cycles through them.bindsym Mod1+minus scratchpad show# Define names for default workspaces for which we configure key bindings later on.# We use variables to avoid repeating the names in multiple places.set $ws1 &quot;1&quot;set $ws2 &quot;2&quot;set $ws3 &quot;3&quot;set $ws4 &quot;4&quot;set $ws5 &quot;5&quot;set $ws6 &quot;6&quot;set $ws7 &quot;7&quot;set $ws8 &quot;8&quot;set $ws9 &quot;9&quot;set $ws10 &quot;10&quot;# switch to workspacebindsym Mod1+1 workspace $ws1bindsym Mod1+2 workspace $ws2bindsym Mod1+3 workspace $ws3bindsym Mod1+4 workspace $ws4bindsym Mod1+5 workspace $ws5bindsym Mod1+6 workspace $ws6bindsym Mod1+7 workspace $ws7bindsym Mod1+8 workspace $ws8bindsym Mod1+9 workspace $ws9bindsym Mod1+0 workspace $ws10# move focused container to workspacebindsym Mod1+Shift+1 move container to workspace $ws1bindsym Mod1+Shift+2 move container to workspace $ws2bindsym Mod1+Shift+3 move container to workspace $ws3bindsym Mod1+Shift+4 move container to workspace $ws4bindsym Mod1+Shift+5 move container to workspace $ws5bindsym Mod1+Shift+6 move container to workspace $ws6bindsym Mod1+Shift+7 move container to workspace $ws7bindsym Mod1+Shift+8 move container to workspace $ws8bindsym Mod1+Shift+9 move container to workspace $ws9bindsym Mod1+Shift+0 move container to workspace $ws10# reload the configuration filebindsym Mod1+Shift+c reload# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)bindsym Mod1+Shift+r restart# exit i3 (logs you out of your X session)bindsym Mod1+Shift+e exec &quot;i3-nagbar -t warning -m &apos;You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.&apos; -B &apos;Yes, exit i3&apos; &apos;i3-msg exit&apos;&quot;# resize window (you can also use the mouse for that)mode &quot;resize&quot; &#123; # These bindings trigger as soon as you enter the resize mode # Pressing left will shrink the window’s width. # Pressing right will grow the window’s width. # Pressing up will shrink the window’s height. # Pressing down will grow the window’s height. bindsym $left resize shrink width 10 px or 10 ppt bindsym $down resize grow height 10 px or 10 ppt bindsym $up resize shrink height 10 px or 10 ppt bindsym $right resize grow width 10 px or 10 ppt # same bindings, but for the arrow keys bindsym Left resize shrink width 10 px or 10 ppt bindsym Down resize grow height 10 px or 10 ppt bindsym Up resize shrink height 10 px or 10 ppt bindsym Right resize grow width 10 px or 10 ppt # back to normal: Enter or Escape or Mod1+r bindsym Return mode &quot;default&quot; bindsym Escape mode &quot;default&quot; bindsym Mod1+r mode &quot;default&quot;&#125;bindsym Mod1+r mode &quot;resize&quot;# Start i3bar to display a workspace bar (plus the system information i3status# finds out, if available)bar &#123; status_command i3status&#125;######################################################################## automatically start i3-config-wizard to offer the user to create a# keysym-based config which used their favorite modifier (alt or windows)## i3-config-wizard will not launch if there already is a config file# in ~/.i3/config.## Please remove the following exec line:#######################################################################exec i3-config-wizard 将上面的内容粘贴到i3的配置文件内即可 四、美化i3-polybarpolybar是一个快速并且易用的状态显示栏 就如同你们看到的桌面预览图一般，上面的状态栏就是通过polybar实现的 我的polybar已经配置完成了，可以方便的显示工作区的数字，以及窗口的标题，以及CPU,RAM,CPU温度,时间,系统托盘等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353;==========================================================;;; ██████╗ ██████╗ ██╗ ██╗ ██╗██████╗ █████╗ ██████╗; ██╔══██╗██╔═══██╗██║ ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗; ██████╔╝██║ ██║██║ ╚████╔╝ ██████╔╝███████║██████╔╝; ██╔═══╝ ██║ ██║██║ ╚██╔╝ ██╔══██╗██╔══██║██╔══██╗; ██║ ╚██████╔╝███████╗██║ ██████╔╝██║ ██║██║ ██║; ╚═╝ ╚═════╝ ╚══════╝╚═╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═╝;;; To learn more about how to configure Polybar; go to https://github.com/polybar/polybar;; The README contains a lot of information;;==========================================================[colors]background = #cc222222background-alt = #444;foreground = $&#123;xrdb:color7:#222&#125;foreground = #dfdfdfforeground-alt = #555primary = #ffb52asecondary = #e60053alert = #bd2c40[bar/example];monitor = $&#123;env:MONITOR:HDMI1&#125;monitor = $&#123;env:MONITOR:eDP1&#125;width = 100%height = 30;offset-x = 1%;offset-y = 1%radius = 6.0fixed-center = truebackground = $&#123;colors.background&#125;foreground = $&#123;colors.foreground&#125;line-size = 3line-color = #f00border-top-size = 0border-left-size = 0border-right-size = 0border-color = #00000000padding-left = 0padding-right = 2module-margin-left = 1module-margin-right = 2font-0 = ttf-liberation-sans:fixed:pixelsize=12;1font-1 = source han sans cn:pixelsize=12:antialias=false;1font-2 = &quot;Font Awesome 5 Free:style=Solid:pixelsize=12;1&quot;font-3 = &quot;Font Awesome 5 Brands:style=Regular:pixelsize=12;1&quot;font-4 = &quot;material icons:pixelsize=16;3&quot;modules-left = i3modules-center = xwindow;modules-center = modules-right = cpu memory temperature battery date tray-position = righttray-padding = 2tray-background = $&#123;colors.background&#125;cursor-click = pointercursor-scroll = ns-resize[module/xwindow]type = internal/xwindowlabel = %title%width = 50label-maxlen = 45[module/xkeyboard]type = internal/xkeyboardblacklist-0 = num lockformat-prefix = &quot;&quot;format-prefix-foreground = $&#123;colors.foreground-alt&#125;format-prefix-underline = $&#123;colors.secondary&#125;label-layout = %layout%label-layout-underline = $&#123;colors.secondary&#125;label-indicator-padding = 2label-indicator-margin = 1label-indicator-background = $&#123;colors.secondary&#125;label-indicator-underline = $&#123;colors.secondary&#125;[module/filesystem]type = internal/fsinterval = 25mount-0 = /label-mounted = %&#123;F#0a81f5&#125;%mountpoint%%&#123;F-&#125;: %percentage_used%%label-unmounted = %mountpoint% not mountedlabel-unmounted-foreground = $&#123;colors.foreground-alt&#125;[module/bspwm]type = internal/bspwmlabel-focused = %index%label-focused-background = $&#123;colors.background-alt&#125;label-focused-underline= $&#123;colors.primary&#125;label-focused-padding = 2label-occupied = %index%label-occupied-padding = 2label-urgent = %index%!label-urgent-background = $&#123;colors.alert&#125;label-urgent-padding = 2label-empty = %index%label-empty-foreground = $&#123;colors.foreground-alt&#125;label-empty-padding = 2[module/i3]type = internal/i3format = &lt;label-state&gt; &lt;label-mode&gt;index-sort = truewrapping-scroll = falselabel-focused = %name%label-unfocused = %name%label-visible = %name%label-urgent = %name%label-mode-padding = 2label-mode-foreground = #000label-mode-background = $&#123;colors.primary&#125;label-focused-background = $&#123;module/bspwm.label-focused-background&#125;label-focused-underline = $&#123;module/bspwm.label-focused-underline&#125;label-focused-padding = $&#123;module/bspwm.label-focused-padding&#125;label-unfocused-padding = $&#123;module/bspwm.label-occupied-padding&#125;label-visible-background = $&#123;self.label-focused-background&#125;label-visible-underline = $&#123;self.label-focused-underline&#125;label-visible-padding = $&#123;self.label-focused-padding&#125;label-urgent-background = $&#123;module/bspwm.label-urgent-background&#125;label-urgent-padding = $&#123;module/bspwm.label-urgent-padding&#125; |[module/xbacklight]type = internal/xbacklightformat = &lt;label&gt; &lt;bar&gt;label = BLbar-width = 10bar-indicator = |bar-indicator-foreground = #ffbar-indicator-font = 2bar-fill = ─bar-fill-font = 2bar-fill-foreground = #9f78e1bar-empty = ─bar-empty-font = 2bar-empty-foreground = $&#123;colors.foreground-alt&#125;[module/backlight-acpi]inherit = module/xbacklighttype = internal/backlightcard = intel_backlight[module/cpu]type = internal/cpuinterval = 2format-prefix = &quot; &quot;;format-prefix-foreground = $&#123;colors.foreground-alt&#125;;format-underline = #f90000label = %percentage:2%%[module/memory]type = internal/memoryinterval = 2format-prefix = &quot; &quot;;format-prefix-foreground = $&#123;colors.foreground-alt&#125;;format-underline = #4bffdclabel = %percentage_used%%[module/wlan]type = internal/networkinterface = wlp3s0interval = 3.0format-connected = &lt;ramp-signal&gt;;format-connected-underline = #9f78e1label-connected = &quot;%essid%&quot;format-disconnected = ;format-disconnected = &lt;label-disconnected&gt;;format-disconnected-underline = $&#123;self.format-connected-underline&#125;label-disconnected = %ifname% disconnectedlabel-disconnected-foreground = #999999ramp-signal-0 = ramp-signal-1 = ramp-signal-2 = ramp-signal-3 = ramp-signal-4 = animation-packetloss-0 = ⚠animation-packetloss-0-foreground = #ffa64c;ramp-signal-foreground = $&#123;colors.foreground-alt&#125;[module/eth]type = internal/networkinterface = enp0s31f6interval = 3.0format-connected-underline = #55aa55format-connected-prefix = &quot;📶&quot;format-connected-prefix-foreground = $&#123;colors.foreground-alt&#125;label-connected = %local_ip%format-disconnected =;format-disconnected = &lt;label-disconnected&gt;;format-disconnected-underline = $&#123;self.format-connected-underline&#125;;label-disconnected = %ifname% disconnected;label-disconnected-foreground = $&#123;colors.foreground-alt&#125;[module/date]type = internal/dateinterval = 5date = &quot; %Y-%m-%d&quot;;date-alt = &quot; %Y-%m-%d&quot;time = %H:%M;time-alt = %H:%M:%Sformat-prefix = ;format-prefix-foreground = $&#123;colors.foreground-alt&#125;;format-underline = #0a6cf5label = %date% %time%[module/alsa]type = internal/volumeformat-volume = &lt;label-volume&gt; &lt;bar-volume&gt;label-volume = label-volume-foreground = $&#123;root.foreground&#125;format-muted-prefix = &quot; &quot;format-muted-foreground = $&#123;colors.foreground-alt&#125;label-muted = bar-volume-width = 5bar-volume-foreground-0 = #55aa55bar-volume-foreground-1 = #55aa55bar-volume-foreground-2 = #55aa55bar-volume-foreground-3 = #55aa55bar-volume-foreground-4 = #55aa55bar-volume-foreground-5 = #f5a70abar-volume-foreground-6 = #ff5555bar-volume-gradient = falsebar-volume-indicator = |bar-volume-indicator-font = 2bar-volume-fill = ─bar-volume-fill-font = 2bar-volume-empty = ─bar-volume-empty-font = 2bar-volume-empty-foreground = $&#123;colors.foreground-alt&#125;[module/battery]type = internal/batterybattery = BAT0adapter = ADP1full-at = 98format-charging = &lt;animation-charging&gt; &lt;label-charging&gt;format-charging-underline = #ffb52aformat-discharging = &lt;ramp-capacity&gt; &lt;label-discharging&gt;;format-discharging-underline = $&#123;self.format-charging-underline&#125;format-full-prefix = &quot; &quot;;format-full-prefix-foreground = $&#123;colors.foreground-alt&#125;format-full-underline = $&#123;self.format-charging-underline&#125;ramp-capacity-0 = ramp-capacity-1 = ramp-capacity-2 = ramp-capacity-3 = ;ramp-capacity-foreground = $&#123;colors.foreground-alt&#125;animation-charging-0 = animation-charging-1 = animation-charging-2 = animation-charging-3 = ;animation-charging-foreground = $&#123;colors.foreground-alt&#125;animation-charging-framerate = 750[module/temperature]type = internal/temperaturethermal-zone = 0warn-temperature = 60format = &lt;ramp&gt; &lt;label&gt;;format-underline = #f50a4dformat-warn = &lt;ramp&gt; &lt;label-warn&gt;;format-warn-underline = $&#123;self.format-underline&#125;label = %temperature%label-warn = %temperature%label-warn-foreground = $&#123;colors.secondary&#125;ramp-0 = ramp-1 = ramp-2 = ;ramp-foreground = $&#123;colors.foreground-alt&#125;[module/powermenu]type = custom/menuexpand-right = trueformat-spacing = 1label-open = label-open-foreground = $&#123;colors.secondary&#125;label-close =  cancellabel-close-foreground = $&#123;colors.secondary&#125;label-separator = |label-separator-foreground = $&#123;colors.foreground-alt&#125;menu-0-0 = rebootmenu-0-0-exec = rebootmenu-0-1 = power offmenu-0-1-exec = poweroff[settings]screenchange-reload = true[global/wm]margin-top = 5margin-bottom = 5 上面这段配置文件是polybar的配置文件，我们还需要一个启动polybar的脚本 launch.sh 这里的launch.sh可以改名，但是不必须得放在~/.config/polybar目录下，改名后需要修改i3配置文件的第33行。 12345678910#!/usr/bin/env bash# Terminate already running bar instanceskillall -q polybar# Wait until the processes have been shut downwhile pgrep -u $UID -x polybar &gt;/dev/null; do sleep 1; done# Launch bar1 and bar2polybar example &amp; 三、使用i3这一小节，我主要介绍我的配置文件所做的事。 下面的说明并不是将我的配置文件全部进行解读，有些我觉得你们能看懂的我就没写。 set $mod Mod1 设置i3的super为Alt键 new_window pixel 1 设置新窗口的窗口边缘的像素 new_float normal 设置浮动窗口，值为默认 hide_edge_borders 设置窗口边框隐藏 按键 说明 $mod+u 设置边框存在 $mod+y 设置边框像素为1 $mod+n 设置边框隐藏 $mod+Return(回车键) 打开alacritty终端 $mod+Shift+Return 通过alacritty打开ranger $mod+Control+g 打开Chrome $mod+Controll+f 打开Firefox $mod+Shift+q 杀死聚焦窗口 $mod+d 打开rofi $mod+h+j+k+l 将聚焦在窗口之间切换 $mdo+上下左右 同上，只不过用的是方向键 $mod+Shift+h+j+k+l 将聚焦窗口改变排列位置 $mod+Shift+上下左右 同上，只不过用的是方向键 $mod+b 切换至上一个工作区 $mod+Shift+b 将上一个工作区的容器，移动至当前工作区内 $mod+q 切换平铺方式 $mod+f 将聚焦窗口全屏 $mod+s 容器窗口排列方式为堆叠式 $mod+w 容器窗口排列方式为标签式 $mod+e 容器窗口排列方式为平铺式 $mod+Shift+space(空格键) 切换容器窗口为平铺还是浮动 $mod+space 在浮动或平铺窗口之间进行聚焦的切换 $mod+Ctrl+左或右 切换工作区，前或后 $mod+1-8 切换工作区 $mod+Ctrl+1-8 将当前容器的窗口移动至某个工作区 $mod+Shift+1-8 将当前容器移动至某个工作区 $mod+Shift+r 重启i3 $mod+Shift+c 重载i3配置文件 $mod+0 进入系统模式 l 系统模式:锁屏 s 系统模式:挂出 u 系统模式:切换用户 e 系统模式:登出 h 系统模式:休眠 r 系统模式:重启 Shift+s 系统模式:关机 $mod+r 进入窗口大小设置模式 h j k l 设置窗口上下左右的大小 上下左右 同上 Return 退出窗口大小设置模式 触摸板开关 触摸板开关 0x2 rofi一、安装rofi sudo pacman -S rofi 二、配置rofi三、使用rofi0x1 ranger一、安装ranger二、配置ranger三、使用ranger0x2 alacritty一、安装alacritty二、配置alacritty三、使用alacritty0x3 vim一、配置vim0x4 zsh一、安装zsh二、配置zsh0x5 ssr+proxychains一、安装ssr二、配置ssr三、安装proxychains四、配置proxychains五、使用ssr+proxychains实现全应用走代理0x6 fcitx一、安装fcitx二、配置fcitx三、启动fcitx]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>i3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boring Article]]></title>
    <url>%2F2019%2F07%2F12%2FBoring-Article%2F</url>
    <content type="text"><![CDATA[Since I returned to Xinjiang,I have to eat and sleep everyday.I was so bored,then I had this article. &emsp;Befor I came to Xinjiang,I hope I can take many beatuiful pictures,eat my favorite food and do what I want to do.But now the only way to take pictures just can with mobile phone,Cameras can not be used.Every day.I eat with my parents.butI can not eat what I want.Finally,I care too much about me .I thought that home is to be free and easy to call home.I always manage my family,which is called cage! &emsp;In fact.this article is a dissemination of negative energy.If you are unhappy,I am sorry.My father just came back,he said that his business is finished.the rest of the time can enjoy.I hope the next summer life will be enriched!]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCuteSister-1]]></title>
    <url>%2F2019%2F07%2F10%2FMyCuteSister-1%2F</url>
    <content type="text"><![CDATA[The article is the next article of “MyCuteSister”. &emsp;Next article we talk about my sister something not bad and she’s appearance,this article let’s we talk about she’s school work. &emsp;My sister is seven years old,she attended Maria Kindergarten in GuangZhou.When she was a kindergraten student,she was excellent.She often become monitor of class. &emsp;She can also draw.Since she attended kindergraten,almost every week draw a works,So for about two hundred draw works stayed we home. &emsp;She can also dance.She use weekend time learn dance,Since she can’t back bend,thwart split to be dance a complete dance.And She often join Kindergraten activites,Our whole famliy is proud for her. &emsp;By the way,She can also play the piano,Whennever I am bored.I watch the video of her playing the piano,Which make me feel better immediately. &emsp;She will become a Primary Student,Because she went up THE AFFILIATED SCHOOL OF GUANGDONG UNIVERSITY OF FOREIGN STUDIES,Bug she need stay at school,I think I will very miss her. &esp;This is my sister,And I LOVE HER.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCuteSister-0]]></title>
    <url>%2F2019%2F07%2F09%2FMyCuteSister-0%2F</url>
    <content type="text"><![CDATA[Last article is so bad,so this article i want is not bad. &emsp;I have a young sister,she is so cute and pretty.Now I will introduce her.Ok let’s do it. She have a black long hair,and clear and shinning eyes.When she lie on soft reading books，I always think she so beatuiful and cute.At this point,I will ask her,what book are reading? then she always say cartoon book,At this point,I say,Why you read cartoon book? She say,because i like it. Let’s talk about she’s not good,also many children’s problems.It picky eaters,such as,she dislike eggplant，I tell her do not picky eaters,she say ok.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCollegeLife]]></title>
    <url>%2F2019%2F07%2F05%2FMyCollegeLife%2F</url>
    <content type="text"><![CDATA[&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,day and night accompany friend.Of course,including you. &emsp;Three years after,I become a college student，Maybe you guessed this article is about my college life.About at 2019-9-1 start my college lift.I think I have very excited at that time. &emsp;Before school start，I participate in Military training.Remember that time ,about one hundred peoples trained in a groups together,Instructor look we are tired,then he will say:”Everyboby listen! Drop Down!”，In the twinkling of an eye one hundred peoples on the ground lie.This time nobody care isn’t dirty，just look the sky，think，THE SKY SO BEATUIFUL. &emsp;The fight of time，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know’s friend add WeChat Friend，Of course，me too. &emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It’s because he teach for me so many knowledge. &emsp;At the last，I sincerely thank my instructor，Peace!]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fraudster Shop-坑爹商店]]></title>
    <url>%2F2019%2F07%2F05%2FFraudster-Shop-%E5%9D%91%E7%88%B9%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。 Chinese&emsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。 &emsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。 &emsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信的，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?” 我说，老板想都没想说了句,”有啊!”，说着便拿出一小沓U盘，我看了看说道:”老板，这些都不是USB3.0，你拿其他的给我看一下吧!”，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，”你一个小时后再来吧，我这里3.0的U盘卖完了。”，虽然老板说是卖完了，但我大概能知道他根本没有进过USB3.0的货，一直靠着用3.0的价格贩卖2.0的U盘。 &emsp;后来我又找了很多家手机店和电脑店，他们居然都没有USB3.0，并且他们卖的都是USB2.0，更让我吃惊的是，他们全部统一地将USB2.0的U盘卖70-80RMB左右。其中我尝试跟他们讲价，就算是2.0U盘我暂时买个4G的USB2.0还可以装我的i3，我出价30，这是我的最高价了…然后卖家给我说不能卖，最低55，掉价这么快，80直接掉到55，最终没谈成，因为我已经很不想买USB2.0了，更不可能花那么多钱买一个过时的产物。 &emsp;说了这么多，其实就是想让大家以后不要再去实体店买这种电子产品了，当然可能有一些实体店还是正常的价格的，但据我的真实体验，实体店普遍就是要坑小白的，并且就算你指明要USB3.0他还是会拿给你USB2.0看，尝试诱骗你。 &emsp;京东晚上7点下的单，第二天9点就可以取件了，真香。强烈推荐一线城市想买这种小物件直接京东买吧，甚至还有同城送，上午买下午就到，不过要多付点运费。]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超酷-字符文件管理-ranger]]></title>
    <url>%2F2019%2F07%2F03%2F%E8%B6%85%E9%85%B7-%E5%AD%97%E7%AC%A6%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-ranger%2F</url>
    <content type="text"><![CDATA[0x0 什么是ranger?ranger是一个基于文本的文件管理器，由Python编写。 0x1 为什么要选择ranger?ranger具有以下特性: vi风格的快捷键 书签 选择 标签 选项 命令历史 创建符号链接 任务视图 自定义命令 自定义快捷键按 0x2 使用ranger在终端内输入ranger以启动ranger 使用h j k l进行目录之间的进出。 0x3 配置ranger配置文件: rc.conf 基本选项与快捷键设置 commands.py 可在ranger下使用:执行的命令 rifile.conf 文件关联，控制不同文件用不同程序打开 配色方案: ranger默认自带四种配色方案:defalut jungle snow zenburn 使用:set colorscheme scheme进行切换。 自定义配色方案文件放在~/.config/ranger/colorschemes 0x4 我的ranger配置以上传至Github 点击访问 0x5 其他下载地址:点击获取 Arch系: 1&gt; pacman -S ranger]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最快-GPU加速-Alacritty终端]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%9C%80%E5%BF%AB-GPU%E5%8A%A0%E9%80%9F-Alacritty%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[0x0 Alacritty是什么?Alacritty是一个终端仿真器。 在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。 0x1 为什么选择Alacritty?Alacritty是目前性能最强的终端之一. 它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。 Alacritty的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过Alacritty仍然提供了很多配置终端的方面。 0x2 Alacritty的配置Alacritty的配置文件在:~/.config/alacritty/alacritty.yml 0 字体打开alacritty.yml文件，找到Font configuration这行注释，即可修改。 例如: 1234567891011# Font configuration (changes require restart)font: normal: family: Droid Sans Mono style: Regular bold: family: Droid Sans Mono italic: family: Droid Sans Mono 1 配色方案Alacritty官方提供了超多种的配置方案，点击我获取 我们只需要找一个自己喜欢的配色方案将配色代码复制 然后粘贴到alacritty.yml配置文件内即可. 例如:12345678910111213141516171819202122232425262728# Colors (Solarized Dark)colors: # Default colors primary: background: &apos;0x002b36&apos; # base03 foreground: &apos;0x839496&apos; # base0 # Normal colors normal: black: &apos;0x073642&apos; # base02 red: &apos;0xdc322f&apos; # red green: &apos;0x859900&apos; # green yellow: &apos;0xb58900&apos; # yellow blue: &apos;0x268bd2&apos; # blue magenta: &apos;0xd33682&apos; # magenta cyan: &apos;0x2aa198&apos; # cyan white: &apos;0xeee8d5&apos; # base2 # Bright colors bright: black: &apos;0x002b36&apos; # base03 red: &apos;0xcb4b16&apos; # orange green: &apos;0x586e75&apos; # base01 yellow: &apos;0x657b83&apos; # base00 blue: &apos;0x839496&apos; # base0 magenta: &apos;0x6c71c4&apos; # violet cyan: &apos;0x93a1a1&apos; # base1 white: &apos;0xfdf6e3&apos; # base3 2 快捷键默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在alacritty.yml内的Key bindings项下进行修改 并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按Paste键和Copy键位改为Ctrl+C和Ctrl+V。 例子： 12- &#123; key: V, mods: Control, action: Paste &#125;- &#123; key: C, mods: Control, action: Copy &#125; 注意不要漏写,号,不然可能会出现如下情况 0x3 我的Alacritty配置已经上传至Github，点击我获取 0x4 其他Alacritty-Github页面 Arch系一键安装: 1&gt; pacman -S alacritty]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>软件折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文件过滤及内容编辑处理命令-2]]></title>
    <url>%2F2019%2F06%2F30%2FLinux-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%8F%8A%E5%86%85%E5%AE%B9%E7%BC%96%E8%BE%91%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4-2%2F</url>
    <content type="text"><![CDATA[3.0 做Linux运维的多个好处 做运维可以认识更多人，同时也被更多人认识。 做运维可以让自己沟通，交际能力变得比开发人员更强。 相比开发岗位，运维的岗位更重要一些。 3.1 cat 合并文件或查看文件内容concatenate cat命令5大常用功能 序号 常用功能 例子以及说明 1 查看文件内容 cat file.txt 查看文件内容，最基本的使用 2 多个文件合并为一个文件 cat f1 f2 &gt; newf 将f1和f2的内容合并到newf 3 创建编辑新文件 cat &gt; file 输入后会请求输入，快捷键Ctrl+d/c可退出 4 非交互式编辑或追加新内容 cat &gt;&gt;file&lt;&lt;EOF 输入后会请求输入，在结束时输入EOF即可退出 5 清空文件内容 cat /dev/null &gt; file 清空文件内容 语法格式 1cat [选项] [文件] 选项 说明 -n 为输出的内容加编号，从1开始 -b 与-n类似，但它忽略空白行 -s 当遇到有多行空白行，则合并为单行空白行 -v 除了LFD和TAB之外，使用^和M-引用 -T 将Tab字符显示为^I -E 在行尾显示$符号 -t 等价与-vT -A 等价于-vE 例子 使用cat命令以非交互式的方式编辑文件 方式1: 123456789&gt; cat &gt;file&lt;&lt;EOFJust a test.EOF&gt; cat fileJust a test 解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现 易错点: 结束EOF必须置前，前面不能有任意字符 方式2: 123456789&gt; cat &gt;file&lt;&lt;-EOFJust a test. EOF&gt; cat fileJust a test. 解释: 在字符标签前加上-可以使得结束标签前可放置制表符，但仅仅只可放制表符 合并多个文件为单个文件 12345678910111213&gt; cat &gt; f1f1Ctrl+d&gt; cat &gt; f2f2Ctrl+c&gt; cat f1 f2f1f2&gt; cat f1 f2 &gt; newfile&gt; cat newfilef1f2 3.2 tac 反向显示文件内容跟cat命令类似，反向输出文件内容 选项 说明 -b 在行前添加分隔标志 -r 将分隔标志视作正则表达式进行解析 -s 使用指定字符作为换行的标志 例子 123456&gt; cat file1helloworld&gt; tac file2worldhello 3.3 more 分页显示文件内容more类似于cat命令，区别在于cat命令是将文件内容一次性全部显示在屏幕上，而more则会分页进行显示。 语法格式 1more [选项] [文件] more参数选项说明 选项 说明 -num 指定屏幕显示大小为num行 +num 从行号num开始显示 -s 把连续的多个空行显示在一行 -p 不滚屏，而是清除整个自己屏幕，然后显示文件 -c 不滚屏，而是从每一屏的顶部开始显示文本，每显示完一行，就清除这一行的剩余部分 more交互式说明 子命令 说明 h/? 查看帮助 空格键 向下滚动一屏 z 向下滚动一屏 Enter 向下显示一行 f 向下滚动一屏 b 返回上一屏 = 输出当前行的行号 /查找文本 查找指定的文本 :f 输出文件名和当前行的行号 v 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 3.4 less 分页显示文件内容less类似more命令，less的功能比more要强大 语法格式 1less [选项] [文件] less命令的参数选项及说明 选项 说明 -i 搜索时忽略大小写 -m 显示进度百分比 -N 显示行号 -s 多行空行显示为单行 -e 当显示到文件结尾时自动退出，若没有此选项则需要用交互式q退出 less命令的交互式子命令及说明 子命令 说明 b 向前翻一页 空格键 向后翻一页 u 向前翻半页 d 向后翻半页 y 向上滚动一行 回车键 向下滚动一行 方向键-上 向上滚动一行 方向键-下 向下滚动一行 Page UP 向上滚动一屏 Page Down 向下滚动一屏 例子: 显示文件内容时并且显示行号 1&gt; less -N 文件名 分页显示命令的结果 1&gt; ls -l | less 3.5 head 显示文件内容头部head命令用于显示文件内容头部，默认输出行数为10行。 语法格式 1head [选项] [文件] head命令的参数选项及说明 选项 说明 -n&lt;行数&gt; 指定显示的行数 -c&lt;字节&gt; 指定显示的字节数 -q 显示时不包含指定的文件名作为文件头部 -v 显示时包含指定的文件的文件名作为文件头部 例子: 默认显示文件的前10行 1234567891011&gt; head /etc/passwdroot:x:0:0::/root:/bin/bashnobody:x:65534:65534:Nobody:/:/sbin/nologindbus:x:81:81:System Message Bus:/:/sbin/nologinbin:x:1:1::/:/sbin/nologindaemon:x:2:2::/:/sbin/nologinmail:x:8:12::/var/spool/mail:/sbin/nologinftp:x:14:11::/srv/ftp:/sbin/nologinhttp:x:33:33::/srv/http:/sbin/nologinsystemd-journal-remote:x:982:982:systemd Journal Remote:/:/sbin/nologinsystemd-network:x:981:981:systemd Network Management:/:/sbin/nologin 显示文件的前n行 123&gt; head -n 2 /etc/passwdroot:x:0:0::/root:/bin/bashnobody:x:65534:65534:Nobody:/:/sbin/nologin 显示文件的前n个字节 12&gt; head -c 4 /etc/passwdroot 显示多个文件 123456&gt; head -1 /etc/passwd /etc/profile==&gt; /etc/passwd &lt;==root:x:0:0::/root:/bin/bash==&gt; /etc/profile &lt;==# /etc/profile 3.6 tail显示文件内容尾部tail命令用于显示文件内容尾部，默认输出行数为10行。 语法格式 1tail [选项] [文件] tail命令的参数选项及说明 选项 说明 -c&lt;字节&gt; 指定显示的字节数 -n&lt;行数&gt; 指定显示的行数 -f 实时输出文件内容追加的数据 –retry 不停的尝试打开文件，直到打开为止 -F 等同于-f–retry –pid=进程号 若进程关闭则tail的-f选项则不会继续输出内容 -s 秒数 N 监视文件的间隔秒数 -q 显示时不包含指定的文件名作为文件头部 -v 显示时包含指定的文件的文件名作为文件头部 例子: 显示文件最后10行 1234567891011&gt; tail /etc/passwdgit:x:973:973:git daemon user:/:/usr/bin/git-shelllightdm:x:620:620:Light Display Manager:/var/lib/lightdm:/sbin/nologinnm-openconnect:x:972:972:NetworkManager OpenConnect:/:/sbin/nologinnm-openvpn:x:971:971:NetworkManager OpenVPN:/:/sbin/nologinntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/falsepolkitd:x:102:102:PolicyKit daemon:/:/sbin/nologinusbmux:x:140:140:usbmux user:/:/sbin/nologinevanmeek:x:1000:1000:EvanMeek:/home/evanmeek:/usr/bin/zshnvidia-persistenced:x:143:143:NVIDIA Persistence Daemon:/:/sbin/nologinprivoxy:x:42:42:Privoxy:/:/sbin/nologin 显示文件最后5行 第一种写法 1&gt; tail -n 5 /etc/passwd 第二种写法 1&gt; tail -5 /etc/passwd 指定从第几行开始显示文件 1&gt; tail -n +10 /etc/passwd 实时监控文件的变化 监测12&gt; tail -f --retry test.txttestwords 追加内容 1&gt; echo testwords &gt;&gt; test.txt]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的VIM配置详解]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%88%91%E7%9A%84VIM%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。 我已经把我的配置文件上传到了Github上了，点击访问 基本都有写中文注释，哪里有不懂的，可以问我，点击查看我的联系方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&quot; 设置vi与vim兼容set nocompatible&quot; 设置使vim识别不同的文件格式filetype onfiletype indent onfiletype plugin onfiletype plugin indent on&quot; 设置使vim能用鼠标操作set mouse=a&quot; 设置字符编码set encoding=utf-8&quot; 使配色更加兼容你的终端let &amp;t_ut=&apos;&apos;&quot; 设置缩进距离set expandtabset tabstop=2set shiftwidth=2set softtabstop=2&quot; 设置空格的显示set listset listchars=tab:▸\ ,trail:▫set tw=0set indentexpr=&quot; 退格键到行首后自动跳转到上行行尾set backspace=indent,eol,start&quot; 收起代码set foldmethod=indentset foldlevel=99&quot; 设置终端的光标在不同模式下用不同的样式,实测Konsole可用let &amp;t_SI = &quot;\&lt;Esc&gt;]50;CursorShape=1\x7&quot;let &amp;t_SR = &quot;\&lt;Esc&gt;]50;CursorShape=2\x7&quot;let &amp;t_EI = &quot;\&lt;Esc&gt;]50;CursorShape=0\x7&quot;&quot; 状态栏等于２？？？set laststatus=2&quot; vim执行的外部命令会在当前目录下执行set autochdir&quot; 关闭文件又打开光标会自动回到关闭前的位置au BufReadPost * if line(&quot;&apos;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&apos;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&apos;\&quot;&quot; | endif&quot; 设置leader键为空格let mapleader=&quot; &quot;&quot; 代码高亮syntax on&quot; 设置行号set number&quot; 设置更好的行号set relativenumber&quot; 设置光标线set cursorline&quot; 自动换行set wrap&quot; 显示命令set showcmd&quot; tab多选项菜单set wildmenu&quot; 设置搜索关键词高亮set hlsearchexec &quot;nohlsearch&quot;&quot; 设置搜索输入时高亮set incsearch&quot; 搜索时忽略大小写set ignorecase &quot; 只能搜索忽略大小写set smartcase&quot; 搜索跳转结果改为=/-并且使搜索结果在屏幕中间noremap = nzznoremap - Nzz&quot; 大写JKHL重复五次执行noremap J 5jnoremap K 5knoremap H 5hnoremap L 5l&quot; 设置取消高亮noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;&quot; 设置光标回到行首noremap &lt;LEADER&gt;a 0&quot; 设置光标回到行尾noremap &lt;LEADER&gt;e $&quot; 取消s删除字符的功能map s &lt;nop&gt;&quot; 快速保存map S :w&lt;CR&gt;&quot; 按大写Q直接退出map Q :q&lt;CR&gt;&quot; R快速source vimrcmap R :source ~/.vim/vimrc&lt;CR&gt;&quot;分屏操作&quot;向右分屏map &lt;LEADER&gt;l :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;&quot;向左分屏map &lt;LEADER&gt;h :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;&quot;向上分屏map &lt;LEADER&gt;k :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;&quot;向下分屏map &lt;LEADER&gt;j :set splitbelow&lt;CR&gt;:split&lt;CR&gt;&quot;光标移动至左分屏map sh &lt;C-w&gt;h&quot;光标移动至右分屏map sl &lt;C-w&gt;l&quot;光标移动至下分屏map sj &lt;C-w&gt;j&quot;光标移动至上分屏map sk &lt;C-w&gt;k&quot;增加纵向分屏大小map &lt;up&gt; :res +5&lt;CR&gt;&quot;减少纵向分屏大小map &lt;down&gt; :res -5&lt;CR&gt;&quot;减少横向分屏大小map &lt;left&gt; :vertical resize-5&lt;CR&gt;&quot;增加横横分屏大小map &lt;right&gt; :vertical resize+5&lt;CR&gt;&quot;将分屏设置为横向分屏map &lt;LEADER&gt;H &lt;C-w&gt;t&lt;C-w&gt;H&quot;将分屏设置为纵向分屏map &lt;LEADER&gt;K &lt;C-w&gt;t&lt;C-w&gt;K&quot;标签&quot;打开新标签map tn :tabe&lt;CR&gt;&quot; 跳转至上一个标签map th :-tabnext&lt;CR&gt;&quot; 跳转至下一个标签map tl :+tabnext&lt;CR&gt; &quot; 关闭当前标签map td :tabclose&lt;CR&gt;&quot;插件安装vim-plugcall plug#begin(&apos;~/.vim/plugged&apos;)Plug &apos;endel/vim-github-colorscheme&apos;Plug &apos;morhetz/gruvbox&apos;Plug &apos;vim-airline/vim-airline&apos;&quot; File navigationPlug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;: &apos;NERDTreeToggle&apos; &#125;Plug &apos;Xuyuanp/nerdtree-git-plugin&apos;&quot; TaglistPlug &apos;majutsushi/tagbar&apos;, &#123; &apos;on&apos;: &apos;TagbarOpenAutoClose&apos; &#125;&quot; Error checkingPlug &apos;w0rp/ale&apos;&quot; Auto CompletePlug &apos;Valloric/YouCompleteMe&apos;&quot; Undo TreePlug &apos;mbbill/undotree/&apos;&quot; Other visual enhancementPlug &apos;nathanaelkane/vim-indent-guides&apos;Plug &apos;itchyny/vim-cursorword&apos;&quot; GitPlug &apos;rhysd/conflict-marker.vim&apos;Plug &apos;tpope/vim-fugitive&apos;Plug &apos;mhinz/vim-signify&apos;Plug &apos;gisphm/vim-gitignore&apos;, &#123; &apos;for&apos;: [&apos;gitignore&apos;, &apos;vim-plug&apos;] &#125;&quot; HTML, CSS, JavaScript, PHP, JSON, etc.Plug &apos;elzr/vim-json&apos;Plug &apos;hail2u/vim-css3-syntax&apos;Plug &apos;spf13/PIV&apos;, &#123; &apos;for&apos; :[&apos;php&apos;, &apos;vim-plug&apos;] &#125;Plug &apos;gko/vim-coloresque&apos;, &#123; &apos;for&apos;: [&apos;vim-plug&apos;, &apos;php&apos;, &apos;html&apos;, &apos;javascript&apos;, &apos;css&apos;, &apos;less&apos;] &#125;Plug &apos;pangloss/vim-javascript&apos;, &#123; &apos;for&apos; :[&apos;javascript&apos;, &apos;vim-plug&apos;] &#125;Plug &apos;mattn/emmet-vim&apos;&quot; PythonPlug &apos;vim-scripts/indentpython.vim&apos;&quot; MarkdownPlug &apos;iamcco/markdown-preview.nvim&apos;, &#123; &apos;do&apos;: &apos;cd app &amp; yarn install&apos; &#125;Plug &apos;dhruvasagar/vim-table-mode&apos;, &#123; &apos;on&apos;: &apos;TableModeToggle&apos; &#125;Plug &apos;vimwiki/vimwiki&apos;&quot; BookmarksPlug &apos;kshenoy/vim-signature&apos;&quot; Other useful utilitiesPlug &apos;terryma/vim-multiple-cursors&apos;Plug &apos;junegunn/goyo.vim&apos; &quot; distraction free writing modePlug &apos;tpope/vim-surround&apos; &quot; type ysks&apos; to wrap the word with &apos;&apos; or type cs&apos;` to change &apos;word&apos; to `word`Plug &apos;godlygeek/tabular&apos; &quot; type ;Tabularize /= to align the =Plug &apos;gcmt/wildfire.vim&apos; &quot; in Visual mode, type i&apos; to select all text in &apos;&apos;, or type i) i] i&#125; ipPlug &apos;scrooloose/nerdcommenter&apos; &quot; in &lt;space&gt;cc to comment a line&quot; DependenciesPlug &apos;MarcWeber/vim-addon-mw-utils&apos;Plug &apos;kana/vim-textobj-user&apos;Plug &apos;fadein/vim-FIGlet&apos;call plug#end()&quot; 设置透明let g:SnazzyTransparent = 1&quot; 设置主题&quot; 可选项&quot; github/snazzy/inkstainedlet g:grubvbox_termcolors=&apos;256&apos;let g:grubvbox_contrast_light = &apos;soft&apos;color gruvboxset background =light&quot; 插件配置&quot; ==== NERDTreemap ff :NERDTreeToggle&lt;CR&gt;&quot; ==== NERDTree-gitlet g:NERDTreeIndicatorMapCustom = &#123; \ &quot;Modified&quot; : &quot;✹&quot;, \ &quot;Staged&quot; : &quot;✚&quot;, \ &quot;Untracked&quot; : &quot;✭&quot;, \ &quot;Renamed&quot; : &quot;➜&quot;, \ &quot;Unmerged&quot; : &quot;═&quot;, \ &quot;Deleted&quot; : &quot;✖&quot;, \ &quot;Dirty&quot; : &quot;✗&quot;, \ &quot;Clean&quot; : &quot;✔︎&quot;, \ &quot;Unknown&quot; : &quot;?&quot; \ &#125;&quot; ==== You Complete ME&quot; 跳转至其他的声明nnoremap gd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;&quot; 跳转至文档nnoremap g/ :YcmCompleter GetDoc&lt;CR&gt;&quot; 获取类型nnoremap gt :YcmCompleter GetType&lt;CR&gt;&quot; 获取参考nnoremap gr :YcmCompleter GoToReferences&lt;CR&gt;let g:ycm_autoclose_preview_window_after_completion=0let g:ycm_autoclose_preview_window_after_insertion=1let g:ycm_use_clangd = 0let g:ycm_python_interpreter_path = &quot;/bin/python3&quot;let g:ycm_python_binary_path = &quot;/bin/python3&quot;&quot; ==== alelet b:ale_linters = [&apos;pylint&apos;]let b:ale_fixers = [&apos;autopep8&apos;, &apos;yapf&apos;]&quot; ==== TagListmap &lt;silent&gt; T :TagbarOpenAutoClose&lt;CR&gt;&quot; ==== MarkdownPreviewnmap &lt;LEADER&gt;mp :MarkdownPreview&lt;CR&gt;&quot; ==== vim-table-modemap &lt;LEADER&gt;tm :TableModeToggle&lt;CR&gt;&quot; ==== vim-indent-guidelet g:indent_guides_guide_size = 0let g:indent_guides_start_level = 2let g:indent_guides_enable_on_vim_startup = 1let g:indent_guides_color_change_percent = 0autocmd WinEnter * silent! unmap &lt;LEADER&gt;ig&quot; ====Goyomap &lt;LEADER&gt;gy :Goyo&lt;CR&gt;&quot; ==== vim-signiturelet g:SignatureMap = &#123; \ &apos;Leader&apos; : &quot;m&quot;, \ &apos;PlaceNextMark&apos; : &quot;m,&quot;, \ &apos;ToggleMarkAtLine&apos; : &quot;m.&quot;, \ &apos;PurgeMarksAtLine&apos; : &quot;dm-&quot;, \ &apos;DeleteMark&apos; : &quot;dm&quot;, \ &apos;PurgeMarks&apos; : &quot;dm/&quot;, \ &apos;PurgeMarkers&apos; : &quot;dm?&quot;, \ &apos;GotoNextLineAlpha&apos; : &quot;m&lt;LEADER&gt;&quot;, \ &apos;GotoPrevLineAlpha&apos; : &quot;&quot;, \ &apos;GotoNextSpotAlpha&apos; : &quot;m&lt;LEADER&gt;&quot;, \ &apos;GotoPrevSpotAlpha&apos; : &quot;&quot;, \ &apos;GotoNextLineByPos&apos; : &quot;&quot;, \ &apos;GotoPrevLineByPos&apos; : &quot;&quot;, \ &apos;GotoNextSpotByPos&apos; : &quot;mn&quot;, \ &apos;GotoPrevSpotByPos&apos; : &quot;mp&quot;, \ &apos;GotoNextMarker&apos; : &quot;&quot;, \ &apos;GotoPrevMarker&apos; : &quot;&quot;, \ &apos;GotoNextMarkerAny&apos; : &quot;&quot;, \ &apos;GotoPrevMarkerAny&apos; : &quot;&quot;, \ &apos;ListLocalMarks&apos; : &quot;m/&quot;, \ &apos;ListLocalMarkers&apos; : &quot;m?&quot; \ &#125;&quot; === Undotreelet g:undotree_DiffAutoOpen = 0map &lt;LEADER&gt;ut :UndotreeToggle&lt;CR&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文件和目录操作命令-find命令]]></title>
    <url>%2F2019%2F06%2F21%2FLinux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示 2.13.1 命令详解find命令参数较多，并且不同的参数所在的子模块不同. 12345678910111213 如何处理符号链接 | | 需要查找的路径 | | | |find -H-L-P path expression / | \ / | \ | | | options tests actions 参数 | | 限定的条件 | 执行的动作 选项 说明 pathname 需要查找的路径 Options模块 -depth 从指定目录下最深层的子目录开始查找 -maxdepth levels 查找的最大目录层级数，levels为自然数! -regextype type 改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended Tests模块 -mtime [-n\ n\ +n] 按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天! -atime[-n\ n\ +n] 同上，只不过是按照访问时间进行查找，单位为天 -ctime 按照文件的状态改变时间来查找文件，单位为天 -amin 按照文件的访问时间查找，单位为分钟 -cmin 按照文件的状态改变时间查找，单位为分钟 -mmin 按照文件的修改时间来查找文件，单位为分钟 -group 按照文件所属的组来查找文件 -name 按照文件名查找文件，只支持*,?,[]等特殊通配符! -newer 查找更改时间比指定文件新的文件 -nogroup 查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在 -nouser 查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在 -path pattern 指定路径样式，配合-prune参数排除指定目录 -perm 按照文件权限来查找文件 -regex 接正则表达式 -iregex 不区分大小写接正则表达式 -size n[cwbkMG] 查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计 -user 按照文件属主来查找文件 -type 查找某一类型的文件:!，后面会讲 -Actions模块 -delete 将查找出的文件删除 -exec 对匹配文件执行该参数给出的Shell命令! -ok 和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行 -prune 使fint命令不再指定的目录中查找 -print 将匹配的文件输出到标准输出(默认可用 OPERATORS find支持逻辑运算符 ! 取反`! -a 取交集，全拼为and！ -o 取并集，全拼为or! -type 查找某一类型的文件: b(块设备文件) c(字符设备文件) d(目录) p(管道文件) l(符号链接文件) f(普通文件) s(socket文件) D(door) 2.13.2 使用范例查找指定时间内访问过的文件 123456&gt; find . -atime -2./Linux-文件和目录操作命令-1.md./Linux-文件和目录操作命令-find命令.md./我的VIM配置详解.md./我的VIM配置详解 查找指定时间内修改过的文件 123456789&gt; find . -mtime -5../Linux-Linux命令行简介-0.md./Linux-文件和目录操作命令-1.md./C-内存四区之栈区.md./Linux-文件和目录操作命令-find命令.md./我的VIM配置详解.md./Linux-Linux命令行简介-man命令.md./我的VIM配置详解 时间关系字符图如下: 12------------+4 4 -4---------------8 7 6 5 4 3 2 1 now -n代表从第四天到现在之内 n代表具体某一天 +n代表某一天之前 根据文件名查找指定时间的文件 12&gt; find . -mtime -1 -name &apos;*.md&apos;./Linux-文件和目录操作命令-find命令.md 根据文件类型查找目录 1234567891011121314151617181920212223242526272829&gt; find . -type d../Linux-Linux命令行简介-0./终端多窗口神器——Screen./Qt5./2008年5月12日14时28分04秒./如何自学编程./Learn-Qt5-自定义信号槽./C-内存四区之代码区与全局区./Linux./C-友元./Learn-Qt5-Qt模块简介./ManjaroLinux的安装过程./C-的命名空间与作用域./Learn-Qt5-信号槽./我儿子的博客./C-内存四区之堆区./fcitx5安装与配置./hexo-next插入网易云音乐./Linux-文件和目录操作命令-1./C-读写文件./Linux-Linux命令行简介-man命令./C-指针-基础02./Learn-Qt5-HelloWorld./常用算法-1./C-内存四区之栈区./我的VIM配置详解./解决KDE下部分应用不能使用fctix中文输入法的问题./如何用hexo-github-pages搭建博客 根据文件类型查找非目录的文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&gt; find . ! -type d./Linux-Linux命令行简介-0/1.1.2-0./fcitx5安装与配置.md./终端多窗口神器——Screen/DefalutCommandKey.png./终端多窗口神器——Screen/detachedInfo.png./Linux中的解压与压缩.md./Linux-Linux命令行简介-0.md./终端多窗口神器——Screen.md./C-内存四区之代码区与全局区.md./C-内存四区之堆区.md./2008年5月12日14时28分04秒/空降.webp./2008年5月12日14时28分04秒/操场.webp./2008年5月12日14时28分04秒/流量图.webp./hexo-next插入网易云音乐.md./如何自学编程/群组.png./Linux-文件和目录操作命令-1.md./我儿子的博客.md./解决KDE下部分应用不能使用fctix中文输入法的问题.md./C-内存四区之代码区与全局区/代码区示意图.png./C-内存四区之栈区.md./Learn-Qt5-信号槽.md./Linux-文件和目录操作命令-find命令.md./Learn-Qt5-Qt模块简介.md./C-读写文件.md./ManjaroLinux的安装过程/编辑文章时截图.png./ManjaroLinux的安装过程/分区.png./ManjaroLinux的安装过程/开始安装.png./ManjaroLinux的安装过程/安装选择界面.png./ManjaroLinux的安装过程/摘要.png./ManjaroLinux的安装过程/分区标识.png./ManjaroLinux的安装过程/桌面.png./Learn-Qt5-自定义信号槽.md./我儿子的博客/预览.png./hexo博客文章插入图片.md./C-函数探幽.md./C-内存四区之堆区/test.png./如何自学编程.md./深拷贝和浅拷贝的区别.md./ManjaroLinux的安装过程.md./fcitx5安装与配置/kcm.png./fcitx5安装与配置/输入.gif./hexo-next插入网易云音乐/01.png./hexo-next插入网易云音乐/插哪.png./2008年5月12日14时28分04秒.md./C-读写文件/二进制文件.png./C-指针-基础02/指针位偏移.png./Learn-Qt5-HelloWorld.md./ManjaroLinuxTG讨论群组.md./Learn-Qt5-HelloWorld/newProject.gif./我的VIM配置详解.md./C-友元.md./如何用hexo-github-pages搭建博客.md./Linux-Linux命令行简介-man命令.md./常用算法-1.md./C-的命名空间与作用域.md./我的Linux之路.md./2019年的规划.md./C-指针-基础01.md./C-指针-基础02.md./如何用hexo-github-pages搭建博客/创建仓库.png./如何用hexo-github-pages搭建博客/deploy.png./如何用hexo-github-pages搭建博客/逆光.jpg./如何用hexo-github-pages搭建博客/本地部署.png./如何用hexo-github-pages搭建博客/hexoinit.png./如何用hexo-github-pages搭建博客/导入密钥.png./如何用hexo-github-pages搭建博客/打开设置.png./如何用hexo-github-pages搭建博客/ssh目录.png./如何用hexo-github-pages搭建博客/设置SSH.png 根据文件或目录的权限查找文件 1234567891011121314151617181920212223242526272829&gt; find . -perm 755../Linux-Linux命令行简介-0./终端多窗口神器——Screen./Qt5./2008年5月12日14时28分04秒./如何自学编程./Learn-Qt5-自定义信号槽./C-内存四区之代码区与全局区./Linux./C-友元./Learn-Qt5-Qt模块简介./ManjaroLinux的安装过程./C-的命名空间与作用域./Learn-Qt5-信号槽./我儿子的博客./C-内存四区之堆区./fcitx5安装与配置./hexo-next插入网易云音乐./Linux-文件和目录操作命令-1./C-读写文件./Linux-Linux命令行简介-man命令./C-指针-基础02./Learn-Qt5-HelloWorld./常用算法-1./C-内存四区之栈区./我的VIM配置详解./解决KDE下部分应用不能使用fctix中文输入法的问题./如何用hexo-github-pages搭建博客 根据文件大小查找文件 12&gt; find . -size +1M./ManjaroLinux的安装过程/桌面.png 查找时忽略某个目录 123456789101112131415161718192021222324&gt; find . -path &quot;*Linux*&quot; -prune -o -type d -print../终端多窗口神器——Screen./Qt5./2008年5月12日14时28分04秒./如何自学编程./Learn-Qt5-自定义信号槽./C-内存四区之代码区与全局区./C-友元./Learn-Qt5-Qt模块简介./C-的命名空间与作用域./Learn-Qt5-信号槽./我儿子的博客./C-内存四区之堆区./fcitx5安装与配置./hexo-next插入网易云音乐./C-读写文件./C-指针-基础02./Learn-Qt5-HelloWorld./常用算法-1./C-内存四区之栈区./我的VIM配置详解./解决KDE下部分应用不能使用fctix中文输入法的问题./如何用hexo-github-pages搭建博客 查找比某个文件新，但比某个文件旧 123# 其中的!不代表取反，代表逻辑运算符非&gt; find . -newer new.txt ! -newer old.txt./verynew.txt 查找文件时使用正则表达式 12345678&gt; lstxt0.txt txt1.txt txt2.txt txt3.txt txt4.txt&gt; find . -regex &quot;.*xt&quot;./txt0.txt./txt4.txt./txt1.txt./txt2.txt./txt3.txt 对查找到的文件执行Shell命令操作 123456&gt; lstxt0.txt txt1.txt txt2.txt txt3.txt txt4.txt# 其中的&#123;&#125;代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\，因为需要转义&gt; find . -regext &quot;.*txt&quot; -exec mv &#123;&#125; &#123;&#125;.demo \;txt0.txt.demo txt1.txt.demo txt2.txt.demo txt3.txt.demo txt4.txt.demo __对查找到的文件使用Shell命令并且使用安全模式-ok 123456&gt; find . -type f -ok rm &#123;&#125; \;&lt; rm ... ./txt1.txt.demo &gt; ? n&lt; rm ... ./txt2.txt.demo &gt; ? n&lt; rm ... ./txt4.txt.demo &gt; ? n&lt; rm ... ./txt0.txt.demo &gt; ? y&lt; rm ... ./txt3.txt.demo &gt; ? n]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文件和目录操作命令-1]]></title>
    <url>%2F2019%2F06%2F16%2FLinux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-1%2F</url>
    <content type="text"><![CDATA[2.0 老男孩新手成为技术大牛心法执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。 专注: 只做一件事。两耳不闻其他事，一心只读运维书。 自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。 心态: 保持空杯，重视基础；基础不牢，地动山摇。 2.1 pwd命令 print working diretory 查看当前路径使用pwd命令 例子: 1[evanmeek@EvanLinux ~]$ pwd 输出信息 1/home/evanmeek 选项 说明 -L 显示当前目录的逻辑路径(忽略软链接文件) -P 显示当前目录的物理路径(若有软链接则显示源文件地址) 所谓的软链接相当于快捷方式，例如~/test.txt是/test.txt的软链接，那么我们操作~/test.txt等同于操作/test.txt，详细的软链接将会在后面的ln命令讲解。 2.2 cd 切换目录 change directory 进入某个目录使用cd命令 例子: 123[evanmeek@EvanLinux ~]$ pwd[evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/[evanmeek@EvanLinux /etc/sysctl.d/]$ pwd 输出信息 12/home/evanmeek//etc/sysctl.d/ 选项 说明 -P 进入目录的物理路径 -L 进入目录的逻辑路径 - 进入上次的目录 ~ 进入系统环境变量的HOME目录路径，即当前登录用户的家目录` .. 进入父目录 cd 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录. 例子: 12345678[evanmeek@EvanLinux ~]$ cd Desktop[evanmeek@EvanLinux ~/Desktop]$ pwd[evanmeek@EvanLinux ~]$ cd -[evanmeek@EvanLinux ~]$ pwd[evanmeek@EvanLinux ~]$ cd /etc/systemd/[evanmeek@EvanLinux /etc/systemd/]$ pwd[evanmeek@EvanLinux /etc/systemd/]$ cd ..[evanmeek@EvanLinux /etc/]$ pwd 输出信息 1234~/Desktop/~/etc/systemd//etc/ 2.3 tree以树形结构显示目录下的内容 树形结构可以很清晰的显示出目录的父子级关系 例子: 1[evanmeek@EvanLinux ~/test]$ tree -L 1 输出信息 123456789.├── dir1│ ├── dir1_1│ └── dir2_2└── dir2 ├── dir1_1 └── dir2_26 directories, 0 files 选项 说明 -a 显示所有文件包括隐藏文件 -d 只显示目录! -f 显示每个文件的绝对路径 -i 不显示树枝 -L levelNum 显示遍历目录的层级，levelNum为层级(数字) -F 显示时根据不同文件类型在文件名结尾处显示不同的符号 例子: 显示隐藏文件 12#假设此目录下有隐藏文件[evanmeek@EvanLinux ~/tmp]$ tree -a 输出信息 1234567891011.├── dir1│ ├── dir1_1│ └── dir2_2├── dir2│ ├── dir1_1│ └── dir2_2├── .file1└── .file26 directories, 2 files 例子: 显示1级层文件完整路径，并不显示树枝 1[evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi . 输出信息 123../dir1./dir2 2.4 mkdir创建目录 make directory 创建目录使用mkdir命令 选项 说明 -p 递归创建目录，若目录已存在不会报错 -m 创建时指定目录的权限 -v 创建时显示过程信息 例子: 创建目录时显示信息 123[evanmeek@EvanLinux ~]$ mkdir -v testDir[evanmeek@EvanLinux ~]$ cd testDir[evanmeek@EvanLinux ~/testDir]$ pwd 输出信息: 1mkdir: 已创建目录 &apos;testDir&apos; 递归创建目录并且显示信息 1[evanmeek@EvanLinux ~]$ mkdir -pv father/son/test 输出信息: 123mkdir: 已创建目录 &apos;father&apos;mkdir: 已创建目录 &apos;father/son&apos;mkdir: 已创建目录 &apos;father/son/test&apos; 创建目录并且指定目录权限 12[evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir[evanmeek@EvanLinux ~]$ ls -ld testDir 输出信息: 12mkdir: 已创建目录 &apos;testDir&apos;d-wx-wx-wx 2 evanmeek evanmeek 4096 6月 17 20:15 testDir 利用特殊符号“{}”同时创建多目录及多子目录 12[evanmeek@EvanLinux ~]$ mkdir -pv father/&#123;son1/&#123;a1,a2&#125;,son2/&#123;b1,b2&#125;,son3/&#123;c1,c2&#125;&#125;[evanmeek@EvanLinux ~]$ tree father 输出信息: 1234567891011121314151617181920212223mkdir: 已创建目录 &apos;father&apos;mkdir: 已创建目录 &apos;father/son1&apos;mkdir: 已创建目录 &apos;father/son1/a1&apos;mkdir: 已创建目录 &apos;father/son1/a2&apos;mkdir: 已创建目录 &apos;father/son2&apos;mkdir: 已创建目录 &apos;father/son2/b1&apos;mkdir: 已创建目录 &apos;father/son2/b2&apos;mkdir: 已创建目录 &apos;father/son3&apos;mkdir: 已创建目录 &apos;father/son3/c1&apos;mkdir: 已创建目录 &apos;father/son3/c2&apos;father├── son1│ ├── a1│ └── a2├── son2│ ├── b1│ └── b2└── son3 ├── c1 └── c29 directories, 0 files 2.5 touch创建空文件或改变文件的时间戳属性 创建新的空文件，改变文件的时间戳属性，需要用到touch 选项 说明 -a 更改指定文件的最新访问时间 -d STRING 用字符串的方式指定一个模板作为指定文件的时间属性 -m 更改指定文件的最新修改时间 -r file 将指定文件的时间属性设置为file的时间属性 -t STAMP 使用时间格式设置文件的时间属性 例子: 创建文件 1[evanmeek@EvanLinux ~]$ touch test.txt 同时创建多个文件 1[evanmeek@EvanLinux ~]$ touch test1.txt test2.txt 利用{}批量创建文件 1[evanmeek@EvanLinux ~]$ touch t&#123;01..05&#125;.txt 利用stat命令查看时间戳 1[evanmeek@EvanLinux ~]$ stat t01.txt 输出信息 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2019-06-17 21:36:42.380004039 +0800Modify: 2019-06-17 21:36:42.380004039 +0800Change: 2019-06-17 21:36:42.380004039 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 时间戳属性说明: Access 访问属性 Modify 修改属性 Birth 状态改变属性 利用-a选项修改文件最后访问属性 12[evanmeek@EvanLinux ~]$ touch -a t01.txt[evanmeek@EvanLinux ~]$ stat t01.txt 输出信息 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2019-06-17 21:44:27.210736590 +0800Modify: 2019-06-17 21:36:42.380004039 +0800Change: 2019-06-17 21:44:27.210736590 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 修改文件的修改时间 12[evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt[evanmeek@EvanLinux ~]$ stat t01.txt 输出信息 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2001-01-01 00:00:00.000000000 +0800Modify: 2001-01-01 00:00:00.000000000 +0800Change: 2019-06-17 21:48:26.700992172 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 修改指定文件为某文件的时间属性 123[evanmeek@EvanLinux ~]$ stat t02.txt[evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt[evanmeek@EvanLinux ~]$ stat t01.txt 输出结果 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2019-06-17 21:36:42.380004039 +0800Modify: 2019-06-17 21:36:42.380004039 +0800Change: 2019-06-17 21:51:35.907031392 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 2.6 ls显示目录下的内容及相关属性信息 list directory contents 例子: 查看当前目录下的文件信息 1[evanmeek@EvanLinux ~]$ ls 输出结果 1Applications Desktop Downloads GameDir index.html Music Pictures temp WorkDir 每个人的目录里面的内容不同，所以可能不一样。 选项 说明 -l 使用长格式列出目录下的文件和信息 -a 显示目录下的所有文件，包括隐藏文件! -t 根据最新的修改时间排序，不加此参数默认是根据文件名排序! -r 反向排序 -F 在显示的条目后加上特殊符号用以区别文件类型! -p 目录后面加上“/” -i 显示inode节点信息 -d 遇到目录时，只列出目录本身，并且不跟随符号链接! -h 以人类可读的信息显示文件或目录大小 -A 列出所有文件，包括隐藏文件夹，但不包括.和.. -S 根据文件大小排序 -R 递归列出所有子目录 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -c 根据状态改变时间排序 -u 根据最后访问时间排序 –color={never,always,auto} 根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示 –full-time 以完整的时间格式进行显示 –time-style={full-iso,long-iso,iso,locale} 以不同的时间格式输出，long-iso最常用 –time={atime,ctimeA} 按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间 例子: 环境准备 123456[evanmeek@EvanLinux ~]$ mkdir temp[evanmeek@EvanLinux ~]$ cd temp[evanmeek@EvanLinux ~]$ mkdir -p father/dir&#123;01..02&#125;[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/txt&#123;01..02&#125;[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/.txt&#123;01..02&#125;[evanmeek@EvanLinux ~]$ tree -a 输出结果 1234567891011121314 . └── father ├── dir01 │ ├── .txt01 │ ├── txt01 │ ├── .txt02 │ └── txt02 └── dir02 ├── .txt01 ├── txt01 ├── .txt02 └── txt023 directories, 8 files 递归显示所有文件 1[evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra 输出信息 1234567891011.:. .. father./father:. .. dir01 dir02./father/dir01:. .. .txt01 txt01 .txt02 txt02./father/dir02:. .. .txt01 txt01 .txt02 txt02 ls命令输出属性解释 目录内容如下： 1234567.├── dir01├── dir02├── file01.txt└── file02.txt2 directories, 2 files 长格式列出人类可读信息并显示inode信息 1[evanmeek@EvanLinux ~]$ ls -lhi 输出信息 12345total 8.0K18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 18 19:27 dir0118219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 18 19:27 dir0218219054 -rw-r--r-- 1 evanmeek evanmeek 0 6月 18 19:28 file01.txt18219055 -rw-r--r-- 1 evanmeek evanmeek 0 6月 18 19:28 file02.txt 从第一列依次往后排，分别含义为: inode索引节点编号 文件类型以及属性(第一字符标注类型，后9个代表权限) 硬链接个数 文件或目录所属用户 文件或目录所属的组 文件或目录的大小 修改时间 文件名或目录名 2.7 cp复制文件或目录 copy 选项 说明 -p 复制文件时保存源文件的所有者、权限信息及时间属性 -d 如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录 -r 递归复制目录，即目录下所有的子目录及文件 -a 等同于上面的p、d、r这3个选项功能的总和 -i 覆盖已有文件前提示用户确认 -t 调换命令格式，默认格式是”cp 源文件 目标文件”，将目标文件和源文件进行位置调换 例子: 环境准备 12345678910.└── fatherDir ├── sonDir1 │ └── test.txt ├── sonDir2 │ └── test.txt └── sonDir3 └── test.txt4 directories, 3 files 拷贝fatherDir为father2Dir并保留源文件的所有者，权限信息及时间属性 1[evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir 再次拷贝fatherDir为father2Dir从而覆盖上个例子的father2Dir 1[evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir 输出信息 123cp：是否覆盖&apos;father2Dir/fatherDir/sonDir1/test.txt&apos;？ ycp：是否覆盖&apos;father2Dir/fatherDir/sonDir2/test.txt&apos;？ ycp：是否覆盖&apos;father2Dir/fatherDir/sonDir3/test.txt&apos;？ y 2.8 mv移动或重命名文件 move | 选项 | 说明 | |——|————————————————————| | -f | 若目标文件已存在，不询问直接覆盖 | | -i | 若目标文件已存在，询问是否覆盖 | | -n | 不覆盖已存在的文件 | | -t | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 | | -u | 源文件比目标文件新，或目标文件不存在时再移动 | 例子: 环境准备 123456总用量 4-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test0.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test1.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test2.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test3.txtdrwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt 更换文件名 12[evanmeek@EvanMeek ~]$mv test0.txt test-1.txt[evanmeek@EvanMeek ~]$ls -l --full-time 输出信息 12345-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test-1.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test1.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test2.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test3.txtdrwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt 移动文件 1[evanmeek@EvanLinux ~]$ mv test-1.txt testTxt 移动多个文件至一个目录 1[evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt 2.9 rm删除文件或目录 前排提示:使用rm命令时最好知道自己在干什么! remove 选项 说明 -f 强制删除并且忽略不存在文件的提示 -i 删除时需要确认 -I 删除三个以上文件或者递归删除前需要确认 -r 递归删除目录以及其内容! 例子: 再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现) 环境准备 1234567.├── test2Txt│ ├── test1.txt│ ├── test2.txt│ └── testTxt│ └── test-1.txt└── test3.txt 删除文件 1[evanmeek@EvanLinux ~]$ rm test3.txt 强制删除并且删除时需要确认 1[evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt 输出信息 1rm：是否删除普通空文件 &apos;test2Txt/test2.txt&apos;？ 删除目录并且删除时需要确认 1[evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt 强制删除+递归删除目录 1[evanmeek@EvanLinux ~]$ rm -rf test2Txt 最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入 1sudo rm -rf /* 这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内. 删除时的小技巧 使用mv命令代替rm命令，可以将要删除的文件暂时保存在/tmp目录下，需要清理空间时再去删除 删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原 若非要用删除命令清理空间可以选择用find代替rm 删除时尽量不要使用系统通配符 2.10 rmdir删除空目录 remove dirctory 此命令只能删除空目录 选项 说明 -p 递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息 -v 删除时显示执行过程 2.11 ln硬链接与软链接 link 链接分为两种，分别是硬链接与软链接 硬链接(hard link): 不能将硬链接链接到不同文件系统的文件 硬链接不能链接目录 删除硬链接或者源文件之一并不能完全删除实体 删除实体需要删除硬链接以及起对应的源文件 硬链接相当与源文件的另外一个入口 对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除 硬链接的文件类型是普通文件(字符型) 硬链接通过索引节点进行链接 例子: 创建硬链接 1[evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt 软链接(Symbolic Link): 类似于Windows的快捷方式 文件内存放的是源文件的路径 即使删除源文件，软链接仍然存在，但无法访问源文件 源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示 软链接可以用rm命令删除 例子: 创建软链接 1[evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt 文件链接案例 通过一个案例演示软链接和硬链接的区别。 1234567891011121314151617181920212223242526272829[evanmeek@EvanLinux ~]$ cat testFile123# 创建硬链接[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink# 创建软链接[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink[evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink123123123# 删除软链接[evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink[evanmeek@EvanLinux ~]$ cat testFile testHardLink123123# 复原[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink# 删除硬链接[evanmeek@EvanLinux ~]$ rm -f testFileHardLink[evanmeek@EvanLinux ~]$ cat testFile testFileHardLink123123# 复原[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink# 删除源文件[evanmeek@EvanLinux ~]$ rm -f testFile[evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink123cat: testFileSymbolicLink: 没有那个文件或目录 硬链接可以没有源文件 软链接不行 2.12 readlink 查看符号链接文件的内容 此命令可查看链接指向的源文件的地址 选项 说明 -f 一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行 例子： 1[evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink 2.13 find 查找目录下的文件 由于本篇篇幅较大，请点击下方超链接进行访问。 点击访问 2.14 xargs将标准输入转换成命令行参数 选项 说明 -n 指定每行命令的最大参数数量，每个参数由空格隔开 -d 自定义分割符 -i 以{}替代xargs命令之前的结果 -I 指定一个符号替代前面的结果，而不是使用默认的{} -P 提示让用户确认是否执行后面的命令，y执行，n不执行 -0 用null替代空格作为分割符，配合find命令的-printf0选项的输出使用 2.14.2使用范例 多行输入变单行 1234567&gt; cat test.txt1 2 3 4 5 6 78 91 &gt; xargs &lt; test.txt1 2 3 4 5 6 7 8 9 1 通过-n指定每行的输出个数 123456&gt; xargs -n 2 &lt; test.txt1 23 45 67 89 1 自定义分隔符(使用-d功能) 123456&gt; echo 123I321I809I098123I321I809I098&gt; echo 123I321I809I098|xargs -d I -n 2123 321890 098 指定一个替换字符串 123456# 将查找出来的结果删除# 先将结果传给&#123;&#125;# 再会被删除&gt; find . -name &quot;*.log&quot;|xargs -i rm -rf &#123;&#125;# 自定义替换字符串&gt; find . -name &quot;*.log&quot;|xargs -I [] rm -rf [] 2.15 rename重命名 rename通过替换字符串的方式批量修改文件名 语法格式 1rename from to file 例子: 批量修改文件名 12345&gt; lstest_demo_0 test_demo_1 test_demo_2 test_demo_3 test_demo_4 test_demo_5&gt; rename &quot;_demo&quot; &quot;&quot; *&gt; lstest_0 test_1 test_2 test_3 test_4 test_5 批量修改文件扩展名 12345&gt; lstest0.txt test1.txt test2.txt test3.txt test4.txt test5.txt&gt; rename .txt .demo *&gt; lstest0.demo test1.demo test2.demo test3.demo test4.demo test5.demo 2.16 basename显示文件名或目录名 basename命令用于显示去除路径和文件后缀的文件名或目录名 语法格式 1basename [&lt;文件或目录&gt;] [后缀] 其中的后缀为可选 例子: 只显示文件名和后缀，不显示完整路径 1234&gt; mkdir -p dir1/dir2/&gt; touch dir1/dir2/test.txt&gt; basename dir1/dir2/test.txttest.txt 只显示文件名，不显示完整路径制定不显示某个后缀 123&gt; touch dir1/dir2/test.demo.txt&gt; basename dir1/dir2/test.demo.txt .txttest.demo 2.17 dirname显示文件或目录的路径 dirname命令用于只显示文件或目录的路径 语法格式 1dirname [&lt;文件或目录&gt;] 例子: 12&gt; dirname dir1/dir2/test.txtdir1/dir2 2.18 chattr改变文件的扩展属性 charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的． 语法格式 1chattr [选项] [模式] [&lt;文件或目录&gt;] 提示:lsattr命令可以查看文件的属性 选项 说明 -R 递归更改目录属性 -V 显示执行过程 mode + 增加参数 - 移除参数 = 更新为指定参数 A 指定文件的最后访问时间不可修改 a 指定文件只能添加数据，无法删除数据! ! 指定文件不能被删除，重命名，写入或新增内容 例子： 给文件加锁，使其只能为只读 1234567&gt; chattr +i test.txt&gt; lsattr test.txt----i---------e----- test.txt&gt; echo a1111 &gt; test.txtzsh: 不允许的操作: test.txt&gt; echo b2222 &gt;&gt; test.txt zsh: 不允许的操作: test.txt 给文件解锁 123456&gt; charttr -i test.txt&gt; lsattr test.txt--------------e----- test.txt&gt; eco 111 &gt; test.txt&gt; cat test.txt111 2.19 lsattr查看文件扩展属性 lsattr命令用于查看文件扩展属 语法格式 1lsattr [选项] [&lt;文件或目录&gt;] 选项 说明 -R 递归查看目录的扩展属性 -a 显示所有文件的扩展属性 -d 显示目录的扩展属性 例子: 查看文件的扩展属性 12345&gt; lsattr test.txt--------------e----- test.txt&gt; chattr +i test.txt&gt; lsattr test.txt----i---------e----- test.txt 查看目录的扩展属性 12345&gt; lsattr -d testDir--------------e----- testDir&gt; chattr +i testDir&gt; lsattr -d testDir----i---------e----- testDir 2.20 file显示文件的类型 file命令用于显示文件的类型 语法格式 1file [选项] [&lt;文件或目录&gt;] 选项 说明 -b 输出信息使用精简格式 例子: 查看文件类型 12345&gt; file test.txttest.txt: empty&gt; file *test.txt: emptytest.txt.link: symbolic link to test.txt 2.21 md5sum计算和校验文件的MD5值 md5sum命令用于计算和校验文件的MD5值. 语法格式 1md5sum [选项] [文件] 选项 说明 -b 二进制模式读取文件 -c 从指定文件中读取MD5校验值，并进行校验 -t 文本模式读取文件，默认 –quiet 校验文件时，若通过不输出OK –status 校验文件时，不输出任何信息，但可通过命令的返回值判断 例子: 生成一个文件的MD5值 12&gt; md5sum test.txtd41d8cd98f00b204e9800998ecf8427e test.txt 校验文件MD5值是否发生改变 123456789101112&gt; md5sum test.txt &gt; md5.log&gt; cat md5.logd41d8cd98f00b204e9800998ecf8427e test.txt&gt; md5sum -c md5.logtest.txt: 成功&gt; echo &quot;update&quot; &gt;&gt; test.txt&gt; md5sum -c md5.logtest.txt: 失败md5sum: 警告：1 个校验和不匹配&gt; md5sum --status -c md5.log&gt; echo $?1 2.22 chown改变文件或目录的用户和用户组 chown命令用于改变文件或目录的用户和用户组 语法格式 1chown [选项] [用户:用户组] [&lt;文件或目录&gt;] 选项 说明 -R 递归更改目录的用户和用户组 例子: 更改文件所属的用户属性 12345678&gt; ls -l test.txt-rw-r--r-- 1 root root 5 6月 27 00:31 test.txt# 授予权限的用户必须存在&gt; chown xxx test.txtchown: 无效的用户: “xxx”&gt; chown evanmeek test.txt&gt; ls -l test.txt-rw-r--r-- 1 evanmeek root 5 6月 27 00:31 test.txt 更改文件所属用户组的属性 1234567&gt; ls -l总用量 4.0K-rw-r--r-- 1 evanmeek evanmeek 5 6月 27 00:34 test.txt&gt; chown .root test.txt&gt; ls -l总用量 4.0K-rw-r--r-- 1 evanmeek root 5 6月 27 00:34 test.txt 同时更改文件的用户和用户组属性 1234&gt; chown evanmeek:evanmeek test.txt&gt; ls -l总用量 4.0K-rw-r--r-- 1 evanmeek evanmeek 5 6月 27 00:34 test.txt 递归更改目录下所有文件及目录的用户和用户组属性 12345678910111213141516&gt; tree.├── dir0│ └── test.txt├── dir1│ └── test.txt└── dir2 └── test.txt3 directories, 3 files&gt; chown -R root:root .&gt; ls -l总用量 12Kdrwxr-xr-x 2 root root 4.0K 6月 27 01:14 dir0drwxr-xr-x 2 root root 4.0K 6月 27 01:14 dir1drwxr-xr-x 2 root root 4.0K 6月 27 01:14 dir2 2.23chmod改变文件或目录权限 只有文件的属主以及超级用户root才能执行此命令 语法格式 1chmod [选项] [模式] [&lt;文件或目录&gt;] 选项 说明 -R 递归指定目录以及子目录的权限 权限对应表 权限位 全称 含义 对应数字 r read 可读权限 4 w write 可写权限 2 x execute 可执行权限 1 - 没有任何权限 0 备注 一些特殊权限位:t,T,s,S,x,X 用户类型 文件所属用户:u(OwnerUser) 用户类型 文件所属用户组:g(Group) 用户类型 其他用户:o(Other) 用户类型 所有:a(ALL),等效于u,g,o的总和 操作字符 +:添加/-:减去/=:设置 例子: 权限字母和操作符表达式 123456789101112131415&gt; ls -l总用量 4-rw-r--r-- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt# 给文件所属用户减去可写权限&gt; chmod u-w test.txt# 给用户所属用户组减去可读权限&gt; chmod g-r test.txt&gt; ls -l总用量 4.0K-r-----r-- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt# 给所有用户以及用户组都设置为可读可写可执行的权限&gt; chmod a=rwx test.txt&gt; ls -l总用量 4.0K-rwxrwxrwx 1 evanmeek evanmeek 4 6月 25 17:43 test.txt 使用数字更改文件或目录权限 先举个例子，有这么一个文件 1-rw-rw---- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt 权限示意图 1234前三个字符代表文件属主的权限中间三个字符代表文件属组的权限后三个字符代表其他用户的权限-rw-rw---- evanmeek evanmeek test.txt 我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660 因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660 1234# 将test.txt文件的所有用户权限设置为可读可写可执行&gt; chmod 777 test.txt&gt; ls -l---------- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt 使用数字递归更改文件或目录的权限 123456789101112131415161718&gt; tree.├── dir0│ └── file.txt├── dir1│ └── file.txt└── dir2 └── file.txt&gt; ls -l总用量 12Kdrwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir0drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir1drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir2&gt; chmod -R 777 dir&#123;0..2&#125;总用量 12Kdrwxrwxrwx 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir0drwxrwxrwx 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir1drwxrwxrwx 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir2 Linux普通文件的读，写，执行权限说明 | 权限 | 说明 | |———|—————————-| | 可读r | 表示具有读取文件内容的权限 | | 可写w | 表示具有修改文件内容的权限 | | 可执行x | 表示具有执行文件的权限 | 可写w 如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo &gt;&gt; 的方式进行追加. 删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里 可执行x 要求文件本身是可执行的 普通用户必须要有r权限才能够执行 root用户即使没有r权限，只需要有x权限即可执行 不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行 Linux目录的，写，执行权限说明| 权限 | 说明 ||———|——————————————–|| 可读r | 表示具有浏览目录下文件以及子目录的权限 || 可写w | 表示具有增加，删除或修改目录内文件名的权限 || 可执行x | 表示具有进入目录的权限 | 可读r 没有x权限不能进入至目录内 ls列表可以看到所有文件名，不过会提示无法访问目录下的文件 如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名 可写w 增加的不是文件内容，而是创建新文件 修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名， 删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除 可执行权限x 没有可读权限r则不能进入目录 没有可写权限w则无法创建新文件 2.24 chgrp更改文件用户组 此命令被chown取代，用法和参数都和chown命令相同 2.25 umask显示或设置权限掩码 umask是通过八进制的数值来定义用户创建文件或目录的默认权限 语法格式 1umask [选项] [模式] 选项 说明 -p 输出的权限掩码可直接作为命令来执行 -S 以字符的方式输出权限掩码 2.25.2 通过umask计算文件目录权限 文件权限的计算 创建文件默认的最大权限为666，也就是说没有可执行权限x. umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。 例子: 假如umask值为:022，那么: 1234 6 6 6 文件默认的权限 0 2 2 umask值- ===== 6 4 4 都为偶数，最终结果为644 假如umask值为:045，那么: 1234567 6 6 6 文件默认的权限 0 4 5 umask值- ===== 6 2 1 其他用户权限位为奇数，所以+1 0 0 1+ ===== 6 2 2 都为偶数，最终结果为622 目录权限的计算 目录权限的计算没有奇偶之分 创建目录是默认的最大权限为777(-rwx-rwx-rwx) 计算方法和文件权限计算方法相同 例子: 假如umask值为:022，那么: 1234 7 7 7 目录默认最大权限 0 2 2 umask值- ===== 7 5 5 得到最终结果 查看系统默认的umask值 123456# 普通用户的默认umask值evanmeek &gt; umask022# 超级用户的默认umask值root &gt; umask0022 -S参数的使用 12&gt; umask -Su=rwx,g=rx,o=rx -p参数的使用 12&gt; umask -pumask 0022 临时修改umask值 1234567891011# 修改umask之前&gt; umask&gt; ls -l file1-rw-r--r-- 1 evanmeek evanmeek 0 6月 30 19:11 file1# 修改umask之后&gt; umask 044&gt; umask044&gt; touch file2&gt; ls -l file1-rw--w--w- 1 evanmeek evanmeek 0 6月 30 19:12 file2 永久修改umask值 若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。 编辑/etc/profile或者/etc/bashrc 找到umask项修改即可]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Linux命令行简介-man命令]]></title>
    <url>%2F2019%2F06%2F15%2FLinux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-man%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。 1.2.1 使用man获取命令帮助信息man命令的作用: 查看命令的使用帮助 查看软件服务配置文件 查看系统调用信息 查看C库函数帮助信息 man命令的使用: 1man 参数选项 命令/文件 man命令可选参数: 参数 英文说明 中文说明 1 User Commands 用户命令相关 2 System Calls 系统调用相关 3 C Library Functions C的库函数相关 4 Devices and Special Files 设备与特殊文件相关 5 File Formats and Conventions 文件格式和规则 6 Games et. Al. 游戏及其他 7 Miscellanea 宏，包及其他杂项 8 System Admin tools and Deamons 系统管理员命令和进程 例子: 1234# 查看cp命令的使用帮助man cp# 查看C语言printf函数的使用帮助man 3 printf man命令信息的格式 标签 说明(!表示重点) NAME 命令说明及介绍! SYNOPSIS 命令的基本使用语法! DESCRIPTION 命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS! OPTIONS 命令参数选项说明 COMMANDS 执行某个软件时可附加的软件的命令 FILES 程序涉及的相关文件 EXAMPLES 命令的例子! SEE ALSO 命令相关信息的说明 BUGS(REPORTING BUGS) 命令对应缺陷问题的描述 COPYRIGHT 版权信息相关声明 AUTHOR 作者介绍 man命令信息操作键 操作键 功能说明 Page Down 向下翻页 Page Up 向上翻页 Home 跳转到第一页 End 跳转到最后一页 / 向下查找某个字符 ? 向上查找某个字符 n,N 当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反 q 结束本次man帮助 1.2.2 使用–help参数获取命令帮助信息 例子: 1[evanmeek@EvanLinux ~]$ ls --help 输出如下: 123456789用法：ls [选项]... [文件]...列出给定文件（默认为当前目录）的信息。如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。必选参数对长短选项同时适用。-a, --all 不隐藏任何以. 开始的项目-A, --almost-all 列出除. 及.. 以外的任何项目 --author 与-l 同时使用时列出每个文件的作者-b, --escape 以八进制溢出序列表示不可打印的字符 1.2.3 使用help命令获取命令帮助信息 例子: 1[evanmeek@EvanLinux ~]$ help cd 输出如下: 123456789101112cd: cd [-L|[-P [-e]] [-@]] [目录] 改变 shell 工作目录。 改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME 的值。 变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。 一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH 不会用上变量。 如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个 变量名。如果该变量有值，则它的值被当作 DIR 目录。 1.2.4 使用info获取帮助信息 例子: 1[evanmeek@EvanLinux ~]$ info cd 即可打开cd的文档信息，操作跟man的使用方式相似。 1.2.5 从互联网搜索获取命令帮助信息 Google Bing Github StackOverFlow]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Linux命令行简介-0]]></title>
    <url>%2F2019%2F06%2F15%2FLinux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-0%2F</url>
    <content type="text"><![CDATA[1.1 Linux命令行概述1.1.1 Linux命令行的作用与意义 Linux命令行相比图形界面操作的优点: 快速 批量 自动化 智能化管理 1.1.2 Linux命令行介绍 大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图: 1.1.3 Linux命令行的开启及退出 主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。 12user login:_password:_ 等待你输入用户名密码，密码输入时是不会显示的。 使用exit,logout或者Ctrl+d快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。 1.1.4 Linux命令行提示符介绍 Linux命令提示符分为两种，分别是: $普通用户 #超级管理员(root) 例子: 12[evanmeek@EvanLinux ~]$:_[root@EvanLinux ~]#:_ 其中@前面的为当前登录的用户名(username),@后面的为主机名(hostname)，主机名后面的~为路径，代表了home目录，而$或#分别代表了用户的是超级管理员还是普通用户。 超级管理员从此以后本系列都以root代表。 root与普通用户的区别： root 拥有管理整个系统的权限。 普通用户 权限较少，通常只有查看系统文件的权限，以及管理自身home目录下所有文件的权限。 查看当前登录的用户名:使用whoami查询查看主机名:使用hostname查询 额外技巧: Linux命令提示符由PS1环境变量控制，通过修改PS1环境变量，可以让提示符发生变化，例子如下: 12[evanmeek@EvanLinux ~]$ set|grep PS1PS1='[\u@\h \W]\$' PS1有特殊的变量可供选择，我们可以设置全局配置文件/etc/bashrc或/etc/profile`进行按需配置。 1.1.5 Linux命令行常用快捷键 企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: SecureCRT和XShell,以下快捷键可在此两款软件中使用。 记住常用的快捷键有利于提高效率，常用快捷键由!标注 快捷键 功能说明(!为常用) 最有用的快捷键 tab 命令或路径的补全键，Linux最有用的快捷键! 移动光标快捷键 Ctrl+a 移动光标至行首! Ctrl+e 移动光标至行尾! Ctrl+f 光标向右移动一个字符(等价与方向键右键) Ctrl+b 光标向左移动一个字符(同上) 剪切、粘贴、清楚快捷键 Ctrl+Insert 复制命令行内容! Shift+Insert 粘贴命令行内容! Ctrl+k 剪切(删除)光标处至行尾的字符! Ctrl+u 剪切(删除)光标处至行首的字符! Ctrl+w 剪切(删除)光标前一个单词! Ctrl+y 粘贴上面三个剪切(删除)的字符 Ctrl+c 终止终端正在执行的任务或删除整行字符! Ctrl+h 删除光标前一个字符(等同于Backspace)! 重复执行命令快捷键 Ctrl+d 退出当前Shell命令行! Ctrl+r 搜索命令历史记录! Ctrl+g 退出搜索命令历史记录 控制快捷键 Ctrl+l 清屏(等同于clear命令)! Ctrl+s 锁定终端，使之无法输入 Ctrl+q 解锁锁定终端 Ctrl+z 暂停执行终端运行中的任务! !开头的快捷键命令 !! 执行上一条命令 !pw 执行最近一次以pw开头的命令! !pw:p 打印输出最近以pwd开头的命令，不执行 !num 执行历史命令列表的第num(数字)条命令! !$ 上一条命令的最后一个参数，等同于Esc+. ESC相关 Esc+. 获取上一条命令的最后部分! Esc+b 移动到当前单词的开头 Esc+f 移动到当前单词的结尾 1.2 在Linux命令行下查看命令帮助 man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。 由于篇幅较大，请点击链接单独查看本章附录man命令。 点击访问 1.3 Linux关机、重启、注销命令 关机或重启命令:shutdown 参数选项 说明 -r 重启机器 -P 关闭机器电源(默认) -H 暂停机器，CPU停止工作但不断电 -h 等效-P，除非使用了-H -k 只发送关机提示,不做任何操作 -c 取消关机 例子: 12345678# 立即关机[evanmeek@EvanLinux ~]$ shutdown -h now# 立即重启 [evanmeek@EvanLinux ~]$ shutdonw -r now# 5分钟后关机[evanmeek@EvanLinux ~]$ shutdown -h +5# 1分钟后重启[evanmeek@EvanLinux ~]$ shutdown -r +1 重启或关机命令:halt/poweroff/reboot halt和poweroff都是reboot的链接而已。 reboot和shutdown都是systemctl的链接 本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fctix5安装与配置]]></title>
    <url>%2F2019%2F06%2F14%2Ffcitx5%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。 所需安装的软件包: fcitx5-git 输入法基础框架主程序 fcitx5-chinese-addons-git 简体中文输入的支持，云拼音 fcitx5-gtk-git gtk 程序的支持 fcitx5-qt4-git qt4 的支持 fcitx5-qt5-git qt5 的支持可能还需要： kcm-fcitx5-git 如果你用的是 KDE ，请装这个 fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎 如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法: 否则将改配置文件~/.config/fcitx5/profile 12345678910111213141516171819202122[Groups/0]# Group NameName=Default# LayoutDefault Layout=us# Default Input MethodDefaultIM=pinyin[Groups/0/Items/0]# NameName=keyboard-us# LayoutLayout=[Groups/0/Items/1]# NameName=pinyin# LayoutLayout=[GroupOrder]0=Default 若没有fcitx5这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。 由于fcitx5不能自动启动，我们需要添加环境变量 将如下内容添加到~/.xprofile 1fcitx5 &amp; 然后再将如下内容添加到~/.pam_environment`，没有则创建 123GTK_IM_MODULE=fcitx5XMODIFIERS=@im=fcitxQT_IM_MODULE=fcitx5 KDE用户可以直接在系统设置模块-自动启动设置 默认的皮肤很丑，我们可以使用这个fcitx5-simple-theme 然后你就可以把fcitx4给删了…]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>fcitx5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-Qt模块简介]]></title>
    <url>%2F2019%2F06%2F12%2FLearn-Qt5-Qt%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Qt5分为两个大的模块，分别是Qt Essentials以及Qt Add-Ons以及一些额外的模块和工具． Qt EssentialsQt Essentials是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件． 模块 简述 Qt Core 其他非图形类模块所使用的核心, Qt GUI 图形界面组件的基类，包括了OpenGL. Qt Multimedia 音频，视频，广播和摄像头相关功能. Qt Network 提供跨平台的网络能力． Qt Qml 提供QML使用的C++API. Qt Quick 允许在Qt/C++程序中嵌入 Qt Quick Qt SQL 允许使用SQL访问数据库 Qt Test 提供Qt程序的单元测试能力｜ Qt Webkit 基于WebKit2的实现以及一套全新的QML API Qt Add-OnsQt Add-Ons是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人． 模块 简述 Qt 3D 提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜ Qt Bluetooth 提供用于访问蓝牙无线设备的C++和QML API. Qt Contacts 用于访问地址薄或联系人数据库的C++和QML API. Qt D-Bus Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互 Qt Graphical Effects 提供一系列用于实现图像特效的类 Qt Image Formats 支持图片格式的一系列插件 Qt JS Backend 为V8 JavaScript引擎的移植，仅供QtQML模块内部使用 Qt Location 方便在Qt应用程序中使用OpenGL，保留于Qt4 Qt Organize 使用QML和C++API访问组织事件｜ Qt Print Support 提供对打印功能的支持｜ Qt Publish and Subscribe 为应用程序提供对项目值的读取，导航，订阅等功能. Qt Quick 1 从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容 Qt Script 提供脚本化机制，为了与Qt5兼容 Qt Script Tools 为了使用Qt Script模块的应用程序提供的额外的组件 Qt Sensors 提供访问各类传感器的QML和C++接口. Qt Service Framework 提供客户端发现其他设备的服务. Qt SVF 提供渲染和创建SVG文件的功能． Qt System Info 提供一套API，用于发现系统相关的信息. Qt Tools 提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools. Qt Versit 提供了对Versit API的支持． Qt Wayland 仅用于Linux平台，用户替代QWS Qt WebKit 从Qt4 一直来的基于WebKit1和QWidget的API Qt Widgets 使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框 Qt XML SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer Qt XML Patterns 提供对XPath,XQuery,XSLT和XML Schema验证的支持．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C_++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-自定义信号槽]]></title>
    <url>%2F2019%2F06%2F11%2FLearn-Qt5-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性． 我们通过一个新闻和订阅者的例子讲解典型的观察者模式． 有一个报纸类Newspaper，有一个订阅者类Subscriber，Subscriber可订阅Newspaper，订阅后若Newspaper有了新内容，那么Subscriber则会立即得到通知． 上面这个案例的观察者是Subscriber，被观察者则是Newspaper．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者． 下面，我们将用Qt的信号槽实现上面的的案例． 12345678910111213141516171819202122232425262728293031323334353637383940414243//newspaper.h#include &lt;QObject&gt;class NewsPaper : public QObject &#123; Q_OBJECTpublic: NewsPaper(const QString &amp;name) : m_name(name) &#123;&#125; void send() &#123; emit newPaper(m_name); &#125;signals: void newPaper(const QString &amp;name);private: QString m_name;&#125;;//reader.h#include &lt;QObject&gt;class Reader : public QObject &#123; Q_OBJECTpublic: void receiverNewsPaper(const QString &amp;name)&#123; qDebug()&lt;&lt;"Newpaper:"&lt;&lt;name; &#125;&#125;;//main.cpp#include &lt;QCoreApplication&gt;#include &lt;newspaper.h&gt;#include &lt;reader.h&gt;int main(int argc, char *argv[]) &#123; QCoreApplication a(argc, argv); NewsPaper paper("xx与xxx结婚了!"); Reader reader; QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader, &amp;Reader::receiverNewsPaper); paper.send(); return a.exec();&#125; 运行结果: 1Newpaper:xx与xxx结婚了! 我们看到Reader类和Newspaper类都继承了QObject 类，在Qt中，只有继承了QObject类的类才具有信号槽的能力．凡是Object类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上Q_OBJECT．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内． 再看Newspaper类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据. Newspaper类的send()函数比较简单，只有一条语句emit newPaper(m_name);. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出newPaper()信号．如果有接受者关注这个信号， 那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字m_name以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移． Reader类是接受信号的，所以我们也需要继承QObject，并且添加Q_OBJECT宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义． main函数中，我们首先创建了Newspaper和Reader两个独享，然后使用QObject::connect()函数．这个然后我们调用Newspaper的send()函数．这个函数只有一个语句：发出信号．由于我们将Newspaper的信号和Reader的槽函数进行了连接，当这个信号发出时，那么将会自动调用Reader的槽函数． 总结自定义信号槽需要注意的事项: 发送者和接收者都需要的是QObject的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外． 使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码； 使用emit发送信号 使用QObject::connect()函数连接信号和槽.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-信号槽]]></title>
    <url>%2F2019%2F06%2F10%2FLearn-Qt5-%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一. 信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号. 但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号． 简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发． 下面看代码: 123456789101112#include &lt;QApplication&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); QPushButton button("Quit"); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit); button.show(); return a.exec();&#125; 编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序． 下面我们分析一下QObject::connect这个函数. 首先它拥有以下几种重载 123456789101112131415161718QMetaObject::Connection connect(const QObject *, const char *, const QObject *, const char *, Qt::ConnectionType);QMetaObject::Connection connect(const QObject *, const QMetaMethod &amp;, const QObject *, const QMetaMethod &amp;, Qt::ConnectionType);QMetaObject::Connection connect(const QObject *, const char *, const char *, Qt::ConnectionType) const;QMetaObject::Connection connect(const QObject *, PointerToMemberFunction, const QObject *, PointerToMemberFunction, Qt::ConnectionType)QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor); 每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法: 1connect(sender,signal,receiver,slot); connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数． 简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数． 根据这个常用的形式，我们可以依次分析connect的重载． 第一种 sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理． 第二种 sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较 第三种 sender仍为const Object，而signal和slot则是const char，这里的reveiver被省略了，它由this指针代替. 第四种 sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针． 第五种 注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式. 经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别． 信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年的规划]]></title>
    <url>%2F2019%2F06%2F09%2F2019%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。 书籍《标准C++入门与编程实践》————————————————————已读完《Linux系统管理完全手册》————————————————————在读《Vim实用技巧》——————————————————————————————未读《计算机网络教程》———————————————————————————未读《Qt5编程入门》——————————————————————————————在读 想学但未学Adobe PhotoshopAdobe AfterEffectsAdobe Primiere 生活想多拿起相机拍拍美好的世界， 想找个女朋友， 想减肥， 想写操作系统….]]></content>
      <categories>
        <category>分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-HelloWorld]]></title>
    <url>%2F2019%2F06%2F08%2FLearn-Qt5-HelloWorld%2F</url>
    <content type="text"><![CDATA[当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选． 那么就让我们从Qt5的HelloWorld开始吧! 第一步先创建一个项目 可以使用快捷键 Ctrl+N 即可呼出创建项目的菜单 创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分 HelloWorld.pro: Qt的工程文件，由qmake处理 main.cpp: 里面就是main函数 mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。 至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。 现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。 修改main.cpp文件 1234567891011#include &lt;QApplication&gt;#include &lt;QLabel&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QLabel label("HelloWorld"); label.show(); return a.exec();&#125; 再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的命名空间与作用域]]></title>
    <url>%2F2019%2F05%2F30%2FC-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决． 命名空间 也称为名字空间，可以解决多模块同名冲突的问题 命名空间的作用在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突． 解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间． 定义命名空间定义命名空间很简单只需要使用namespace关键字即可 我们可以定义一个命名空间将自己的类，函数或对象包括起来: 123456789101112131415namespace myspace&#123; class Test&#123; public: int a; Test(int a):this-&gt;a(a)&#123;&#125; &#125;; Test t(10);&#125;int main()&#123; using namespace myspace; Test t(20); cout&lt;&lt;t.a&lt;&lt;endl;&#125; 与类的成员类似，这些对象，函数，类，被称为名字空间的成员． using声明 using namespace 命名空间名; 在前面的内容中，已经不知不觉地使用上了名字空间，例如: 12using namespace std;cout&lt;&lt;"hello"&lt;&lt;endl; using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl. using指令倘若我们只需要使用std命名空间中的cout和endl成员，那么可以通过using指令指定待使用的命名空间的成员. 123using std::cout;using std::endl;cout&lt;&lt;"hello"&lt;&lt;endl; using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点. 命名空间的别名如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分. 123namespace myStd = std;myStd::cout&lt;&lt;"hello"&lt;&lt;myStd::endl; 其中myStd作为std命名空间的别名． 作用域 可以简称为域,是指对象的可见性问题 C++目前支持3种作用域: 局部作用域(local scope); 名字作用域(namespace scope); 类域(calss scope); 局部作用域在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用． 例如，函数体，循环体都是局部作用域: 12345void foo()&#123; int a(10);&#125;//error a超过了作用域，访问不到foo()函数内部的a变量cout&lt;&lt;a&lt;&lt;endl; 12345for(int i=0;i&lt;100;i++)&#123; cout&lt;&lt;i&lt;&lt;endl;&#125;//error i超过了for的作用域，i是for的局部变量cout&lt;&lt;i&lt;&lt;endl; 提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错. 下面再看一个case语句块的作用域 1234567891011int choose(-1);cin&gt;&gt;choose;switch(choose)&#123; case 0: string str; break; case 1: //error:重定义了str string str; break;&#125; 若不用{}将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下: 123456789101112131415int choose(-1);cin&gt;&gt;choose;switch(choose)&#123; case 0: &#123; string str; break; &#125; case 1: &#123; //error:重定义了str string str; break; &#125;&#125; 我们通过加上{}使得给每个case块加上了不同的作用域，也就解决了重定义的问题． 函数的作用域函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问． 函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制． 123456void foo(int i)&#123; //正常访问i变量 cout&lt;&lt;i&lt;&lt;endl;&#125;//error 未声明i变量cout&lt;&lt;i&lt;&lt;endl; 当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的 123456void foo(int i)&#123; cout&lt;&lt;i&lt;&lt;endl; if(i&gt;0)&#123; foo(i/2); &#125;&#125; 局部变量的存储类型你可能听说过:自动存储类型，静态存储类型，但是你听过寄存器存储类型么? 不同的存储类型，决定了C++编译器存储这些属性的空间和方式. 自动存储类型在默认情况下，我们定义的变量就属于自动存储类型 1234void foo()&#123; int a(10); cout&lt;&lt;a&lt;&lt;endl;&#125; 在foo()函数体执行完毕后a变量将会自动释放，我们也可以换种写法: 1234void foo()&#123; auto int a(10); cout&lt;&lt;a&lt;&lt;endl;&#125; 这样做只不过为了显式的说明这个是个自动存储类型的变量 我们还可以使用类函数观测自动存储类型的销毁时间: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Test &#123;public: int a; Test(int a); ~Test();&#125;;Test::Test(int a) : a(a) &#123; cout &lt;&lt; "创建[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl;&#125;Test::~Test() &#123; cout &lt;&lt; "销毁[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl;&#125;int main() &#123; Test t(10); Test t1(20); return 0;&#125; 输出结果 123456创建[0x7fff82f501c0]创建[0x7fff82f501c4]销毁[0x7fff82f501c4]销毁[0x7fff82f501c0]Process finished with exit code 0 以上代码就可观测到自动存储类型变量的自动销毁过程． 注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义． 1234void *foo()&#123; auto Test t(10); return &amp;t;&#125; 寄存器存储类型寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量． 12345void foo()&#123; for (register int i = 0; i &lt; 10000; ++i) &#123; cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上register仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效． 静态存储类型静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁． 请看下面的代码: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Test &#123; int _a;public: Test(int a) : _a(a) &#123; cout &lt;&lt; "创建[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; "销毁[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl; &#125;&#125;;void foo() &#123; //静态变量 static Test t(10); cout &lt;&lt; "t对象已销毁" &lt;&lt; endl;&#125;int main() &#123; //调用第一次 foo(); //调用第二次 foo(); return 0;&#125; 输出结果: 1234创建[0x5645e7afa19c]t对象已销毁t对象已销毁销毁[0x5645e7afa19c] 可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量t依然存在! 常见用法 程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据. 12345678910111213141516#include &lt;iostream&gt;using namespace std;void foo() &#123; static int i(0); i++; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "次调用foo()" &lt;&lt; endl;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) &#123; foo(); &#125; return 0;&#125; 输出结果 12345第1次调用foo()第2次调用foo()第3次调用foo()Process finished with exit code 0 今天就先写到这里，继续学习了. 命名空间域全局域123456789101112131415161718//全局作用域下的varAint varA=100;void foo1()&#123; varA++;&#125;void foo2()&#123; int varA=200; ::varA++; //输出内部作用域的varA cout&lt;&lt;varA&lt;&lt;endl; //输出全局作用域的varA cout&lt;&lt;::varA&lt;&lt;endl;&#125;int main() &#123; foo1(); foo2(); return 0;&#125; 输出结果 1234200102Process finished with exit code 0 最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。 我们使用域操作符”::”来显式的指定作用域。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法-1]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来. 常用算法 本页理解几个常用的算法 冒泡排序冒泡排序是一种稳定的排序算法 稳定即是，如果相邻的元素相同，不会再去进行调换位置 冒排的运作是(从后往前)。 我们操作数组来进行演示。 我们首先定义一个整型数组里面存储几个整型数据 12//待排序的数列int[] nums = &#123;9,6,4,3,10,25&#125;; 基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。 每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。 我们尝试先用大脑来演示排序的过程12345678//未排序时9 6 4 3 10 256 9 3 4 10 25 //第一轮 调换了2次6 3 4 9 10 //第二轮 调换了2次3 4 6 9 //第三轮 调换了2次3 4 6 //第四轮 调换了0次3 4 //第五轮 调换了0次 我们可以看到我们这组数据只需要排序三轮就可以排序成功，排序轮数是数组长度-1轮，调换次数是看数组相邻元素的大小关系，这个我们不用知道，我们只需要记住，排序轮数是数组长度-1就好。 那么在代码中我们要如何将其进行调换呢？ 有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。 了解了基本思路，我们直接进行代码编写吧！ 123456789101112131415161718192021222324252627public class Demo&#123; public static void main(String args[])&#123; //待排序的数列 int[] nums = &#123;9,6,4,3,10,25&#125;; //临时变量，用于调换位置 int temp; //第一层循环，控制轮数 for(int i = 0;i &lt;nums.length;i++)&#123; //第二层，控制每轮要进行排序的元素数量 for(int j = 0;j&lt;nums.length-1-i;j++)&#123; //如果当前元素比后一个元素大那么则调换元素值 if(nums[j]&gt;nums[j+1])&#123; //我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖 temp = nums[j+1]; //把当前元素的值覆盖后一个元素 nums[j+1] = nums[j]; //再把当前元素存入后一个元素的值(刚刚保存在temp变量里的) nums[j] = temp; &#125; &#125; &#125; //遍历输出 for(int num:nums)&#123; System.out.println(num); &#125; &#125;&#125; 刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。 引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码 123456789101112131415161718/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*///这个if不用加，我只是让你们知道是哪些代码if(nums[j]&gt;nums[j+1])&#123; //当前元素的值是与后一个元素值的和 nums[j] = nums[j]+nums[j+1]; //上一行代码等同于 nums[j] = 9 + 6 //执行完上一行代码，nums[j] = 15; //执行完此行代码nums[j+1] = 9 //等价于 nums[j+1]= 15 - 6 nums[j+1] = nums[j]-nums[j+1]; //执行完此行代码nums[j] = 6 //等价于 nums[j] = 15 - 9 nums[j] = nums[j] - nums[j+1];&#125; 第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！ 下一记: 选择排序算法 选择排序算法 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。 上面这个引用是网上随便抄的一个思路。 这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。 我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。 下面我们直接看代码 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; //需要排序的数组 int[] nums = &#123;6, 9, 4, 4, 25, 10&#125;; //记录每轮排序时最小元素的下标 int minIndex; //第一层循环控制轮数 for (int i = 0; i &lt; nums.length - 1; i++) &#123; minIndex = i;//假设当前轮最小元素下标为i //内层循环要记录出当前轮最小元素的下标 for (int j = i + 1; j &lt; nums.length; j++) &#123; //比较两个相邻元素的大小 if (nums[minIndex] &gt; nums[j]) &#123; //由于找到新的最小值，所以记录一下 minIndex = j; &#125; &#125; //如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置 if (minIndex != i) &#123; //下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大 nums[minIndex] += nums[i]; nums[i] = nums[minIndex] - nums[i]; nums[minIndex] -= nums[i]; &#125; &#125; //遍历输出排序后的结果 for (int num : nums) &#123; System.out.println(num); &#125; &#125;&#125; 小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。 下一节，二分查找算法 二分查找法 这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。 二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是: 定义起始查找位，结束查找位 求得数组长度中间值都 如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。 如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。 如果要查找的值等于中间值，那么直接返回中间值的下标即可 如果都没找到，那么返回-1. 看了这个概念，我们还得注意几点 需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。 好了，我们直接看代码吧！ 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; int nums[] = &#123;1,3,5,78,90,100,300&#125;; System.out.println(binarySearch(nums,1)); &#125; /** * 二分查找法 * @param nums 要查找的数列 * @param key 要查找的值 * @return */ static int binarySearch(int[] nums,int key)&#123; //起始下标 int start = 0; //结束下标 int end = nums.length-1; //起始查询的下标不能超过结束下标 while(start&lt;=end)&#123; //中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值 int middle = (start+end)/2; //如果中间下标的值比要查找的值大 if(nums[middle]&gt;key)&#123; //要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找 end = middle-1; &#125;else if(nums[middle]&lt;key)&#123; //二分的右边开始查找 start = middle+1; &#125;else&#123; //如果要查找的值就是二分下标的值，那么直接返回即可 return middle; &#125; &#125; //如果没有查找到那么则返回-1代表没有查找到 return -1; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何自学编程?]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。 今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到， 为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。 0x0 制定目标这个目标最好是十分远大的，并且必须是准确的。 例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。 制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。 0x1 选择方向你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。 当然，我这里是推荐学习C++，虽然它曾经被我的偶像Linus Torvalds臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种hack玩法。 0x2 学习过程在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。 0x21学习心态我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。 0x22学习方法不要问，去调试，去反编译 这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。 多写代码，多讨论，尝试新想法 多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。 多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。 尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。 0x3 充分利用互联网虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。 不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下原子弹制作从入门到精通。这边推荐一个更好的利用搜索引擎的文章点击访问 0x4 读书在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。 推荐书籍以后会写。 0x5 推荐学习C++视频教程 C++书籍 Git视频教程 0x6 其他如果你是Windows系统，那么推荐Visual Studio作为你的编程工具。 如果你是Linux系统，那么推荐CLion作为你的编程工具。 如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。 推荐学习资源:点击访问 0x7 讨论群组]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++读写文件]]></title>
    <url>%2F2019%2F05%2F22%2FC-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一些简单的读写文件的操作。 本篇文章使用C++fstream头文件提供的库函数进行读写操作 请引入#include \&lt;fstream>进行下面的操作。 写入写入文件步骤如下: 实例化ofstream对象，或者fstream对象. ofstream ofs; 打开文件流 ofs.open(const std::string &amp;s,ios_base::openmode=ios_base::out); 写入文件 ofs&lt;&lt;; 关闭文件流 ofs.close(); 注意打开文件流函数的参数分别为路径和打开方式. 常用的打开方式如下: 模式标识 适用对象 描述 ios::int ifstream,fstream 打开输入,默认用于ifstream和fstream ios::out ofstream,fstream 打开输出，默认用于ofstream和fstream ios::trunc ofstream 打开输入，默认用户ofstream ios::ate ifstream 打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错 ios::app ostream,fstream 打开输出，并且将数据输出至文件末尾，相当与追加 iso::binary ifstream,ofstream,fstream 以二进制的方式打开文件，进行输入或输出 以上所有的打开方式可以通过或|运算符进行联合使用，例如: 12//以二进制的方式打开输出ofstream ofs(path,ios::out|ios::binary); 不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作 好的，下面可以看例子了，我们将写入一些数据到一个文件内。 以文本写入 下面将读取两种不同类型的文件以作为案例进行讲解。 1234567891011121314151617181920/** * 写入文件 * @param path 文件路径 * @param context 内容 */void writeFile(string path,string context)&#123; //实例化写入对象 ofstream ofs; //打开输出 ofs.open(path,ios::out); //向文件写入数据 ofs&lt;&lt;context&lt;&lt;endl; //关闭输出 ofs.close();&#125;int main()&#123; //调用 writeFile("./test.txt","测试");&#125; 这样我们就将测试这个段文本信息，写入到当前目录下test.txt文件内了. 以二进制文件写入以二进制文件方式写入，C++提供了write()库函数,它的函数原型是: write(const _CharT* __s, streamsize __n); 其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。 123456789101112131415161718192021222324252627282930class Student &#123;private: char name[64]; int age;public: Student(char name[64], int age) &#123; for (int i = 0; i &lt; sizeof(name); ++i) this-&gt;name[i] = name[i]; this-&gt;age = age; &#125;&#125;;`/** * 写入二进制文件 * @param path */void writeFileByBinary(string path) &#123; //创建输出流对象，并且指定路径和文件打开方式 ofstream ofs(path, ios::out | ios::binary); Student *student = new Student("张三", 18); //写入文件 ofs.write((const char *) student, sizeof(Student)); ofs.close(); delete (student);&#125;int main()&#123; writeFileByBinary("student.bin");&#125; 这里我们将类成员属性的值以二进制的方式写入进一个文件内。 最终文件内的内容人类是看不大懂的。 注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码. 读取 下面将读取两种不同类型的文件以作为案例进行讲解。 以文本文件读取读取有很多种方式，下面将会演示三种，分别是: 逐行读取 逐词读取 逐字符读取 逐字符读取(不推荐)逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。 123456789101112131415161718/** * 逐字符读取 * @param path 路径 */void readFile04(string path) &#123; //实例化读取操作对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //数据存储变量 char cbuffer; //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾. while ((cbuffer = ifs.get()) != EOF) &#123; cout &lt;&lt; cbuffer &lt;&lt; endl; &#125; //关闭文件 ifs.close();&#125; EOF代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。 逐行读取(有两种方式，但都是逐行读取)第一种： 123456789101112131415161718/** * 逐行读取 * @param path 路径 */void readFile02(string path) &#123; //实例化 fstream fs; //打开文件 fs.open(path, ios::in); //用字符数组进行缓存 char buffer[1024] = &#123;0&#125;; //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数) while (fs.getline(buffer, sizeof(buffer))) &#123; cout &lt;&lt; buffer &lt;&lt; endl; &#125; //关闭文件 fs.close();&#125; 使用字符数组作为数据存储容器，用fstream对象的getline()函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用sizeof()是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。 第二种: 123456789101112131415161718/** * 逐行读取 * @param path 路径 */void readFile03(string path) &#123; //实例化读取操作对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //数据存储容器 string buffer; //使用全局函数getline(输入流，可存储的容器)进行逐行读取 while (getline(ifs, buffer)) &#123; cout &lt;&lt; buffer &lt;&lt; endl; &#125; //关闭文件 ifs.close();&#125; 与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数getline(输入对象,数据存储容器),它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。 逐词读取(以空格区分)逐词读取，将会已空格进行区分每个词汇，再读取。 12345678910111213141516171819202122/** * 逐词读取文件 * @param path 文件路径 */void readFile01(string path) &#123; //实例化读取文件对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //判断文件是否能打开 if (!ifs.is_open()) &#123; cout &lt;&lt; "文件打开失败!" &lt;&lt; endl; return; &#125; //字符数组缓存 char buffer[1024] = &#123;0&#125;; //将读取的数据放入缓存区 while (ifs &gt;&gt; buffer) cout &lt;&lt; buffer &lt;&lt; endl; //关闭文件 ifs.close();&#125; 这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。 这种逐词读取的方式是读取对象通过右移运算符把读取的数据存入容器之中，但是是以空格区分每个词汇。 以二进制的方式读取前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。 1234567891011121314/** * 以二进制的方式读取文件 * @param path 路径 */void readFileByBinary(string path) &#123; //创建输入流对象，并且指定路径和文件打开方式 ifstream ifs(path, ios::in | ios::binary); char * c = new char[64]; ifs.read(c, sizeof(c)); cout&lt;&lt;c&lt;&lt;endl;&#125;int main()&#123; readFileByBinary("Student.smi");&#125; 输出结果: 123张三Process finished with exit code 0 这里我们将Student.smi这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。 总结读取文件创建ifstream对象,写入文件创建ofstream对象，fstream对象既可以读又可以写。 操作文件得先打开文件 操作文件完毕得关闭文件 二进制文件读取需要读取二进制格式的文件]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我儿子的博客]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%88%91%E5%84%BF%E5%AD%90%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。 随便截取一个片段，这哥们咋那么傻的可爱。 想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。 PS:痔疮，你看到了别打我 EvanShady的博客]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>欢乐时光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决KDE下部分应用不能使用fcitx中文输入法的问题]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%A7%A3%E5%86%B3KDE%E4%B8%8B%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8fctix%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。 *** 本教程使用fcitx输入法框架。** 第一步首先安装一些必要的软件: 1$ sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin 第二步安装完成后编辑:/etc/environment文件，加上如下内容: 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 第三步注销当前会话，配置输入法为googlepinyin即可使用。 本文参考]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>KDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2F2019%2F05%2F17%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。 什么是友元？友元可以访问类中私有的成员。 它的使用场景又如下几种: 全局函数作友元 类作友元 成员函数做友元 实例下面将通过几个案例，分别演示不同场景下，友元的使用方式。 全局函数作友元本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//先声明Person类，防止下面报错class Person;//声明showPrivateVar函数，防止报错.void showPrivateVar();//定义Person类class Person&#123;private: //私有属性，money,showPrivateVar函数访问的就是这个 double money;public: //声明构造函数 Person();&#125;;//类外定义构造函数Person::Person()&#123; this-&gt;money = 10;&#125;/** * 访问私有成员 */void showPrivateVar()&#123; //实例化Person类对象 Person p; //访问Person对象的私有成员 cout&lt;&lt;"尝试访问Person类的私有属性:"&lt;&lt;p.money&lt;&lt;endl;&#125;int main()&#123; //调用访问私有成员函数 showPrivateVar(); return 0;&#125; 显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。 12345678910class Person&#123; //使showPrivateVar函数作为Person类的友元 friend void showPrivateVar();private: //私有属性，money,showPrivateVar函数访问的就是这个 double money;public: //声明构造函数 Person();&#125;; 运行结果: 123尝试访问Person类的私有属性:10Process finished with exit code 0 我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员. 那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。 类作类的友元这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;//声明类，防止报错class Build;/** * Build类的好朋友类，可以访问它的私有属性 */class FriendForBuild&#123; Build * b;public: //声明构造函数 FriendForBuild(); //声明visit函数 void visit();&#125;;//定义Build类class Build&#123; friend FriendForBuild;private: //私有房间 string privateRoom;public: //公共房间 string publicRoom; /** * 构造函数 */ Build()&#123; this-&gt;privateRoom = "私人卧室"; this-&gt;publicRoom = "公共客厅"; &#125;&#125;;FriendForBuild::FriendForBuild() &#123; b = new Build();&#125;/** * 访问Build类对象的所有成员，包括私有成员 */void FriendForBuild::visit()&#123; cout&lt;&lt;"我正在访问Build类对象的publicRoom成员:"&lt;&lt;b-&gt;publicRoom&lt;&lt;endl; cout&lt;&lt;"我正在访问Build类对象的privateRoom成员:"&lt;&lt;b-&gt;privateRoom&lt;&lt;endl;&#125;int main()&#123; FriendForBuild friendForBuild; friendForBuild.visit(); return 0;&#125; 输出结果: 1234我正在访问Build类对象的publicRoom成员:公共客厅我正在访问Build类对象的privateRoom成员:私人卧室Process finished with exit code 0 可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。 成员函数做友元上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;//声明类，防止报错class Build;/** * Build类的好朋友类，可以访问它的私有属性 */class FriendForBuild&#123; Build * b;public: //声明构造函数 FriendForBuild(); //声明visit函数 void visit();&#125;;//定义Build类class Build&#123; friend void FriendForBuild::visit();private: //私有房间 string privateRoom;public: //公共房间 string publicRoom; /** * 构造函数 */ Build()&#123; this-&gt;privateRoom = "私人卧室"; this-&gt;publicRoom = "公共客厅"; &#125;&#125;;FriendForBuild::FriendForBuild() &#123; b = new Build();&#125;/** * 访问Build类对象的所有成员，包括私有成员 */void FriendForBuild::visit()&#123; cout&lt;&lt;"我正在访问Build类对象的publicRoom成员:"&lt;&lt;b-&gt;publicRoom&lt;&lt;endl; cout&lt;&lt;"我正在访问Build类对象的privateRoom成员:"&lt;&lt;b-&gt;privateRoom&lt;&lt;endl;&#125;int main()&#123; FriendForBuild friendForBuild; friendForBuild.visit(); return 0;&#125; 总结友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinuxTG讨论群组]]></title>
    <url>%2F2019%2F05%2F16%2FManjaroLinuxTG%E8%AE%A8%E8%AE%BA%E7%BE%A4%E7%BB%84%2F</url>
    <content type="text"><![CDATA[创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。 点击加入]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Telegram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux之路]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法. 先说说一些题外话 我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。 第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。 我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢? 某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了…. 好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。 身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。 终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。 自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞! 下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。 说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验） 我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。 我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。 下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了! 解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。 但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。 总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝和浅拷贝的区别]]></title>
    <url>%2F2019%2F05%2F14%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。 浅拷贝我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。 那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。 那什么是拷贝构造函数呢? 拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象 下面看个例子: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; age = f_age; cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //析构函数 ~Human() &#123; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt; h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt; h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 1234567Human有参构造函数调用.李四的年龄为:18李四的年龄为:18Human析构函数调用.Human析构函数调用.Process finished with exit code 0 根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。 浅拷贝的具体代码实现是怎样的呢？请看下面的代码: 12345//默认的拷贝构造函数Human(const Human &amp; h)&#123; name = h.name; age = h.age;&#125; 可与看出，它只是简单的将对象属性的值，进行拷贝。 大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？ 答案是否定的，下面看下深拷贝。 深拷贝什么是深拷贝? 深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景. 下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int *age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; //动态分配内存空间，将age的数据存入堆区 age = new int(f_age); cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //析构函数 ~Human() &#123; //如果age指针变量是空，则释放 if(age !=NULL)&#123; delete age; //防止指针变量成为野指针 age = NULL; &#125; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt;*h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt;*h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 1234567free(): double free detected in tcache 2Human有参构造函数调用.李四的年龄为:18李四的年龄为:18Human析构函数调用.Process finished with exit code 134 (interrupted by signal 6: SIGABRT) 通过输出结果，我们发现，程序发生了错误。 因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。 上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。 由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。 然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。 既然问题找到了，我们就需要进行修改，将这个问题解决。 下面通过深拷贝的方式，让这个bug被修复: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int *age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; //动态分配内存空间，将age的数据存入堆区 age = new int(f_age); cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //拷贝构造函数 Human(const Human &amp; h)&#123; name = h.name; //新开辟内存空间到堆区，存放age所指向的数据。 age = new int(*h.age); cout&lt;&lt;"Human拷贝构造函数调用."&lt;&lt;endl; &#125; //析构函数 ~Human() &#123; //如果age指针变量是空，则释放 if(age !=NULL)&#123; delete age; //防止指针变量成为野指针 age = NULL; &#125; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt;*h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt;*h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 12345678Human有参构造函数调用.李四的年龄为:18Human拷贝构造函数调用.李四的年龄为:18Human析构函数调用.Human析构函数调用.Process finished with exit code 0 程序没有报错，说明我们的bug成功解决了。 上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。 深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。 为什么能避免？ 原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。 两者该如何选择?说得绝对点： 若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。 这时需要使用深拷贝。 说的不那么绝对: 若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经典案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2008年5月12日14时28分04秒]]></title>
    <url>%2F2019%2F05%2F12%2F2008%E5%B9%B45%E6%9C%8812%E6%97%A514%E6%97%B628%E5%88%8604%E7%A7%92%2F</url>
    <content type="text"><![CDATA[图为汶川大地震时某部队空降救灾 0x005·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。 此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。 伤亡人数：69227人遇难，374643人受伤，17923人失踪。 以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。 0x01每年的这个时刻，我都不由自主的想起这个事情。 2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。 那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课， 突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。 这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！ 跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。 宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。 因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。 大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。 晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。 学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。 天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。 0x022008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。 我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。 两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。 这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。 这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。 谷歌当时的博文说道： “当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。” 几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。 全世界的中华儿女在这三分钟连在了一起。 0x03在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。 大家那时候就只有一个身份，就叫中国人。 那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。 况且古往今来，历史诚不欺我。 知乎 ———— 小小白告 汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。 打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。 最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。 多年过去，讲起这个故事，仍旧热泪盈眶。 知乎 ———— 匿名用户 昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。 她给我看她们初中的学校。 我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。 我听了这句话瞬间眼睛红了，那年她初二，今年她研二。 活着，本身就意味着一切。 知乎 ———— 匿名用户 推荐25分钟纪录片:《为了生命》。 本篇文章转载于：阅读原文作者：纯洁的微笑(一个有故事的程序员)]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>社会事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之代码区与全局区]]></title>
    <url>%2F2019%2F05%2F11%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[其实这一篇应该是作为”C++内存四区”的第一篇的。 0x00 内存分区模型C++程序在执行时，内存大方向的可划分为 *四个区域** 代码区: 存放代码的二进制代码，由操作系统进行管理。 全局区: 存放全局变量和静态变量以及常量。 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 内存四区的意义:不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。 0x01 程序运行前在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域 代码区: 存放CPU执行的机器指令 共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。 只读的，为了防止程序意外修改代码的指令，所以有了只读。 如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中, 而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之堆区]]></title>
    <url>%2F2019%2F05%2F10%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[什么是堆区由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收． 如何将数据放在堆区在C++中由new关键字在堆区中开辟内存。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int* func()&#123; //创建局部指针变量，但是数据是存放在堆区的。 int *a_p= new int(10); return a_p;&#125; int main()&#123; int *p = func(); cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出结果为: 110 看到上述代码的创建局部指针变量，但数据存放在栈区是什么意思呢? 其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。 也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之栈区]]></title>
    <url>%2F2019%2F05%2F10%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E6%A0%88%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[什么是栈区栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等.. 操作栈区的注意事项在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址． 因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错． 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int *func()&#123; //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放． int a = 10; //尝试返回局部变量的地址 return &amp;a;&#125;int main()&#123; //接受func的返回值 int *p = func(); //输出p cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出结果: 1Process finished with exit code 139 (interrupted by signal 11: SIGSEGV) 上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题． 其他问题可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端多窗口神器——Screen]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%BB%88%E7%AB%AF%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Screen%2F</url>
    <content type="text"><![CDATA[曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。 曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。 有了Screen,你就可以获得更好的使用终端多窗口的体验。 我想你肯定遇到以下几种情况: ftp传输 系统备份 长时间运行任务 好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。 凶手 SIGHUP 信号 以下资料来自维基百科 SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。 简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。 发送信号在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。 Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。 Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。 Ctrl-\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。 前因后果相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。 更多有关SIGHUP信号的资料，我会在后面的文章进行更新。 开始使用Screen先简单说说什么是Screen: Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。 Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。 1.创建一个screen窗口 1[evanmeek@Evan-PC]# screen 这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。 2.创建窗口+执行命令 1[evanmeek@Evan-PC]# screen vim screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。 3.一个窗口中再有一个窗口中再有一个窗口中… 你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。 4.screen的暂时断开(detach)和重新链接(attach) 比如在screen窗口下用vim编辑C++源文件 1[evanmeek@Evan-PC]# screen vim test.cpp 但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached). 当你做完其他事你就可以找回该会话，进行重新连接: 找到会话 12345[evanmeek@Evan-PC]# screen -lsThere are screens on: 17944.pts-4.EvanLinux (Detached) 14290.server (Detached)2 Sockets in /run/screens/S-evanmeek. 重新连接 1[evanmeek＠Evan-PC]# screen- r 17944 这样就可以恢复pts这个会话的窗口了． 配置你的Screen前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符. 可通过如下键绑定查看所有键绑定． C-a ? 常用的键绑定有： 键绑定 描述 C-a ? 显示所有键绑定信息 C-a w 显示所有窗口列表 C-a C-a 切换到之前显示的窗口 C-a c 创建一个新的运行shell的窗口并切换到该窗口 C-a n 切换到下一个窗口 C-a p 切换到前一个窗口 C-a 0~9 切换到0~9窗口 C-a a 发送C-a到当前窗口 C-a d 暂时断开screen会话 C-a k 杀掉当前窗口 C-a [ 进入拷贝/回滚模式 我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a; ; 我们可以修改它，通过如下格式: -exy x:命令字符 y:转义字符 1[evanmeek@Evan-PC]# screen -e^oo 这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>软件折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的解压与压缩]]></title>
    <url>%2F2019%2F05%2F08%2FLinux%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。 在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。 Linux下有三种主流常用的解压压缩软件可选: gzip (GNUzip) bz2 (bzip2) xz (xzutils) 三个软件的参数相同，只是命令不同: 1$ gzip [参数] &lt;文件名&gt; 1$ bzip2 [参数] &lt;文件名&gt; 1$ xz [参数] &lt;文件名&gt; 可选参数 参数名 作用 -d 解压 -k 压缩时不删除源文件 -r 递归查找目录下的文件，并且压缩 -v 显示详细信息 -t 测试压缩包是否完整 -l 显示压缩包信息 -c 写入标准输出，保持原始文件不变 -1~9 压缩等级 示例: 压缩test.txt，并删除. 1$ gzip test.txt 压缩test.txt，不删除原文件，并且显示信息. 1$ gzip -vk test.txt 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz 1$ gzip -9cvk test.txt test2.txt &gt; test.gz 解压test.gz 1$ gzip -d test.gz 介绍完上面的几种压缩软件，下面介绍一个打包软件tar 我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。 压缩这里注意第一个参数，它们分别代表使用什么压缩软件。 bz21$ tar -jcvf test.tar.bz test/ xz1$ tar -Jcvf test.tar.xz test/ gzip1$ tar -zcvf test.tar.gz test/ 解压只需要看文件名的后缀，然后把参数c改为x即可.x代表解压. 1$ tar -Jxvf test.tar.xz test/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针[基础02]]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[C++指针和数组的操作。 C++中访问数组元素可以使用如下示例进行访问: 123int arr[3]=&#123;0,1,2&#125;;cout&lt;&lt;"第2个元素为:"&lt;&lt;arr[1]&lt;&lt;endl; 想必大家都知道输出的值为:1 那么我们现在可以使用指针进行访问数组元素 数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。 12345int arr[3]=&#123;0,1,2&#125;;int *p = arr;cout&lt;&lt;"p:"&lt;&lt;*p&lt;&lt;endl; 输出结果为: 1p:0 提问: 为什么指针可以指向数组名，而不需要使用引用符(&amp;)？ 疑惑解答: 那是因为在C++中，数组其实就是一块内存空间，然而里面的每个元素也就组成了一块连续的内存空间，而数组名就当任了数组的首地址的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。 通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1]; 12345678int arr[3]=&#123;0,1,2&#125;;int *p = arr;//对指针进行位偏移p++;cout&lt;&lt;"p:"; 输出结果: 1p: 1 上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。 最后利用指针遍历输出数组内的元素 1234567int arr[3] = &#123;0,1,2&#125;;int *p = arr;for(int i = 0;i &lt;3;i++,p++)&#123; std::cout&lt;&lt;*p&lt;&lt;std::endl;&#125; 输出结果: 123012]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针[基础01]]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[开始写C++中比较难理解的几个知识点的笔记。 0x00 空指针用途:给指针初始化值。 特性:空指针不可访问。 为什么不可访问? 因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。 报错例子 12345//定义空指针int *p = NULL;//尝试修改空指针所指向的空间的值,报错!*p = 2; 常用情景 1234567//定义空指针int *p = NULL;int a = 10;//使指针重新指向内存空间,可行!p = &amp;a; 小结 空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。 0x01 野指针说明:指针指向的是非法的内存空间叫做野指针 异常:读取访问权限错误 报错例子: 12345//使指针指向一个未知空间int *p = (int*)0x1010;//尝试修改指向的空间的值,报错!*p = 10; 小结 我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃! 0x02 const修饰指针const修饰指针分为三种场景 const修饰指针————常量指针 const修饰常量————指针常量 const既修饰指针又修饰常量 常量指针 12345678910int a=10,b=20;//定义常量指针const int *p = &amp;a;//尝试修改指针所指向空间的值,报错!*p = 20;//指针重新指向新的空间,可行!p = &amp;b; 看上面的案例，可以得出，常量指针是不能修改所指向的空间的值，但可重新指向新的空间,并且定义时，const关键字是放在指针的左侧的。 指针常量 12345678910int a=10,b=20;//定义指针常量int * const p = &amp;a;//修改指针所指向空间的值,可行!*p=20;//尝试为指针重新指向新的空间，报错!p = &amp;b; 看上面的案例，可以得出，常量指针可修改所指向的空间的值，但不可重新指向新的空间,并且定义时，const关键字是放在指针的右侧的。 既修饰指针又修饰常量 123456789101112int a=10,b=20;//定义同时const修饰指针常量的指针const int * cosnt p = &amp;a;//尝试修改指针所指向的空间的值，报错!*p = 20;//尝试为指针重新指向新的空间，报错!p = &amp;b; 看上面的案例，可以得出，如果指针和常量都被const修饰，那么就和const 引用非常类似了。 小结 常量指针 不可修改所指向的空间的值 可重新指向新的空间 指针常量 可修改所指向的空间的值 不可重新指向新的空间 指针和常量都被const所修饰 不可修改所指向的空间的值 不可重新指向新的空间 小技巧 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>学习笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next插入网易云音乐]]></title>
    <url>%2F2019%2F04%2F30%2Fhexo-next%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[让大爷们在阅读博客时能优哉游哉的听着歌看文章。 获取外链打开网易云音乐官网 找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。 可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧! 插入外链如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的. 如果是想插入到侧边栏 需要编辑next/layout/_macro/sidebar.swig文件 此时我们就需要使用开发者工具插入到自己合适的位置下 可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用hexo+github-pages搭建博客]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章. 为何选择hexo hexo博客框架的网上资料较多，技术较为成熟. hexo使用Makrdown进行渲染. hexo只需几步就可部署博客. hexo具有丰富的主题/插件可选. 安装hexo安装Nodejs,Git要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。 大部分发行版自带Git,Nodejs只需要一条命令: apt 1$ sudo apt install nodejs npm pacman 1$ sudo pacman -S nodejs npm 配置Nodejs安装完成Nodejs和Git后还需要设置npm的软件源. 在任意目录下执行如下命令: 1$ npm config set registry https://registry.npm.taobao.org 执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功): 1$ npm config get registry 配置Git注册Github注册Github 创建仓库创建Github仓库 注意: 仓库名必须是name.github.io 例如我的 evanmeek.github.io 需要设置两点: Git身份标识 12$ git config --global user.email "你的邮箱"$ git config --global user.name "你的名字" 推荐把邮箱和名字设置为Github上的邮箱和名字相同 SSH密钥 如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看: 1$ ls ~/.ssh 若没有则创建新的密钥 1$ ssh-keygen -t rsa -C "你的邮箱" 创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。 创建完成后，你会在~/.ssh内看到两个文件 分别是私钥(id_rsa),公钥(id_rsa.pub) 下一步则是需要在Github中添加刚刚生成的密钥 首先登陆Github,打开设置. 如图所示： 下一步找到SSH选项 如图所示： 下一步导入公钥 复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名 1$ cat ~/.ssh/id_rsa.pub 安装hexo前面安装完Nodejs和Git之后可以通过一条命令安装hexo 要使用sudo提权 执行如下命令: 1$ npm install -g hexo-cli 看到Done!之后则为安装成功. 开始搭建初始化hexo博客使用如下命令初始化博客 1$ hexo init &lt;目录&gt; 初始化完成之后目录结构大概是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 下面分别讲下这些文件或目录分别存放了些什么。 主配置文件: _config.yml 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件. 插件信息: package.json 包含了当前hexo博客中安装了哪些插件. 模板目录: scaffolds/ 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染. 资源目录: source/ 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下. 主题目录: themes/ 主题目录，所有的主题都丢在这里。 生成博客执行如下命令创建一篇博文: 1$ hexo n "文章名" hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了! 这一步用于生成静态文件(就是把md转为html的操作) 要在网站目录(就是初始化的目录下)下执行 1$ hexo generate 这个命令可以简化，并且还可以带两个参数 简化+参数:123$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)$ hexo g -w # 可以监视有哪些文件被生成了 配置hexo这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同. 下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。 找到deploy项 修改为: type为git不能为大写 部署博客部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署 本地部署 执行如下命令:1$ npm install hexo-deployer-git --save 1$ hexo s 执行完后可以通过localhost:4000进行查看. 部署到Github 1$ hexo d 这样就可以部署到Github了，通过https://你的Github用户名.github.io访问 寻找主题Hexo主题 把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。 使用体验还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客文章插入图片]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。 如何安装安装此插件很简单，你只需要在你的hexo目录下执行如下命令: 1$ npm install hexo-asset-image --save 如果安装速度很慢可以把npm源改为国内源。 点击打开npm源改为国内源的方法 在设置镜像源-&gt;npm国内源下 如何使用第一步首先，我们得先设置主目录(博客目录)下的 _config.yml 文件. 找到 post_asset_folder: 项，将其修改为 true 第二步使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。 然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。 栗子12$ hexo n "test"$ mv test.jpg source/_posts/test 插入图片 123![图片alt](图片地址)# ![test](./test/test.jpng)]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数探幽]]></title>
    <url>%2F2019%2F04%2F24%2FC-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD%2F</url>
    <content type="text"><![CDATA[本章内容 内联函数 引用变量 如何按引用传递函数参数 默认参数 函数重载 函数模板 函数模板具体化 本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步． C++内联函数 说明 内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部． 那么，我们现在就深入到程序内部． 首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成． 当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令． 执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处． 那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销． 所以 C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来． 相当于编译器将使用相应的函数代码替换函数调用． 对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销． 但是 虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快． 结论 我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间． 另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大． _除非_ :该函数被经常调用 使用 使用内联函数只需要做到以下两点即可： 在函数声明前加上关键字inline; 在函数定义前加上关键字inline; 通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方． 可能遇到的问题 在我们编写函数为内联函数时，编译器不一定满足这种要求． 编译器认为该函数过大或识别到函数调用了自己 (内联函数不能递归) . 有些编译器没有启动或实现这种特性． 案例 12345678910111213141516#include &lt;iostream&gt;using namespace std;inline double square(double x) &#123; return x * x; &#125;int main() &#123; double a(2.0), b(5.0), c(0); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; " \tc=" &lt;&lt; c &lt;&lt; endl; square(a); b = square(b); c = square(7 + 1); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; "\tc=" &lt;&lt; c &lt;&lt; endl; return 0;&#125; 该程序的输出为: 12此时a=2 b=5 c=0此时a=4 b=25 c=64 看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的． 也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递. 这使得C++的内联功能远远胜过C语言的宏定义 尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型. 这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参 内联与宏inline是C++新增的特性. C语言使用预处理语句#define来提供宏－－内联代码的原始实现． 例如下面这个例子. 12345#define SQUARE(X) X*Xa = SQUARE(2.0);b = SQUARE(3.2++);c = SQUARE(1+2.3); 上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的． 引用变量引用变量是C++新增的一种复合类型. 引用是为已定义的变量创建了一个别名． 例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同. 引用变量通常的使用场景是作为函数的形参． 通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径． 创建引用变量C++使用 &amp; 用于声明引用，但是它还有另外一个作用：地址运算符。 当&amp;为声明引用时可有这样的一个例子: 12int a;int &amp; b = a; 是否感觉跟指针有点相像呢？ 是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。 上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。 下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int a=1; int &amp; b = a; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; b = 2; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;"b-address:"&lt;&lt;&amp;b&lt;&lt;endl; return 0;&#125; 输出结果为: 123456a:1b:1a:2b:2a-address:0x7ffdd4c4ae74b-address:0x7ffdd4c4ae74 首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。 然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。 再然后，我们输出的不是a和b的值了而是输出它们的地址: 1cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; 此时的&amp;代表的就是地址运算符。 经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a,*p; int b,*p2(&amp;b); *p = a; return 0;&#125; 上述代码是可以编译通过的。 指针在声明时编译器允许不为其进行初始化值 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int a,&amp;b; b = a; return 0;&#125; 如果代码是这样，那么则编译不通过。 我们可以把引用看成cosnt指针，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。 也就是说： 1int a,&amp;b(a); 仅在表示上等同于 12int a;const int *p(&amp;a); 上面提到“仅在表示上等同于“为什么呢，请看下面的例子。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int a(10),&amp;b(a); cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; int c(20); b = c; cout&lt;&lt;"c:"&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; return 0;&#125; 输出结果为: 12345a:10b:10c:20a:20b:20 可以看到最初b引用的是a，但随后b作为c的引用： 1b = c; 这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的. 我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于: 1a = c; 也就是说，这意味着”将c变量的值赋给a变量“。 简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 下面有一段有趣的代码，你们可以看看。 12345int a(10);int *p =&amp;a;int &amp;b = *p;int c(20);*p = &amp;c; 上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。 将]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinux的安装过程]]></title>
    <url>%2F2019%2F04%2F23%2FManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[获取镜像ManjaroLinux官方提供了多个桌面环境的镜像，分别是: XFCE 特点 系统资源低耗，快速 KDE 特点 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+ GNOME 特点 简单易用，可定制化，美化较为简单，内存占用大 并且ManjaroLinux在国内有4个镜像源可选，分别是: 清华大学 中科大 华为 浙江大学 我们也可以直接使用官方的镜像源获取镜像Manjaro 选择好自己要使用的桌面环境就可以开始制作启动盘了。 制作启动盘Windows: 推荐使用Rufus进行制作启动盘。 下载好后直接选择镜像和要进行制作的U盘，选择开始。 开始时会让你勾选制作方式请选择dd模式 Linux: 只需要执行这几条命令 1$ sudo lsblk #列出系统上的所有磁盘 找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是sdb或sda 如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载. 1$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名， 取消挂载之后就可以进行格式化了. 1$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名. 格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘. 1$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda 如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。 开始安装最好是在网络稳定的环境下进行 第一步如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到: keytable————设置键盘布局 通常默认即可 lang————设置语言 设置为zh_CN，代表汉语 driver————设置使用的驱动是开源的还是不开源的 笔记本双显卡，想省电可以用free。 台式机单显卡，推荐nofree。 Boot————选择这个就开始安装了 第二步等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统) 这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。 标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。 点击后还可以设置一次语言，默认为中文了 然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。 下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。 再下一步就是分区了，这一步是挺重要的，请认真看。 默认情况下有两种选项: 抹除磁盘 将磁盘全部数据清除，分区是Manjaro自动帮你分配的. 这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。 手动分区 选择手动分区之后，你将看到: 如果你是单硬盘(也就是只有一个硬盘,mdzz) 那比较简单(就算有多个也没啥) 点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…) 然后就可以看到有一个空闲空间，选中它，然后可以看到创建按钮可以点击了 然后你就点击吧… 你就可以看到创建分区的窗口，我们要创建的分区是根目录,主目录，引导 引导的挂载点: /boot/efi 记得标记点为:boot 和 esp 根目录的挂载点: / 记得标记点为:root 主目录的挂载点: /home 如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。 要注意的是主目录要选择扩展分区。 下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。 用户名首字母不要大写 密码不要太简单 下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。 静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。 设置镜像源选择一个好的源是使用Linux体验是否良好的一个重要因素。 官方软件包源12$ sudo pacman-mirrors -i -c China -m rank$ sudo pacman -Syu 随便选一个就好，推荐中科大的(USTC). Aur软件包源123$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi$ sudo pacman -Syu 在最后一行输入: 12[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装签名 1$ sudo pacman -S archlinuxcn-keyring npm国内源首先你得先下载npm和nodejs 1$ sudo pacman -S npm nodejs 打开终端输入: 1$ npm config set registry https://registry.npm.taobao.org 测试是否成功: 1$ npm config get registry 如果看到上面这个链接就对了 pip国内源修改~/.pip/pip.conf (没有则创建) 修改为:1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com 你也可以使用其他的源 清华 阿里云 中国科技大学 豆瓣 安装软件首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库 Install Yay 1$ sudo pacman -S yay 安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8 Install Vim 1$ sudo pacman -S Vim Install VSCode 1$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制 Install OracleJDK8 1$ yay -S jdk8 #这里就是由第三方打包了的 Install 搜狗输入法 1$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin 再编辑配置文件~/.xprofile(若没有创建即可) 修改为: 12345export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 注销后就能使用搜狗输入法了 Install IDEA 12$ yay -S intellij-idea-community-edition #社区版 IDEA$ yay -S intellij-idea-ultimate-edition #付费版 IDEA Install CLion 1$ yay -S CLion Install 网易云音乐 1$ sudo pacman -S netease-cloud-music Install Chrome 1$ sudo pacman -S google-chrome 这样就能完成基本的日常使用啦~ 使用体验总结稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux 最终还是选择了Manjaro-kde 非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。 这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>折腾</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
</search>
