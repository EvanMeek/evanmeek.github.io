<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我不会编程的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evanmeek.github.io/"/>
  <updated>2019-07-05T14:15:08.668Z</updated>
  <id>https://evanmeek.github.io/</id>
  
  <author>
    <name>EvanMeek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyCollegeLife</title>
    <link href="https://evanmeek.github.io/2019/07/05/MyCollegeLife/"/>
    <id>https://evanmeek.github.io/2019/07/05/MyCollegeLife/</id>
    <published>2019-07-05T13:00:15.000Z</published>
    <updated>2019-07-05T14:15:08.668Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,<strong>day and night accompany friend</strong>.Of course,<strong>including you</strong>.</p><p>&emsp;Three years after,I become a <strong>college</strong> student，Maybe you guessed this <strong>article</strong> is about my college life.About at 2019-9-1 start my college lift.I think I have very <strong>excited</strong> at that time.</p><p>&emsp;Before school start，I <strong>participate in</strong> <strong>Military training</strong>.Remember that time ,about one hundred peoples <strong>trained</strong> in a groups together,Instructor look we are tired,then he will say:”Everyboby listen! Drop Down!”，<strong>In the twinkling of an eye</strong> one hundred peoples on the ground <strong>lie</strong>.This time nobody care isn’t dirty，just look the sky，think，THE SKY SO BEATUIFUL.</p><p>&emsp;<strong>The fight of time</strong>，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know’s friend add WeChat Friend，Of course，me too.</p><p>&emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It’s because he teach for me so many <strong>knowledge</strong>.</p><p>&emsp;At the last，I <strong>sincerely</strong> thank my instructor，Peace!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,&lt;strong&gt;day and night accompany friend
      
    
    </summary>
    
      <category term="英文文章" scheme="https://evanmeek.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="个人感想" scheme="https://evanmeek.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Fraudster Shop-坑爹商店</title>
    <link href="https://evanmeek.github.io/2019/07/05/Fraudster-Shop-%E5%9D%91%E7%88%B9%E5%95%86%E5%BA%97/"/>
    <id>https://evanmeek.github.io/2019/07/05/Fraudster-Shop-坑爹商店/</id>
    <published>2019-07-05T08:44:41.000Z</published>
    <updated>2019-07-05T12:47:26.228Z</updated>
    
    <content type="html"><![CDATA[<p>  昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。<br><a id="more"></a></p><hr><h1 id="Chinese"><a href="#Chinese" class="headerlink" title="Chinese"></a>Chinese</h1><p>&nbsp;&nbsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。</p><p>&nbsp;&nbsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。</p><p>&nbsp;&nbsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?” 我说，老板想都没想说了句,”有啊!”，说着便拿出一小沓U盘，我看了看说道:”老板，这些都不是USB3.0，你拿其他的给我看一下吧!”，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，你一个小时后再来吧，我这里3.0</p><p>未完待续…</p><p>&nbsp;</p><h1 id="English"><a href="#English" class="headerlink" title="English"></a>English</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="英文文章" scheme="https://evanmeek.github.io/categories/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="日常" scheme="https://evanmeek.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>超酷-字符文件管理-ranger</title>
    <link href="https://evanmeek.github.io/2019/07/03/%E8%B6%85%E9%85%B7-%E5%AD%97%E7%AC%A6%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-ranger/"/>
    <id>https://evanmeek.github.io/2019/07/03/超酷-字符文件管理-ranger/</id>
    <published>2019-07-03T01:47:24.000Z</published>
    <updated>2019-07-03T03:19:03.563Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="/2019/07/03/超酷-字符文件管理-ranger/ranger-pre.png" alt="ranger"></p><h1 id="0x0-什么是ranger"><a href="#0x0-什么是ranger" class="headerlink" title="0x0 什么是ranger?"></a>0x0 什么是ranger?</h1><p><code>ranger</code>是一个基于文本的文件管理器，由Python编写。</p><h1 id="0x1-为什么要选择ranger"><a href="#0x1-为什么要选择ranger" class="headerlink" title="0x1 为什么要选择ranger?"></a>0x1 为什么要选择ranger?</h1><p><code>ranger</code>具有以下特性:</p><ul><li><p>vi风格的快捷键</p></li><li><p>书签</p></li><li><p>选择</p></li><li><p>标签</p></li><li><p>选项</p></li><li><p>命令历史</p></li><li><p>创建符号链接</p></li><li><p>任务视图</p></li><li><p>自定义命令</p></li><li><p>自定义快捷键按</p></li></ul><h1 id="0x2-使用ranger"><a href="#0x2-使用ranger" class="headerlink" title="0x2 使用ranger"></a>0x2 使用ranger</h1><p>在终端内输入<code>ranger</code>以启动ranger</p><p>使用<code>h j k l</code>进行目录之间的进出。</p><h1 id="0x3-配置ranger"><a href="#0x3-配置ranger" class="headerlink" title="0x3 配置ranger"></a>0x3 配置ranger</h1><p>配置文件:</p><ul><li><p>rc.conf 基本选项与快捷键设置</p></li><li><p>commands.py 可在ranger下使用<code>:</code>执行的命令</p></li><li><p>rifile.conf 文件关联，控制不同文件用不同程序打开</p></li></ul><p>配色方案:</p><p><code>ranger</code>默认自带四种配色方案:<code>defalut</code> <code>jungle</code> <code>snow</code> <code>zenburn</code></p><p>使用<code>:set colorscheme scheme</code>进行切换。</p><p>自定义配色方案文件放在<code>~/.config/ranger/colorschemes</code></p><h1 id="0x4-我的ranger配置"><a href="#0x4-我的ranger配置" class="headerlink" title="0x4 我的ranger配置"></a>0x4 我的ranger配置</h1><p>以上传至Github</p><p><a href="https://github.com/EvanMeek/Vanilla/tree/master/ranger" target="_blank" rel="noopener">点击访问</a></p><h1 id="0x5-其他"><a href="#0x5-其他" class="headerlink" title="0x5 其他"></a>0x5 其他</h1><p>下载地址:<a href="https://github.com/ranger/ranger/releases" target="_blank" rel="noopener">点击获取</a></p><p>Arch系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; pacman -S ranger</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/03/超酷-字符文件管理-ranger/ranger-pre.png&quot; alt=&quot;ranger&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x0-什么是ranger&quot;&gt;&lt;a href=&quot;#0x0-什么是ranger
      
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>最快-GPU加速-Alacritty终端</title>
    <link href="https://evanmeek.github.io/2019/07/03/%E6%9C%80%E5%BF%AB-GPU%E5%8A%A0%E9%80%9F-Alacritty%E7%BB%88%E7%AB%AF/"/>
    <id>https://evanmeek.github.io/2019/07/03/最快-GPU加速-Alacritty终端/</id>
    <published>2019-07-02T23:06:11.000Z</published>
    <updated>2019-07-03T02:10:35.140Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="/2019/07/03/最快-GPU加速-Alacritty终端/ponysay.png" alt="ponysay"></p><h1 id="0x0-Alacritty是什么"><a href="#0x0-Alacritty是什么" class="headerlink" title="0x0 Alacritty是什么?"></a>0x0 Alacritty是什么?</h1><p><code>Alacritty</code>是一个终端仿真器。</p><p>在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。</p><h1 id="0x1-为什么选择Alacritty"><a href="#0x1-为什么选择Alacritty" class="headerlink" title="0x1 为什么选择Alacritty?"></a>0x1 为什么选择Alacritty?</h1><p><code>Alacritty</code>是目前性能最强的终端之一.</p><p>它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。</p><p><code>Alacritty</code>的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过<code>Alacritty</code>仍然提供了很多配置终端的方面。</p><h1 id="0x2-Alacritty的配置"><a href="#0x2-Alacritty的配置" class="headerlink" title="0x2 Alacritty的配置"></a>0x2 Alacritty的配置</h1><p><code>Alacritty</code>的配置文件在:<code>~/.config/alacritty/alacritty.yml</code></p><h2 id="0-字体"><a href="#0-字体" class="headerlink" title="0 字体"></a>0 字体</h2><p>打开<code>alacritty.yml</code>文件，找到<code>Font configuration</code>这行注释，即可修改。</p><p>例如:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Font configuration (changes require restart)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line"><span class="attr">  normal:</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Droid</span> <span class="string">Sans</span> <span class="string">Mono</span></span><br><span class="line"><span class="attr">    style:</span> <span class="string">Regular</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  bold:</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Droid</span> <span class="string">Sans</span> <span class="string">Mono</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  italic:</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Droid</span> <span class="string">Sans</span> <span class="string">Mono</span></span><br></pre></td></tr></table></figure><h2 id="1-配色方案"><a href="#1-配色方案" class="headerlink" title="1 配色方案"></a>1 配色方案</h2><p><code>Alacritty</code>官方提供了超多种的配置方案，<a href="https://github.com/jwilm/alacritty/wiki/Color-schemes" target="_blank" rel="noopener">点击我获取</a></p><p>我们只需要找一个自己喜欢的配色方案将配色代码复制</p><p>然后粘贴到<code>alacritty.yml</code>配置文件内即可.</p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Colors (Solarized Dark)</span><br><span class="line">colors:</span><br><span class="line">  # Default colors</span><br><span class="line">  primary:</span><br><span class="line">    background: &apos;0x002b36&apos; # base03</span><br><span class="line">    foreground: &apos;0x839496&apos; # base0</span><br><span class="line"></span><br><span class="line">  # Normal colors</span><br><span class="line">  normal:</span><br><span class="line">    black:   &apos;0x073642&apos; # base02</span><br><span class="line">    red:     &apos;0xdc322f&apos; # red</span><br><span class="line">    green:   &apos;0x859900&apos; # green</span><br><span class="line">    yellow:  &apos;0xb58900&apos; # yellow</span><br><span class="line">    blue:    &apos;0x268bd2&apos; # blue</span><br><span class="line">    magenta: &apos;0xd33682&apos; # magenta</span><br><span class="line">    cyan:    &apos;0x2aa198&apos; # cyan</span><br><span class="line">    white:   &apos;0xeee8d5&apos; # base2</span><br><span class="line"></span><br><span class="line">  # Bright colors</span><br><span class="line">  bright:</span><br><span class="line">    black:   &apos;0x002b36&apos; # base03</span><br><span class="line">    red:     &apos;0xcb4b16&apos; # orange</span><br><span class="line">    green:   &apos;0x586e75&apos; # base01</span><br><span class="line">    yellow:  &apos;0x657b83&apos; # base00</span><br><span class="line">    blue:    &apos;0x839496&apos; # base0</span><br><span class="line">    magenta: &apos;0x6c71c4&apos; # violet</span><br><span class="line">    cyan:    &apos;0x93a1a1&apos; # base1</span><br><span class="line">    white:   &apos;0xfdf6e3&apos; # base3</span><br></pre></td></tr></table></figure></p><h2 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2 快捷键"></a>2 快捷键</h2><p>默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在<code>alacritty.yml</code>内的<code>Key bindings</code>项下进行修改</p><p>并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按<code>Paste</code>键和<code>Copy</code>键位改为<code>Ctrl+C</code>和<code>Ctrl+V</code>。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- &#123; key: V,        mods: Control, action: Paste                            &#125;</span><br><span class="line">- &#123; key: C,        mods: Control, action: Copy                             &#125;</span><br></pre></td></tr></table></figure><p><strong>注意不要漏写<code>,</code>号,不然可能会出现如下情况</strong></p><p><img src="/2019/07/03/最快-GPU加速-Alacritty终端/error.png" alt="error"></p><h1 id="0x3-我的Alacritty配置"><a href="#0x3-我的Alacritty配置" class="headerlink" title="0x3 我的Alacritty配置"></a>0x3 我的Alacritty配置</h1><p>已经上传至Github，<a href="https://github.com/EvanMeek/Vanilla/tree/master/alacritty" target="_blank" rel="noopener">点击我获取</a></p><h1 id="0x4-其他"><a href="#0x4-其他" class="headerlink" title="0x4 其他"></a>0x4 其他</h1><p><a href="https://github.com/jwilm/alacritty" target="_blank" rel="noopener">Alacritty-Github页面</a></p><p>Arch系一键安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; pacman -S alacritty</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/03/最快-GPU加速-Alacritty终端/ponysay.png&quot; alt=&quot;ponysay&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x0-Alacritty是什么&quot;&gt;&lt;a href=&quot;#0x0-Alac
      
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="软件折腾" scheme="https://evanmeek.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux-文件过滤及内容编辑处理命令-2</title>
    <link href="https://evanmeek.github.io/2019/06/30/Linux-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%8F%8A%E5%86%85%E5%AE%B9%E7%BC%96%E8%BE%91%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4-2/"/>
    <id>https://evanmeek.github.io/2019/06/30/Linux-文件过滤及内容编辑处理命令-2/</id>
    <published>2019-06-30T11:26:29.000Z</published>
    <updated>2019-07-03T04:02:43.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-0-做Linux运维的多个好处"><a href="#3-0-做Linux运维的多个好处" class="headerlink" title="3.0 做Linux运维的多个好处"></a>3.0 做Linux运维的多个好处</h1><ol><li><p>做运维可以认识更多人，同时也被更多人认识。</p></li><li><p>做运维可以让自己沟通，交际能力变得比开发人员更强。</p></li><li><p>相比开发岗位，运维的岗位更重要一些。</p></li></ol><h1 id="3-1-cat-合并文件或查看文件内容"><a href="#3-1-cat-合并文件或查看文件内容" class="headerlink" title="3.1 cat 合并文件或查看文件内容"></a>3.1 cat 合并文件或查看文件内容</h1><p><code>concatenate</code></p><p><strong>cat命令5大常用功能</strong></p><table><thead><tr><th>序号</th><th>常用功能</th><th>例子以及说明</th></tr></thead><tbody><tr><td>1</td><td>查看文件内容</td><td>cat file.txt 查看文件内容，最基本的使用</td></tr><tr><td>2</td><td>多个文件合并为一个文件</td><td>cat f1 f2 &gt; newf 将f1和f2的内容合并到newf</td></tr><tr><td>3</td><td>创建编辑新文件</td><td>cat &gt; file 输入后会请求输入，快捷键Ctrl+d/c可退出</td></tr><tr><td>4</td><td>非交互式编辑或追加新内容</td><td>cat &gt;&gt;file&lt;&lt;EOF 输入后会请求输入，在结束时输入EOF即可退出</td></tr><tr><td>5</td><td>清空文件内容</td><td>cat /dev/null &gt; file 清空文件内容</td></tr></tbody></table><p>语法格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>为输出的内容加编号，从1开始</td></tr><tr><td>-b</td><td>与-n类似，但它忽略空白行</td></tr><tr><td>-s</td><td>当遇到有多行空白行，则合并为单行空白行</td></tr><tr><td>-v</td><td>除了LFD和TAB之外，使用^和M-引用</td></tr><tr><td>-T</td><td>将Tab字符显示为^I</td></tr><tr><td>-E</td><td>在行尾显示$符号</td></tr><tr><td>-t</td><td>等价与-vT</td></tr><tr><td>-A</td><td>等价于-vE</td></tr></tbody></table><p>例子</p><p><strong>使用cat命令以非交互式的方式编辑文件</strong></p><p>方式1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat &gt;file&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Just a test.</span><br><span class="line">EOF</span><br><span class="line">&gt; cat file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Just a test</span><br></pre></td></tr></table></figure><p>解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现</p><p>易错点: 结束EOF必须置前，前面不能有任意字符</p><p>方式2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat &gt;file&lt;&lt;-EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Just a test.</span><br><span class="line">  EOF</span><br><span class="line">&gt; cat file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Just a test.</span><br></pre></td></tr></table></figure><p>解释: 在字符标签前加上<code>-</code>可以使得结束标签前可放置制表符，但仅仅只可放制表符</p><p><strong>合并多个文件为单个文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat &gt; f1</span><br><span class="line">f1</span><br><span class="line">Ctrl+d</span><br><span class="line">&gt; cat &gt; f2</span><br><span class="line">f2</span><br><span class="line">Ctrl+c</span><br><span class="line">&gt; cat f1 f2</span><br><span class="line">f1</span><br><span class="line">f2</span><br><span class="line">&gt; cat f1 f2 &gt; newfile</span><br><span class="line">&gt; cat newfile</span><br><span class="line">f1</span><br><span class="line">f2</span><br></pre></td></tr></table></figure><h1 id="3-2-tac-反向显示文件内容"><a href="#3-2-tac-反向显示文件内容" class="headerlink" title="3.2 tac 反向显示文件内容"></a>3.2 tac 反向显示文件内容</h1><p>跟<code>cat</code>命令类似，反向输出文件内容</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>在行前添加分隔标志</td></tr><tr><td>-r</td><td>将分隔标志视作正则表达式进行解析</td></tr><tr><td>-s</td><td>使用指定字符作为换行的标志</td></tr></tbody></table><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat file1</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">&gt; tac file2</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h1 id="3-3-more-分页显示文件内容"><a href="#3-3-more-分页显示文件内容" class="headerlink" title="3.3 more 分页显示文件内容"></a>3.3 more 分页显示文件内容</h1><p><code>more</code>类似于<code>cat</code>命令，区别在于<code>cat</code>命令是将文件内容一次性全部</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-0-做Linux运维的多个好处&quot;&gt;&lt;a href=&quot;#3-0-做Linux运维的多个好处&quot; class=&quot;headerlink&quot; title=&quot;3.0 做Linux运维的多个好处&quot;&gt;&lt;/a&gt;3.0 做Linux运维的多个好处&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;做
      
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>我的VIM配置详解</title>
    <link href="https://evanmeek.github.io/2019/06/21/%E6%88%91%E7%9A%84VIM%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://evanmeek.github.io/2019/06/21/我的VIM配置详解/</id>
    <published>2019-06-21T09:35:54.000Z</published>
    <updated>2019-06-25T08:19:32.510Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。<br><a id="more"></a></p><p>我已经把我的配置文件上传到了Github上了，<a href="https://github.com/EvanMeek/Vanilla" target="_blank" rel="noopener">点击访问</a></p><p>基本都有写中文注释，哪里有不懂的，可以问我，<a href="https://evanmeek.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/">点击查看我的联系方式</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot; 设置vi与vim兼容</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 设置使vim识别不同的文件格式</span><br><span class="line">filetype on</span><br><span class="line">filetype indent on</span><br><span class="line">filetype plugin on</span><br><span class="line">filetype plugin indent on</span><br><span class="line">&quot; 设置使vim能用鼠标操作</span><br><span class="line">set mouse=a</span><br><span class="line">&quot; 设置字符编码</span><br><span class="line">set encoding=utf-8</span><br><span class="line">&quot; 使配色更加兼容你的终端</span><br><span class="line">let &amp;t_ut=&apos;&apos;</span><br><span class="line">&quot; 设置缩进距离</span><br><span class="line">set expandtab</span><br><span class="line">set tabstop=2</span><br><span class="line">set shiftwidth=2</span><br><span class="line">set softtabstop=2</span><br><span class="line">&quot; 设置空格的显示</span><br><span class="line">set list</span><br><span class="line">set listchars=tab:▸\ ,trail:▫</span><br><span class="line">set tw=0</span><br><span class="line">set indentexpr=</span><br><span class="line">&quot; 退格键到行首后自动跳转到上行行尾</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">&quot; 收起代码</span><br><span class="line">set foldmethod=indent</span><br><span class="line">set foldlevel=99</span><br><span class="line">&quot; 设置终端的光标在不同模式下用不同的样式,实测Konsole可用</span><br><span class="line">let &amp;t_SI = &quot;\&lt;Esc&gt;]50;CursorShape=1\x7&quot;</span><br><span class="line">let &amp;t_SR = &quot;\&lt;Esc&gt;]50;CursorShape=2\x7&quot;</span><br><span class="line">let &amp;t_EI = &quot;\&lt;Esc&gt;]50;CursorShape=0\x7&quot;</span><br><span class="line">&quot; 状态栏等于２？？？</span><br><span class="line">set laststatus=2</span><br><span class="line">&quot; vim执行的外部命令会在当前目录下执行</span><br><span class="line">set autochdir</span><br><span class="line">&quot; 关闭文件又打开光标会自动回到关闭前的位置</span><br><span class="line">au BufReadPost * if line(&quot;&apos;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&apos;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&apos;\&quot;&quot; | endif</span><br><span class="line">&quot; 设置leader键为空格</span><br><span class="line">let mapleader=&quot; &quot;</span><br><span class="line">&quot; 代码高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 设置行号</span><br><span class="line">set number</span><br><span class="line">&quot; 设置更好的行号</span><br><span class="line">set relativenumber</span><br><span class="line">&quot; 设置光标线</span><br><span class="line">set cursorline</span><br><span class="line">&quot; 自动换行</span><br><span class="line">set wrap</span><br><span class="line">&quot; 显示命令</span><br><span class="line">set showcmd</span><br><span class="line">&quot; tab多选项菜单</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 设置搜索关键词高亮</span><br><span class="line">set hlsearch</span><br><span class="line">exec &quot;nohlsearch&quot;</span><br><span class="line">&quot; 设置搜索输入时高亮</span><br><span class="line">set incsearch</span><br><span class="line">&quot; 搜索时忽略大小写</span><br><span class="line">set ignorecase </span><br><span class="line">&quot; 只能搜索忽略大小写</span><br><span class="line">set smartcase</span><br><span class="line"></span><br><span class="line">&quot; 搜索跳转结果改为=/-并且使搜索结果在屏幕中间</span><br><span class="line">noremap = nzz</span><br><span class="line">noremap - Nzz</span><br><span class="line"></span><br><span class="line">&quot; 大写JKHL重复五次执行</span><br><span class="line">noremap J 5j</span><br><span class="line">noremap K 5k</span><br><span class="line">noremap H 5h</span><br><span class="line">noremap L 5l</span><br><span class="line">&quot; 设置取消高亮</span><br><span class="line">noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 设置光标回到行首</span><br><span class="line">noremap &lt;LEADER&gt;a 0</span><br><span class="line"></span><br><span class="line">&quot; 设置光标回到行尾</span><br><span class="line">noremap &lt;LEADER&gt;e $</span><br><span class="line"></span><br><span class="line">&quot; 取消s删除字符的功能</span><br><span class="line">map s &lt;nop&gt;</span><br><span class="line"></span><br><span class="line">&quot; 快速保存</span><br><span class="line">map S :w&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 按大写Q直接退出</span><br><span class="line">map Q :q&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; R快速source vimrc</span><br><span class="line">map R :source ~/.vim/vimrc&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;分屏操作</span><br><span class="line">&quot;向右分屏</span><br><span class="line">map &lt;LEADER&gt;l :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class="line">&quot;向左分屏</span><br><span class="line">map &lt;LEADER&gt;h :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class="line">&quot;向上分屏</span><br><span class="line">map &lt;LEADER&gt;k :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class="line">&quot;向下分屏</span><br><span class="line">map &lt;LEADER&gt;j :set splitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class="line">&quot;光标移动至左分屏</span><br><span class="line">map sh &lt;C-w&gt;h</span><br><span class="line">&quot;光标移动至右分屏</span><br><span class="line">map sl &lt;C-w&gt;l</span><br><span class="line">&quot;光标移动至下分屏</span><br><span class="line">map sj &lt;C-w&gt;j</span><br><span class="line">&quot;光标移动至上分屏</span><br><span class="line">map sk &lt;C-w&gt;k</span><br><span class="line">&quot;增加纵向分屏大小</span><br><span class="line">map &lt;up&gt; :res +5&lt;CR&gt;</span><br><span class="line">&quot;减少纵向分屏大小</span><br><span class="line">map &lt;down&gt; :res -5&lt;CR&gt;</span><br><span class="line">&quot;减少横向分屏大小</span><br><span class="line">map &lt;left&gt; :vertical resize-5&lt;CR&gt;</span><br><span class="line">&quot;增加横横分屏大小</span><br><span class="line">map &lt;right&gt; :vertical resize+5&lt;CR&gt;</span><br><span class="line">&quot;将分屏设置为横向分屏</span><br><span class="line">map &lt;LEADER&gt;H &lt;C-w&gt;t&lt;C-w&gt;H</span><br><span class="line">&quot;将分屏设置为纵向分屏</span><br><span class="line">map &lt;LEADER&gt;K &lt;C-w&gt;t&lt;C-w&gt;K</span><br><span class="line"></span><br><span class="line">&quot;标签</span><br><span class="line">&quot;打开新标签</span><br><span class="line">map tn :tabe&lt;CR&gt;</span><br><span class="line">&quot; 跳转至上一个标签</span><br><span class="line">map th :-tabnext&lt;CR&gt;</span><br><span class="line">&quot; 跳转至下一个标签</span><br><span class="line">map tl :+tabnext&lt;CR&gt;</span><br><span class="line">  &quot; 关闭当前标签</span><br><span class="line">map td :tabclose&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;插件安装vim-plug</span><br><span class="line">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class="line">Plug &apos;endel/vim-github-colorscheme&apos;</span><br><span class="line">Plug &apos;morhetz/gruvbox&apos;</span><br><span class="line"></span><br><span class="line">Plug &apos;vim-airline/vim-airline&apos;</span><br><span class="line"></span><br><span class="line">&quot; File navigation</span><br><span class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;: &apos;NERDTreeToggle&apos; &#125;</span><br><span class="line">Plug &apos;Xuyuanp/nerdtree-git-plugin&apos;</span><br><span class="line"></span><br><span class="line">&quot; Taglist</span><br><span class="line">Plug &apos;majutsushi/tagbar&apos;, &#123; &apos;on&apos;: &apos;TagbarOpenAutoClose&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Error checking</span><br><span class="line">Plug &apos;w0rp/ale&apos;</span><br><span class="line"></span><br><span class="line">&quot; Auto Complete</span><br><span class="line">Plug &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line"></span><br><span class="line">&quot; Undo Tree</span><br><span class="line">Plug &apos;mbbill/undotree/&apos;</span><br><span class="line"></span><br><span class="line">&quot; Other visual enhancement</span><br><span class="line">Plug &apos;nathanaelkane/vim-indent-guides&apos;</span><br><span class="line">Plug &apos;itchyny/vim-cursorword&apos;</span><br><span class="line"></span><br><span class="line">&quot; Git</span><br><span class="line">Plug &apos;rhysd/conflict-marker.vim&apos;</span><br><span class="line">Plug &apos;tpope/vim-fugitive&apos;</span><br><span class="line">Plug &apos;mhinz/vim-signify&apos;</span><br><span class="line">Plug &apos;gisphm/vim-gitignore&apos;, &#123; &apos;for&apos;: [&apos;gitignore&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class="line"></span><br><span class="line">&quot; HTML, CSS, JavaScript, PHP, JSON, etc.</span><br><span class="line">Plug &apos;elzr/vim-json&apos;</span><br><span class="line">Plug &apos;hail2u/vim-css3-syntax&apos;</span><br><span class="line">Plug &apos;spf13/PIV&apos;, &#123; &apos;for&apos; :[&apos;php&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class="line">Plug &apos;gko/vim-coloresque&apos;, &#123; &apos;for&apos;: [&apos;vim-plug&apos;, &apos;php&apos;, &apos;html&apos;, &apos;javascript&apos;, &apos;css&apos;, &apos;less&apos;] &#125;</span><br><span class="line">Plug &apos;pangloss/vim-javascript&apos;, &#123; &apos;for&apos; :[&apos;javascript&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class="line">Plug &apos;mattn/emmet-vim&apos;</span><br><span class="line"></span><br><span class="line">&quot; Python</span><br><span class="line">Plug &apos;vim-scripts/indentpython.vim&apos;</span><br><span class="line"></span><br><span class="line">&quot; Markdown</span><br><span class="line">Plug &apos;iamcco/markdown-preview.nvim&apos;, &#123; &apos;do&apos;: &apos;cd app &amp; yarn install&apos;  &#125;</span><br><span class="line">Plug &apos;dhruvasagar/vim-table-mode&apos;, &#123; &apos;on&apos;: &apos;TableModeToggle&apos; &#125;</span><br><span class="line">Plug &apos;vimwiki/vimwiki&apos;</span><br><span class="line"></span><br><span class="line">&quot; Bookmarks</span><br><span class="line">Plug &apos;kshenoy/vim-signature&apos;</span><br><span class="line"></span><br><span class="line">&quot; Other useful utilities</span><br><span class="line">Plug &apos;terryma/vim-multiple-cursors&apos;</span><br><span class="line">Plug &apos;junegunn/goyo.vim&apos; &quot; distraction free writing mode</span><br><span class="line">Plug &apos;tpope/vim-surround&apos; &quot; type ysks&apos; to wrap the word with &apos;&apos; or type cs&apos;` to change &apos;word&apos; to `word`</span><br><span class="line">Plug &apos;godlygeek/tabular&apos; &quot; type ;Tabularize /= to align the =</span><br><span class="line">Plug &apos;gcmt/wildfire.vim&apos; &quot; in Visual mode, type i&apos; to select all text in &apos;&apos;, or type i) i] i&#125; ip</span><br><span class="line">Plug &apos;scrooloose/nerdcommenter&apos; &quot; in &lt;space&gt;cc to comment a line</span><br><span class="line"></span><br><span class="line">&quot; Dependencies</span><br><span class="line">Plug &apos;MarcWeber/vim-addon-mw-utils&apos;</span><br><span class="line">Plug &apos;kana/vim-textobj-user&apos;</span><br><span class="line">Plug &apos;fadein/vim-FIGlet&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call plug#end()</span><br><span class="line"></span><br><span class="line">&quot; 设置透明</span><br><span class="line">let g:SnazzyTransparent = 1</span><br><span class="line"></span><br><span class="line">&quot; 设置主题</span><br><span class="line">&quot; 可选项</span><br><span class="line">&quot; github/snazzy/inkstained</span><br><span class="line">let g:grubvbox_termcolors=&apos;256&apos;</span><br><span class="line">let g:grubvbox_contrast_light = &apos;soft&apos;</span><br><span class="line">color gruvbox</span><br><span class="line">set background =light</span><br><span class="line"></span><br><span class="line">&quot; 插件配置</span><br><span class="line"></span><br><span class="line">&quot; ==== NERDTree</span><br><span class="line">map ff :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; ==== NERDTree-git</span><br><span class="line"></span><br><span class="line">let g:NERDTreeIndicatorMapCustom = &#123;</span><br><span class="line">    \ &quot;Modified&quot;  : &quot;✹&quot;,</span><br><span class="line">    \ &quot;Staged&quot;    : &quot;✚&quot;,</span><br><span class="line">    \ &quot;Untracked&quot; : &quot;✭&quot;,</span><br><span class="line">    \ &quot;Renamed&quot;   : &quot;➜&quot;,</span><br><span class="line">    \ &quot;Unmerged&quot;  : &quot;═&quot;,</span><br><span class="line">    \ &quot;Deleted&quot;   : &quot;✖&quot;,</span><br><span class="line">    \ &quot;Dirty&quot;     : &quot;✗&quot;,</span><br><span class="line">    \ &quot;Clean&quot;     : &quot;✔︎&quot;,</span><br><span class="line">    \ &quot;Unknown&quot;   : &quot;?&quot;</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line">&quot; ==== You Complete ME</span><br><span class="line">&quot; 跳转至其他的声明</span><br><span class="line">nnoremap gd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">&quot; 跳转至文档</span><br><span class="line">nnoremap g/ :YcmCompleter GetDoc&lt;CR&gt;</span><br><span class="line">&quot; 获取类型</span><br><span class="line">nnoremap gt :YcmCompleter GetType&lt;CR&gt;</span><br><span class="line">&quot; 获取参考</span><br><span class="line">nnoremap gr :YcmCompleter GoToReferences&lt;CR&gt;</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=0</span><br><span class="line">let g:ycm_autoclose_preview_window_after_insertion=1</span><br><span class="line">let g:ycm_use_clangd = 0</span><br><span class="line">let g:ycm_python_interpreter_path = &quot;/bin/python3&quot;</span><br><span class="line">let g:ycm_python_binary_path = &quot;/bin/python3&quot;</span><br><span class="line"></span><br><span class="line">&quot; ==== ale</span><br><span class="line">let b:ale_linters = [&apos;pylint&apos;]</span><br><span class="line">let b:ale_fixers = [&apos;autopep8&apos;, &apos;yapf&apos;]</span><br><span class="line"></span><br><span class="line">&quot; ==== TagList</span><br><span class="line">map &lt;silent&gt; T :TagbarOpenAutoClose&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; ==== MarkdownPreview</span><br><span class="line">nmap &lt;LEADER&gt;mp :MarkdownPreview&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; ==== vim-table-mode</span><br><span class="line"></span><br><span class="line">map &lt;LEADER&gt;tm :TableModeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; ==== vim-indent-guide</span><br><span class="line">let g:indent_guides_guide_size = 0</span><br><span class="line">let g:indent_guides_start_level = 2</span><br><span class="line">let g:indent_guides_enable_on_vim_startup = 1</span><br><span class="line">let g:indent_guides_color_change_percent = 0</span><br><span class="line">autocmd WinEnter * silent! unmap &lt;LEADER&gt;ig</span><br><span class="line"></span><br><span class="line">&quot; ====Goyo</span><br><span class="line">map &lt;LEADER&gt;gy :Goyo&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; ==== vim-signiture</span><br><span class="line">let g:SignatureMap = &#123;</span><br><span class="line">        \ &apos;Leader&apos;             :  &quot;m&quot;,</span><br><span class="line">        \ &apos;PlaceNextMark&apos;      :  &quot;m,&quot;,</span><br><span class="line">        \ &apos;ToggleMarkAtLine&apos;   :  &quot;m.&quot;,</span><br><span class="line">        \ &apos;PurgeMarksAtLine&apos;   :  &quot;dm-&quot;,</span><br><span class="line">        \ &apos;DeleteMark&apos;         :  &quot;dm&quot;,</span><br><span class="line">        \ &apos;PurgeMarks&apos;         :  &quot;dm/&quot;,</span><br><span class="line">        \ &apos;PurgeMarkers&apos;       :  &quot;dm?&quot;,</span><br><span class="line">        \ &apos;GotoNextLineAlpha&apos;  :  &quot;m&lt;LEADER&gt;&quot;,</span><br><span class="line">        \ &apos;GotoPrevLineAlpha&apos;  :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoNextSpotAlpha&apos;  :  &quot;m&lt;LEADER&gt;&quot;,</span><br><span class="line">        \ &apos;GotoPrevSpotAlpha&apos;  :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoNextLineByPos&apos;  :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoPrevLineByPos&apos;  :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoNextSpotByPos&apos;  :  &quot;mn&quot;,</span><br><span class="line">        \ &apos;GotoPrevSpotByPos&apos;  :  &quot;mp&quot;,</span><br><span class="line">        \ &apos;GotoNextMarker&apos;     :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoPrevMarker&apos;     :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoNextMarkerAny&apos;  :  &quot;&quot;,</span><br><span class="line">        \ &apos;GotoPrevMarkerAny&apos;  :  &quot;&quot;,</span><br><span class="line">        \ &apos;ListLocalMarks&apos;     :  &quot;m/&quot;,</span><br><span class="line">        \ &apos;ListLocalMarkers&apos;   :  &quot;m?&quot;</span><br><span class="line">        \ &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; === Undotree</span><br><span class="line">let g:undotree_DiffAutoOpen = 0</span><br><span class="line">map &lt;LEADER&gt;ut :UndotreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="VIM" scheme="https://evanmeek.github.io/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>Linux-文件和目录操作命令-find命令</title>
    <link href="https://evanmeek.github.io/2019/06/21/Linux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4/"/>
    <id>https://evanmeek.github.io/2019/06/21/Linux-文件和目录操作命令-find命令/</id>
    <published>2019-06-20T17:04:56.000Z</published>
    <updated>2019-06-22T13:03:15.802Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示</p><a id="more"></a><h1 id="2-13-1-命令详解"><a href="#2-13-1-命令详解" class="headerlink" title="2.13.1 命令详解"></a>2.13.1 命令详解</h1><p>find命令参数较多，并且不同的参数所在的子模块不同.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    如何处理符号链接</span><br><span class="line">        |</span><br><span class="line">        |  需要查找的路径</span><br><span class="line">        |     |</span><br><span class="line">        |     |</span><br><span class="line">find -H-L-P path expression</span><br><span class="line">                /    |     \</span><br><span class="line">              /      |       \</span><br><span class="line">            |        |         |</span><br><span class="line">            options tests actions</span><br><span class="line">            参数      |       |</span><br><span class="line">                限定的条件     |</span><br><span class="line">                          执行的动作</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>pathname</td><td>需要查找的路径</td></tr><tr><td>Options模块</td><td></td></tr><tr><td>-depth</td><td>从指定目录下最深层的子目录开始查找</td></tr><tr><td>-maxdepth levels</td><td>查找的最大目录层级数，levels为自然数<code>!</code></td></tr><tr><td>-regextype type</td><td>改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended</td></tr><tr><td>Tests模块</td><td></td></tr><tr><td>-mtime [-n\</td><td>n\</td><td>+n]</td><td>按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天<code>!</code></td></tr><tr><td>-atime[-n\</td><td>n\</td><td>+n]</td><td>同上，只不过是按照访问时间进行查找，单位为天</td></tr><tr><td>-ctime</td><td>按照文件的状态改变时间来查找文件，单位为天</td></tr><tr><td>-amin</td><td>按照文件的访问时间查找，单位为分钟</td></tr><tr><td>-cmin</td><td>按照文件的状态改变时间查找，单位为分钟</td></tr><tr><td>-mmin</td><td>按照文件的修改时间来查找文件，单位为分钟</td></tr><tr><td>-group</td><td>按照文件所属的组来查找文件</td></tr><tr><td>-name</td><td>按照文件名查找文件，只支持*,?,[]等特殊通配符<code>!</code></td></tr><tr><td>-newer</td><td>查找更改时间比指定文件新的文件</td></tr><tr><td>-nogroup</td><td>查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在</td></tr><tr><td>-nouser</td><td>查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在</td></tr><tr><td>-path pattern</td><td>指定路径样式，配合-prune参数排除指定目录</td></tr><tr><td>-perm</td><td>按照文件权限来查找文件</td></tr><tr><td>-regex</td><td>接正则表达式</td></tr><tr><td>-iregex</td><td>不区分大小写接正则表达式</td></tr><tr><td>-size n[cwbkMG]</td><td>查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计</td></tr><tr><td>-user</td><td>按照文件属主来查找文件</td></tr><tr><td>-type</td><td>查找某一类型的文件:<code>!</code>，后面会讲</td></tr><tr><td>-Actions模块</td><td></td></tr><tr><td>-delete</td><td>将查找出的文件删除</td></tr><tr><td>-exec</td><td>对匹配文件执行该参数给出的Shell命令<code>!</code></td></tr><tr><td>-ok</td><td>和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行</td></tr><tr><td>-prune</td><td>使fint命令不再指定的目录中查找</td></tr><tr><td>-print</td><td>将匹配的文件输出到标准输出(默认可用</td></tr><tr><td>OPERATORS</td><td>find支持逻辑运算符</td></tr><tr><td>!</td><td>取反`!</td></tr><tr><td>-a</td><td>取交集，全拼为and<code>！</code></td></tr><tr><td>-o</td><td>取并集，全拼为or<code>!</code></td></tr></tbody></table><p>-type 查找某一类型的文件:</p><ul><li><p>b(块设备文件)</p></li><li><p>c(字符设备文件)</p></li><li><p>d(目录)</p></li><li><p>p(管道文件)</p></li><li><p>l(符号链接文件)</p></li><li><p>f(普通文件)</p></li><li><p>s(socket文件)</p></li><li><p>D(door)</p></li></ul><h1 id="2-13-2-使用范例"><a href="#2-13-2-使用范例" class="headerlink" title="2.13.2 使用范例"></a>2.13.2 使用范例</h1><p><strong>查找指定时间内访问过的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -atime -2</span><br><span class="line"></span><br><span class="line">./Linux-文件和目录操作命令-1.md</span><br><span class="line">./Linux-文件和目录操作命令-find命令.md</span><br><span class="line">./我的VIM配置详解.md</span><br><span class="line">./我的VIM配置详解</span><br></pre></td></tr></table></figure><p><strong>查找指定时间内修改过的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -mtime -5</span><br><span class="line">.</span><br><span class="line">./Linux-Linux命令行简介-0.md</span><br><span class="line">./Linux-文件和目录操作命令-1.md</span><br><span class="line">./C-内存四区之栈区.md</span><br><span class="line">./Linux-文件和目录操作命令-find命令.md</span><br><span class="line">./我的VIM配置详解.md</span><br><span class="line">./Linux-Linux命令行简介-man命令.md</span><br><span class="line">./我的VIM配置详解</span><br></pre></td></tr></table></figure><p>时间关系字符图如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">------------+4  4 -4---------------</span><br><span class="line">8   7   6   5   4   3   2   1   now</span><br></pre></td></tr></table></figure><p><code>-n</code>代表从第四天到现在之内</p><p><code>n</code>代表具体某一天</p><p><code>+n</code>代表某一天之前</p><p><strong>根据文件名查找指定时间的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -mtime -1 -name &apos;*.md&apos;</span><br><span class="line">./Linux-文件和目录操作命令-find命令.md</span><br></pre></td></tr></table></figure><p><strong>根据文件类型查找目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -type d</span><br><span class="line">.</span><br><span class="line">./Linux-Linux命令行简介-0</span><br><span class="line">./终端多窗口神器——Screen</span><br><span class="line">./Qt5</span><br><span class="line">./2008年5月12日14时28分04秒</span><br><span class="line">./如何自学编程</span><br><span class="line">./Learn-Qt5-自定义信号槽</span><br><span class="line">./C-内存四区之代码区与全局区</span><br><span class="line">./Linux</span><br><span class="line">./C-友元</span><br><span class="line">./Learn-Qt5-Qt模块简介</span><br><span class="line">./ManjaroLinux的安装过程</span><br><span class="line">./C-的命名空间与作用域</span><br><span class="line">./Learn-Qt5-信号槽</span><br><span class="line">./我儿子的博客</span><br><span class="line">./C-内存四区之堆区</span><br><span class="line">./fcitx5安装与配置</span><br><span class="line">./hexo-next插入网易云音乐</span><br><span class="line">./Linux-文件和目录操作命令-1</span><br><span class="line">./C-读写文件</span><br><span class="line">./Linux-Linux命令行简介-man命令</span><br><span class="line">./C-指针-基础02</span><br><span class="line">./Learn-Qt5-HelloWorld</span><br><span class="line">./常用算法-1</span><br><span class="line">./C-内存四区之栈区</span><br><span class="line">./我的VIM配置详解</span><br><span class="line">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class="line">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure><p><strong>根据文件类型查找非目录的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . ! -type d</span><br><span class="line">./Linux-Linux命令行简介-0/1.1.2-0</span><br><span class="line">./fcitx5安装与配置.md</span><br><span class="line">./终端多窗口神器——Screen/DefalutCommandKey.png</span><br><span class="line">./终端多窗口神器——Screen/detachedInfo.png</span><br><span class="line">./Linux中的解压与压缩.md</span><br><span class="line">./Linux-Linux命令行简介-0.md</span><br><span class="line">./终端多窗口神器——Screen.md</span><br><span class="line">./C-内存四区之代码区与全局区.md</span><br><span class="line">./C-内存四区之堆区.md</span><br><span class="line">./2008年5月12日14时28分04秒/空降.webp</span><br><span class="line">./2008年5月12日14时28分04秒/操场.webp</span><br><span class="line">./2008年5月12日14时28分04秒/流量图.webp</span><br><span class="line">./hexo-next插入网易云音乐.md</span><br><span class="line">./如何自学编程/群组.png</span><br><span class="line">./Linux-文件和目录操作命令-1.md</span><br><span class="line">./我儿子的博客.md</span><br><span class="line">./解决KDE下部分应用不能使用fctix中文输入法的问题.md</span><br><span class="line">./C-内存四区之代码区与全局区/代码区示意图.png</span><br><span class="line">./C-内存四区之栈区.md</span><br><span class="line">./Learn-Qt5-信号槽.md</span><br><span class="line">./Linux-文件和目录操作命令-find命令.md</span><br><span class="line">./Learn-Qt5-Qt模块简介.md</span><br><span class="line">./C-读写文件.md</span><br><span class="line">./ManjaroLinux的安装过程/编辑文章时截图.png</span><br><span class="line">./ManjaroLinux的安装过程/分区.png</span><br><span class="line">./ManjaroLinux的安装过程/开始安装.png</span><br><span class="line">./ManjaroLinux的安装过程/安装选择界面.png</span><br><span class="line">./ManjaroLinux的安装过程/摘要.png</span><br><span class="line">./ManjaroLinux的安装过程/分区标识.png</span><br><span class="line">./ManjaroLinux的安装过程/桌面.png</span><br><span class="line">./Learn-Qt5-自定义信号槽.md</span><br><span class="line">./我儿子的博客/预览.png</span><br><span class="line">./hexo博客文章插入图片.md</span><br><span class="line">./C-函数探幽.md</span><br><span class="line">./C-内存四区之堆区/test.png</span><br><span class="line">./如何自学编程.md</span><br><span class="line">./深拷贝和浅拷贝的区别.md</span><br><span class="line">./ManjaroLinux的安装过程.md</span><br><span class="line">./fcitx5安装与配置/kcm.png</span><br><span class="line">./fcitx5安装与配置/输入.gif</span><br><span class="line">./hexo-next插入网易云音乐/01.png</span><br><span class="line">./hexo-next插入网易云音乐/插哪.png</span><br><span class="line">./2008年5月12日14时28分04秒.md</span><br><span class="line">./C-读写文件/二进制文件.png</span><br><span class="line">./C-指针-基础02/指针位偏移.png</span><br><span class="line">./Learn-Qt5-HelloWorld.md</span><br><span class="line">./ManjaroLinuxTG讨论群组.md</span><br><span class="line">./Learn-Qt5-HelloWorld/newProject.gif</span><br><span class="line">./我的VIM配置详解.md</span><br><span class="line">./C-友元.md</span><br><span class="line">./如何用hexo-github-pages搭建博客.md</span><br><span class="line">./Linux-Linux命令行简介-man命令.md</span><br><span class="line">./常用算法-1.md</span><br><span class="line">./C-的命名空间与作用域.md</span><br><span class="line">./我的Linux之路.md</span><br><span class="line">./2019年的规划.md</span><br><span class="line">./C-指针-基础01.md</span><br><span class="line">./C-指针-基础02.md</span><br><span class="line">./如何用hexo-github-pages搭建博客/创建仓库.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/deploy.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/逆光.jpg</span><br><span class="line">./如何用hexo-github-pages搭建博客/本地部署.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/hexoinit.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/导入密钥.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/打开设置.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/ssh目录.png</span><br><span class="line">./如何用hexo-github-pages搭建博客/设置SSH.png</span><br></pre></td></tr></table></figure><p><strong>根据文件或目录的权限查找文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -perm 755</span><br><span class="line">.</span><br><span class="line">./Linux-Linux命令行简介-0</span><br><span class="line">./终端多窗口神器——Screen</span><br><span class="line">./Qt5</span><br><span class="line">./2008年5月12日14时28分04秒</span><br><span class="line">./如何自学编程</span><br><span class="line">./Learn-Qt5-自定义信号槽</span><br><span class="line">./C-内存四区之代码区与全局区</span><br><span class="line">./Linux</span><br><span class="line">./C-友元</span><br><span class="line">./Learn-Qt5-Qt模块简介</span><br><span class="line">./ManjaroLinux的安装过程</span><br><span class="line">./C-的命名空间与作用域</span><br><span class="line">./Learn-Qt5-信号槽</span><br><span class="line">./我儿子的博客</span><br><span class="line">./C-内存四区之堆区</span><br><span class="line">./fcitx5安装与配置</span><br><span class="line">./hexo-next插入网易云音乐</span><br><span class="line">./Linux-文件和目录操作命令-1</span><br><span class="line">./C-读写文件</span><br><span class="line">./Linux-Linux命令行简介-man命令</span><br><span class="line">./C-指针-基础02</span><br><span class="line">./Learn-Qt5-HelloWorld</span><br><span class="line">./常用算法-1</span><br><span class="line">./C-内存四区之栈区</span><br><span class="line">./我的VIM配置详解</span><br><span class="line">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class="line">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure><p><strong>根据文件大小查找文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -size +1M</span><br><span class="line">./ManjaroLinux的安装过程/桌面.png</span><br></pre></td></tr></table></figure><p><strong>查找时忽略某个目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -path &quot;*Linux*&quot; -prune -o -type d -print</span><br><span class="line">.</span><br><span class="line">./终端多窗口神器——Screen</span><br><span class="line">./Qt5</span><br><span class="line">./2008年5月12日14时28分04秒</span><br><span class="line">./如何自学编程</span><br><span class="line">./Learn-Qt5-自定义信号槽</span><br><span class="line">./C-内存四区之代码区与全局区</span><br><span class="line">./C-友元</span><br><span class="line">./Learn-Qt5-Qt模块简介</span><br><span class="line">./C-的命名空间与作用域</span><br><span class="line">./Learn-Qt5-信号槽</span><br><span class="line">./我儿子的博客</span><br><span class="line">./C-内存四区之堆区</span><br><span class="line">./fcitx5安装与配置</span><br><span class="line">./hexo-next插入网易云音乐</span><br><span class="line">./C-读写文件</span><br><span class="line">./C-指针-基础02</span><br><span class="line">./Learn-Qt5-HelloWorld</span><br><span class="line">./常用算法-1</span><br><span class="line">./C-内存四区之栈区</span><br><span class="line">./我的VIM配置详解</span><br><span class="line">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class="line">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure><p><strong>查找比某个文件新，但比某个文件旧</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 其中的!不代表取反，代表逻辑运算符非</span><br><span class="line">&gt; find . -newer new.txt ! -newer old.txt</span><br><span class="line">./verynew.txt</span><br></pre></td></tr></table></figure><p><strong>查找文件时使用正则表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls</span><br><span class="line">txt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt</span><br><span class="line">&gt; find . -regex &quot;.*xt&quot;</span><br><span class="line">./txt0.txt</span><br><span class="line">./txt4.txt</span><br><span class="line">./txt1.txt</span><br><span class="line">./txt2.txt</span><br><span class="line">./txt3.txt</span><br></pre></td></tr></table></figure><p><strong>对查找到的文件执行Shell命令操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls</span><br><span class="line">txt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt</span><br><span class="line"></span><br><span class="line"># 其中的&#123;&#125;代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\，因为需要转义</span><br><span class="line">&gt; find . -regext &quot;.*txt&quot; -exec mv &#123;&#125; &#123;&#125;.demo \;</span><br><span class="line">txt0.txt.demo  txt1.txt.demo  txt2.txt.demo  txt3.txt.demo  txt4.txt.demo</span><br></pre></td></tr></table></figure><p>__对查找到的文件使用Shell命令并且使用安全模式-ok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -type f -ok rm &#123;&#125; \;</span><br><span class="line">&lt; rm ... ./txt1.txt.demo &gt; ? n</span><br><span class="line">&lt; rm ... ./txt2.txt.demo &gt; ? n</span><br><span class="line">&lt; rm ... ./txt4.txt.demo &gt; ? n</span><br><span class="line">&lt; rm ... ./txt0.txt.demo &gt; ? y</span><br><span class="line">&lt; rm ... ./txt3.txt.demo &gt; ? n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示&lt;/p&gt;
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-文件和目录操作命令-1</title>
    <link href="https://evanmeek.github.io/2019/06/16/Linux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-1/"/>
    <id>https://evanmeek.github.io/2019/06/16/Linux-文件和目录操作命令-1/</id>
    <published>2019-06-16T07:56:11.000Z</published>
    <updated>2019-06-30T11:24:03.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-0-老男孩新手成为技术大牛心法"><a href="#2-0-老男孩新手成为技术大牛心法" class="headerlink" title="2.0 老男孩新手成为技术大牛心法"></a>2.0 老男孩新手成为技术大牛心法</h1><p>执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。</p><p>专注: 只做一件事。两耳不闻其他事，一心只读运维书。</p><p>自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。</p><p>心态: 保持空杯，重视基础；基础不牢，地动山摇。</p><h1 id="2-1-pwd命令"><a href="#2-1-pwd命令" class="headerlink" title="2.1 pwd命令"></a>2.1 pwd命令</h1><p>  <code>print working diretory</code></p><p>  <strong>查看当前路径使用<code>pwd</code>命令</strong></p><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ pwd</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/evanmeek</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-L</td><td>显示当前目录的逻辑路径(忽略软链接文件)</td></tr><tr><td>-P</td><td>显示当前目录的物理路径(若有软链接则显示源文件地址)</td></tr></tbody></table><p>  所谓的软链接相当于快捷方式，例如<code>~/test.txt</code>是<code>/test.txt</code>的软链接，那么我们操作<code>~/test.txt</code>等同于操作<code>/test.txt</code>，详细的软链接将会在后面的<code>ln</code>命令讲解。</p><h1 id="2-2-cd-切换目录"><a href="#2-2-cd-切换目录" class="headerlink" title="2.2 cd 切换目录"></a>2.2 cd 切换目录</h1><p>  <code>change directory</code></p><p>  <strong>进入某个目录使用<code>cd</code>命令</strong></p><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ pwd</span><br><span class="line">[evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/</span><br><span class="line">[evanmeek@EvanLinux /etc/sysctl.d/]$ pwd</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/evanmeek/</span><br><span class="line">/etc/sysctl.d/</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-P</td><td>进入目录的物理路径</td></tr><tr><td>-L</td><td>进入目录的逻辑路径</td></tr><tr><td>-</td><td>进入上次的目录</td></tr><tr><td>~</td><td>进入系统环境变量的<code>HOME</code>目录路径，即当前登录用户的家目录`</td></tr><tr><td>..</td><td>进入父目录</td></tr></tbody></table><p>  <code>cd</code> 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录.</p><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ cd Desktop</span><br><span class="line">[evanmeek@EvanLinux ~/Desktop]$ pwd</span><br><span class="line">[evanmeek@EvanLinux ~]$ cd -</span><br><span class="line">[evanmeek@EvanLinux ~]$ pwd</span><br><span class="line">[evanmeek@EvanLinux ~]$ cd /etc/systemd/</span><br><span class="line">[evanmeek@EvanLinux /etc/systemd/]$ pwd</span><br><span class="line">[evanmeek@EvanLinux /etc/systemd/]$ cd ..</span><br><span class="line">[evanmeek@EvanLinux /etc/]$ pwd</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/Desktop/</span><br><span class="line">~</span><br><span class="line">/etc/systemd/</span><br><span class="line">/etc/</span><br></pre></td></tr></table></figure><h1 id="2-3-tree以树形结构显示目录下的内容"><a href="#2-3-tree以树形结构显示目录下的内容" class="headerlink" title="2.3 tree以树形结构显示目录下的内容"></a>2.3 tree以树形结构显示目录下的内容</h1><p>  <strong>树形结构可以很清晰的显示出目录的父子级关系</strong></p><p>  例子:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~/test]$ tree -L 1</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── dir1_1</span><br><span class="line">│   └── dir2_2</span><br><span class="line">└── dir2</span><br><span class="line">    ├── dir1_1</span><br><span class="line">    └── dir2_2</span><br><span class="line"></span><br><span class="line">6 directories, 0 files</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件包括隐藏文件</td></tr><tr><td>-d</td><td>只显示目录<code>!</code></td></tr><tr><td>-f</td><td>显示每个文件的绝对路径</td></tr><tr><td>-i</td><td>不显示树枝</td></tr><tr><td>-L levelNum</td><td>显示遍历目录的层级，levelNum为层级(数字)</td></tr><tr><td>-F</td><td>显示时根据不同文件类型在文件名结尾处显示不同的符号</td></tr></tbody></table><p>  例子:</p><p>  显示隐藏文件<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设此目录下有隐藏文件</span><br><span class="line">[evanmeek@EvanLinux ~/tmp]$ tree -a</span><br></pre></td></tr></table></figure></p><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── dir1_1</span><br><span class="line">│   └── dir2_2</span><br><span class="line">├── dir2</span><br><span class="line">│   ├── dir1_1</span><br><span class="line">│   └── dir2_2</span><br><span class="line">├── .file1</span><br><span class="line">└── .file2</span><br><span class="line"></span><br><span class="line">6 directories, 2 files</span><br></pre></td></tr></table></figure><p>  例子:</p><p>  显示1级层文件完整路径，并不显示树枝<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi .</span><br></pre></td></tr></table></figure></p><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">./dir1</span><br><span class="line">./dir2</span><br></pre></td></tr></table></figure><h1 id="2-4-mkdir创建目录"><a href="#2-4-mkdir创建目录" class="headerlink" title="2.4 mkdir创建目录"></a>2.4 mkdir创建目录</h1><p>  <code>make directory</code></p><p>  <strong>创建目录使用<code>mkdir</code>命令</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>递归创建目录，若目录已存在不会报错</td></tr><tr><td>-m</td><td>创建时指定目录的权限</td></tr><tr><td>-v</td><td>创建时显示过程信息</td></tr></tbody></table><p>  例子:</p><p>  创建目录时显示信息<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mkdir -v testDir</span><br><span class="line">[evanmeek@EvanLinux ~]$ cd testDir</span><br><span class="line">[evanmeek@EvanLinux ~/testDir]$ pwd</span><br></pre></td></tr></table></figure></p><p>  输出信息:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir: 已创建目录 &apos;testDir&apos;</span><br></pre></td></tr></table></figure><p>  递归创建目录并且显示信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mkdir -pv father/son/test</span><br></pre></td></tr></table></figure><p>  输出信息:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir: 已创建目录 &apos;father&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son/test&apos;</span><br></pre></td></tr></table></figure><p>  创建目录并且指定目录权限</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir</span><br><span class="line">[evanmeek@EvanLinux ~]$ ls -ld testDir</span><br></pre></td></tr></table></figure><p>  输出信息:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir: 已创建目录 &apos;testDir&apos;</span><br><span class="line">d-wx-wx-wx 2 evanmeek evanmeek 4096  6月 17 20:15 testDir</span><br></pre></td></tr></table></figure><p>  利用特殊符号“{}”同时创建多目录及多子目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mkdir -pv father/&#123;son1/&#123;a1,a2&#125;,son2/&#123;b1,b2&#125;,son3/&#123;c1,c2&#125;&#125;</span><br><span class="line">[evanmeek@EvanLinux ~]$ tree father</span><br></pre></td></tr></table></figure><p>  输出信息:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mkdir: 已创建目录 &apos;father&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son1&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son1/a1&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son1/a2&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son2&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son2/b1&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son2/b2&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son3&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son3/c1&apos;</span><br><span class="line">mkdir: 已创建目录 &apos;father/son3/c2&apos;</span><br><span class="line"></span><br><span class="line">father</span><br><span class="line">├── son1</span><br><span class="line">│   ├── a1</span><br><span class="line">│   └── a2</span><br><span class="line">├── son2</span><br><span class="line">│   ├── b1</span><br><span class="line">│   └── b2</span><br><span class="line">└── son3</span><br><span class="line">    ├── c1</span><br><span class="line">    └── c2</span><br><span class="line"></span><br><span class="line">9 directories, 0 files</span><br></pre></td></tr></table></figure><h1 id="2-5-touch创建空文件或改变文件的时间戳属性"><a href="#2-5-touch创建空文件或改变文件的时间戳属性" class="headerlink" title="2.5 touch创建空文件或改变文件的时间戳属性"></a>2.5 touch创建空文件或改变文件的时间戳属性</h1><p>  <strong>创建新的空文件，改变文件的时间戳属性，需要用到touch</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>更改指定文件的最新访问时间</td></tr><tr><td>-d STRING</td><td>用字符串的方式指定一个模板作为指定文件的时间属性</td></tr><tr><td>-m</td><td>更改指定文件的最新修改时间</td></tr><tr><td>-r file</td><td>将指定文件的时间属性设置为file的时间属性</td></tr><tr><td>-t STAMP</td><td>使用时间格式设置文件的时间属性</td></tr></tbody></table><p>  例子:</p><p>  创建文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ touch test.txt</span><br></pre></td></tr></table></figure><p>  同时创建多个文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ touch test1.txt test2.txt</span><br></pre></td></tr></table></figure><p>  利用{}批量创建文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ touch t&#123;01..05&#125;.txt</span><br></pre></td></tr></table></figure><p>  利用<code>stat</code>命令查看时间戳</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File: t01.txt</span><br><span class="line">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class="line">Access: 2019-06-17 21:36:42.380004039 +0800</span><br><span class="line">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class="line">Change: 2019-06-17 21:36:42.380004039 +0800</span><br><span class="line">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure><p>  <strong>时间戳属性说明:</strong></p><ul><li><p>Access 访问属性</p></li><li><p>Modify 修改属性</p></li><li><p>Birth 状态改变属性</p><p>利用-a选项修改文件最后访问属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ touch -a t01.txt</span><br><span class="line">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure><p>输出信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File: t01.txt</span><br><span class="line">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class="line">Access: 2019-06-17 21:44:27.210736590 +0800</span><br><span class="line">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class="line">Change: 2019-06-17 21:44:27.210736590 +0800</span><br><span class="line">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure><p>修改文件的修改时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt</span><br><span class="line">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure><p>输出信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File: t01.txt</span><br><span class="line">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class="line">Access: 2001-01-01 00:00:00.000000000 +0800</span><br><span class="line">Modify: 2001-01-01 00:00:00.000000000 +0800</span><br><span class="line">Change: 2019-06-17 21:48:26.700992172 +0800</span><br><span class="line">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure><p>修改指定文件为某文件的时间属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ stat t02.txt</span><br><span class="line">[evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt</span><br><span class="line">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File: t01.txt</span><br><span class="line">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class="line">Access: 2019-06-17 21:36:42.380004039 +0800</span><br><span class="line">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class="line">Change: 2019-06-17 21:51:35.907031392 +0800</span><br><span class="line">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-6-ls显示目录下的内容及相关属性信息"><a href="#2-6-ls显示目录下的内容及相关属性信息" class="headerlink" title="2.6 ls显示目录下的内容及相关属性信息"></a>2.6 ls显示目录下的内容及相关属性信息</h1><p>  <code>list directory contents</code></p><p>  例子:</p><p>  查看当前目录下的文件信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ ls</span><br></pre></td></tr></table></figure><p>  输出结果</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Applications  Desktop  Downloads  GameDir  index.html  Music  Pictures  temp  WorkDir</span><br></pre></td></tr></table></figure><p>  每个人的目录里面的内容不同，所以可能不一样。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>使用长格式列出目录下的文件和信息</td></tr><tr><td>-a</td><td>显示目录下的所有文件，包括隐藏文件<code>!</code></td></tr><tr><td>-t</td><td>根据最新的修改时间排序，不加此参数默认是根据文件名排序<code>!</code></td></tr><tr><td>-r</td><td>反向排序</td></tr><tr><td>-F</td><td>在显示的条目后加上特殊符号用以区别文件类型<code>!</code></td></tr><tr><td>-p</td><td>目录后面加上“/”</td></tr><tr><td>-i</td><td>显示inode节点信息</td></tr><tr><td>-d</td><td>遇到目录时，只列出目录本身，并且不跟随符号链接<code>!</code></td></tr><tr><td>-h</td><td>以人类可读的信息显示文件或目录大小</td></tr><tr><td>-A</td><td>列出所有文件，包括隐藏文件夹，但不包括.和..</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-R</td><td>递归列出所有子目录</td></tr><tr><td>-x</td><td>逐行列出项目而不是逐栏列出</td></tr><tr><td>-X</td><td>根据扩展名排序</td></tr><tr><td>-c</td><td>根据状态改变时间排序</td></tr><tr><td>-u</td><td>根据最后访问时间排序</td></tr><tr><td>–color={never,always,auto}</td><td>根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示</td></tr><tr><td>–full-time</td><td>以完整的时间格式进行显示</td></tr><tr><td>–time-style={full-iso,long-iso,iso,locale}</td><td>以不同的时间格式输出，long-iso最常用</td></tr><tr><td>–time={atime,ctimeA}</td><td>按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间</td></tr></tbody></table><p>  例子:</p><p>  环境准备</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mkdir temp</span><br><span class="line">[evanmeek@EvanLinux ~]$ cd temp</span><br><span class="line">[evanmeek@EvanLinux ~]$ mkdir -p father/dir&#123;01..02&#125;</span><br><span class="line">[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/txt&#123;01..02&#125;</span><br><span class="line">[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/.txt&#123;01..02&#125;</span><br><span class="line">[evanmeek@EvanLinux ~]$ tree -a</span><br></pre></td></tr></table></figure><p>  输出结果</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  .</span><br><span class="line">  └── father</span><br><span class="line">      ├── dir01</span><br><span class="line">      │   ├── .txt01</span><br><span class="line">      │   ├── txt01</span><br><span class="line">      │   ├── .txt02</span><br><span class="line">      │   └── txt02</span><br><span class="line">      └── dir02</span><br><span class="line">          ├── .txt01</span><br><span class="line">          ├── txt01</span><br><span class="line">          ├── .txt02</span><br><span class="line">          └── txt02</span><br><span class="line"></span><br><span class="line">3 directories, 8 files</span><br></pre></td></tr></table></figure><p>  递归显示所有文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.:</span><br><span class="line">.  ..  father</span><br><span class="line"></span><br><span class="line">./father:</span><br><span class="line">.  ..  dir01  dir02</span><br><span class="line"></span><br><span class="line">./father/dir01:</span><br><span class="line">.  ..  .txt01  txt01  .txt02  txt02</span><br><span class="line"></span><br><span class="line">./father/dir02:</span><br><span class="line">.  ..  .txt01  txt01  .txt02  txt02</span><br></pre></td></tr></table></figure><p> <strong>ls命令输出属性解释</strong></p><p>  目录内容如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dir01</span><br><span class="line">├── dir02</span><br><span class="line">├── file01.txt</span><br><span class="line">└── file02.txt</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure><p>  长格式列出人类可读信息并显示inode信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ ls -lhi</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total 8.0K</span><br><span class="line">18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir01</span><br><span class="line">18219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir02</span><br><span class="line">18219054 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file01.txt</span><br><span class="line">18219055 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file02.txt</span><br></pre></td></tr></table></figure><p>  从第一列依次往后排，分别含义为:</p><ol><li>inode索引节点编号</li><li>文件类型以及属性(第一字符标注类型，后9个代表权限)</li><li>硬链接个数</li><li>文件或目录所属用户</li><li>文件或目录所属的组</li><li>文件或目录的大小</li><li>修改时间</li><li>文件名或目录名</li></ol><h1 id="2-7-cp复制文件或目录"><a href="#2-7-cp复制文件或目录" class="headerlink" title="2.7 cp复制文件或目录"></a>2.7 cp复制文件或目录</h1><p>  <code>copy</code></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>复制文件时保存源文件的所有者、权限信息及时间属性</td></tr><tr><td>-d</td><td>如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录</td></tr><tr><td>-r</td><td>递归复制目录，即目录下所有的子目录及文件</td></tr><tr><td>-a</td><td>等同于上面的p、d、r这3个选项功能的总和</td></tr><tr><td>-i</td><td>覆盖已有文件前提示用户确认</td></tr><tr><td>-t</td><td>调换命令格式，默认格式是”cp 源文件 目标文件”，将目标文件和源文件进行位置调换</td></tr></tbody></table><p>  例子:</p><p>  环境准备</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── fatherDir</span><br><span class="line">    ├── sonDir1</span><br><span class="line">    │   └── test.txt</span><br><span class="line">    ├── sonDir2</span><br><span class="line">    │   └── test.txt</span><br><span class="line">    └── sonDir3</span><br><span class="line">        └── test.txt</span><br><span class="line"></span><br><span class="line">4 directories, 3 files</span><br></pre></td></tr></table></figure><p>  拷贝<code>fatherDir</code>为<code>father2Dir</code>并保留源文件的所有者，权限信息及时间属性</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir</span><br></pre></td></tr></table></figure><p>  再次拷贝<code>fatherDir</code>为<code>father2Dir</code>从而覆盖上个例子的<code>father2Dir</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir1/test.txt&apos;？ y</span><br><span class="line">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir2/test.txt&apos;？ y</span><br><span class="line">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir3/test.txt&apos;？ y</span><br></pre></td></tr></table></figure><h1 id="2-8-mv移动或重命名文件"><a href="#2-8-mv移动或重命名文件" class="headerlink" title="2.8 mv移动或重命名文件"></a>2.8 mv移动或重命名文件</h1><p>  <code>move</code><br>  | 选项 | 说明                                                       |<br>  |——|————————————————————|<br>  | -f   | 若目标文件已存在，不询问直接覆盖                           |<br>  | -i   | 若目标文件已存在，询问是否覆盖                             |<br>  | -n   | 不覆盖已存在的文件                                         |<br>  | -t   | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 |<br>  | -u   | 源文件比目标文件新，或目标文件不存在时再移动               |</p><p>  例子:</p><p>  环境准备</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test0.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt</span><br><span class="line">drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt</span><br></pre></td></tr></table></figure><p>  更换文件名</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanMeek ~]$mv test0.txt test-1.txt</span><br><span class="line">[evanmeek@EvanMeek ~]$ls -l --full-time</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test-1.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt</span><br><span class="line">drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt</span><br></pre></td></tr></table></figure><p>  <strong>移动文件</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mv test-1.txt testTxt</span><br></pre></td></tr></table></figure><p>  <strong>移动多个文件至一个目录</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt</span><br></pre></td></tr></table></figure><h1 id="2-9-rm删除文件或目录"><a href="#2-9-rm删除文件或目录" class="headerlink" title="2.9 rm删除文件或目录"></a>2.9 rm删除文件或目录</h1><p>  <strong>前排提示:使用rm命令时最好知道自己在干什么!</strong></p><p>  <code>remove</code></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>强制删除并且忽略不存在文件的提示</td></tr><tr><td>-i</td><td>删除时需要确认</td></tr><tr><td>-I</td><td>删除三个以上文件或者递归删除前需要确认</td></tr><tr><td>-r</td><td>递归删除目录以及其内容<code>!</code></td></tr></tbody></table><p>  例子:</p><p>  <strong>再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现)</strong></p><p>  环境准备<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── test2Txt</span><br><span class="line">│   ├── test1.txt</span><br><span class="line">│   ├── test2.txt</span><br><span class="line">│   └── testTxt</span><br><span class="line">│       └── test-1.txt</span><br><span class="line">└── test3.txt</span><br></pre></td></tr></table></figure></p><p>  <strong>删除文件</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ rm test3.txt</span><br></pre></td></tr></table></figure><p>  <strong>强制删除并且删除时需要确认</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt</span><br></pre></td></tr></table></figure><p>  输出信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm：是否删除普通空文件 &apos;test2Txt/test2.txt&apos;？</span><br></pre></td></tr></table></figure><p>  <strong>删除目录并且删除时需要确认</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt</span><br></pre></td></tr></table></figure><p>  <strong>强制删除+递归删除目录</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ rm -rf test2Txt</span><br></pre></td></tr></table></figure><p>  <strong>最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /*</span><br></pre></td></tr></table></figure><p>  <strong>这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内.</strong></p><h2 id="删除时的小技巧"><a href="#删除时的小技巧" class="headerlink" title="删除时的小技巧"></a>删除时的小技巧</h2><ul><li><p>使用<code>mv</code>命令代替<code>rm</code>命令，可以将要删除的文件暂时保存在<code>/tmp</code>目录下，需要清理空间时再去删除</p></li><li><p>删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原</p></li><li><p>若非要用删除命令清理空间可以选择用<code>find</code>代替<code>rm</code></p></li><li><p>删除时尽量不要使用系统通配符</p></li></ul><h1 id="2-10-rmdir删除空目录"><a href="#2-10-rmdir删除空目录" class="headerlink" title="2.10 rmdir删除空目录"></a>2.10 rmdir删除空目录</h1><p>  <code>remove dirctory</code></p><p>  此命令只能删除空目录</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息</td></tr><tr><td>-v</td><td>删除时显示执行过程</td></tr></tbody></table><h1 id="2-11-ln硬链接与软链接"><a href="#2-11-ln硬链接与软链接" class="headerlink" title="2.11 ln硬链接与软链接"></a>2.11 ln硬链接与软链接</h1><p>  <code>link</code></p><p>  链接分为两种，分别是硬链接与软链接</p><p>  硬链接(hard link):</p><ul><li><p>不能将硬链接链接到不同文件系统的文件</p></li><li><p>硬链接不能链接目录</p></li><li><p>删除硬链接或者源文件之一并不能完全删除实体</p></li><li><p>删除实体需要删除硬链接以及起对应的源文件</p></li><li><p>硬链接相当与源文件的另外一个入口</p></li><li><p>对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除</p></li><li><p>硬链接的文件类型是普通文件(字符型)</p></li><li><p>硬链接通过索引节点进行链接</p><p>例子:</p><p>创建硬链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt</span><br></pre></td></tr></table></figure><p>软链接(Symbolic Link):</p></li><li><p>类似于Windows的快捷方式</p></li><li><p>文件内存放的是源文件的路径</p></li><li><p>即使删除源文件，软链接仍然存在，但无法访问源文件</p></li><li><p>源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示</p></li><li><p>软链接可以用rm命令删除</p><p>例子:</p><p><strong>创建软链接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件链接案例"><a href="#文件链接案例" class="headerlink" title="文件链接案例"></a>文件链接案例</h2><p>  通过一个案例演示软链接和硬链接的区别。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ cat testFile</span><br><span class="line">123</span><br><span class="line"># 创建硬链接</span><br><span class="line">[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink</span><br><span class="line"># 创建软链接</span><br><span class="line">[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink</span><br><span class="line">[evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line"># 删除软链接</span><br><span class="line">[evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink</span><br><span class="line">[evanmeek@EvanLinux ~]$ cat testFile testHardLink</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line"># 复原</span><br><span class="line">[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink</span><br><span class="line"># 删除硬链接</span><br><span class="line">[evanmeek@EvanLinux ~]$ rm -f testFileHardLink</span><br><span class="line">[evanmeek@EvanLinux ~]$ cat testFile testFileHardLink</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line"># 复原</span><br><span class="line">[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink</span><br><span class="line"># 删除源文件</span><br><span class="line">[evanmeek@EvanLinux ~]$ rm -f testFile</span><br><span class="line">[evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink</span><br><span class="line">123</span><br><span class="line">cat: testFileSymbolicLink: 没有那个文件或目录</span><br></pre></td></tr></table></figure><ul><li><p>硬链接可以没有源文件</p></li><li><p>软链接不行</p></li></ul><h1 id="2-12-readlink-查看符号链接文件的内容"><a href="#2-12-readlink-查看符号链接文件的内容" class="headerlink" title="2.12 readlink 查看符号链接文件的内容"></a>2.12 readlink 查看符号链接文件的内容</h1><p>  此命令可查看链接指向的源文件的地址</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行</td></tr></tbody></table><p>  例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink</span><br></pre></td></tr></table></figure><h1 id="2-13-find-查找目录下的文件"><a href="#2-13-find-查找目录下的文件" class="headerlink" title="2.13 find 查找目录下的文件"></a>2.13 find 查找目录下的文件</h1><p>  由于本篇篇幅较大，请点击下方超链接进行访问。</p><p>  <a href="/2019/6/21/Linux-文件和目录操作命令-find命令">点击访问</a></p><h1 id="2-14-xargs将标准输入转换成命令行参数"><a href="#2-14-xargs将标准输入转换成命令行参数" class="headerlink" title="2.14 xargs将标准输入转换成命令行参数"></a>2.14 xargs将标准输入转换成命令行参数</h1><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>指定每行命令的最大参数数量，每个参数由空格隔开</td></tr><tr><td>-d</td><td>自定义分割符</td></tr><tr><td>-i</td><td>以{}替代xargs命令之前的结果</td></tr><tr><td>-I</td><td>指定一个符号替代前面的结果，而不是使用默认的{}</td></tr><tr><td>-P</td><td>提示让用户确认是否执行后面的命令，y执行，n不执行</td></tr><tr><td>-0</td><td>用null替代空格作为分割符，配合find命令的-printf0选项的输出使用</td></tr></tbody></table><h2 id="2-14-2使用范例"><a href="#2-14-2使用范例" class="headerlink" title="2.14.2使用范例"></a>2.14.2使用范例</h2><p>  <strong>多行输入变单行</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat test.txt</span><br><span class="line">1 2 3 4 </span><br><span class="line">5 6 7</span><br><span class="line">8 9</span><br><span class="line">1 </span><br><span class="line">&gt; xargs &lt; test.txt</span><br><span class="line">1 2 3 4 5 6 7 8 9 1</span><br></pre></td></tr></table></figure><p>  <strong>通过-n指定每行的输出个数</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; xargs -n 2 &lt; test.txt</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br><span class="line">9 1</span><br></pre></td></tr></table></figure><p>  <strong>自定义分隔符(使用-d功能)</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo 123I321I809I098</span><br><span class="line">123I321I809I098</span><br><span class="line"></span><br><span class="line">&gt; echo 123I321I809I098|xargs -d I -n 2</span><br><span class="line">123 321</span><br><span class="line">890 098</span><br></pre></td></tr></table></figure></p><p>  <strong>指定一个替换字符串</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将查找出来的结果删除</span><br><span class="line"># 先将结果传给&#123;&#125;</span><br><span class="line"># 再会被删除</span><br><span class="line">&gt; find . -name &quot;*.log&quot;|xargs -i rm -rf &#123;&#125;</span><br><span class="line"># 自定义替换字符串</span><br><span class="line">&gt; find . -name &quot;*.log&quot;|xargs -I [] rm -rf []</span><br></pre></td></tr></table></figure></p><h1 id="2-15-rename重命名"><a href="#2-15-rename重命名" class="headerlink" title="2.15 rename重命名"></a>2.15 rename重命名</h1><p>  rename通过替换字符串的方式批量修改文件名</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename from to file</span><br></pre></td></tr></table></figure><p>  例子:</p><p>  <strong>批量修改文件名</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls</span><br><span class="line">test_demo_0  test_demo_1  test_demo_2  test_demo_3  test_demo_4  test_demo_5</span><br><span class="line">&gt; rename &quot;_demo&quot; &quot;&quot; *</span><br><span class="line">&gt; ls</span><br><span class="line">test_0  test_1  test_2  test_3  test_4  test_5</span><br></pre></td></tr></table></figure><p>  <strong>批量修改文件扩展名</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls</span><br><span class="line">test0.txt  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">&gt; rename .txt .demo *</span><br><span class="line">&gt; ls</span><br><span class="line">test0.demo  test1.demo  test2.demo  test3.demo  test4.demo  test5.demo</span><br></pre></td></tr></table></figure><h1 id="2-16-basename显示文件名或目录名"><a href="#2-16-basename显示文件名或目录名" class="headerlink" title="2.16 basename显示文件名或目录名"></a>2.16 basename显示文件名或目录名</h1><p>  basename命令用于显示去除路径和文件后缀的文件名或目录名</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename [&lt;文件或目录&gt;] [后缀]</span><br></pre></td></tr></table></figure><p>  其中的后缀为可选</p><p>  例子:</p><p>  <strong>只显示文件名和后缀，不显示完整路径</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir -p dir1/dir2/</span><br><span class="line">&gt; touch dir1/dir2/test.txt</span><br><span class="line">&gt; basename dir1/dir2/test.txt</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><p>  只显示文件名，不显示完整路径制定不显示某个后缀</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; touch dir1/dir2/test.demo.txt</span><br><span class="line">&gt; basename dir1/dir2/test.demo.txt .txt</span><br><span class="line">test.demo</span><br></pre></td></tr></table></figure><h1 id="2-17-dirname显示文件或目录的路径"><a href="#2-17-dirname显示文件或目录的路径" class="headerlink" title="2.17 dirname显示文件或目录的路径"></a>2.17 dirname显示文件或目录的路径</h1><p>  dirname命令用于只显示文件或目录的路径</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure><p>  例子:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; dirname dir1/dir2/test.txt</span><br><span class="line">dir1/dir2</span><br></pre></td></tr></table></figure><h1 id="2-18-chattr改变文件的扩展属性"><a href="#2-18-chattr改变文件的扩展属性" class="headerlink" title="2.18 chattr改变文件的扩展属性"></a>2.18 chattr改变文件的扩展属性</h1><p>  charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的．</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [选项] [模式] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure><p>  提示:<code>lsattr</code>命令可以查看文件的属性</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>递归更改目录属性</td></tr><tr><td>-V</td><td>显示执行过程</td></tr><tr><td>mode</td><td></td></tr><tr><td>+</td><td>增加参数</td></tr><tr><td>-</td><td>移除参数</td></tr><tr><td>=</td><td>更新为指定参数</td></tr><tr><td>A</td><td>指定文件的最后访问时间不可修改</td></tr><tr><td>a</td><td>指定文件只能添加数据，无法删除数据<code>!</code></td></tr><tr><td>!</td><td>指定文件不能被删除，重命名，写入或新增内容</td></tr></tbody></table><p>  例子：</p><p>  <strong>给文件加锁，使其只能为只读</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; chattr +i test.txt</span><br><span class="line">&gt; lsattr test.txt</span><br><span class="line">----i---------e----- test.txt</span><br><span class="line">&gt; echo a1111 &gt; test.txt</span><br><span class="line">zsh: 不允许的操作: test.txt</span><br><span class="line">&gt; echo b2222 &gt;&gt; test.txt </span><br><span class="line">zsh: 不允许的操作: test.txt</span><br></pre></td></tr></table></figure><p>  <strong>给文件解锁</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; charttr -i test.txt</span><br><span class="line">&gt; lsattr test.txt</span><br><span class="line">--------------e----- test.txt</span><br><span class="line">&gt; eco 111 &gt; test.txt</span><br><span class="line">&gt; cat test.txt</span><br><span class="line">111</span><br></pre></td></tr></table></figure><h1 id="2-19-lsattr查看文件扩展属性"><a href="#2-19-lsattr查看文件扩展属性" class="headerlink" title="2.19 lsattr查看文件扩展属性"></a>2.19 lsattr查看文件扩展属性</h1><p>  lsattr命令用于查看文件扩展属</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr [选项] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>递归查看目录的扩展属性</td></tr><tr><td>-a</td><td>显示所有文件的扩展属性</td></tr><tr><td>-d</td><td>显示目录的扩展属性</td></tr></tbody></table><p>  例子:</p><p>  <strong>查看文件的扩展属性</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; lsattr test.txt</span><br><span class="line">--------------e----- test.txt</span><br><span class="line">&gt; chattr +i test.txt</span><br><span class="line">&gt; lsattr test.txt</span><br><span class="line">----i---------e----- test.txt</span><br></pre></td></tr></table></figure><p>  <strong>查看目录的扩展属性</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; lsattr -d testDir</span><br><span class="line">--------------e----- testDir</span><br><span class="line">&gt; chattr +i testDir</span><br><span class="line">&gt; lsattr -d testDir</span><br><span class="line">----i---------e----- testDir</span><br></pre></td></tr></table></figure><h1 id="2-20-file显示文件的类型"><a href="#2-20-file显示文件的类型" class="headerlink" title="2.20 file显示文件的类型"></a>2.20 file显示文件的类型</h1><p>  file命令用于显示文件的类型</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [选项] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>输出信息使用精简格式</td></tr></tbody></table><p>  例子:</p><p>  <strong>查看文件类型</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; file test.txt</span><br><span class="line">test.txt: empty</span><br><span class="line">&gt; file *</span><br><span class="line">test.txt:      empty</span><br><span class="line">test.txt.link: symbolic link to test.txt</span><br></pre></td></tr></table></figure><h1 id="2-21-md5sum计算和校验文件的MD5值"><a href="#2-21-md5sum计算和校验文件的MD5值" class="headerlink" title="2.21 md5sum计算和校验文件的MD5值"></a>2.21 md5sum计算和校验文件的MD5值</h1><p>  md5sum命令用于计算和校验文件的MD5值.</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum [选项] [文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>二进制模式读取文件</td></tr><tr><td>-c</td><td>从指定文件中读取MD5校验值，并进行校验</td></tr><tr><td>-t</td><td>文本模式读取文件，默认</td></tr><tr><td>–quiet</td><td>校验文件时，若通过不输出OK</td></tr><tr><td>–status</td><td>校验文件时，不输出任何信息，但可通过命令的返回值判断</td></tr></tbody></table><p>  例子:</p><p>  <strong>生成一个文件的MD5值</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; md5sum test.txt</span><br><span class="line">d41d8cd98f00b204e9800998ecf8427e  test.txt</span><br></pre></td></tr></table></figure><p>  <strong>校验文件MD5值是否发生改变</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; md5sum test.txt &gt; md5.log</span><br><span class="line">&gt; cat md5.log</span><br><span class="line">d41d8cd98f00b204e9800998ecf8427e  test.txt</span><br><span class="line">&gt; md5sum -c md5.log</span><br><span class="line">test.txt: 成功</span><br><span class="line">&gt; echo &quot;update&quot; &gt;&gt; test.txt</span><br><span class="line">&gt; md5sum -c md5.log</span><br><span class="line">test.txt: 失败</span><br><span class="line">md5sum: 警告：1 个校验和不匹配</span><br><span class="line">&gt; md5sum --status -c md5.log</span><br><span class="line">&gt; echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="2-22-chown改变文件或目录的用户和用户组"><a href="#2-22-chown改变文件或目录的用户和用户组" class="headerlink" title="2.22 chown改变文件或目录的用户和用户组"></a>2.22 chown改变文件或目录的用户和用户组</h1><p>  chown命令用于改变文件或目录的用户和用户组</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] [用户:用户组] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>递归更改目录的用户和用户组</td></tr></tbody></table><p>  例子:</p><p>  <strong>更改文件所属的用户属性</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l test.txt</span><br><span class="line">-rw-r--r-- 1 root root 5  6月 27 00:31 test.txt</span><br><span class="line"># 授予权限的用户必须存在</span><br><span class="line">&gt; chown xxx test.txt</span><br><span class="line">chown: 无效的用户: “xxx”</span><br><span class="line">&gt; chown evanmeek test.txt</span><br><span class="line">&gt; ls -l test.txt</span><br><span class="line">-rw-r--r-- 1 evanmeek root 5  6月 27 00:31 test.txt</span><br></pre></td></tr></table></figure><p>  <strong>更改文件所属用户组的属性</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l</span><br><span class="line">总用量 4.0K</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt</span><br><span class="line">&gt; chown .root test.txt</span><br><span class="line">&gt; ls -l</span><br><span class="line">总用量 4.0K</span><br><span class="line">-rw-r--r-- 1 evanmeek root 5  6月 27 00:34 test.txt</span><br></pre></td></tr></table></figure><p>  <strong>同时更改文件的用户和用户组属性</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; chown evanmeek:evanmeek test.txt</span><br><span class="line">&gt; ls -l</span><br><span class="line">总用量 4.0K</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt</span><br></pre></td></tr></table></figure><p>  <strong>递归更改目录下所有文件及目录的用户和用户组属性</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; tree</span><br><span class="line">.</span><br><span class="line">├── dir0</span><br><span class="line">│   └── test.txt</span><br><span class="line">├── dir1</span><br><span class="line">│   └── test.txt</span><br><span class="line">└── dir2</span><br><span class="line">    └── test.txt</span><br><span class="line"></span><br><span class="line">3 directories, 3 files</span><br><span class="line">&gt; chown -R root:root .</span><br><span class="line">&gt; ls -l</span><br><span class="line">总用量 12K</span><br><span class="line">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir0</span><br><span class="line">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir1</span><br><span class="line">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir2</span><br></pre></td></tr></table></figure><h1 id="2-23chmod改变文件或目录权限"><a href="#2-23chmod改变文件或目录权限" class="headerlink" title="2.23chmod改变文件或目录权限"></a>2.23chmod改变文件或目录权限</h1><p>  只有文件的属主以及超级用户<code>root</code>才能执行此命令</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] [模式] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>递归指定目录以及子目录的权限</td></tr></tbody></table><p>  权限对应表</p><table><thead><tr><th>权限位</th><th>全称</th><th>含义</th><th>对应数字</th></tr></thead><tbody><tr><td>r</td><td>read</td><td>可读权限</td><td>4</td></tr><tr><td>w</td><td>write</td><td>可写权限</td><td>2</td></tr><tr><td>x</td><td>execute</td><td>可执行权限</td><td>1</td></tr><tr><td>-</td><td></td><td>没有任何权限</td><td>0</td></tr><tr><td>备注</td><td>一些特殊权限位:t,T,s,S,x,X</td><td></td><td></td></tr><tr><td>用户类型</td><td>文件所属用户:u(OwnerUser)</td><td></td><td></td></tr><tr><td>用户类型</td><td>文件所属用户组:g(Group)</td><td></td><td></td></tr><tr><td>用户类型</td><td>其他用户:o(Other)</td><td></td><td></td></tr><tr><td>用户类型</td><td>所有:a(ALL),等效于u,g,o的总和</td><td></td><td></td></tr><tr><td>操作字符</td><td>+:添加/-:减去/=:设置</td><td></td></tr></tbody></table><p>  例子:</p><p>  <strong>权限字母和操作符表达式</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br><span class="line"># 给文件所属用户减去可写权限</span><br><span class="line">&gt; chmod u-w test.txt</span><br><span class="line"># 给用户所属用户组减去可读权限</span><br><span class="line">&gt; chmod g-r test.txt</span><br><span class="line">&gt; ls -l</span><br><span class="line">总用量 4.0K</span><br><span class="line">-r-----r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br><span class="line"># 给所有用户以及用户组都设置为可读可写可执行的权限</span><br><span class="line">&gt; chmod a=rwx test.txt</span><br><span class="line">&gt; ls -l</span><br><span class="line">总用量 4.0K</span><br><span class="line">-rwxrwxrwx 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure><p>  <strong>使用数字更改文件或目录权限</strong></p><p>  先举个例子，有这么一个文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw---- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure><p>  权限示意图</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前三个字符代表文件属主的权限</span><br><span class="line">中间三个字符代表文件属组的权限</span><br><span class="line">后三个字符代表其他用户的权限</span><br><span class="line">-rw-rw---- evanmeek evanmeek test.txt</span><br></pre></td></tr></table></figure><p>  <strong>我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660</strong></p><p>  <em>因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660</em></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将test.txt文件的所有用户权限设置为可读可写可执行</span><br><span class="line">&gt; chmod 777 test.txt</span><br><span class="line">&gt; ls -l</span><br><span class="line">---------- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure><p>  <strong>使用数字递归更改文件或目录的权限</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; tree</span><br><span class="line">.</span><br><span class="line">├── dir0</span><br><span class="line">│   └── file.txt</span><br><span class="line">├── dir1</span><br><span class="line">│   └── file.txt</span><br><span class="line">└── dir2</span><br><span class="line">    └── file.txt</span><br><span class="line">&gt; ls -l</span><br><span class="line">总用量 12K</span><br><span class="line">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0</span><br><span class="line">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1</span><br><span class="line">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2</span><br><span class="line">&gt; chmod -R 777 dir&#123;0..2&#125;</span><br><span class="line">总用量 12K</span><br><span class="line">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0</span><br><span class="line">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1</span><br><span class="line">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2</span><br></pre></td></tr></table></figure><p>  <strong>Linux普通文件的读，写，执行权限说明</strong><br>  | 权限    | 说明                       |<br>  |———|—————————-|<br>  | 可读r   | 表示具有读取文件内容的权限 |<br>  | 可写w   | 表示具有修改文件内容的权限 |<br>  | 可执行x | 表示具有执行文件的权限     |</p><ul><li><p>可写w</p><ol><li>如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo &gt;&gt;　的方式进行追加.</li><li>删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里</li></ol></li><li><p>可执行x</p><ol><li>要求文件本身是可执行的</li><li>普通用户必须要有r权限才能够执行</li><li>root用户即使没有r权限，只需要有x权限即可执行</li><li>不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行</li></ol><p><strong>Linux目录的，写，执行权限说明</strong><br>| 权限    | 说明                                       |<br>|———|——————————————–|<br>| 可读r   | 表示具有浏览目录下文件以及子目录的权限     |<br>| 可写w   | 表示具有增加，删除或修改目录内文件名的权限 |<br>| 可执行x | 表示具有进入目录的权限                     |</p></li><li><p>可读r</p><ol><li>没有x权限不能进入至目录内</li><li>ls列表可以看到所有文件名，不过会提示无法访问目录下的文件</li><li>如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名</li></ol></li><li><p>可写w</p><ol><li>增加的不是文件内容，而是创建新文件</li><li>修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名，</li><li>删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除</li></ol></li><li>可执行权限x<ol><li>没有可读权限r则不能进入目录</li><li>没有可写权限w则无法创建新文件</li></ol></li></ul><h1 id="2-24-chgrp更改文件用户组"><a href="#2-24-chgrp更改文件用户组" class="headerlink" title="2.24 chgrp更改文件用户组"></a>2.24 chgrp更改文件用户组</h1><p>  此命令被<code>chown</code>取代，用法和参数都和<code>chown</code>命令相同</p><h1 id="2-25-umask显示或设置权限掩码"><a href="#2-25-umask显示或设置权限掩码" class="headerlink" title="2.25 umask显示或设置权限掩码"></a>2.25 umask显示或设置权限掩码</h1><p>  umask是通过八进制的数值来定义用户创建文件或目录的默认权限</p><p>  语法格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask [选项] [模式]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>输出的权限掩码可直接作为命令来执行</td></tr><tr><td>-S</td><td>以字符的方式输出权限掩码</td></tr></tbody></table><h2 id="2-25-2-通过umask计算文件目录权限"><a href="#2-25-2-通过umask计算文件目录权限" class="headerlink" title="2.25.2 通过umask计算文件目录权限"></a>2.25.2 通过umask计算文件目录权限</h2><p>  <strong>文件权限的计算</strong></p><p>  创建文件默认的最大权限为666，也就是说没有可执行权限x.</p><p>  umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。</p><p>  例子:</p><p>  假如umask值为:022，那么:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  6 6 6 文件默认的权限</span><br><span class="line">  0 2 2 umask值</span><br><span class="line">- =====</span><br><span class="line">  6 4 4 都为偶数，最终结果为644</span><br></pre></td></tr></table></figure></p><p>  假如umask值为:045，那么:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    6 6 6 文件默认的权限</span><br><span class="line">    0 4 5 umask值</span><br><span class="line">- =====</span><br><span class="line">    6 2 1 其他用户权限位为奇数，所以+1</span><br><span class="line">    0 0 1</span><br><span class="line">+ =====</span><br><span class="line">    6 2 2 都为偶数，最终结果为622</span><br></pre></td></tr></table></figure></p><p>  <strong>目录权限的计算</strong></p><p>  <em>目录权限的计算没有奇偶之分</em></p><p>  创建目录是默认的最大权限为777(-rwx-rwx-rwx)</p><p>  计算方法和文件权限计算方法相同</p><p>  例子:</p><p>  假如umask值为:022，那么:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  7 7 7 目录默认最大权限</span><br><span class="line">  0 2 2 umask值</span><br><span class="line">- =====</span><br><span class="line">  7 5 5 得到最终结果</span><br></pre></td></tr></table></figure></p><p>  <strong>查看系统默认的umask值</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 普通用户的默认umask值</span><br><span class="line">evanmeek &gt; umask</span><br><span class="line">022</span><br><span class="line"># 超级用户的默认umask值</span><br><span class="line">root &gt; umask</span><br><span class="line">0022</span><br></pre></td></tr></table></figure><p>  <strong>-S参数的使用</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; umask -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure><p>  <strong>-p参数的使用</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; umask -p</span><br><span class="line">umask 0022</span><br></pre></td></tr></table></figure><p>  <strong>临时修改umask值</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 修改umask之前</span><br><span class="line">&gt; umask</span><br><span class="line">&gt; ls -l file1</span><br><span class="line">-rw-r--r-- 1 evanmeek evanmeek 0  6月 30 19:11 file1</span><br><span class="line"># 修改umask之后</span><br><span class="line">&gt; umask 044</span><br><span class="line">&gt; umask</span><br><span class="line">044</span><br><span class="line">&gt; touch file2</span><br><span class="line">&gt; ls -l file1</span><br><span class="line">-rw--w--w- 1 evanmeek evanmeek 0  6月 30 19:12 file2</span><br></pre></td></tr></table></figure><p>  <strong>永久修改umask值</strong></p><p>  <em>若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。</em></p><p>  编辑<code>/etc/profile</code>或者<code>/etc/bashrc</code></p><p>  找到<code>umask</code>项修改即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-0-老男孩新手成为技术大牛心法&quot;&gt;&lt;a href=&quot;#2-0-老男孩新手成为技术大牛心法&quot; class=&quot;headerlink&quot; title=&quot;2.0 老男孩新手成为技术大牛心法&quot;&gt;&lt;/a&gt;2.0 老男孩新手成为技术大牛心法&lt;/h1&gt;&lt;p&gt;执着: 学Linux
      
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Linux命令行简介-man命令</title>
    <link href="https://evanmeek.github.io/2019/06/15/Linux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-man%E5%91%BD%E4%BB%A4/"/>
    <id>https://evanmeek.github.io/2019/06/15/Linux-Linux命令行简介-man命令/</id>
    <published>2019-06-15T10:31:17.000Z</published>
    <updated>2019-06-20T10:35:41.064Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。</p><a id="more"></a><h1 id="1-2-1-使用man获取命令帮助信息"><a href="#1-2-1-使用man获取命令帮助信息" class="headerlink" title="1.2.1 使用man获取命令帮助信息"></a>1.2.1 使用man获取命令帮助信息</h1><p>man命令的作用:</p><ul><li><p>查看命令的使用帮助</p></li><li><p>查看软件服务配置文件</p></li><li><p>查看系统调用信息</p></li><li><p>查看C库函数帮助信息</p></li></ul><p>man命令的使用:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 参数选项 命令/文件</span><br></pre></td></tr></table></figure><p>man命令可选参数:</p><table><thead><tr><th>参数</th><th>英文说明</th><th>中文说明</th></tr></thead><tbody><tr><td>1</td><td>User Commands</td><td>用户命令相关</td></tr><tr><td>2</td><td>System Calls</td><td>系统调用相关</td></tr><tr><td>3</td><td>C Library Functions</td><td>C的库函数相关</td></tr><tr><td>4</td><td>Devices and Special Files</td><td>设备与特殊文件相关</td></tr><tr><td>5</td><td>File Formats and Conventions</td><td>文件格式和规则</td></tr><tr><td>6</td><td>Games et. Al.</td><td>游戏及其他</td></tr><tr><td>7</td><td>Miscellanea</td><td>宏，包及其他杂项</td></tr><tr><td>8</td><td>System Admin tools and Deamons</td><td>系统管理员命令和进程</td></tr></tbody></table><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看cp命令的使用帮助</span><br><span class="line">man cp</span><br><span class="line"><span class="meta">#</span> 查看C语言printf函数的使用帮助</span><br><span class="line">man 3 printf</span><br></pre></td></tr></table></figure><p>man命令信息的格式</p><table><thead><tr><th>标签</th><th>说明(<code>!</code>表示重点)</th></tr></thead><tbody><tr><td>NAME</td><td>命令说明及介绍<code>!</code></td></tr><tr><td>SYNOPSIS</td><td>命令的基本使用语法<code>!</code></td></tr><tr><td>DESCRIPTION</td><td>命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS<code>!</code></td></tr><tr><td>OPTIONS</td><td>命令参数选项说明</td></tr><tr><td>COMMANDS</td><td>执行某个软件时可附加的软件的命令</td></tr><tr><td>FILES</td><td>程序涉及的相关文件</td></tr><tr><td>EXAMPLES</td><td>命令的例子<code>!</code></td></tr><tr><td>SEE ALSO</td><td>命令相关信息的说明</td></tr><tr><td>BUGS(REPORTING BUGS)</td><td>命令对应缺陷问题的描述</td></tr><tr><td>COPYRIGHT</td><td>版权信息相关声明</td></tr><tr><td>AUTHOR</td><td>作者介绍</td></tr></tbody></table><p>man命令信息操作键</p><table><thead><tr><th>操作键</th><th>功能说明</th></tr></thead><tbody><tr><td>Page Down</td><td>向下翻页</td></tr><tr><td>Page Up</td><td>向上翻页</td></tr><tr><td>Home</td><td>跳转到第一页</td></tr><tr><td>End</td><td>跳转到最后一页</td></tr><tr><td>/</td><td>向下查找某个字符</td></tr><tr><td>?</td><td>向上查找某个字符</td></tr><tr><td>n,N</td><td>当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反</td></tr><tr><td>q</td><td>结束本次man帮助</td></tr></tbody></table><h1 id="1-2-2-使用–help参数获取命令帮助信息"><a href="#1-2-2-使用–help参数获取命令帮助信息" class="headerlink" title="1.2.2 使用–help参数获取命令帮助信息"></a>1.2.2 使用–help参数获取命令帮助信息</h1><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ ls --help</span><br></pre></td></tr></table></figure><p>  输出如下:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用法：ls [选项]... [文件]...</span><br><span class="line">列出给定文件（默认为当前目录）的信息。</span><br><span class="line">如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。</span><br><span class="line"></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line">-a, --all                     不隐藏任何以. 开始的项目</span><br><span class="line">-A, --almost-all              列出除. 及.. 以外的任何项目</span><br><span class="line">    --author                  与-l 同时使用时列出每个文件的作者</span><br><span class="line">-b, --escape                  以八进制溢出序列表示不可打印的字符</span><br></pre></td></tr></table></figure><h1 id="1-2-3-使用help命令获取命令帮助信息"><a href="#1-2-3-使用help命令获取命令帮助信息" class="headerlink" title="1.2.3 使用help命令获取命令帮助信息"></a>1.2.3 使用help命令获取命令帮助信息</h1><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ help cd</span><br></pre></td></tr></table></figure><p>  输出如下:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd: cd [-L|[-P [-e]] [-@]] [目录]</span><br><span class="line">  改变 shell 工作目录。</span><br><span class="line">  </span><br><span class="line">  改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME</span><br><span class="line">  的值。</span><br><span class="line">  </span><br><span class="line">  变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。</span><br><span class="line">  一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH</span><br><span class="line">  不会用上变量。</span><br><span class="line">  </span><br><span class="line">  如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个</span><br><span class="line">  变量名。如果该变量有值，则它的值被当作 DIR 目录。</span><br></pre></td></tr></table></figure><h1 id="1-2-4-使用info获取帮助信息"><a href="#1-2-4-使用info获取帮助信息" class="headerlink" title="1.2.4 使用info获取帮助信息"></a>1.2.4 使用info获取帮助信息</h1><p>  例子:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ info cd</span><br></pre></td></tr></table></figure><p>  即可打开cd的文档信息，操作跟man的使用方式相似。</p><h1 id="1-2-5-从互联网搜索获取命令帮助信息"><a href="#1-2-5-从互联网搜索获取命令帮助信息" class="headerlink" title="1.2.5 从互联网搜索获取命令帮助信息"></a>1.2.5 从互联网搜索获取命令帮助信息</h1><p>  <a href="https://www.google.com" target="_blank" rel="noopener">Google</a><br>  <a href="https://www.bing.com" target="_blank" rel="noopener">Bing</a><br>  <a href="https://www.github.com" target="_blank" rel="noopener">Github</a><br>  <a href="https://stackoverflow.com" target="_blank" rel="noopener">StackOverFlow</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Linux命令行简介-0</title>
    <link href="https://evanmeek.github.io/2019/06/15/Linux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-0/"/>
    <id>https://evanmeek.github.io/2019/06/15/Linux-Linux命令行简介-0/</id>
    <published>2019-06-15T08:35:38.000Z</published>
    <updated>2019-06-20T10:33:23.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-Linux命令行概述"><a href="#1-1-Linux命令行概述" class="headerlink" title="1.1 Linux命令行概述"></a>1.1 Linux命令行概述</h1><h2 id="1-1-1-Linux命令行的作用与意义"><a href="#1-1-1-Linux命令行的作用与意义" class="headerlink" title="1.1.1 Linux命令行的作用与意义"></a>1.1.1 Linux命令行的作用与意义</h2><p>  Linux命令行相比图形界面操作的优点:</p><ul><li><p>快速</p></li><li><p>批量</p></li><li><p>自动化</p></li><li><p>智能化管理</p></li></ul><h2 id="1-1-2-Linux命令行介绍"><a href="#1-1-2-Linux命令行介绍" class="headerlink" title="1.1.2 Linux命令行介绍"></a>1.1.2 Linux命令行介绍</h2><p>  大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图:</p><p>  <img src="/2019/06/15/Linux-Linux命令行简介-0/1.1.2-0" alt="命令行图"></p><h2 id="1-1-3-Linux命令行的开启及退出"><a href="#1-1-3-Linux命令行的开启及退出" class="headerlink" title="1.1.3 Linux命令行的开启及退出"></a>1.1.3 Linux命令行的开启及退出</h2><p>  主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user login:_</span><br><span class="line">password:_</span><br></pre></td></tr></table></figure><p>  等待你输入用户名密码，密码输入时是不会显示的。</p><p>  使用<code>exit</code>,<code>logout</code>或者<code>Ctrl+d</code>快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。</p><h2 id="1-1-4-Linux命令行提示符介绍"><a href="#1-1-4-Linux命令行提示符介绍" class="headerlink" title="1.1.4 Linux命令行提示符介绍"></a>1.1.4 Linux命令行提示符介绍</h2><p>  Linux命令提示符分为两种，分别是:</p><ul><li><code>$</code>普通用户</li><li><p><code>#</code>超级管理员(root)</p><p>例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$:_</span><br><span class="line">[root@EvanLinux ~]#:_</span><br></pre></td></tr></table></figure><p>其中@前面的为当前登录的<code>用户名(username)</code>,@后面的为<code>主机名(hostname)</code>，主机名后面的<code>~</code>为路径，代表了<code>home目录</code>，而<code>$</code>或<code>#</code>分别代表了用户的是超级管理员还是普通用户。</p><blockquote><p>超级管理员从此以后本系列都以<code>root</code>代表。</p></blockquote><p>root与普通用户的区别：</p></li><li><p>root</p><blockquote><p>拥有管理整个系统的权限。</p></blockquote></li><li><p>普通用户</p><blockquote><p>权限较少，通常只有查看系统文件的权限，以及管理自身<code>home</code>目录下所有文件的权限。</p></blockquote><p>查看当前登录的用户名:使用<code>whoami</code>查询<br>查看主机名:使用<code>hostname</code>查询</p><p>额外技巧: Linux命令提示符由<code>PS1</code>环境变量控制，通过修改<code>PS1</code>环境变量，可以让提示符发生变化，例子如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek@EvanLinux ~]$ set|grep PS1</span><br><span class="line">PS1='[\u@\h \W]\$'</span><br></pre></td></tr></table></figure></li></ul><p>  <code>PS1</code>有特殊的变量可供选择，我们可以设置全局配置文件<code>/etc/bashrc</code>或/etc/profile`进行按需配置。</p><h2 id="1-1-5-Linux命令行常用快捷键"><a href="#1-1-5-Linux命令行常用快捷键" class="headerlink" title="1.1.5 Linux命令行常用快捷键"></a>1.1.5 Linux命令行常用快捷键</h2><p>  企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: <code>SecureCRT</code>和<code>XShell</code>,以下快捷键可在此两款软件中使用。</p><p>  记住常用的快捷键有利于提高效率，常用快捷键由<code>!</code>标注</p><table><thead><tr><th>快捷键</th><th>功能说明(<code>!</code>为常用)</th></tr></thead><tbody><tr><td>最有用的快捷键</td><td></td></tr><tr><td>tab</td><td>命令或路径的补全键，Linux最有用的快捷键<code>!</code></td></tr><tr><td>移动光标快捷键</td><td></td></tr><tr><td>Ctrl+a</td><td>移动光标至行首<code>!</code></td></tr><tr><td>Ctrl+e</td><td>移动光标至行尾<code>!</code></td></tr><tr><td>Ctrl+f</td><td>光标向右移动一个字符(等价与方向键右键)</td></tr><tr><td>Ctrl+b</td><td>光标向左移动一个字符(同上)</td></tr><tr><td>剪切、粘贴、清楚快捷键</td><td></td></tr><tr><td>Ctrl+Insert</td><td>复制命令行内容<code>!</code></td></tr><tr><td>Shift+Insert</td><td>粘贴命令行内容<code>!</code></td></tr><tr><td>Ctrl+k</td><td>剪切(删除)光标处至行尾的字符<code>!</code></td></tr><tr><td>Ctrl+u</td><td>剪切(删除)光标处至行首的字符<code>!</code></td></tr><tr><td>Ctrl+w</td><td>剪切(删除)光标前一个单词<code>!</code></td></tr><tr><td>Ctrl+y</td><td>粘贴上面三个剪切(删除)的字符</td></tr><tr><td>Ctrl+c</td><td>终止终端正在执行的任务或删除整行字符<code>!</code></td></tr><tr><td>Ctrl+h</td><td>删除光标前一个字符(等同于Backspace)<code>!</code></td></tr><tr><td>重复执行命令快捷键</td><td></td></tr><tr><td>Ctrl+d</td><td>退出当前Shell命令行<code>!</code></td></tr><tr><td>Ctrl+r</td><td>搜索命令历史记录<code>!</code></td></tr><tr><td>Ctrl+g</td><td>退出搜索命令历史记录</td></tr><tr><td>控制快捷键</td></tr><tr><td>Ctrl+l</td><td>清屏(等同于clear命令)<code>!</code></td></tr><tr><td>Ctrl+s</td><td>锁定终端，使之无法输入</td></tr><tr><td>Ctrl+q</td><td>解锁锁定终端</td></tr><tr><td>Ctrl+z</td><td>暂停执行终端运行中的任务<code>!</code></td></tr><tr><td>!开头的快捷键命令</td></tr><tr><td>!!</td><td>执行上一条命令</td></tr><tr><td>!pw</td><td>执行最近一次以pw开头的命令<code>!</code></td></tr><tr><td>!pw:p</td><td>打印输出最近以pwd开头的命令，不执行</td></tr><tr><td>!num</td><td>执行历史命令列表的第num(数字)条命令<code>!</code></td></tr><tr><td>!$</td><td>上一条命令的最后一个参数，等同于<code>Esc+.</code></td></tr><tr><td>ESC相关</td></tr><tr><td>Esc+.</td><td>获取上一条命令的最后部分<code>!</code></td></tr><tr><td>Esc+b</td><td>移动到当前单词的开头</td></tr><tr><td>Esc+f</td><td>移动到当前单词的结尾</td></tr></tbody></table><h1 id="1-2-在Linux命令行下查看命令帮助"><a href="#1-2-在Linux命令行下查看命令帮助" class="headerlink" title="1.2 在Linux命令行下查看命令帮助"></a>1.2 在Linux命令行下查看命令帮助</h1><p>  man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。</p><p>  由于篇幅较大，请点击链接单独查看本章附录man命令。</p><p>  <a href="/2019/06/15/Linux-Linux命令行简介-man命令/">点击访问</a></p><h1 id="1-3-Linux关机、重启、注销命令"><a href="#1-3-Linux关机、重启、注销命令" class="headerlink" title="1.3 Linux关机、重启、注销命令"></a>1.3 Linux关机、重启、注销命令</h1><p>  关机或重启命令:<code>shutdown</code></p><table><thead><tr><th>参数选项</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>重启机器</td></tr><tr><td>-P</td><td>关闭机器电源(默认)</td></tr><tr><td>-H</td><td>暂停机器，CPU停止工作但不断电</td></tr><tr><td>-h</td><td>等效-P，除非使用了-H</td></tr><tr><td>-k</td><td>只发送关机提示,不做任何操作</td></tr><tr><td>-c</td><td>取消关机</td></tr></tbody></table><p>  例子:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 立即关机</span><br><span class="line">[evanmeek@EvanLinux ~]$ shutdown -h now</span><br><span class="line"># 立即重启 </span><br><span class="line">[evanmeek@EvanLinux ~]$ shutdonw -r now</span><br><span class="line"># 5分钟后关机</span><br><span class="line">[evanmeek@EvanLinux ~]$ shutdown -h +5</span><br><span class="line"># 1分钟后重启</span><br><span class="line">[evanmeek@EvanLinux ~]$ shutdown -r +1</span><br></pre></td></tr></table></figure><p>  重启或关机命令:<code>halt</code>/<code>poweroff</code>/<code>reboot</code></p><p>  <code>halt</code>和<code>poweroff</code>都是<code>reboot</code>的链接而已。</p><p>  <code>reboot</code>和<code>shutdown</code>都是<code>systemctl</code>的链接</p><p><strong>本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-1-Linux命令行概述&quot;&gt;&lt;a href=&quot;#1-1-Linux命令行概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 Linux命令行概述&quot;&gt;&lt;/a&gt;1.1 Linux命令行概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-1-Linux命令行的作用
      
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>fctix5安装与配置</title>
    <link href="https://evanmeek.github.io/2019/06/14/fcitx5%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://evanmeek.github.io/2019/06/14/fcitx5安装与配置/</id>
    <published>2019-06-13T18:11:41.000Z</published>
    <updated>2019-06-13T18:39:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。</p><a id="more"></a><p><img src="/2019/06/14/fcitx5安装与配置/输入.gif" alt="演示"></p><p>所需安装的软件包:</p><ul><li>fcitx5-git 输入法基础框架主程序</li><li>fcitx5-chinese-addons-git 简体中文输入的支持，云拼音</li><li>fcitx5-gtk-git gtk 程序的支持</li><li>fcitx5-qt4-git qt4 的支持</li><li>fcitx5-qt5-git qt5 的支持<br>可能还需要：</li><li>kcm-fcitx5-git 如果你用的是 KDE ，请装这个</li><li>fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎</li></ul><p>如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法:</p><p><img src="/2019/06/14/fcitx5安装与配置/kcm.png" alt="kcm"></p><p>否则将改配置文件<code>~/.config/fcitx5/profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Groups/0]</span><br><span class="line"># Group Name</span><br><span class="line">Name=Default</span><br><span class="line"># Layout</span><br><span class="line">Default Layout=us</span><br><span class="line"># Default Input Method</span><br><span class="line">DefaultIM=pinyin</span><br><span class="line"></span><br><span class="line">[Groups/0/Items/0]</span><br><span class="line"># Name</span><br><span class="line">Name=keyboard-us</span><br><span class="line"># Layout</span><br><span class="line">Layout=</span><br><span class="line"></span><br><span class="line">[Groups/0/Items/1]</span><br><span class="line"># Name</span><br><span class="line">Name=pinyin</span><br><span class="line"># Layout</span><br><span class="line">Layout=</span><br><span class="line"></span><br><span class="line">[GroupOrder]</span><br><span class="line">0=Default</span><br></pre></td></tr></table></figure><p><strong>若没有<code>fcitx5</code>这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。</strong></p><p>由于fcitx5不能自动启动，我们需要添加环境变量</p><p>将如下内容添加到<code>~/.xprofile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcitx5 &amp;</span><br></pre></td></tr></table></figure><p>然后再将如下内容添加到~/.pam_environment`，没有则创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx5</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx5</span><br></pre></td></tr></table></figure><p>KDE用户可以直接在<code>系统设置模块-自动启动</code>设置</p><p>默认的皮肤很丑，我们可以使用这个<a href="https://github.com/iovxw/fcitx5-simple-theme" target="_blank" rel="noopener">fcitx5-simple-theme</a></p><p>然后你就可以把fcitx4给删了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="fcitx5" scheme="https://evanmeek.github.io/tags/fcitx5/"/>
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-Qt模块简介</title>
    <link href="https://evanmeek.github.io/2019/06/12/Learn-Qt5-Qt%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/"/>
    <id>https://evanmeek.github.io/2019/06/12/Learn-Qt5-Qt模块简介/</id>
    <published>2019-06-12T12:30:42.000Z</published>
    <updated>2019-06-12T13:08:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Qt5分为两个大的模块，分别是<code>Qt Essentials</code>以及<code>Qt Add-Ons</code>以及一些额外的模块和工具．</p><a id="more"></a><h1 id="Qt-Essentials"><a href="#Qt-Essentials" class="headerlink" title="Qt Essentials"></a>Qt Essentials</h1><p><code>Qt Essentials</code>是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件．</p><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">简述</th></tr></thead><tbody><tr><td style="text-align:center">Qt Core</td><td style="text-align:center">其他非图形类模块所使用的核心,</td></tr><tr><td style="text-align:center">Qt GUI</td><td style="text-align:center">图形界面组件的基类，包括了OpenGL.</td></tr><tr><td style="text-align:center">Qt Multimedia</td><td style="text-align:center">音频，视频，广播和摄像头相关功能.</td></tr><tr><td style="text-align:center">Qt Network</td><td style="text-align:center">提供跨平台的网络能力．</td></tr><tr><td style="text-align:center">Qt Qml</td><td style="text-align:center">提供QML使用的C++API.</td></tr><tr><td style="text-align:center">Qt Quick</td><td style="text-align:center">允许在Qt/C++程序中嵌入 Qt Quick</td></tr><tr><td style="text-align:center">Qt SQL</td><td style="text-align:center">允许使用SQL访问数据库</td></tr><tr><td style="text-align:center">Qt Test</td><td style="text-align:center">提供Qt程序的单元测试能力｜</td></tr><tr><td style="text-align:center">Qt Webkit</td><td style="text-align:center">基于WebKit2的实现以及一套全新的QML API</td></tr></tbody></table><h1 id="Qt-Add-Ons"><a href="#Qt-Add-Ons" class="headerlink" title="Qt Add-Ons"></a>Qt Add-Ons</h1><p><code>Qt Add-Ons</code>是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人．</p><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">简述</th></tr></thead><tbody><tr><td style="text-align:center">Qt 3D</td><td style="text-align:center">提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜</td></tr><tr><td style="text-align:center">Qt Bluetooth</td><td style="text-align:center">提供用于访问蓝牙无线设备的C++和QML API.</td></tr><tr><td style="text-align:center">Qt Contacts</td><td style="text-align:center">用于访问地址薄或联系人数据库的C++和QML API.</td></tr><tr><td style="text-align:center">Qt D-Bus</td><td style="text-align:center">Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互</td></tr><tr><td style="text-align:center">Qt Graphical Effects</td><td style="text-align:center">提供一系列用于实现图像特效的类</td></tr><tr><td style="text-align:center">Qt Image Formats</td><td style="text-align:center">支持图片格式的一系列插件</td></tr><tr><td style="text-align:center">Qt JS Backend</td><td style="text-align:center">为V8 JavaScript引擎的移植，仅供QtQML模块内部使用</td></tr><tr><td style="text-align:center">Qt Location</td><td style="text-align:center">方便在Qt应用程序中使用OpenGL，保留于Qt4</td></tr><tr><td style="text-align:center">Qt Organize</td><td style="text-align:center">使用QML和C++API访问组织事件｜</td></tr><tr><td style="text-align:center">Qt Print Support</td><td style="text-align:center">提供对打印功能的支持｜</td></tr><tr><td style="text-align:center">Qt Publish and Subscribe</td><td style="text-align:center">为应用程序提供对项目值的读取，导航，订阅等功能.</td></tr><tr><td style="text-align:center">Qt Quick 1</td><td style="text-align:center">从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容</td></tr><tr><td style="text-align:center">Qt Script</td><td style="text-align:center">提供脚本化机制，为了与Qt5兼容</td></tr><tr><td style="text-align:center">Qt Script Tools</td><td style="text-align:center">为了使用Qt Script模块的应用程序提供的额外的组件</td></tr><tr><td style="text-align:center">Qt Sensors</td><td style="text-align:center">提供访问各类传感器的QML和C++接口.</td></tr><tr><td style="text-align:center">Qt Service Framework</td><td style="text-align:center">提供客户端发现其他设备的服务.</td></tr><tr><td style="text-align:center">Qt SVF</td><td style="text-align:center">提供渲染和创建SVG文件的功能．</td></tr><tr><td style="text-align:center">Qt System Info</td><td style="text-align:center">提供一套API，用于发现系统相关的信息.</td></tr><tr><td style="text-align:center">Qt Tools</td><td style="text-align:center">提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools.</td></tr><tr><td style="text-align:center">Qt Versit</td><td style="text-align:center">提供了对Versit API的支持．</td></tr><tr><td style="text-align:center">Qt Wayland</td><td style="text-align:center">仅用于Linux平台，用户替代QWS</td></tr><tr><td style="text-align:center">Qt WebKit</td><td style="text-align:center">从Qt4 一直来的基于WebKit1和QWidget的API</td></tr><tr><td style="text-align:center">Qt Widgets</td><td style="text-align:center">使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框</td></tr><tr><td style="text-align:center">Qt XML</td><td style="text-align:center">SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer</td></tr><tr><td style="text-align:center">Qt XML Patterns</td><td style="text-align:center">提供对XPath,XQuery,XSLT和XML Schema验证的支持．</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Qt5分为两个大的模块，分别是&lt;code&gt;Qt Essentials&lt;/code&gt;以及&lt;code&gt;Qt Add-Ons&lt;/code&gt;以及一些额外的模块和工具．&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://evanmeek.github.io/tags/Qt/"/>
    
      <category term="C_++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-自定义信号槽</title>
    <link href="https://evanmeek.github.io/2019/06/11/Learn-Qt5-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>https://evanmeek.github.io/2019/06/11/Learn-Qt5-自定义信号槽/</id>
    <published>2019-06-11T03:26:58.000Z</published>
    <updated>2019-06-11T06:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．</p><p>我们通过一个新闻和订阅者的例子讲解典型的观察者模式．</p><p>有一个报纸类<code>Newspaper</code>，有一个订阅者类<code>Subscriber</code>，<code>Subscriber</code>可订阅<code>Newspaper</code>，订阅后若<code>Newspaper</code>有了新内容，那么<code>Subscriber</code>则会立即得到通知．</p><p>上面这个案例的观察者是<code>Subscriber</code>，被观察者则是<code>Newspaper</code>．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者．</p><p>下面，我们将用Qt的信号槽实现上面的的案例．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//newspaper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NewsPaper(<span class="keyword">const</span> QString &amp;name) : m_name(name) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123; <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>; &#125;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  QString m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiverNewsPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>&#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"Newpaper:"</span>&lt;&lt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;newspaper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  <span class="function">NewsPaper <span class="title">paper</span><span class="params">(<span class="string">"xx与xxx结婚了!"</span>)</span></span>;</span><br><span class="line">  Reader reader;</span><br><span class="line"></span><br><span class="line">  QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader,</span><br><span class="line">                   &amp;Reader::receiverNewsPaper);</span><br><span class="line"></span><br><span class="line">  paper.send();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Newpaper:xx与xxx结婚了!</span><br></pre></td></tr></table></figure><p>我们看到<code>Reader</code>类和<code>Newspaper</code>类都继承了<code>QObject</code> 类，在Qt中，只有继承了<code>QObject</code>类的类才具有信号槽的能力．凡是<code>Object</code>类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上<code>Q_OBJECT</code>．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内．</p><p>再看<code>Newspaper</code>类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据.</p><p><code>Newspaper</code>类的<code>send()</code>函数比较简单，只有一条语句<code>emit newPaper(m_name);</code>. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出<code>newPaper()</code>信号．如果有接受者关注这个信号，　那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字<code>m_name</code>以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移．</p><p><code>Reader</code>类是接受信号的，所以我们也需要继承<code>QObject</code>，并且添加<code>Q_OBJECT</code>宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义．</p><p>main函数中，我们首先创建了<code>Newspaper</code>和<code>Reader</code>两个独享，然后使用<code>QObject::connect()</code>函数．这个然后我们调用<code>Newspaper</code>的<code>send()</code>函数．这个函数只有一个语句：发出信号．由于我们将<code>Newspaper</code>的信号和<code>Reader</code>的槽函数进行了连接，当这个信号发出时，那么将会自动调用<code>Reader</code>的槽函数．</p><p>总结自定义信号槽需要注意的事项:</p><ul><li>发送者和接收者都需要的是<code>QObject</code>的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外．</li><li>使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码；</li><li>使用emit发送信号</li><li>使用QObject::connect()函数连接信号和槽.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．&lt;/p&gt;
&lt;p&gt;我们通过一个新闻和订阅者的例子讲解典型的观察者模式
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="Qt5" scheme="https://evanmeek.github.io/tags/Qt5/"/>
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-信号槽</title>
    <link href="https://evanmeek.github.io/2019/06/10/Learn-Qt5-%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>https://evanmeek.github.io/2019/06/10/Learn-Qt5-信号槽/</id>
    <published>2019-06-10T00:49:35.000Z</published>
    <updated>2019-06-11T02:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.</p><a id="more"></a><p>信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号.</p><p>但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号．</p><p>简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发．</p><p>下面看代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">  QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit);</span><br><span class="line">  button.show();</span><br><span class="line">  <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序．</p><p>下面我们分析一下QObject::connect这个函数.</p><p>首先它拥有以下几种重载</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> QMetaMethod &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, <span class="keyword">const</span> QMetaMethod &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor);</span><br></pre></td></tr></table></figure><p>每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sender,signal,receiver,slot);</span><br></pre></td></tr></table></figure><p>connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数．</p><p>简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数．</p><p>根据这个常用的形式，我们可以依次分析connect的重载．</p><ul><li><p>第一种</p><blockquote><p>sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理．</p></blockquote></li><li><p>第二种</p><blockquote><p>sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较</p></blockquote></li><li><p>第三种</p><blockquote><p>sender仍为const Object<em>，而signal和slot则是const char</em>，这里的reveiver被省略了，它由this指针代替.</p></blockquote></li><li><p>第四种</p><blockquote><p>sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针．</p></blockquote></li><li><p>第五种</p><blockquote><p>注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式.</p></blockquote></li></ul><p>经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别．</p><p>信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="Qt5" scheme="https://evanmeek.github.io/tags/Qt5/"/>
    
  </entry>
  
  <entry>
    <title>2019年的规划</title>
    <link href="https://evanmeek.github.io/2019/06/09/2019%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92/"/>
    <id>https://evanmeek.github.io/2019/06/09/2019年的规划/</id>
    <published>2019-06-09T14:23:53.000Z</published>
    <updated>2019-06-10T00:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。</p><a id="more"></a><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>《标准C++入门与编程实践》————————————————————已读完<br>《Linux系统管理完全手册》————————————————————在读<br>《Vim实用技巧》——————————————————————————————未读<br>《计算机网络教程》———————————————————————————未读<br>《Qt5编程入门》——————————————————————————————在读</p><h1 id="想学但未学"><a href="#想学但未学" class="headerlink" title="想学但未学"></a>想学但未学</h1><p>Adobe Photoshop<br>Adobe AfterEffects<br>Adobe Primiere</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>想多拿起相机拍拍美好的世界，</p><p>想找个女朋友，</p><p>想减肥，</p><p>想写操作系统….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。&lt;/p&gt;
    
    </summary>
    
      <category term="分享" scheme="https://evanmeek.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-HelloWorld</title>
    <link href="https://evanmeek.github.io/2019/06/08/Learn-Qt5-HelloWorld/"/>
    <id>https://evanmeek.github.io/2019/06/08/Learn-Qt5-HelloWorld/</id>
    <published>2019-06-08T07:57:36.000Z</published>
    <updated>2019-06-10T00:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．</p><p>那么就让我们从Qt5的HelloWorld开始吧!</p><a id="more"></a><p>第一步先创建一个项目</p><p>可以使用快捷键 <code>Ctrl+N</code> 即可呼出创建项目的菜单</p><p><img src="/2019/06/08/Learn-Qt5-HelloWorld/newProject.gif" alt="新建项目"></p><p>创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分</p><p>HelloWorld.pro: Qt的工程文件，由qmake处理</p><p>main.cpp: 里面就是main函数</p><p>mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。</p><p>至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。</p><hr><p>现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。</p><p>修改main.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line">    label.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．&lt;/p&gt;
&lt;p&gt;那么就让我们从Qt5的HelloWorld开始吧!&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="Qt5" scheme="https://evanmeek.github.io/tags/Qt5/"/>
    
  </entry>
  
  <entry>
    <title>C++的命名空间与作用域</title>
    <link href="https://evanmeek.github.io/2019/05/30/C-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://evanmeek.github.io/2019/05/30/C-的命名空间与作用域/</id>
    <published>2019-05-30T07:42:43.000Z</published>
    <updated>2019-06-04T10:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．</p><a id="more"></a><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><strong>命名空间</strong></h1><blockquote><p>也称为名字空间，可以解决多模块同名冲突的问题</p></blockquote><h2 id="命名空间的作用"><a href="#命名空间的作用" class="headerlink" title="命名空间的作用"></a><strong>命名空间的作用</strong></h2><p>在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突．</p><p>解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间．</p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a><strong>定义命名空间</strong></h2><p>定义命名空间很简单只需要使用<code>namespace</code>关键字即可</p><p>我们可以定义一个命名空间将自己的类，函数或对象包括起来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myspace&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      Test(<span class="keyword">int</span> a):<span class="keyword">this</span>-&gt;a(a)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> myspace;</span><br><span class="line"></span><br><span class="line">  <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;t.a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与类的成员类似，这些对象，函数，类，被称为名字空间的成员．</p><h2 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a><strong>using声明</strong></h2><blockquote><p>using namespace <code>命名空间名</code>;</p></blockquote><p>在前面的内容中，已经不知不觉地使用上了名字空间，例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl.</p><h2 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a><strong>using指令</strong></h2><p>倘若我们只需要使用<code>std</code>命名空间中的<code>cout</code>和<code>endl</code>成员，那么可以通过using指令指定待使用的命名空间的成员.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点.</p><h2 id="命名空间的别名"><a href="#命名空间的别名" class="headerlink" title="命名空间的别名"></a><strong>命名空间的别名</strong></h2><p>如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myStd = <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">myStd::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;myStd::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>其中<code>myStd</code>作为<code>std</code>命名空间的别名．</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><blockquote><p>可以简称为<code>域</code>,是指对象的可见性问题</p></blockquote><p>C++目前支持3种作用域:</p><ul><li><p>局部作用域(local scope);</p></li><li><p>名字作用域(namespace scope);</p></li><li><p>类域(calss scope);</p></li></ul><h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a><strong>局部作用域</strong></h2><p>在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用．</p><p>例如，函数体，循环体都是局部作用域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error a超过了作用域，访问不到foo()函数内部的a变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error i超过了for的作用域，i是for的局部变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错.</strong></p><p>下面再看一个case语句块的作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;choose;</span><br><span class="line"><span class="keyword">switch</span>(choose)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">//error:重定义了str</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不用<code>{}</code>将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;choose;</span><br><span class="line"><span class="keyword">switch</span>(choose)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//error:重定义了str</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过加上<code>{}</code>使得给每个case块加上了不同的作用域，也就解决了重定义的问题．</p><h2 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a><strong>函数的作用域</strong></h2><p>函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问．</p><p>函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="comment">//正常访问i变量</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error 未声明i变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    foo(i/<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="局部变量的存储类型"><a href="#局部变量的存储类型" class="headerlink" title="局部变量的存储类型"></a><strong>局部变量的存储类型</strong></h1><p>你可能听说过:自动存储类型，静态存储类型，但是你听过<code>寄存器存储类型</code>么?</p><p>不同的存储类型，决定了C++编译器存储这些属性的空间和方式.</p><h2 id="自动存储类型"><a href="#自动存储类型" class="headerlink" title="自动存储类型"></a><strong>自动存储类型</strong></h2><p>在默认情况下，我们定义的变量就属于自动存储类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在foo()函数体执行完毕后<code>a</code>变量将会自动释放，我们也可以换种写法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做只不过为了显式的说明这个是个自动存储类型的变量</p><p>我们还可以使用类函数观测自动存储类型的销毁时间:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    Test(<span class="keyword">int</span> a);</span><br><span class="line"></span><br><span class="line">    ~Test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">int</span> a) : a(a) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::~Test() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建[0x7fff82f501c0]</span><br><span class="line">创建[0x7fff82f501c4]</span><br><span class="line">销毁[0x7fff82f501c4]</span><br><span class="line">销毁[0x7fff82f501c0]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>以上代码就可观测到自动存储类型变量的自动销毁过程．</p><p><strong>注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义．</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寄存器存储类型"><a href="#寄存器存储类型" class="headerlink" title="寄存器存储类型"></a><strong>寄存器存储类型</strong></h2><p>寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上<code>register</code>仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效．</p><h2 id="静态存储类型"><a href="#静态存储类型" class="headerlink" title="静态存储类型"></a><strong>静态存储类型</strong></h2><p>静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁．</p><p>请看下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a) : _a(a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t对象已销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用第一次</span></span><br><span class="line">    foo();</span><br><span class="line">    <span class="comment">//调用第二次</span></span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建[0x5645e7afa19c]</span><br><span class="line">t对象已销毁</span><br><span class="line">t对象已销毁</span><br><span class="line">销毁[0x5645e7afa19c]</span><br></pre></td></tr></table></figure><p>可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量<code>t</code>依然存在!</p><p><strong>常见用法</strong></p><p>程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i &lt;&lt; <span class="string">"次调用foo()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1次调用foo()</span><br><span class="line">第2次调用foo()</span><br><span class="line">第3次调用foo()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>今天就先写到这里，继续学习了.</p><h1 id="命名空间域"><a href="#命名空间域" class="headerlink" title="命名空间域"></a><strong>命名空间域</strong></h1><h2 id="全局域"><a href="#全局域" class="headerlink" title="全局域"></a><strong>全局域</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局作用域下的varA</span></span><br><span class="line"><span class="keyword">int</span> varA=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    varA++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> varA=<span class="number">200</span>;</span><br><span class="line">    ::varA++;</span><br><span class="line">    <span class="comment">//输出内部作用域的varA</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;varA&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出全局作用域的varA</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::varA&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo1();</span><br><span class="line">    foo2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">102</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。</p><p>我们使用域操作符”::”来显式的指定作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-1</title>
    <link href="https://evanmeek.github.io/2019/05/27/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-1/"/>
    <id>https://evanmeek.github.io/2019/05/27/常用算法-1/</id>
    <published>2019-05-27T04:14:16.000Z</published>
    <updated>2019-05-27T04:16:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.</p><a id="more"></a><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><blockquote><p>本页理解几个常用的算法</p></blockquote><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>冒泡排序是一种稳定的排序算法</strong></p><blockquote><p>稳定即是，如果相邻的元素相同，不会再去进行调换位置</p></blockquote><p>冒排的运作是(从后往前)。</p><p>我们操作数组来进行演示。</p><p>我们首先定义一个整型数组里面存储几个整型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待排序的数列</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。</p></blockquote><p><strong>每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。</strong></p><p>我们尝试先用大脑来演示排序的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//未排序时</span><br><span class="line">9 6 4 3 10 25</span><br><span class="line"></span><br><span class="line">6 9 3 4 10 25 //第一轮 调换了2次</span><br><span class="line">6 3 4 9 10 //第二轮 调换了2次</span><br><span class="line">3 4 6 9 //第三轮 调换了2次</span><br><span class="line">3 4 6 //第四轮 调换了0次</span><br><span class="line">3 4 //第五轮 调换了0次</span><br></pre></td></tr></table></figure></p><p>我们可以看到我们这组数据只需要排序三轮就可以排序成功，<strong>排序轮数是数组长度-1轮</strong>，调换次数是看数组相邻元素的大小关系，这个我们不用知道，<strong>我们只需要记住，排序轮数是数组长度-1就好。</strong></p><p>那么在代码中我们要如何将其进行调换呢？</p><p>有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。</p><blockquote><p>了解了基本思路，我们直接进行代码编写吧！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//待排序的数列</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">//临时变量，用于调换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//第一层循环，控制轮数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//第二层，控制每轮要进行排序的元素数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="comment">//如果当前元素比后一个元素大那么则调换元素值</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖</span></span><br><span class="line">                    temp = nums[j+<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//把当前元素的值覆盖后一个元素</span></span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                    <span class="comment">//再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)</span></span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。</p><p><strong>引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个if不用加，我只是让你们知道是哪些代码</span></span><br><span class="line"><span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">    <span class="comment">//当前元素的值是与后一个元素值的和</span></span><br><span class="line">    nums[j] = nums[j]+nums[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一行代码等同于 nums[j] = 9 + 6</span></span><br><span class="line">    <span class="comment">//执行完上一行代码，nums[j] = 15;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完此行代码nums[j+1] = 9</span></span><br><span class="line">    <span class="comment">//等价于 nums[j+1]= 15 - 6</span></span><br><span class="line">    nums[j+<span class="number">1</span>] = nums[j]-nums[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完此行代码nums[j] = 6</span></span><br><span class="line">    <span class="comment">//等价于 nums[j] = 15 - 9</span></span><br><span class="line">    nums[j] = nums[j] - nums[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！</p><p>下一记: <strong>选择排序算法</strong></p><hr><h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><blockquote><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。</p></blockquote><p>上面这个引用是网上随便抄的一个思路。</p><p>这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。</p><p>我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。</p><p>下面我们直接看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要排序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">//记录每轮排序时最小元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> minIndex;</span><br><span class="line">        <span class="comment">//第一层循环控制轮数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            minIndex = i;<span class="comment">//假设当前轮最小元素下标为i</span></span><br><span class="line">            <span class="comment">//内层循环要记录出当前轮最小元素的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">//比较两个相邻元素的大小</span></span><br><span class="line">                <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">//由于找到新的最小值，所以记录一下</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大</span></span><br><span class="line">                nums[minIndex] += nums[i];</span><br><span class="line">                nums[i] = nums[minIndex] - nums[i];</span><br><span class="line">                nums[minIndex] -= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历输出排序后的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。</p><p>下一节，二分查找算法</p><hr><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><blockquote><p>这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。</p></blockquote><p>二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:</p><ul><li>定义起始查找位，结束查找位</li><li>求得数组长度中间值都</li><li>如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。</li><li>如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。</li><li>如果要查找的值等于中间值，那么直接返回中间值的下标即可</li><li>如果都没找到，那么返回-1.</li></ul><p>看了这个概念，我们还得注意几点</p><p>需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。</p><p>好了，我们直接看代码吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">100</span>,<span class="number">300</span>&#125;;</span><br><span class="line">        System.out.println(binarySearch(nums,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums　要查找的数列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key　要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//起始下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结束下标</span></span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//起始查询的下标不能超过结束下标</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="comment">//中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果中间下标的值比要查找的值大</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&gt;key)&#123;</span><br><span class="line">                <span class="comment">//要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找</span></span><br><span class="line">                end = middle-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;key)&#123;</span><br><span class="line">                <span class="comment">//二分的右边开始查找</span></span><br><span class="line">                start = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果要查找的值就是二分下标的值，那么直接返回即可</span></span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有查找到那么则返回-1代表没有查找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="https://evanmeek.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何自学编程?</title>
    <link href="https://evanmeek.github.io/2019/05/23/%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    <id>https://evanmeek.github.io/2019/05/23/如何自学编程/</id>
    <published>2019-05-23T14:19:59.000Z</published>
    <updated>2019-05-24T02:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。</p><p>今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，</p><p>为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。</p><a id="more"></a><h1 id="0x0-制定目标"><a href="#0x0-制定目标" class="headerlink" title="0x0 制定目标"></a>0x0 制定目标</h1><p>这个目标最好是十分远大的，并且必须是准确的。</p><p>例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。</p><p>制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。</p><h1 id="0x1-选择方向"><a href="#0x1-选择方向" class="headerlink" title="0x1 选择方向"></a>0x1 选择方向</h1><p>你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。</p><p>当然，我这里是推荐学习C++，虽然它曾经被我的偶像<code>Linus Torvalds</code>臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种<code>hack</code>玩法。</p><h1 id="0x2-学习过程"><a href="#0x2-学习过程" class="headerlink" title="0x2 学习过程"></a>0x2 学习过程</h1><p>在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。</p><h2 id="0x21学习心态"><a href="#0x21学习心态" class="headerlink" title="0x21学习心态"></a>0x21学习心态</h2><p>我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。</p><h2 id="0x22学习方法"><a href="#0x22学习方法" class="headerlink" title="0x22学习方法"></a>0x22学习方法</h2><p><code>不要问，去调试，去反编译</code></p><p>这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。</p><p><code>多写代码，多讨论，尝试新想法</code></p><p>多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。</p><p>多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。</p><p>尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。</p><h1 id="0x3-充分利用互联网"><a href="#0x3-充分利用互联网" class="headerlink" title="0x3 充分利用互联网"></a>0x3 充分利用互联网</h1><p>虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。</p><p>不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下<code>原子弹制作从入门到精通</code>。这边推荐一个更好的利用搜索引擎的文章<a href="https://www.zhihu.com/question/23622803" target="_blank" rel="noopener">点击访问</a></p><h1 id="0x4-读书"><a href="#0x4-读书" class="headerlink" title="0x4 读书"></a>0x4 读书</h1><p>在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。</p><p>推荐书籍以后会写。</p><h1 id="0x5-推荐学习"><a href="#0x5-推荐学习" class="headerlink" title="0x5 推荐学习"></a>0x5 推荐学习</h1><p><a href="https://www.bilibili.com/video/av41559729" target="_blank" rel="noopener">C++视频教程</a></p><p><a href="http://bestcbooks.com/recommended-cpp-books/" target="_blank" rel="noopener">C++书籍</a></p><p><a href="https://www.bilibili.com/video/av24736323" target="_blank" rel="noopener">Git视频教程</a></p><h1 id="0x6-其他"><a href="#0x6-其他" class="headerlink" title="0x6 其他"></a>0x6 其他</h1><p>如果你是Windows系统，那么推荐<a href="https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F" target="_blank" rel="noopener">Visual Studio</a>作为你的编程工具。</p><p>如果你是Linux系统，那么推荐<a href="https://www.jetbrains.com/clion/download/download-thanks.html" target="_blank" rel="noopener">CLion</a>作为你的编程工具。</p><p>如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。</p><p>推荐学习资源:<a href="https://www.codedream.xin/archives/learning-material-list" target="_blank" rel="noopener">点击访问</a></p><h1 id="0x7-讨论群组"><a href="#0x7-讨论群组" class="headerlink" title="0x7 讨论群组"></a>0x7 讨论群组</h1><p><img src="/2019/05/23/如何自学编程/群组.png" alt="群组"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。&lt;/p&gt;
&lt;p&gt;今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，&lt;/p&gt;
&lt;p&gt;为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="个人感想" scheme="https://evanmeek.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人感想" scheme="https://evanmeek.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>C++读写文件</title>
    <link href="https://evanmeek.github.io/2019/05/22/C-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
    <id>https://evanmeek.github.io/2019/05/22/C-读写文件/</id>
    <published>2019-05-22T03:20:45.000Z</published>
    <updated>2019-05-23T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些简单的读写文件的操作。</p><a id="more"></a><p><strong>本篇文章使用C++<code>fstream</code>头文件提供的库函数进行读写操作</strong></p><blockquote><p>请引入#include \&lt;fstream>进行下面的操作。</p></blockquote><h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a><strong>写入</strong></h1><p>写入文件步骤如下:</p><ol><li><p>实例化ofstream对象，或者fstream对象.</p><blockquote><p>ofstream ofs;</p></blockquote></li><li><p>打开文件流</p><blockquote><p>ofs.open(const std::string &amp;<strong>s,ios_base::open</strong>mode=ios_base::out);</p></blockquote></li><li><p>写入文件</p><blockquote><p>ofs&lt;&lt;;</p></blockquote></li><li><p>关闭文件流</p><blockquote><p>ofs.close();</p></blockquote></li></ol><p><strong>注意打开文件流函数的参数分别为<code>路径</code>和<code>打开方式</code>.</strong></p><p>常用的打开方式如下:</p><table><thead><tr><th style="text-align:center">模式标识</th><th style="text-align:center">适用对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ios::int</td><td style="text-align:center">ifstream,fstream</td><td style="text-align:center">打开输入,默认用于<code>ifstream</code>和<code>fstream</code></td></tr><tr><td style="text-align:center">ios::out</td><td style="text-align:center">ofstream,fstream</td><td style="text-align:center">打开输出，默认用于<code>ofstream</code>和<code>fstream</code></td></tr><tr><td style="text-align:center">ios::trunc</td><td style="text-align:center">ofstream</td><td style="text-align:center">打开输入，默认用户<code>ofstream</code></td></tr><tr><td style="text-align:center">ios::ate</td><td style="text-align:center">ifstream</td><td style="text-align:center">打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错</td></tr><tr><td style="text-align:center">ios::app</td><td style="text-align:center">ostream,fstream</td><td style="text-align:center">打开输出，并且将数据输出至文件末尾，相当与追加</td></tr><tr><td style="text-align:center">iso::binary</td><td style="text-align:center">ifstream,ofstream,fstream</td><td style="text-align:center">以二进制的方式打开文件，进行输入或输出</td></tr></tbody></table><p>以上所有的打开方式可以通过或<code>|</code>运算符进行联合使用，例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以二进制的方式打开输出</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(path,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作</strong></p><p>好的，下面可以看例子了，我们将写入一些数据到一个文件内。</p><h2 id="以文本写入"><a href="#以文本写入" class="headerlink" title="以文本写入"></a><strong>以文本写入</strong></h2><blockquote><p>下面将读取两种不同类型的文件以作为案例进行讲解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入文件</span></span><br><span class="line"><span class="comment"> * @param path 文件路径</span></span><br><span class="line"><span class="comment"> * @param context 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(<span class="built_in">string</span> path,<span class="built_in">string</span> context)</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化写入对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//打开输出</span></span><br><span class="line">    ofs.open(path,ios::out);</span><br><span class="line">    <span class="comment">//向文件写入数据</span></span><br><span class="line">    ofs&lt;&lt;context&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//关闭输出</span></span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    writeFile(<span class="string">"./test.txt"</span>,<span class="string">"测试"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就将<code>测试</code>这个段文本信息，写入到当前目录下<code>test.txt</code>文件内了.</p><h2 id="以二进制文件写入"><a href="#以二进制文件写入" class="headerlink" title="以二进制文件写入"></a><strong>以二进制文件写入</strong></h2><p>以二进制文件方式写入，C++提供了<code>write()</code>库函数,它的函数原型是:</p><blockquote><p><code>write(const _CharT* __s, streamsize __n);</code></p></blockquote><p>其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> name[<span class="number">64</span>], <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(name); ++i)</span><br><span class="line">            <span class="keyword">this</span>-&gt;name[i] = name[i];</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;`</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入二进制文件</span></span><br><span class="line"><span class="comment"> * @param path </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFileByBinary</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建输出流对象，并且指定路径和文件打开方式</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(path, ios::out | ios::binary)</span></span>;</span><br><span class="line">    Student *student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    ofs.write((<span class="keyword">const</span> <span class="keyword">char</span> *) student, <span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line">    ofs.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> (student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    writeFileByBinary(<span class="string">"student.bin"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将类成员属性的值以二进制的方式写入进一个文件内。</p><p>最终文件内的内容人类是看不大懂的。</p><p><img src="/2019/05/22/C-读写文件/二进制文件.png" alt="二进制写"></p><p><strong>注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.</strong></p><h1 id="读取"><a href="#读取" class="headerlink" title="读取"></a><strong>读取</strong></h1><blockquote><p>下面将读取两种不同类型的文件以作为案例进行讲解。</p></blockquote><h2 id="以文本文件读取"><a href="#以文本文件读取" class="headerlink" title="以文本文件读取"></a><strong>以文本文件读取</strong></h2><p>读取有很多种方式，下面将会演示三种，分别是:</p><ul><li><p>逐行读取</p></li><li><p>逐词读取</p></li><li><p>逐字符读取</p></li></ul><hr><h3 id="逐字符读取-不推荐"><a href="#逐字符读取-不推荐" class="headerlink" title="逐字符读取(不推荐)"></a><strong>逐字符读取(不推荐)</strong></h3><p><strong>逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐字符读取</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile04</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化读取操作对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ifs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//数据存储变量</span></span><br><span class="line">    <span class="keyword">char</span> cbuffer;</span><br><span class="line">    <span class="comment">//逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.</span></span><br><span class="line">    <span class="keyword">while</span> ((cbuffer = ifs.get()) != EOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cbuffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EOF</code>代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。</p><h3 id="逐行读取-有两种方式，但都是逐行读取"><a href="#逐行读取-有两种方式，但都是逐行读取" class="headerlink" title="逐行读取(有两种方式，但都是逐行读取)"></a><strong>逐行读取(有两种方式，但都是逐行读取)</strong></h3><p>第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐行读取</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile02</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化</span></span><br><span class="line">    fstream fs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//用字符数组进行缓存</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)</span></span><br><span class="line">    <span class="keyword">while</span> (fs.getline(buffer, <span class="keyword">sizeof</span>(buffer))) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>字符数组</code>作为数据存储容器，用<code>fstream</code>对象的<code>getline()</code>函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用<code>sizeof()</code>是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。</p><p>第二种:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐行读取</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile03</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化读取操作对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ifs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//数据存储容器</span></span><br><span class="line">    <span class="built_in">string</span> buffer;</span><br><span class="line">    <span class="comment">//使用全局函数getline(输入流，可存储的容器)进行逐行读取</span></span><br><span class="line">    <span class="keyword">while</span> (getline(ifs, buffer)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数<code>getline(输入对象,数据存储容器)</code>,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。</p><h3 id="逐词读取-以空格区分"><a href="#逐词读取-以空格区分" class="headerlink" title="逐词读取(以空格区分)"></a><strong>逐词读取(以空格区分)</strong></h3><p>逐词读取，将会已空格进行区分每个词汇，再读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐词读取文件</span></span><br><span class="line"><span class="comment"> * @param path 文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile01</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化读取文件对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ifs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//判断文件是否能打开</span></span><br><span class="line">    <span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"文件打开失败!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符数组缓存</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//将读取的数据放入缓存区</span></span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buffer)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。</p><p>这种逐词读取的方式是<code>读取对象</code>通过<code>右移运算符</code>把读取的数据存入容器之中，但是是以空格区分每个词汇。</p><h2 id="以二进制的方式读取"><a href="#以二进制的方式读取" class="headerlink" title="以二进制的方式读取"></a><strong>以二进制的方式读取</strong></h2><p>前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以二进制的方式读取文件</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFileByBinary</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建输入流对象，并且指定路径和文件打开方式</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(path, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> * c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];</span><br><span class="line">    ifs.read(c, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readFileByBinary(<span class="string">"Student.smi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这里我们将<code>Student.smi</code>这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>读取文件创建<code>ifstream</code>对象,写入文件创建<code>ofstream</code>对象，<code>fstream</code>对象既可以读又可以写。</p><p>操作文件得先<code>打开文件</code></p><p>操作文件完毕得<code>关闭文件</code></p><p>二进制文件读取需要读取二进制格式的文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些简单的读写文件的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
</feed>
