<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我不会编程的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evanmeek.github.io/"/>
  <updated>2019-06-15T08:55:35.058Z</updated>
  <id>https://evanmeek.github.io/</id>
  
  <author>
    <name>EvanMeek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-Linux命令行简介-0</title>
    <link href="https://evanmeek.github.io/2019/06/15/Linux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-0/"/>
    <id>https://evanmeek.github.io/2019/06/15/Linux-Linux命令行简介-0/</id>
    <published>2019-06-15T08:35:38.000Z</published>
    <updated>2019-06-15T08:55:35.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-Linux命令行概述"><a href="#1-1-Linux命令行概述" class="headerlink" title="1.1 Linux命令行概述"></a>1.1 Linux命令行概述</h1><h2 id="1-1-1-Linux命令行的作用与意义"><a href="#1-1-1-Linux命令行的作用与意义" class="headerlink" title="1.1.1 Linux命令行的作用与意义"></a>1.1.1 Linux命令行的作用与意义</h2><p>  Linux命令行相比图形界面操作的优点:</p><ul><li><p>快速</p></li><li><p>批量</p></li><li><p>自动化</p></li><li><p>智能化管理</p></li></ul><h2 id="1-1-2-Linux命令行介绍"><a href="#1-1-2-Linux命令行介绍" class="headerlink" title="1.1.2 Linux命令行介绍"></a>1.1.2 Linux命令行介绍</h2><p>  大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图:</p><p>  <img src="/2019/06/15/Linux-Linux命令行简介-0/Linux-Linux命令行简介/1.1.2-0.png" alt="命令行图"></p><h2 id="1-1-3-Linux命令行的开启及退出"><a href="#1-1-3-Linux命令行的开启及退出" class="headerlink" title="1.1.3 Linux命令行的开启及退出"></a>1.1.3 Linux命令行的开启及退出</h2><p>  主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user login:\_</span><br><span class="line">password:\_</span><br></pre></td></tr></table></figure><p>  等待你输入用户名密码，密码输入时是不会显示的。</p><p>  使用<code>exit</code>,<code>logout</code>或者<code>Ctrl+d</code>快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。</p><h2 id="1-1-4-Linux命令行提示符介绍"><a href="#1-1-4-Linux命令行提示符介绍" class="headerlink" title="1.1.4 Linux命令行提示符介绍"></a>1.1.4 Linux命令行提示符介绍</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-1-Linux命令行概述&quot;&gt;&lt;a href=&quot;#1-1-Linux命令行概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 Linux命令行概述&quot;&gt;&lt;/a&gt;1.1 Linux命令行概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-1-Linux命令行的作用
      
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>fctix5安装与配置</title>
    <link href="https://evanmeek.github.io/2019/06/14/fcitx5%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://evanmeek.github.io/2019/06/14/fcitx5安装与配置/</id>
    <published>2019-06-13T18:11:41.000Z</published>
    <updated>2019-06-13T18:39:44.311Z</updated>
    
    <content type="html"><![CDATA[<p>某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。</p><a id="more"></a><p><img src="/2019/06/14/fcitx5安装与配置/输入.gif" alt="演示"></p><p>所需安装的软件包:</p><ul><li>fcitx5-git 输入法基础框架主程序</li><li>fcitx5-chinese-addons-git 简体中文输入的支持，云拼音</li><li>fcitx5-gtk-git gtk 程序的支持</li><li>fcitx5-qt4-git qt4 的支持</li><li>fcitx5-qt5-git qt5 的支持<br>可能还需要：</li><li>kcm-fcitx5-git 如果你用的是 KDE ，请装这个</li><li>fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎</li></ul><p>如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法:</p><p><img src="/2019/06/14/fcitx5安装与配置/kcm.png" alt="kcm"></p><p>否则将改配置文件<code>~/.config/fcitx5/profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Groups/0]</span><br><span class="line"># Group Name</span><br><span class="line">Name=Default</span><br><span class="line"># Layout</span><br><span class="line">Default Layout=us</span><br><span class="line"># Default Input Method</span><br><span class="line">DefaultIM=pinyin</span><br><span class="line"></span><br><span class="line">[Groups/0/Items/0]</span><br><span class="line"># Name</span><br><span class="line">Name=keyboard-us</span><br><span class="line"># Layout</span><br><span class="line">Layout=</span><br><span class="line"></span><br><span class="line">[Groups/0/Items/1]</span><br><span class="line"># Name</span><br><span class="line">Name=pinyin</span><br><span class="line"># Layout</span><br><span class="line">Layout=</span><br><span class="line"></span><br><span class="line">[GroupOrder]</span><br><span class="line">0=Default</span><br></pre></td></tr></table></figure><p><strong>若没有<code>fcitx5</code>这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。</strong></p><p>由于fcitx5不能自动启动，我们需要添加环境变量</p><p>将如下内容添加到<code>~/.xprofile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcitx5 &amp;</span><br></pre></td></tr></table></figure><p>然后再将如下内容添加到~/.pam_environment`，没有则创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx5</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx5</span><br></pre></td></tr></table></figure><p>KDE用户可以直接在<code>系统设置模块-自动启动</code>设置</p><p>默认的皮肤很丑，我们可以使用这个<a href="https://github.com/iovxw/fcitx5-simple-theme" target="_blank" rel="noopener">fcitx5-simple-theme</a></p><p>然后你就可以把fcitx4给删了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="fcitx5" scheme="https://evanmeek.github.io/tags/fcitx5/"/>
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-Qt模块简介</title>
    <link href="https://evanmeek.github.io/2019/06/12/Learn-Qt5-Qt%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/"/>
    <id>https://evanmeek.github.io/2019/06/12/Learn-Qt5-Qt模块简介/</id>
    <published>2019-06-12T12:30:42.000Z</published>
    <updated>2019-06-12T13:08:15.043Z</updated>
    
    <content type="html"><![CDATA[<p>Qt5分为两个大的模块，分别是<code>Qt Essentials</code>以及<code>Qt Add-Ons</code>以及一些额外的模块和工具．</p><a id="more"></a><h1 id="Qt-Essentials"><a href="#Qt-Essentials" class="headerlink" title="Qt Essentials"></a>Qt Essentials</h1><p><code>Qt Essentials</code>是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件．</p><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">简述</th></tr></thead><tbody><tr><td style="text-align:center">Qt Core</td><td style="text-align:center">其他非图形类模块所使用的核心,</td></tr><tr><td style="text-align:center">Qt GUI</td><td style="text-align:center">图形界面组件的基类，包括了OpenGL.</td></tr><tr><td style="text-align:center">Qt Multimedia</td><td style="text-align:center">音频，视频，广播和摄像头相关功能.</td></tr><tr><td style="text-align:center">Qt Network</td><td style="text-align:center">提供跨平台的网络能力．</td></tr><tr><td style="text-align:center">Qt Qml</td><td style="text-align:center">提供QML使用的C++API.</td></tr><tr><td style="text-align:center">Qt Quick</td><td style="text-align:center">允许在Qt/C++程序中嵌入 Qt Quick</td></tr><tr><td style="text-align:center">Qt SQL</td><td style="text-align:center">允许使用SQL访问数据库</td></tr><tr><td style="text-align:center">Qt Test</td><td style="text-align:center">提供Qt程序的单元测试能力｜</td></tr><tr><td style="text-align:center">Qt Webkit</td><td style="text-align:center">基于WebKit2的实现以及一套全新的QML API</td></tr></tbody></table><h1 id="Qt-Add-Ons"><a href="#Qt-Add-Ons" class="headerlink" title="Qt Add-Ons"></a>Qt Add-Ons</h1><p><code>Qt Add-Ons</code>是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人．</p><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">简述</th></tr></thead><tbody><tr><td style="text-align:center">Qt 3D</td><td style="text-align:center">提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜</td></tr><tr><td style="text-align:center">Qt Bluetooth</td><td style="text-align:center">提供用于访问蓝牙无线设备的C++和QML API.</td></tr><tr><td style="text-align:center">Qt Contacts</td><td style="text-align:center">用于访问地址薄或联系人数据库的C++和QML API.</td></tr><tr><td style="text-align:center">Qt D-Bus</td><td style="text-align:center">Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互</td></tr><tr><td style="text-align:center">Qt Graphical Effects</td><td style="text-align:center">提供一系列用于实现图像特效的类</td></tr><tr><td style="text-align:center">Qt Image Formats</td><td style="text-align:center">支持图片格式的一系列插件</td></tr><tr><td style="text-align:center">Qt JS Backend</td><td style="text-align:center">为V8 JavaScript引擎的移植，仅供QtQML模块内部使用</td></tr><tr><td style="text-align:center">Qt Location</td><td style="text-align:center">方便在Qt应用程序中使用OpenGL，保留于Qt4</td></tr><tr><td style="text-align:center">Qt Organize</td><td style="text-align:center">使用QML和C++API访问组织事件｜</td></tr><tr><td style="text-align:center">Qt Print Support</td><td style="text-align:center">提供对打印功能的支持｜</td></tr><tr><td style="text-align:center">Qt Publish and Subscribe</td><td style="text-align:center">为应用程序提供对项目值的读取，导航，订阅等功能.</td></tr><tr><td style="text-align:center">Qt Quick 1</td><td style="text-align:center">从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容</td></tr><tr><td style="text-align:center">Qt Script</td><td style="text-align:center">提供脚本化机制，为了与Qt5兼容</td></tr><tr><td style="text-align:center">Qt Script Tools</td><td style="text-align:center">为了使用Qt Script模块的应用程序提供的额外的组件</td></tr><tr><td style="text-align:center">Qt Sensors</td><td style="text-align:center">提供访问各类传感器的QML和C++接口.</td></tr><tr><td style="text-align:center">Qt Service Framework</td><td style="text-align:center">提供客户端发现其他设备的服务.</td></tr><tr><td style="text-align:center">Qt SVF</td><td style="text-align:center">提供渲染和创建SVG文件的功能．</td></tr><tr><td style="text-align:center">Qt System Info</td><td style="text-align:center">提供一套API，用于发现系统相关的信息.</td></tr><tr><td style="text-align:center">Qt Tools</td><td style="text-align:center">提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools.</td></tr><tr><td style="text-align:center">Qt Versit</td><td style="text-align:center">提供了对Versit API的支持．</td></tr><tr><td style="text-align:center">Qt Wayland</td><td style="text-align:center">仅用于Linux平台，用户替代QWS</td></tr><tr><td style="text-align:center">Qt WebKit</td><td style="text-align:center">从Qt4 一直来的基于WebKit1和QWidget的API</td></tr><tr><td style="text-align:center">Qt Widgets</td><td style="text-align:center">使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框</td></tr><tr><td style="text-align:center">Qt XML</td><td style="text-align:center">SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer</td></tr><tr><td style="text-align:center">Qt XML Patterns</td><td style="text-align:center">提供对XPath,XQuery,XSLT和XML Schema验证的支持．</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Qt5分为两个大的模块，分别是&lt;code&gt;Qt Essentials&lt;/code&gt;以及&lt;code&gt;Qt Add-Ons&lt;/code&gt;以及一些额外的模块和工具．&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://evanmeek.github.io/tags/Qt/"/>
    
      <category term="C_++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-自定义信号槽</title>
    <link href="https://evanmeek.github.io/2019/06/11/Learn-Qt5-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>https://evanmeek.github.io/2019/06/11/Learn-Qt5-自定义信号槽/</id>
    <published>2019-06-11T03:26:58.000Z</published>
    <updated>2019-06-11T06:32:00.589Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．</p><p>我们通过一个新闻和订阅者的例子讲解典型的观察者模式．</p><p>有一个报纸类<code>Newspaper</code>，有一个订阅者类<code>Subscriber</code>，<code>Subscriber</code>可订阅<code>Newspaper</code>，订阅后若<code>Newspaper</code>有了新内容，那么<code>Subscriber</code>则会立即得到通知．</p><p>上面这个案例的观察者是<code>Subscriber</code>，被观察者则是<code>Newspaper</code>．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者．</p><p>下面，我们将用Qt的信号槽实现上面的的案例．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//newspaper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NewsPaper(<span class="keyword">const</span> QString &amp;name) : m_name(name) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123; <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>; &#125;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  QString m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiverNewsPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>&#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"Newpaper:"</span>&lt;&lt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;newspaper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  <span class="function">NewsPaper <span class="title">paper</span><span class="params">(<span class="string">"xx与xxx结婚了!"</span>)</span></span>;</span><br><span class="line">  Reader reader;</span><br><span class="line"></span><br><span class="line">  QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader,</span><br><span class="line">                   &amp;Reader::receiverNewsPaper);</span><br><span class="line"></span><br><span class="line">  paper.send();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Newpaper:xx与xxx结婚了!</span><br></pre></td></tr></table></figure><p>我们看到<code>Reader</code>类和<code>Newspaper</code>类都继承了<code>QObject</code> 类，在Qt中，只有继承了<code>QObject</code>类的类才具有信号槽的能力．凡是<code>Object</code>类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上<code>Q_OBJECT</code>．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内．</p><p>再看<code>Newspaper</code>类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据.</p><p><code>Newspaper</code>类的<code>send()</code>函数比较简单，只有一条语句<code>emit newPaper(m_name);</code>. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出<code>newPaper()</code>信号．如果有接受者关注这个信号，　那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字<code>m_name</code>以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移．</p><p><code>Reader</code>类是接受信号的，所以我们也需要继承<code>QObject</code>，并且添加<code>Q_OBJECT</code>宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义．</p><p>main函数中，我们首先创建了<code>Newspaper</code>和<code>Reader</code>两个独享，然后使用<code>QObject::connect()</code>函数．这个然后我们调用<code>Newspaper</code>的<code>send()</code>函数．这个函数只有一个语句：发出信号．由于我们将<code>Newspaper</code>的信号和<code>Reader</code>的槽函数进行了连接，当这个信号发出时，那么将会自动调用<code>Reader</code>的槽函数．</p><p>总结自定义信号槽需要注意的事项:</p><ul><li>发送者和接收者都需要的是<code>QObject</code>的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外．</li><li>使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码；</li><li>使用emit发送信号</li><li>使用QObject::connect()函数连接信号和槽.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．&lt;/p&gt;
&lt;p&gt;我们通过一个新闻和订阅者的例子讲解典型的观察者模式
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="Qt5" scheme="https://evanmeek.github.io/tags/Qt5/"/>
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-信号槽</title>
    <link href="https://evanmeek.github.io/2019/06/10/Learn-Qt5-%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>https://evanmeek.github.io/2019/06/10/Learn-Qt5-信号槽/</id>
    <published>2019-06-10T00:49:35.000Z</published>
    <updated>2019-06-11T02:22:48.390Z</updated>
    
    <content type="html"><![CDATA[<p>信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.</p><a id="more"></a><p>信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号.</p><p>但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号．</p><p>简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发．</p><p>下面看代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">  QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit);</span><br><span class="line">  button.show();</span><br><span class="line">  <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序．</p><p>下面我们分析一下QObject::connect这个函数.</p><p>首先它拥有以下几种重载</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> QMetaMethod &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, <span class="keyword">const</span> QMetaMethod &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor);</span><br></pre></td></tr></table></figure><p>每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sender,signal,receiver,slot);</span><br></pre></td></tr></table></figure><p>connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数．</p><p>简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数．</p><p>根据这个常用的形式，我们可以依次分析connect的重载．</p><ul><li><p>第一种</p><blockquote><p>sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理．</p></blockquote></li><li><p>第二种</p><blockquote><p>sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较</p></blockquote></li><li><p>第三种</p><blockquote><p>sender仍为const Object<em>，而signal和slot则是const char</em>，这里的reveiver被省略了，它由this指针代替.</p></blockquote></li><li><p>第四种</p><blockquote><p>sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针．</p></blockquote></li><li><p>第五种</p><blockquote><p>注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式.</p></blockquote></li></ul><p>经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别．</p><p>信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="Qt5" scheme="https://evanmeek.github.io/tags/Qt5/"/>
    
  </entry>
  
  <entry>
    <title>2019年的规划</title>
    <link href="https://evanmeek.github.io/2019/06/09/2019%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92/"/>
    <id>https://evanmeek.github.io/2019/06/09/2019年的规划/</id>
    <published>2019-06-09T14:23:53.000Z</published>
    <updated>2019-06-10T00:24:44.493Z</updated>
    
    <content type="html"><![CDATA[<p>2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。</p><a id="more"></a><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>《标准C++入门与编程实践》————————————————————已读完<br>《Linux系统管理完全手册》————————————————————在读<br>《Vim实用技巧》——————————————————————————————未读<br>《计算机网络教程》———————————————————————————未读<br>《Qt5编程入门》——————————————————————————————在读</p><h1 id="想学但未学"><a href="#想学但未学" class="headerlink" title="想学但未学"></a>想学但未学</h1><p>Adobe Photoshop<br>Adobe AfterEffects<br>Adobe Primiere</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>想多拿起相机拍拍美好的世界，</p><p>想找个女朋友，</p><p>想减肥，</p><p>想写操作系统….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。&lt;/p&gt;
    
    </summary>
    
      <category term="分享" scheme="https://evanmeek.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Learn-Qt5-HelloWorld</title>
    <link href="https://evanmeek.github.io/2019/06/08/Learn-Qt5-HelloWorld/"/>
    <id>https://evanmeek.github.io/2019/06/08/Learn-Qt5-HelloWorld/</id>
    <published>2019-06-08T07:57:36.000Z</published>
    <updated>2019-06-10T00:24:44.493Z</updated>
    
    <content type="html"><![CDATA[<p>当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．</p><p>那么就让我们从Qt5的HelloWorld开始吧!</p><a id="more"></a><p>第一步先创建一个项目</p><p>可以使用快捷键 <code>Ctrl+N</code> 即可呼出创建项目的菜单</p><p><img src="/2019/06/08/Learn-Qt5-HelloWorld/newProject.gif" alt="新建项目"></p><p>创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分</p><p>HelloWorld.pro: Qt的工程文件，由qmake处理</p><p>main.cpp: 里面就是main函数</p><p>mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。</p><p>至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。</p><hr><p>现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。</p><p>修改main.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line">    label.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．&lt;/p&gt;
&lt;p&gt;那么就让我们从Qt5的HelloWorld开始吧!&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="Qt5" scheme="https://evanmeek.github.io/tags/Qt5/"/>
    
  </entry>
  
  <entry>
    <title>C++的命名空间与作用域</title>
    <link href="https://evanmeek.github.io/2019/05/30/C-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://evanmeek.github.io/2019/05/30/C-的命名空间与作用域/</id>
    <published>2019-05-30T07:42:43.000Z</published>
    <updated>2019-06-04T10:12:54.854Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．</p><a id="more"></a><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><strong>命名空间</strong></h1><blockquote><p>也称为名字空间，可以解决多模块同名冲突的问题</p></blockquote><h2 id="命名空间的作用"><a href="#命名空间的作用" class="headerlink" title="命名空间的作用"></a><strong>命名空间的作用</strong></h2><p>在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突．</p><p>解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间．</p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a><strong>定义命名空间</strong></h2><p>定义命名空间很简单只需要使用<code>namespace</code>关键字即可</p><p>我们可以定义一个命名空间将自己的类，函数或对象包括起来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myspace&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      Test(<span class="keyword">int</span> a):<span class="keyword">this</span>-&gt;a(a)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> myspace;</span><br><span class="line"></span><br><span class="line">  <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;t.a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与类的成员类似，这些对象，函数，类，被称为名字空间的成员．</p><h2 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a><strong>using声明</strong></h2><blockquote><p>using namespace <code>命名空间名</code>;</p></blockquote><p>在前面的内容中，已经不知不觉地使用上了名字空间，例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl.</p><h2 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a><strong>using指令</strong></h2><p>倘若我们只需要使用<code>std</code>命名空间中的<code>cout</code>和<code>endl</code>成员，那么可以通过using指令指定待使用的命名空间的成员.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点.</p><h2 id="命名空间的别名"><a href="#命名空间的别名" class="headerlink" title="命名空间的别名"></a><strong>命名空间的别名</strong></h2><p>如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myStd = <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">myStd::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;myStd::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>其中<code>myStd</code>作为<code>std</code>命名空间的别名．</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><blockquote><p>可以简称为<code>域</code>,是指对象的可见性问题</p></blockquote><p>C++目前支持3种作用域:</p><ul><li><p>局部作用域(local scope);</p></li><li><p>名字作用域(namespace scope);</p></li><li><p>类域(calss scope);</p></li></ul><h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a><strong>局部作用域</strong></h2><p>在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用．</p><p>例如，函数体，循环体都是局部作用域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error a超过了作用域，访问不到foo()函数内部的a变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error i超过了for的作用域，i是for的局部变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错.</strong></p><p>下面再看一个case语句块的作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;choose;</span><br><span class="line"><span class="keyword">switch</span>(choose)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">//error:重定义了str</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不用<code>{}</code>将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;choose;</span><br><span class="line"><span class="keyword">switch</span>(choose)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//error:重定义了str</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过加上<code>{}</code>使得给每个case块加上了不同的作用域，也就解决了重定义的问题．</p><h2 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a><strong>函数的作用域</strong></h2><p>函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问．</p><p>函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="comment">//正常访问i变量</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error 未声明i变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    foo(i/<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="局部变量的存储类型"><a href="#局部变量的存储类型" class="headerlink" title="局部变量的存储类型"></a><strong>局部变量的存储类型</strong></h1><p>你可能听说过:自动存储类型，静态存储类型，但是你听过<code>寄存器存储类型</code>么?</p><p>不同的存储类型，决定了C++编译器存储这些属性的空间和方式.</p><h2 id="自动存储类型"><a href="#自动存储类型" class="headerlink" title="自动存储类型"></a><strong>自动存储类型</strong></h2><p>在默认情况下，我们定义的变量就属于自动存储类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在foo()函数体执行完毕后<code>a</code>变量将会自动释放，我们也可以换种写法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做只不过为了显式的说明这个是个自动存储类型的变量</p><p>我们还可以使用类函数观测自动存储类型的销毁时间:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    Test(<span class="keyword">int</span> a);</span><br><span class="line"></span><br><span class="line">    ~Test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">int</span> a) : a(a) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::~Test() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建[0x7fff82f501c0]</span><br><span class="line">创建[0x7fff82f501c4]</span><br><span class="line">销毁[0x7fff82f501c4]</span><br><span class="line">销毁[0x7fff82f501c0]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>以上代码就可观测到自动存储类型变量的自动销毁过程．</p><p><strong>注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义．</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寄存器存储类型"><a href="#寄存器存储类型" class="headerlink" title="寄存器存储类型"></a><strong>寄存器存储类型</strong></h2><p>寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上<code>register</code>仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效．</p><h2 id="静态存储类型"><a href="#静态存储类型" class="headerlink" title="静态存储类型"></a><strong>静态存储类型</strong></h2><p>静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁．</p><p>请看下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a) : _a(a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t对象已销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用第一次</span></span><br><span class="line">    foo();</span><br><span class="line">    <span class="comment">//调用第二次</span></span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建[0x5645e7afa19c]</span><br><span class="line">t对象已销毁</span><br><span class="line">t对象已销毁</span><br><span class="line">销毁[0x5645e7afa19c]</span><br></pre></td></tr></table></figure><p>可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量<code>t</code>依然存在!</p><p><strong>常见用法</strong></p><p>程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i &lt;&lt; <span class="string">"次调用foo()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1次调用foo()</span><br><span class="line">第2次调用foo()</span><br><span class="line">第3次调用foo()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>今天就先写到这里，继续学习了.</p><h1 id="命名空间域"><a href="#命名空间域" class="headerlink" title="命名空间域"></a><strong>命名空间域</strong></h1><h2 id="全局域"><a href="#全局域" class="headerlink" title="全局域"></a><strong>全局域</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局作用域下的varA</span></span><br><span class="line"><span class="keyword">int</span> varA=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    varA++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> varA=<span class="number">200</span>;</span><br><span class="line">    ::varA++;</span><br><span class="line">    <span class="comment">//输出内部作用域的varA</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;varA&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出全局作用域的varA</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::varA&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo1();</span><br><span class="line">    foo2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">102</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。</p><p>我们使用域操作符”::”来显式的指定作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-1</title>
    <link href="https://evanmeek.github.io/2019/05/27/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-1/"/>
    <id>https://evanmeek.github.io/2019/05/27/常用算法-1/</id>
    <published>2019-05-27T04:14:16.000Z</published>
    <updated>2019-05-27T04:16:09.046Z</updated>
    
    <content type="html"><![CDATA[<p>这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.</p><a id="more"></a><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><blockquote><p>本页理解几个常用的算法</p></blockquote><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>冒泡排序是一种稳定的排序算法</strong></p><blockquote><p>稳定即是，如果相邻的元素相同，不会再去进行调换位置</p></blockquote><p>冒排的运作是(从后往前)。</p><p>我们操作数组来进行演示。</p><p>我们首先定义一个整型数组里面存储几个整型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待排序的数列</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。</p></blockquote><p><strong>每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。</strong></p><p>我们尝试先用大脑来演示排序的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//未排序时</span><br><span class="line">9 6 4 3 10 25</span><br><span class="line"></span><br><span class="line">6 9 3 4 10 25 //第一轮 调换了2次</span><br><span class="line">6 3 4 9 10 //第二轮 调换了2次</span><br><span class="line">3 4 6 9 //第三轮 调换了2次</span><br><span class="line">3 4 6 //第四轮 调换了0次</span><br><span class="line">3 4 //第五轮 调换了0次</span><br></pre></td></tr></table></figure></p><p>我们可以看到我们这组数据只需要排序三轮就可以排序成功，<strong>排序轮数是数组长度-1轮</strong>，调换次数是看数组相邻元素的大小关系，这个我们不用知道，<strong>我们只需要记住，排序轮数是数组长度-1就好。</strong></p><p>那么在代码中我们要如何将其进行调换呢？</p><p>有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。</p><blockquote><p>了解了基本思路，我们直接进行代码编写吧！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//待排序的数列</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">//临时变量，用于调换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//第一层循环，控制轮数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//第二层，控制每轮要进行排序的元素数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="comment">//如果当前元素比后一个元素大那么则调换元素值</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖</span></span><br><span class="line">                    temp = nums[j+<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//把当前元素的值覆盖后一个元素</span></span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                    <span class="comment">//再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)</span></span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。</p><p><strong>引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个if不用加，我只是让你们知道是哪些代码</span></span><br><span class="line"><span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">    <span class="comment">//当前元素的值是与后一个元素值的和</span></span><br><span class="line">    nums[j] = nums[j]+nums[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一行代码等同于 nums[j] = 9 + 6</span></span><br><span class="line">    <span class="comment">//执行完上一行代码，nums[j] = 15;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完此行代码nums[j+1] = 9</span></span><br><span class="line">    <span class="comment">//等价于 nums[j+1]= 15 - 6</span></span><br><span class="line">    nums[j+<span class="number">1</span>] = nums[j]-nums[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完此行代码nums[j] = 6</span></span><br><span class="line">    <span class="comment">//等价于 nums[j] = 15 - 9</span></span><br><span class="line">    nums[j] = nums[j] - nums[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！</p><p>下一记: <strong>选择排序算法</strong></p><hr><h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><blockquote><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。</p></blockquote><p>上面这个引用是网上随便抄的一个思路。</p><p>这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。</p><p>我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。</p><p>下面我们直接看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要排序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">//记录每轮排序时最小元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> minIndex;</span><br><span class="line">        <span class="comment">//第一层循环控制轮数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            minIndex = i;<span class="comment">//假设当前轮最小元素下标为i</span></span><br><span class="line">            <span class="comment">//内层循环要记录出当前轮最小元素的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">//比较两个相邻元素的大小</span></span><br><span class="line">                <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">//由于找到新的最小值，所以记录一下</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大</span></span><br><span class="line">                nums[minIndex] += nums[i];</span><br><span class="line">                nums[i] = nums[minIndex] - nums[i];</span><br><span class="line">                nums[minIndex] -= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历输出排序后的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。</p><p>下一节，二分查找算法</p><hr><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><blockquote><p>这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。</p></blockquote><p>二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:</p><ul><li>定义起始查找位，结束查找位</li><li>求得数组长度中间值都</li><li>如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。</li><li>如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。</li><li>如果要查找的值等于中间值，那么直接返回中间值的下标即可</li><li>如果都没找到，那么返回-1.</li></ul><p>看了这个概念，我们还得注意几点</p><p>需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。</p><p>好了，我们直接看代码吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">100</span>,<span class="number">300</span>&#125;;</span><br><span class="line">        System.out.println(binarySearch(nums,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums　要查找的数列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key　要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//起始下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结束下标</span></span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//起始查询的下标不能超过结束下标</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="comment">//中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果中间下标的值比要查找的值大</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&gt;key)&#123;</span><br><span class="line">                <span class="comment">//要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找</span></span><br><span class="line">                end = middle-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;key)&#123;</span><br><span class="line">                <span class="comment">//二分的右边开始查找</span></span><br><span class="line">                start = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果要查找的值就是二分下标的值，那么直接返回即可</span></span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有查找到那么则返回-1代表没有查找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="https://evanmeek.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何自学编程?</title>
    <link href="https://evanmeek.github.io/2019/05/23/%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    <id>https://evanmeek.github.io/2019/05/23/如何自学编程/</id>
    <published>2019-05-23T14:19:59.000Z</published>
    <updated>2019-05-24T02:09:01.656Z</updated>
    
    <content type="html"><![CDATA[<p>前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。</p><p>今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，</p><p>为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。</p><a id="more"></a><h1 id="0x0-制定目标"><a href="#0x0-制定目标" class="headerlink" title="0x0 制定目标"></a>0x0 制定目标</h1><p>这个目标最好是十分远大的，并且必须是准确的。</p><p>例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。</p><p>制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。</p><h1 id="0x1-选择方向"><a href="#0x1-选择方向" class="headerlink" title="0x1 选择方向"></a>0x1 选择方向</h1><p>你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。</p><p>当然，我这里是推荐学习C++，虽然它曾经被我的偶像<code>Linus Torvalds</code>臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种<code>hack</code>玩法。</p><h1 id="0x2-学习过程"><a href="#0x2-学习过程" class="headerlink" title="0x2 学习过程"></a>0x2 学习过程</h1><p>在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。</p><h2 id="0x21学习心态"><a href="#0x21学习心态" class="headerlink" title="0x21学习心态"></a>0x21学习心态</h2><p>我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。</p><h2 id="0x22学习方法"><a href="#0x22学习方法" class="headerlink" title="0x22学习方法"></a>0x22学习方法</h2><p><code>不要问，去调试，去反编译</code></p><p>这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。</p><p><code>多写代码，多讨论，尝试新想法</code></p><p>多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。</p><p>多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。</p><p>尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。</p><h1 id="0x3-充分利用互联网"><a href="#0x3-充分利用互联网" class="headerlink" title="0x3 充分利用互联网"></a>0x3 充分利用互联网</h1><p>虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。</p><p>不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下<code>原子弹制作从入门到精通</code>。这边推荐一个更好的利用搜索引擎的文章<a href="https://www.zhihu.com/question/23622803" target="_blank" rel="noopener">点击访问</a></p><h1 id="0x4-读书"><a href="#0x4-读书" class="headerlink" title="0x4 读书"></a>0x4 读书</h1><p>在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。</p><p>推荐书籍以后会写。</p><h1 id="0x5-推荐学习"><a href="#0x5-推荐学习" class="headerlink" title="0x5 推荐学习"></a>0x5 推荐学习</h1><p><a href="https://www.bilibili.com/video/av41559729" target="_blank" rel="noopener">C++视频教程</a></p><p><a href="http://bestcbooks.com/recommended-cpp-books/" target="_blank" rel="noopener">C++书籍</a></p><p><a href="https://www.bilibili.com/video/av24736323" target="_blank" rel="noopener">Git视频教程</a></p><h1 id="0x6-其他"><a href="#0x6-其他" class="headerlink" title="0x6 其他"></a>0x6 其他</h1><p>如果你是Windows系统，那么推荐<a href="https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F" target="_blank" rel="noopener">Visual Studio</a>作为你的编程工具。</p><p>如果你是Linux系统，那么推荐<a href="https://www.jetbrains.com/clion/download/download-thanks.html" target="_blank" rel="noopener">CLion</a>作为你的编程工具。</p><p>如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。</p><p>推荐学习资源:<a href="https://www.codedream.xin/archives/learning-material-list" target="_blank" rel="noopener">点击访问</a></p><h1 id="0x7-讨论群组"><a href="#0x7-讨论群组" class="headerlink" title="0x7 讨论群组"></a>0x7 讨论群组</h1><p><img src="/2019/05/23/如何自学编程/群组.png" alt="群组"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。&lt;/p&gt;
&lt;p&gt;今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，&lt;/p&gt;
&lt;p&gt;为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="个人感想" scheme="https://evanmeek.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人感想" scheme="https://evanmeek.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>C++读写文件</title>
    <link href="https://evanmeek.github.io/2019/05/22/C-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
    <id>https://evanmeek.github.io/2019/05/22/C-读写文件/</id>
    <published>2019-05-22T03:20:45.000Z</published>
    <updated>2019-05-23T06:01:22.978Z</updated>
    
    <content type="html"><![CDATA[<p>一些简单的读写文件的操作。</p><a id="more"></a><p><strong>本篇文章使用C++<code>fstream</code>头文件提供的库函数进行读写操作</strong></p><blockquote><p>请引入#include \&lt;fstream>进行下面的操作。</p></blockquote><h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a><strong>写入</strong></h1><p>写入文件步骤如下:</p><ol><li><p>实例化ofstream对象，或者fstream对象.</p><blockquote><p>ofstream ofs;</p></blockquote></li><li><p>打开文件流</p><blockquote><p>ofs.open(const std::string &amp;<strong>s,ios_base::open</strong>mode=ios_base::out);</p></blockquote></li><li><p>写入文件</p><blockquote><p>ofs&lt;&lt;;</p></blockquote></li><li><p>关闭文件流</p><blockquote><p>ofs.close();</p></blockquote></li></ol><p><strong>注意打开文件流函数的参数分别为<code>路径</code>和<code>打开方式</code>.</strong></p><p>常用的打开方式如下:</p><table><thead><tr><th style="text-align:center">模式标识</th><th style="text-align:center">适用对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ios::int</td><td style="text-align:center">ifstream,fstream</td><td style="text-align:center">打开输入,默认用于<code>ifstream</code>和<code>fstream</code></td></tr><tr><td style="text-align:center">ios::out</td><td style="text-align:center">ofstream,fstream</td><td style="text-align:center">打开输出，默认用于<code>ofstream</code>和<code>fstream</code></td></tr><tr><td style="text-align:center">ios::trunc</td><td style="text-align:center">ofstream</td><td style="text-align:center">打开输入，默认用户<code>ofstream</code></td></tr><tr><td style="text-align:center">ios::ate</td><td style="text-align:center">ifstream</td><td style="text-align:center">打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错</td></tr><tr><td style="text-align:center">ios::app</td><td style="text-align:center">ostream,fstream</td><td style="text-align:center">打开输出，并且将数据输出至文件末尾，相当与追加</td></tr><tr><td style="text-align:center">iso::binary</td><td style="text-align:center">ifstream,ofstream,fstream</td><td style="text-align:center">以二进制的方式打开文件，进行输入或输出</td></tr></tbody></table><p>以上所有的打开方式可以通过或<code>|</code>运算符进行联合使用，例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以二进制的方式打开输出</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(path,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作</strong></p><p>好的，下面可以看例子了，我们将写入一些数据到一个文件内。</p><h2 id="以文本写入"><a href="#以文本写入" class="headerlink" title="以文本写入"></a><strong>以文本写入</strong></h2><blockquote><p>下面将读取两种不同类型的文件以作为案例进行讲解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入文件</span></span><br><span class="line"><span class="comment"> * @param path 文件路径</span></span><br><span class="line"><span class="comment"> * @param context 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(<span class="built_in">string</span> path,<span class="built_in">string</span> context)</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化写入对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//打开输出</span></span><br><span class="line">    ofs.open(path,ios::out);</span><br><span class="line">    <span class="comment">//向文件写入数据</span></span><br><span class="line">    ofs&lt;&lt;context&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//关闭输出</span></span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    writeFile(<span class="string">"./test.txt"</span>,<span class="string">"测试"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就将<code>测试</code>这个段文本信息，写入到当前目录下<code>test.txt</code>文件内了.</p><h2 id="以二进制文件写入"><a href="#以二进制文件写入" class="headerlink" title="以二进制文件写入"></a><strong>以二进制文件写入</strong></h2><p>以二进制文件方式写入，C++提供了<code>write()</code>库函数,它的函数原型是:</p><blockquote><p><code>write(const _CharT* __s, streamsize __n);</code></p></blockquote><p>其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> name[<span class="number">64</span>], <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(name); ++i)</span><br><span class="line">            <span class="keyword">this</span>-&gt;name[i] = name[i];</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;`</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入二进制文件</span></span><br><span class="line"><span class="comment"> * @param path </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFileByBinary</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建输出流对象，并且指定路径和文件打开方式</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(path, ios::out | ios::binary)</span></span>;</span><br><span class="line">    Student *student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    ofs.write((<span class="keyword">const</span> <span class="keyword">char</span> *) student, <span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line">    ofs.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> (student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    writeFileByBinary(<span class="string">"student.bin"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将类成员属性的值以二进制的方式写入进一个文件内。</p><p>最终文件内的内容人类是看不大懂的。</p><p><img src="/2019/05/22/C-读写文件/二进制文件.png" alt="二进制写"></p><p><strong>注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.</strong></p><h1 id="读取"><a href="#读取" class="headerlink" title="读取"></a><strong>读取</strong></h1><blockquote><p>下面将读取两种不同类型的文件以作为案例进行讲解。</p></blockquote><h2 id="以文本文件读取"><a href="#以文本文件读取" class="headerlink" title="以文本文件读取"></a><strong>以文本文件读取</strong></h2><p>读取有很多种方式，下面将会演示三种，分别是:</p><ul><li><p>逐行读取</p></li><li><p>逐词读取</p></li><li><p>逐字符读取</p></li></ul><hr><h3 id="逐字符读取-不推荐"><a href="#逐字符读取-不推荐" class="headerlink" title="逐字符读取(不推荐)"></a><strong>逐字符读取(不推荐)</strong></h3><p><strong>逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐字符读取</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile04</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化读取操作对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ifs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//数据存储变量</span></span><br><span class="line">    <span class="keyword">char</span> cbuffer;</span><br><span class="line">    <span class="comment">//逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.</span></span><br><span class="line">    <span class="keyword">while</span> ((cbuffer = ifs.get()) != EOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cbuffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EOF</code>代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。</p><h3 id="逐行读取-有两种方式，但都是逐行读取"><a href="#逐行读取-有两种方式，但都是逐行读取" class="headerlink" title="逐行读取(有两种方式，但都是逐行读取)"></a><strong>逐行读取(有两种方式，但都是逐行读取)</strong></h3><p>第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐行读取</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile02</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化</span></span><br><span class="line">    fstream fs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//用字符数组进行缓存</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)</span></span><br><span class="line">    <span class="keyword">while</span> (fs.getline(buffer, <span class="keyword">sizeof</span>(buffer))) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>字符数组</code>作为数据存储容器，用<code>fstream</code>对象的<code>getline()</code>函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用<code>sizeof()</code>是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。</p><p>第二种:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐行读取</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile03</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化读取操作对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ifs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//数据存储容器</span></span><br><span class="line">    <span class="built_in">string</span> buffer;</span><br><span class="line">    <span class="comment">//使用全局函数getline(输入流，可存储的容器)进行逐行读取</span></span><br><span class="line">    <span class="keyword">while</span> (getline(ifs, buffer)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数<code>getline(输入对象,数据存储容器)</code>,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。</p><h3 id="逐词读取-以空格区分"><a href="#逐词读取-以空格区分" class="headerlink" title="逐词读取(以空格区分)"></a><strong>逐词读取(以空格区分)</strong></h3><p>逐词读取，将会已空格进行区分每个词汇，再读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐词读取文件</span></span><br><span class="line"><span class="comment"> * @param path 文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile01</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化读取文件对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ifs.open(path, ios::in);</span><br><span class="line">    <span class="comment">//判断文件是否能打开</span></span><br><span class="line">    <span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"文件打开失败!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符数组缓存</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//将读取的数据放入缓存区</span></span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buffer)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。</p><p>这种逐词读取的方式是<code>读取对象</code>通过<code>右移运算符</code>把读取的数据存入容器之中，但是是以空格区分每个词汇。</p><h2 id="以二进制的方式读取"><a href="#以二进制的方式读取" class="headerlink" title="以二进制的方式读取"></a><strong>以二进制的方式读取</strong></h2><p>前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以二进制的方式读取文件</span></span><br><span class="line"><span class="comment"> * @param path 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFileByBinary</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建输入流对象，并且指定路径和文件打开方式</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(path, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> * c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];</span><br><span class="line">    ifs.read(c, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readFileByBinary(<span class="string">"Student.smi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这里我们将<code>Student.smi</code>这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>读取文件创建<code>ifstream</code>对象,写入文件创建<code>ofstream</code>对象，<code>fstream</code>对象既可以读又可以写。</p><p>操作文件得先<code>打开文件</code></p><p>操作文件完毕得<code>关闭文件</code></p><p>二进制文件读取需要读取二进制格式的文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些简单的读写文件的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我儿子的博客</title>
    <link href="https://evanmeek.github.io/2019/05/21/%E6%88%91%E5%84%BF%E5%AD%90%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://evanmeek.github.io/2019/05/21/我儿子的博客/</id>
    <published>2019-05-21T08:06:54.000Z</published>
    <updated>2019-05-21T08:12:06.768Z</updated>
    
    <content type="html"><![CDATA[<p>自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。</p><a id="more"></a><p>随便截取一个片段，这哥们咋那么傻的可爱。</p><p><img src="/2019/05/21/我儿子的博客/预览.png" alt="预览"></p><p>想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。</p><p><code>PS:痔疮，你看到了别打我</code></p><h1 id="EvanShady的博客"><a href="#EvanShady的博客" class="headerlink" title="EvanShady的博客"></a><a href="https://evanshady.github.io/" target="_blank" rel="noopener">EvanShady的博客</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。&lt;/p&gt;
    
    </summary>
    
      <category term="分享" scheme="https://evanmeek.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="欢乐时光" scheme="https://evanmeek.github.io/tags/%E6%AC%A2%E4%B9%90%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>解决KDE下部分应用不能使用fctix中文输入法的问题</title>
    <link href="https://evanmeek.github.io/2019/05/19/%E8%A7%A3%E5%86%B3KDE%E4%B8%8B%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8fctix%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://evanmeek.github.io/2019/05/19/解决KDE下部分应用不能使用fctix中文输入法的问题/</id>
    <published>2019-05-19T07:56:33.000Z</published>
    <updated>2019-05-19T08:31:31.577Z</updated>
    
    <content type="html"><![CDATA[<p>我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。</p><a id="more"></a><p><strong><strong>***</strong></strong> 本教程使用fctix输入法框架。<strong><strong><strong>**</strong></strong></strong></p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>首先安装一些必要的软件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S fctix fctix-im fctix-configtool fctix-googlepinyin</span><br></pre></td></tr></table></figure><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>安装完成后编辑:<strong>/etc/environment</strong>文件，加上如下内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>注销当前会话，配置输入法为googlepinyin即可使用。</p><blockquote><p><a href="https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">本文参考</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="KDE" scheme="https://evanmeek.github.io/tags/KDE/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://evanmeek.github.io/2019/05/17/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://evanmeek.github.io/2019/05/17/C-友元/</id>
    <published>2019-05-17T09:07:28.000Z</published>
    <updated>2019-05-20T03:21:50.468Z</updated>
    
    <content type="html"><![CDATA[<p>相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。</p><a id="more"></a><h1 id="什么是友元？"><a href="#什么是友元？" class="headerlink" title="什么是友元？"></a>什么是友元？</h1><p>友元可以访问类中私有的成员。</p><p>它的使用场景又如下几种:</p><ul><li><p>全局函数作友元</p></li><li><p>类作友元</p></li><li><p>成员函数做友元</p></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面将通过几个案例，分别演示不同场景下，友元的使用方式。</p><hr><h2 id="全局函数作友元"><a href="#全局函数作友元" class="headerlink" title="全局函数作友元"></a>全局函数作友元</h2><p>本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先声明Person类，防止下面报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="comment">//声明showPrivateVar函数，防止报错.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPrivateVar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class="line">    <span class="keyword">double</span> money;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    Person();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义构造函数</span></span><br><span class="line">Person::Person()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;money = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问私有成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPrivateVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化Person类对象</span></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//访问Person对象的私有成员</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"尝试访问Person类的私有属性:"</span>&lt;&lt;p.money&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用访问私有成员函数</span></span><br><span class="line">    showPrivateVar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="comment">//使showPrivateVar函数作为Person类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">showPrivateVar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class="line">    <span class="keyword">double</span> money;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    Person();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尝试访问Person类的私有属性:10</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.</p><p><strong>那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。</strong></p><hr><h2 id="类作类的友元"><a href="#类作类的友元" class="headerlink" title="类作类的友元"></a>类作类的友元</h2><p>这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明类，防止报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span>;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendForBuild</span>&#123;</span></span><br><span class="line">    Build * b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    FriendForBuild();</span><br><span class="line">    <span class="comment">//声明visit函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Build类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> FriendForBuild;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有房间</span></span><br><span class="line">    <span class="built_in">string</span> privateRoom;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//公共房间</span></span><br><span class="line">    <span class="built_in">string</span> publicRoom;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Build()&#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;privateRoom = <span class="string">"私人卧室"</span>;</span><br><span class="line">       <span class="keyword">this</span>-&gt;publicRoom = <span class="string">"公共客厅"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FriendForBuild::FriendForBuild() &#123;</span><br><span class="line">    b = <span class="keyword">new</span> Build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> FriendForBuild::visit()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"我正在访问Build类对象的publicRoom成员:"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"我正在访问Build类对象的privateRoom成员:"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FriendForBuild friendForBuild;</span><br><span class="line">    friendForBuild.visit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我正在访问Build类对象的publicRoom成员:公共客厅</span><br><span class="line">我正在访问Build类对象的privateRoom成员:私人卧室</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。</strong></p><hr><h2 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h2><p>上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明类，防止报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span>;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendForBuild</span>&#123;</span></span><br><span class="line">    Build * b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    FriendForBuild();</span><br><span class="line">    <span class="comment">//声明visit函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Build类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> FriendForBuild::visit();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有房间</span></span><br><span class="line">    <span class="built_in">string</span> privateRoom;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//公共房间</span></span><br><span class="line">    <span class="built_in">string</span> publicRoom;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Build()&#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;privateRoom = <span class="string">"私人卧室"</span>;</span><br><span class="line">       <span class="keyword">this</span>-&gt;publicRoom = <span class="string">"公共客厅"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FriendForBuild::FriendForBuild() &#123;</span><br><span class="line">    b = <span class="keyword">new</span> Build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> FriendForBuild::visit()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"我正在访问Build类对象的publicRoom成员:"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"我正在访问Build类对象的privateRoom成员:"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FriendForBuild friendForBuild;</span><br><span class="line">    friendForBuild.visit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ManjaroLinuxTG讨论群组</title>
    <link href="https://evanmeek.github.io/2019/05/16/ManjaroLinuxTG%E8%AE%A8%E8%AE%BA%E7%BE%A4%E7%BB%84/"/>
    <id>https://evanmeek.github.io/2019/05/16/ManjaroLinuxTG讨论群组/</id>
    <published>2019-05-15T16:01:58.000Z</published>
    <updated>2019-05-19T08:32:31.246Z</updated>
    
    <content type="html"><![CDATA[<p>创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。</p><h1 id="点击加入"><a href="#点击加入" class="headerlink" title="点击加入"></a><a href="https://t.me/manjarozhihu" target="_blank" rel="noopener">点击加入</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。&lt;/p&gt;
&lt;h1 id=&quot;点击加入&quot;&gt;&lt;a href=&quot;#点击加入&quot; class=&quot;headerlink&quot; title=&quot;点击加入&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://t.me/manjaro
      
    
    </summary>
    
      <category term="分享" scheme="https://evanmeek.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="Telegram" scheme="https://evanmeek.github.io/tags/Telegram/"/>
    
  </entry>
  
  <entry>
    <title>我的Linux之路</title>
    <link href="https://evanmeek.github.io/2019/05/15/%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF/"/>
    <id>https://evanmeek.github.io/2019/05/15/我的Linux之路/</id>
    <published>2019-05-14T16:04:56.000Z</published>
    <updated>2019-05-19T08:32:31.246Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.</p><a id="more"></a><p>先说说一些题外话</p><p>我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。</p><p>第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。</p><p>我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了….</p><p>好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。</p><p>身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。</p><p>终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。</p><p>自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!</p><p>下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。</p><p>说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）</p><p>我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。</p><p>我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。</p><p>下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!</p><p>解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。</p><p>但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。</p><p>总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.&lt;/p&gt;
    
    </summary>
    
      <category term="个人感想" scheme="https://evanmeek.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝的区别</title>
    <link href="https://evanmeek.github.io/2019/05/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://evanmeek.github.io/2019/05/14/深拷贝和浅拷贝的区别/</id>
    <published>2019-05-14T14:55:24.000Z</published>
    <updated>2019-05-19T08:32:31.249Z</updated>
    
    <content type="html"><![CDATA[<p>虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。</p><a id="more"></a><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。</p><p><strong>那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。</strong></p><p>那什么是拷贝构造函数呢?</p><p><strong>拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象</strong></p><p>下面看个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human默认构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Human(<span class="built_in">string</span> f_name, <span class="keyword">int</span> f_age) &#123;</span><br><span class="line">        name = f_name;</span><br><span class="line">        age = f_age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human有参构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human析构函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">h1</span><span class="params">(<span class="string">"李四"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt; h1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class="line">    <span class="function">Human <span class="title">h2</span><span class="params">(h1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h2.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt; h2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Human有参构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human析构函数调用.</span><br><span class="line">Human析构函数调用.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，<strong>这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。</strong></p><p>浅拷贝的具体代码实现是怎样的呢？请看下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的拷贝构造函数</span></span><br><span class="line">Human(<span class="keyword">const</span> Human &amp; h)&#123;</span><br><span class="line">    name = h.name;</span><br><span class="line">    age = h.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可与看出，它只是简单的将对象属性的值，进行拷贝。</p><p>大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？</p><p>答案是否定的，下面看下深拷贝。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>什么是深拷贝?</p><p><strong>深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.</strong></p><p>下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> *age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human默认构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Human(<span class="built_in">string</span> f_name, <span class="keyword">int</span> f_age) &#123;</span><br><span class="line">        name = f_name;</span><br><span class="line">        <span class="comment">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class="line">        age = <span class="keyword">new</span> <span class="keyword">int</span>(f_age);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human有参构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Human() &#123;</span><br><span class="line">        <span class="comment">//如果age指针变量是空，则释放</span></span><br><span class="line">        <span class="keyword">if</span>(age !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> age;</span><br><span class="line">            <span class="comment">//防止指针变量成为野指针</span></span><br><span class="line">            age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human析构函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">h1</span><span class="params">(<span class="string">"李四"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class="line">    <span class="function">Human <span class="title">h2</span><span class="params">(h1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h2.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free(): double free detected in tcache 2</span><br><span class="line">Human有参构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human析构函数调用.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></table></figure><p>通过输出结果，我们发现，程序发生了错误。</p><p>因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。</p><p>上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。</p><p>由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。</p><p>然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。</p><p>既然问题找到了，我们就需要进行修改，将这个问题解决。</p><p>下面通过深拷贝的方式，让这个bug被修复:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> *age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Human() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human默认构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Human(<span class="built_in">string</span> f_name, <span class="keyword">int</span> f_age) &#123;</span><br><span class="line">        name = f_name;</span><br><span class="line">        <span class="comment">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class="line">        age = <span class="keyword">new</span> <span class="keyword">int</span>(f_age);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human有参构造函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    Human(<span class="keyword">const</span> Human &amp; h)&#123;</span><br><span class="line">        name = h.name;</span><br><span class="line">        <span class="comment">//新开辟内存空间到堆区，存放age所指向的数据。</span></span><br><span class="line">        age = <span class="keyword">new</span> <span class="keyword">int</span>(*h.age);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Human拷贝构造函数调用."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Human() &#123;</span><br><span class="line">        <span class="comment">//如果age指针变量是空，则释放</span></span><br><span class="line">        <span class="keyword">if</span>(age !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> age;</span><br><span class="line">            <span class="comment">//防止指针变量成为野指针</span></span><br><span class="line">            age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Human析构函数调用."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">h1</span><span class="params">(<span class="string">"李四"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class="line">    <span class="function">Human <span class="title">h2</span><span class="params">(h1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h2.name &lt;&lt; <span class="string">"的年龄为:"</span> &lt;&lt;*h2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Human有参构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human拷贝构造函数调用.</span><br><span class="line">李四的年龄为:18</span><br><span class="line">Human析构函数调用.</span><br><span class="line">Human析构函数调用.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>程序没有报错，说明我们的bug成功解决了。</p><p>上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。</p><p>深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。</p><p>为什么能避免？</p><p>原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。</p><h1 id="两者该如何选择"><a href="#两者该如何选择" class="headerlink" title="两者该如何选择?"></a>两者该如何选择?</h1><p><strong>说得绝对点：</strong></p><p>若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。</p><p>这时需要使用深拷贝。</p><p><strong>说的不那么绝对:</strong></p><p>若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="经典案例" scheme="https://evanmeek.github.io/tags/%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>2008年5月12日14时28分04秒</title>
    <link href="https://evanmeek.github.io/2019/05/12/2008%E5%B9%B45%E6%9C%8812%E6%97%A514%E6%97%B628%E5%88%8604%E7%A7%92/"/>
    <id>https://evanmeek.github.io/2019/05/12/2008年5月12日14时28分04秒/</id>
    <published>2019-05-12T14:53:06.000Z</published>
    <updated>2019-05-13T11:23:40.404Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/05/12/2008年5月12日14时28分04秒/空降.webp" alt="空降"></p><p>  图为汶川大地震时某部队空降救灾  </p><a id="more"></a><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。</p><p>此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。</p><p>伤亡人数：69227人遇难，374643人受伤，17923人失踪。</p><p>以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。</p><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>每年的这个时刻，我都不由自主的想起这个事情。</p><p>2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。</p><p>那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，</p><p>突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。</p><p>这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！</p><p>跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。</p><p>宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。</p><p>因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。</p><p>大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。</p><p>晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。</p><p>学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。</p><p>天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。</p><p><img src="/2019/05/12/2008年5月12日14时28分04秒/操场.webp" alt="操场"></p><h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。</p><p>我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。</p><p>两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。</p><p><img src="/2019/05/12/2008年5月12日14时28分04秒/流量图.webp" alt="流量"></p><p>这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。</p><p>这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。</p><p>谷歌当时的博文说道：</p><p>“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”</p><p>几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。</p><p>全世界的中华儿女在这三分钟连在了一起。</p><h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。</p><p>大家那时候就只有一个身份，就叫中国人。</p><p>那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。</p><p>   况且古往今来，历史诚不欺我。   </p><blockquote><p>知乎 ———— 小小白告</p></blockquote><p>汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。</p><p>打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。</p><p>最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。</p><p>  多年过去，讲起这个故事，仍旧热泪盈眶。  </p><blockquote><p>知乎 ———— 匿名用户</p></blockquote><p>昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。</p><p>她给我看她们初中的学校。</p><p>我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。</p><p>我听了这句话瞬间眼睛红了，那年她初二，今年她研二。</p><p>   活着，本身就意味着一切。   </p><blockquote><p>知乎 ———— 匿名用户</p></blockquote><p>推荐25分钟纪录片:《为了生命》。</p><hr><p>本篇文章转载于：<a href="https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##" target="_blank" rel="noopener">阅读原文</a><br>作者：纯洁的微笑(一个有故事的程序员)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/05/12/2008年5月12日14时28分04秒/空降.webp&quot; alt=&quot;空降&quot;&gt;&lt;/p&gt;
&lt;p&gt;  图为汶川大地震时某部队空降救灾  &lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://evanmeek.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="社会事件" scheme="https://evanmeek.github.io/tags/%E7%A4%BE%E4%BC%9A%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存四区之代码区与全局区</title>
    <link href="https://evanmeek.github.io/2019/05/11/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8C%BA/"/>
    <id>https://evanmeek.github.io/2019/05/11/C-内存四区之代码区与全局区/</id>
    <published>2019-05-11T12:52:44.000Z</published>
    <updated>2019-05-19T08:32:31.246Z</updated>
    
    <content type="html"><![CDATA[<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p><a id="more"></a><h1 id="0x00-内存分区模型"><a href="#0x00-内存分区模型" class="headerlink" title="0x00 内存分区模型"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p><ul><li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p></li><li><p>全局区: 存放全局变量和静态变量以及常量。</p></li><li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p></li><li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p></li></ul><h2 id="内存四区的意义"><a href="#内存四区的意义" class="headerlink" title="内存四区的意义:"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p><h1 id="0x01-程序运行前"><a href="#0x01-程序运行前" class="headerlink" title="0x01 程序运行前"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p><p>代码区:</p><p>   存放CPU执行的机器指令</p><p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p><p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p><p><img src="/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png" alt="代码区示意图"></p><p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p><p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这一篇应该是作为”C++内存四区”的第一篇的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++内存四区之堆区</title>
    <link href="https://evanmeek.github.io/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA/"/>
    <id>https://evanmeek.github.io/2019/05/10/C-内存四区之堆区/</id>
    <published>2019-05-10T03:13:46.000Z</published>
    <updated>2019-05-10T04:10:31.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是堆区"><a href="#什么是堆区" class="headerlink" title="什么是堆区"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p><h1 id="如何将数据放在堆区"><a href="#如何将数据放在堆区" class="headerlink" title="如何将数据放在堆区"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class="line">    <span class="keyword">int</span> *a_p= <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a_p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p><p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p><p><img src="/2019/05/10/C-内存四区之堆区/test.png" alt="堆区"></p><p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是堆区&quot;&gt;&lt;a href=&quot;#什么是堆区&quot; class=&quot;headerlink&quot; title=&quot;什么是堆区&quot;&gt;&lt;/a&gt;什么是堆区&lt;/h1&gt;&lt;p&gt;由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．&lt;/p&gt;
&lt;h1 id=&quot;如何将数据放在堆
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
</feed>
