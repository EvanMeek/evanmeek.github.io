<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我不会编程的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evanmeek.github.io/"/>
  <updated>2019-05-11T13:18:49.147Z</updated>
  <id>https://evanmeek.github.io/</id>
  
  <author>
    <name>EvanMeek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++内存四区之代码区</title>
    <link href="https://evanmeek.github.io/2019/05/11/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA/"/>
    <id>https://evanmeek.github.io/2019/05/11/C-内存四区之代码区/</id>
    <published>2019-05-11T12:52:44.000Z</published>
    <updated>2019-05-11T13:18:49.147Z</updated>
    
    <content type="html"><![CDATA[<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p><a id="more"></a><h1 id="0x00-内存分区模型"><a href="#0x00-内存分区模型" class="headerlink" title="0x00 内存分区模型"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p><ul><li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p></li><li><p>全局区: 存放全局变量和静态变量以及常量。</p></li><li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p></li><li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p></li></ul><h2 id="内存四区的意义"><a href="#内存四区的意义" class="headerlink" title="内存四区的意义:"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p><h1 id="0x01-程序运行前"><a href="#0x01-程序运行前" class="headerlink" title="0x01 程序运行前"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p><p>代码区:</p><p>   存放CPU执行的机器指令</p><p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p><p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p><p><img src="/2019/05/11/C-内存四区之代码区/代码区示意图.png" alt="代码区示意图"></p><p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p><p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这一篇应该是作为”C++内存四区”的第一篇的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++核心编程" scheme="https://evanmeek.github.io/tags/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++内存四区之堆区</title>
    <link href="https://evanmeek.github.io/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA/"/>
    <id>https://evanmeek.github.io/2019/05/10/C-内存四区之堆区/</id>
    <published>2019-05-10T03:13:46.000Z</published>
    <updated>2019-05-10T10:00:13.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是堆区"><a href="#什么是堆区" class="headerlink" title="什么是堆区"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p><h1 id="如何将数据放在堆区"><a href="#如何将数据放在堆区" class="headerlink" title="如何将数据放在堆区"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class="line">    <span class="keyword">int</span> *a_p= <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a_p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p><p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p><p><img src="/2019/05/10/C-内存四区之堆区/test.png" alt="堆区"></p><p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是堆区&quot;&gt;&lt;a href=&quot;#什么是堆区&quot; class=&quot;headerlink&quot; title=&quot;什么是堆区&quot;&gt;&lt;/a&gt;什么是堆区&lt;/h1&gt;&lt;p&gt;由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．&lt;/p&gt;
&lt;h1 id=&quot;如何将数据放在堆
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++内存四区之栈区</title>
    <link href="https://evanmeek.github.io/2019/05/10/C-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E6%A0%88%E5%8C%BA/"/>
    <id>https://evanmeek.github.io/2019/05/10/C-内存四区之栈区/</id>
    <published>2019-05-10T02:51:17.000Z</published>
    <updated>2019-05-10T10:00:13.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是栈区"><a href="#什么是栈区" class="headerlink" title="什么是栈区"></a>什么是栈区</h1><p>栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..</p><h1 id="操作栈区的注意事项"><a href="#操作栈区的注意事项" class="headerlink" title="操作栈区的注意事项"></a>操作栈区的注意事项</h1><p>在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．</p><p>因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试返回局部变量的地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//接受func的返回值</span></span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line">    <span class="comment">//输出p</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure><p>上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是栈区&quot;&gt;&lt;a href=&quot;#什么是栈区&quot; class=&quot;headerlink&quot; title=&quot;什么是栈区&quot;&gt;&lt;/a&gt;什么是栈区&lt;/h1&gt;&lt;p&gt;栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..&lt;/p&gt;
&lt;h1 id=&quot;操作栈
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>终端多窗口神器——Screen</title>
    <link href="https://evanmeek.github.io/2019/05/09/%E7%BB%88%E7%AB%AF%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Screen/"/>
    <id>https://evanmeek.github.io/2019/05/09/终端多窗口神器——Screen/</id>
    <published>2019-05-09T08:56:08.000Z</published>
    <updated>2019-05-09T14:54:00.133Z</updated>
    
    <content type="html"><![CDATA[<p>曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。</p><p>曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。</p><p>有了Screen,你就可以获得更好的使用终端多窗口的体验。</p><a id="more"></a><p>我想你肯定遇到以下几种情况:</p><ul><li><p>ftp传输</p></li><li><p>系统备份</p></li><li><p>长时间运行任务</p></li></ul><p>好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。</p><h1 id="凶手-SIGHUP-信号"><a href="#凶手-SIGHUP-信号" class="headerlink" title="凶手 SIGHUP 信号"></a>凶手 SIGHUP 信号</h1><blockquote><p>以下资料来自维基百科 </p><blockquote><p>SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p></blockquote></blockquote><p>简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。</p><ul><li><p>Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。</p></li><li><p>Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。</p></li><li><p>Ctrl-\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。</p></li></ul><h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。</p><p><strong>更多有关SIGHUP信号的资料，我会在后面的文章进行更新。</strong></p><hr><h1 id="开始使用Screen"><a href="#开始使用Screen" class="headerlink" title="开始使用Screen"></a>开始使用Screen</h1><p>先简单说说什么是Screen:</p><p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。</p><p>Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。</p><p><strong>1.创建一个screen窗口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen</span><br></pre></td></tr></table></figure><p>这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。</p><p><strong>2.创建窗口+执行命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen vim</span><br></pre></td></tr></table></figure><p>screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。</p><p><strong>3.一个窗口中再有一个窗口中再有一个窗口中…</strong></p><p>你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。</p><p><strong>4.screen的暂时断开(detach)和重新链接(attach)</strong></p><p>比如在screen窗口下用vim编辑C++源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen vim test.cpp</span><br></pre></td></tr></table></figure><p>但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).</p><p><img src="/2019/05/09/终端多窗口神器——Screen/detachedInfo.png" alt="挂起提示"></p><p>当你做完其他事你就可以找回该会话，进行重新连接:</p><p>找到会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen -ls</span><br><span class="line">There are screens on:</span><br><span class="line">        17944.pts-4.EvanLinux   (Detached)</span><br><span class="line">        14290.server    (Detached)</span><br><span class="line">2 Sockets in /run/screens/S-evanmeek.</span><br></pre></td></tr></table></figure><p>重新连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[evanmeek＠Evan-PC]# screen- r 17944</span><br></pre></td></tr></table></figure><p>这样就可以恢复pts这个会话的窗口了．</p><hr><h1 id="配置你的Screen"><a href="#配置你的Screen" class="headerlink" title="配置你的Screen"></a>配置你的Screen</h1><p>前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.</p><p>可通过如下键绑定查看所有键绑定．</p><p><strong>C-a ?</strong></p><p>常用的键绑定有：</p><table><thead><tr><th style="text-align:center">键绑定</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">C-a ?</td><td style="text-align:center">显示所有键绑定信息</td></tr><tr><td style="text-align:center">C-a w</td><td style="text-align:center">显示所有窗口列表</td></tr><tr><td style="text-align:center">C-a C-a</td><td style="text-align:center">切换到之前显示的窗口</td></tr><tr><td style="text-align:center">C-a c</td><td style="text-align:center">创建一个新的运行shell的窗口并切换到该窗口</td></tr><tr><td style="text-align:center">C-a n</td><td style="text-align:center">切换到下一个窗口</td></tr><tr><td style="text-align:center">C-a p</td><td style="text-align:center">切换到前一个窗口</td></tr><tr><td style="text-align:center">C-a 0~9</td><td style="text-align:center">切换到0~9窗口</td></tr><tr><td style="text-align:center">C-a a</td><td style="text-align:center">发送C-a到当前窗口</td></tr><tr><td style="text-align:center">C-a d</td><td style="text-align:center">暂时断开screen会话</td></tr><tr><td style="text-align:center">C-a k</td><td style="text-align:center">杀掉当前窗口</td></tr><tr><td style="text-align:center">C-a [</td><td style="text-align:center">进入拷贝/回滚模式</td></tr></tbody></table><p>我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;</p><p><img src="/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png" alt="默认的命令字符">;</p><p>我们可以修改它，通过如下格式:</p><p><strong>-exy</strong></p><p>x:命令字符</p><p>y:转义字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[evanmeek@Evan-PC]#</span> screen -e^oo</span><br></pre></td></tr></table></figure><p>这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。&lt;/p&gt;
&lt;p&gt;曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。&lt;/p&gt;
&lt;p&gt;有了Screen,你就可以获得更好的使用终端多窗口的体验。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="软件折腾" scheme="https://evanmeek.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的解压与压缩</title>
    <link href="https://evanmeek.github.io/2019/05/08/Linux%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9/"/>
    <id>https://evanmeek.github.io/2019/05/08/Linux中的解压与压缩/</id>
    <published>2019-05-08T12:54:19.000Z</published>
    <updated>2019-05-09T14:54:32.530Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。</p><a id="more"></a><p>在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。</p><p>Linux下有三种主流常用的解压压缩软件可选:</p><ul><li><p>gzip (GNUzip)</p></li><li><p>bz2 (bzip2)</p></li><li><p>xz (xzutils)</p></li></ul><p>三个软件的参数相同，只是命令不同:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bzip2 [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> xz [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure><blockquote><p>可选参数</p></blockquote><table><thead><tr><th></th><th style="text-align:center">参数名</th><th>作用</th></tr></thead><tbody><tr><td></td><td style="text-align:center">-d</td><td>解压</td><td></td></tr><tr><td></td><td style="text-align:center">-k</td><td>压缩时不删除源文件</td><td></td></tr><tr><td></td><td style="text-align:center">-r</td><td>递归查找目录下的文件，并且压缩</td><td></td></tr><tr><td></td><td style="text-align:center">-v</td><td>显示详细信息</td><td></td></tr><tr><td></td><td style="text-align:center">-t</td><td>测试压缩包是否完整</td><td></td></tr><tr><td></td><td style="text-align:center">-l</td><td>显示压缩包信息</td><td></td></tr><tr><td></td><td style="text-align:center">-c</td><td>写入标准输出，保持原始文件不变</td><td></td></tr><tr><td></td><td style="text-align:center">-1~9</td><td>压缩等级</td><td></td></tr></tbody></table><p><strong>示例:</strong></p><blockquote><p>压缩test.txt，并删除.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip test.txt</span><br></pre></td></tr></table></figure><blockquote><p>压缩test.txt，不删除原文件，并且显示信息.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip -vk test.txt</span><br></pre></td></tr></table></figure><blockquote><p>以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip -9cvk test.txt test2.txt &gt; test.gz</span><br></pre></td></tr></table></figure><blockquote><p>解压test.gz</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip -d test.gz</span><br></pre></td></tr></table></figure><hr><p>介绍完上面的几种压缩软件，下面介绍一个打包软件<strong>tar</strong></p><p>我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。</p><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>这里注意第一个参数，它们分别代表使用什么压缩软件。</p><blockquote><p>bz2<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -jcvf test.tar.bz test/</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>xz<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -Jcvf test.tar.xz test/</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>gzip<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -zcvf test.tar.gz test/</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -Jxvf test.tar.xz test/</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++指针[基础02]</title>
    <link href="https://evanmeek.github.io/2019/05/06/C-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8002/"/>
    <id>https://evanmeek.github.io/2019/05/06/C-指针-基础02/</id>
    <published>2019-05-06T13:58:29.000Z</published>
    <updated>2019-05-09T14:54:57.567Z</updated>
    
    <content type="html"><![CDATA[<p>C++指针和数组的操作。</p><a id="more"></a><p>C++中访问数组元素可以使用如下示例进行访问:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第2个元素为:"</span>&lt;&lt;arr[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>想必大家都知道输出的值为:1</p><hr><p>那么我们现在可以使用指针进行访问数组元素</p><p>数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"p:"</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:0</span><br></pre></td></tr></table></figure><p><strong>提问:</strong></p><p>为什么指针可以指向数组名，而不需要使用引用符(&amp;)？</p><p><strong>疑惑解答:</strong></p><p>那是因为在C++中，数组其实就是一块内存空间，然而里面的<strong>每个元素也就组成了一块连续的内存空间</strong>，而<strong>数组名就当任了数组的首地址</strong>的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。</p><hr><p>通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对指针进行位偏移</span></span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"p:"</span>;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p: 1</span><br></pre></td></tr></table></figure><p>上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。</p><p><img src="/2019/05/06/C-指针-基础02/指针位偏移.png" alt="位偏移"></p><hr><p>最后利用指针遍历输出数组内的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;<span class="number">3</span>;i++,p++)&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++指针和数组的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="指针" scheme="https://evanmeek.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++指针[基础01]</title>
    <link href="https://evanmeek.github.io/2019/05/06/C-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8001/"/>
    <id>https://evanmeek.github.io/2019/05/06/C-指针-基础01/</id>
    <published>2019-05-06T12:19:25.000Z</published>
    <updated>2019-05-09T14:55:03.853Z</updated>
    
    <content type="html"><![CDATA[<p>开始写C++中比较难理解的几个知识点的笔记。</p><a id="more"></a><h1 id="0x00-空指针"><a href="#0x00-空指针" class="headerlink" title="0x00 空指针"></a>0x00 <strong>空指针</strong></h1><p><strong>用途:给指针初始化值。</strong></p><p><strong>特性:空指针不可访问。</strong></p><p>为什么不可访问?</p><p>因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。</p><p><strong>报错例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义空指针</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改空指针所指向的空间的值,报错!</span></span><br><span class="line">*p = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>常用情景</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义空指针</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使指针重新指向内存空间,可行!</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。</p><h1 id="0x01-野指针"><a href="#0x01-野指针" class="headerlink" title="0x01 野指针"></a>0x01 <strong>野指针</strong></h1><p><strong>说明:指针指向的是非法的内存空间叫做野指针</strong></p><p><strong>异常:读取访问权限错误</strong></p><p><strong>报错例子:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使指针指向一个未知空间</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="number">0x1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改指向的空间的值,报错!</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!</p><h1 id="0x02-const修饰指针"><a href="#0x02-const修饰指针" class="headerlink" title="0x02 const修饰指针"></a>0x02 <strong>const修饰指针</strong></h1><p>const修饰指针分为三种场景</p><ul><li><p>const修饰指针————常量指针</p></li><li><p>const修饰常量————指针常量</p></li><li><p>const既修饰指针又修饰常量</p></li></ul><blockquote><p>常量指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改指针所指向空间的值,报错!</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针重新指向新的空间,可行!</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>看上面的案例，可以得出，<strong>常量指针是不能修改所指向的空间的值，但可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的左侧的</strong>。</p><hr><blockquote><p>指针常量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针常量</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指针所指向空间的值,可行!</span></span><br><span class="line">*p=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试为指针重新指向新的空间，报错!</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>看上面的案例，可以得出，<strong>常量指针可修改所指向的空间的值，但不可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的右侧的</strong>。</p><hr><blockquote><p>既修饰指针又修饰常量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义同时const修饰指针常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * cosnt p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试修改指针所指向的空间的值，报错!</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试为指针重新指向新的空间，报错!</span></span><br><span class="line"></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>看上面的案例，可以得出，<strong>如果指针和常量都被const修饰，那么就和const 引用非常类似了</strong>。</p><hr><p><strong>小结</strong></p><p>常量指针</p><ul><li>不可修改所指向的空间的值</li><li>可重新指向新的空间</li></ul><p>指针常量</p><ul><li>可修改所指向的空间的值</li><li>不可重新指向新的空间</li></ul><p>指针和常量都被const所修饰</p><ul><li>不可修改所指向的空间的值</li><li>不可重新指向新的空间</li></ul><p><strong>小技巧</strong></p><blockquote><p>辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始写C++中比较难理解的几个知识点的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="指针" scheme="https://evanmeek.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础" scheme="https://evanmeek.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>hexo+next插入网易云音乐</title>
    <link href="https://evanmeek.github.io/2019/04/30/hexo-next%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>https://evanmeek.github.io/2019/04/30/hexo-next插入网易云音乐/</id>
    <published>2019-04-30T12:05:20.000Z</published>
    <updated>2019-05-09T14:54:49.830Z</updated>
    
    <content type="html"><![CDATA[<p>让大爷们在阅读博客时能优哉游哉的听着歌看文章。</p><a id="more"></a><h1 id="获取外链"><a href="#获取外链" class="headerlink" title="获取外链"></a>获取外链</h1><p>打开<a href="https://music.163.com" target="_blank" rel="noopener">网易云音乐</a>官网</p><p>找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。</p><p><img src="/2019/04/30/hexo-next插入网易云音乐/01.png" alt="01"></p><p>可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!</p><h1 id="插入外链"><a href="#插入外链" class="headerlink" title="插入外链"></a>插入外链</h1><p><strong>如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.</strong></p><p><strong>如果是想插入到侧边栏</strong></p><p>需要编辑next/layout/_macro/sidebar.swig文件</p><p>此时我们就需要使用开发者工具插入到自己合适的位置下</p><p><img src="/2019/04/30/hexo-next插入网易云音乐/插哪.png" alt="插哪"></p><p>可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让大爷们在阅读博客时能优哉游哉的听着歌看文章。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记录" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hexo" scheme="https://evanmeek.github.io/tags/hexo/"/>
    
      <category term="网易云音乐" scheme="https://evanmeek.github.io/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>如何用hexo+github-pages搭建博客</title>
    <link href="https://evanmeek.github.io/2019/04/29/%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://evanmeek.github.io/2019/04/29/如何用hexo-github-pages搭建博客/</id>
    <published>2019-04-29T14:56:54.000Z</published>
    <updated>2019-05-09T14:54:22.657Z</updated>
    
    <content type="html"><![CDATA[<p>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</p><a id="more"></a><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg" alt="逆光"></p><h1 id="为何选择hexo"><a href="#为何选择hexo" class="headerlink" title="为何选择hexo"></a>为何选择hexo</h1><ul><li><p>hexo博客框架的网上资料较多，技术较为成熟.</p></li><li><p>hexo使用Makrdown进行渲染.</p></li><li><p>hexo只需几步就可部署博客.</p></li><li><p>hexo具有丰富的主题/插件可选.</p></li></ul><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><h2 id="安装Nodejs-Git"><a href="#安装Nodejs-Git" class="headerlink" title="安装Nodejs,Git"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p><p>大部分发行版自带Git,Nodejs只需要一条命令:</p><p><strong>apt</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure><p><strong>pacman</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure><h2 id="配置Nodejs"><a href="#配置Nodejs" class="headerlink" title="配置Nodejs"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p><p>在任意目录下执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm config get registry</span><br></pre></td></tr></table></figure><h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><h3 id="注册Github"><a href="#注册Github" class="headerlink" title="注册Github"></a><strong>注册Github</strong></h3><p><a href="https://github.com/join" target="_blank" rel="noopener">注册Github</a></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a><strong>创建仓库</strong></h3><p><a href="https://github.com/new" target="_blank" rel="noopener">创建Github仓库</a></p><p>注意: 仓库名必须是<strong>name.github.io</strong></p><p>例如我的 evanmeek.github.io</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png" alt="创建Github仓库"></p><p>需要设置两点:</p><ul><li>Git身份标识</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.email "你的邮箱"</span><br><span class="line"><span class="meta">$</span> git config --global user.name "你的名字"</span><br></pre></td></tr></table></figure><p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p><ul><li>SSH密钥</li></ul><p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure><p>若没有则创建新的密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "你的邮箱"</span><br></pre></td></tr></table></figure><p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p><p>创建完成后，你会在~/.ssh内看到两个文件</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png" alt="ssh目录"></p><p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p><p>下一步则是需要在Github中添加刚刚生成的密钥</p><p>首先登陆Github,打开设置.</p><p>如图所示：</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png" alt="登陆Github"></p><p>下一步找到SSH选项</p><p>如图所示：</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png" alt="设置SSH"></p><p>下一步导入公钥</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png" alt="导入密钥"></p><p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="安装hexo-1"><a href="#安装hexo-1" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p><p><strong>要使用sudo提权</strong></p><p>执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>看到Done!之后则为安装成功.</p><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="初始化hexo博客"><a href="#初始化hexo博客" class="headerlink" title="初始化hexo博客"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png" alt="hexoinit"></p><p>初始化完成之后目录结构大概是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>下面分别讲下这些文件或目录分别存放了些什么。</p><p>主配置文件: <strong>_config.yml</strong></p><blockquote><p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p></blockquote><p>插件信息: <strong>package.json</strong></p><blockquote><p>包含了当前hexo博客中安装了哪些插件.</p></blockquote><p>模板目录: <strong>scaffolds/</strong></p><blockquote><p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p></blockquote><p>资源目录: <strong>source/</strong></p><blockquote><p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p></blockquote><p>主题目录: <strong>themes/</strong></p><blockquote><p>主题目录，所有的主题都丢在这里。</p></blockquote><hr><h2 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo n "文章名"</span><br></pre></td></tr></table></figure><p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p><p>这一步用于生成静态文件(就是把md转为html的操作)</p><p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo generate</span><br></pre></td></tr></table></figure><p>这个命令可以简化，并且还可以带两个参数</p><p>简化+参数:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p><hr><h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p><p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p><p>找到deploy项</p><p>修改为:</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png" alt="deploy"></p><p><strong>type为git不能为大写</strong></p><hr><h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p><p><strong>本地部署</strong></p><p>执行如下命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo s</span><br></pre></td></tr></table></figure><p>执行完后可以通过localhost:4000进行<a href="localhost:4000" target="_blank" rel="noopener">查看</a>.</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png" alt="本地部署"></p><p><strong>部署到Github</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo d</span><br></pre></td></tr></table></figure><p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p><h1 id="寻找主题"><a href="#寻找主题" class="headerlink" title="寻找主题"></a>寻找主题</h1><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题</a></p><p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href="mailto:the_lty_mail@foxmail.com" target="_blank" rel="noopener">the_lty_mail@foxmail.com</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记录" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hexo" scheme="https://evanmeek.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://evanmeek.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客文章插入图片</title>
    <link href="https://evanmeek.github.io/2019/04/29/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>https://evanmeek.github.io/2019/04/29/hexo博客文章插入图片/</id>
    <published>2019-04-29T07:15:29.000Z</published>
    <updated>2019-05-09T14:54:41.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p><a id="more"></a><h1 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>如果安装速度很慢可以把npm源改为国内源。</p><p><a href="https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/">点击打开npm源改为国内源的方法</a></p><p>在设置镜像源-&gt;npm国内源下</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p><p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p><p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo n "test"</span><br><span class="line"><span class="meta">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure><p>插入图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址)</span><br><span class="line"></span><br><span class="line"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记录" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hexo" scheme="https://evanmeek.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++函数探幽</title>
    <link href="https://evanmeek.github.io/2019/04/24/C-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/"/>
    <id>https://evanmeek.github.io/2019/04/24/C-函数探幽/</id>
    <published>2019-04-23T22:38:43.000Z</published>
    <updated>2019-05-09T14:55:10.943Z</updated>
    
    <content type="html"><![CDATA[<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66"></iframe>--><a id="more"></a><p><strong>本章内容</strong></p><ul><li>内联函数</li><li>引用变量</li><li>如何按引用传递函数参数</li><li>默认参数</li><li>函数重载</li><li>函数模板</li><li>函数模板具体化</li></ul><p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p><hr><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3></blockquote><p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p><p>那么，我们现在就深入到程序内部．</p><p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p><p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p><p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p><p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p><p><strong>所以</strong></p><p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p><p>相当于编译器将使用相应的函数代码替换函数调用．</p><p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p><p><strong>但是</strong></p><p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p><p><strong>结论</strong></p><p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p><p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p><p>_除非_　:该函数被经常调用</p><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3></blockquote><p>使用内联函数只需要做到以下两点即可：</p><ul><li><p>在函数声明前加上关键字<strong>inline</strong>;</p></li><li><p>在函数定义前加上关键字<strong>inline</strong>;</p></li></ul><p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p><p><strong>可能遇到的问题</strong></p><p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p><ul><li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p></li><li><p>有些编译器没有启动或实现这种特性．</p></li></ul><blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    double a(2.0), b(5.0), c(0);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">" \tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    square(a);</span><br><span class="line">    b = square(b);</span><br><span class="line">    c = square(<span class="number">7</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时a=2b=5c=0</span><br><span class="line">此时a=4b=25c=64</span><br></pre></td></tr></table></figure><p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p><p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p><p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p><p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p><p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p><h3 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h3><p>inline是C++新增的特性.</p><p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p><p>例如下面这个例子.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line">a = SQUARE(<span class="number">2.0</span>);</span><br><span class="line">b = SQUARE(<span class="number">3.2</span>++);</span><br><span class="line">c = SQUARE(<span class="number">1</span>+<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure><p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p><hr><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p><p>引用是为已定义的变量创建了一个别名．</p><p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p><p>引用变量通常的使用场景是作为函数的形参．</p><p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p><hr><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p><p>当&amp;为声明引用时可有这样的一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure><p>是否感觉跟指针有点相像呢？</p><p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p><p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p><p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"a-address:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b-address:"</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:1</span><br><span class="line">b:1</span><br><span class="line">a:2</span><br><span class="line">b:2</span><br><span class="line">a-address:0x7ffdd4c4ae74</span><br><span class="line">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure><p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p><p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p><p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a-address:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此时的&amp;代表的就是地址运算符。</p><p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,*p;</span><br><span class="line"><span class="keyword">int</span> b,*p2(&amp;b);</span><br><span class="line">*p = a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以编译通过的。</p><p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,&amp;b;</span><br><span class="line">    b = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码是这样，那么则编译不通过。</p><p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p><p>也就是说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure><p><strong>仅在表示上等同于</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">p</span><span class="params">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure><p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">int a(10),&amp;b(a);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">b = c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"c:"</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:10</span><br><span class="line">b:10</span><br><span class="line">c:20</span><br><span class="line">a:20</span><br><span class="line">b:20</span><br></pre></td></tr></table></figure><p>可以看到最初b引用的是a，但随后b作为c的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br></pre></td></tr></table></figure><p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p><p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = c;</span><br></pre></td></tr></table></figure><p>也就是说，这意味着”将c变量的值赋给a变量“。</p><p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p><p>下面有一段有趣的代码，你们可以看看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p =&amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;b = *p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">*p = &amp;c;</span><br></pre></td></tr></table></figure><p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p><h3 id="将"><a href="#将" class="headerlink" title="将"></a>将</h3>]]></content>
    
    <summary type="html">
    
      &lt;!--
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=544070223&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;
--&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="编程" scheme="https://evanmeek.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ManjaroLinux的安装过程</title>
    <link href="https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
    <id>https://evanmeek.github.io/2019/04/23/ManjaroLinux的安装过程/</id>
    <published>2019-04-23T08:37:18.000Z</published>
    <updated>2019-05-09T14:54:15.127Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/23/ManjaroLinux的安装过程/桌面.png" alt="桌面"></p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p><ul><li>XFCE </li></ul><p>特点</p><blockquote><p>系统资源低耗，快速</p></blockquote><ul><li>KDE</li></ul><p>特点</p><blockquote><p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p></blockquote><ul><li>GNOME</li></ul><p>特点</p><blockquote><p>简单易用，可定制化，美化较为简单，内存占用大</p></blockquote><p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/" target="_blank" rel="noopener">清华大学</a></li><li><a href="http://mirrors.ustc.edu.cn/manjaro-cd/" target="_blank" rel="noopener">中科大</a></li><li><a href="https://mirrors.huaweicloud.com/manjaro-cd/" target="_blank" rel="noopener">华为</a></li><li><a href="http://mirrors.zju.edu.cn/manjaro/" target="_blank" rel="noopener">浙江大学</a></li></ul><p>我们也可以直接使用官方的镜像源获取镜像<a href="https://manjaro.org/get-manjaro/" target="_blank" rel="noopener">Manjaro</a></p><p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p><strong>Windows:</strong></p><p>推荐使用<a href="https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe" target="_blank" rel="noopener">Rufus</a>进行制作启动盘。</p><p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p><p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p><hr><p><strong>Linux:</strong></p><p>只需要执行这几条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure><p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p><p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure><p>取消挂载之后就可以进行格式化了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure><p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure><p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png" alt="安装选择界面"></p><p><strong>keytable</strong>————设置键盘布局</p><p>通常默认即可</p><p><strong>lang</strong>————设置语言</p><p>设置为zh_CN，代表汉语</p><p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p><p>笔记本双显卡，想省电可以用free。</p><p>台式机单显卡，推荐nofree。</p><p><strong>Boot</strong>————选择这个就开始安装了</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/开始安装.png" alt="开始安装-01"></p><p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p><p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p><p>点击后还可以设置一次语言，默认为中文了</p><p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p><p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p><p>再下一步就是分区了，这一步是挺重要的，请认真看。</p><p>默认情况下有两种选项:</p><p><strong>抹除磁盘</strong></p><p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p><p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p><p><strong>手动分区</strong></p><p>选择手动分区之后，你将看到:</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/分区.png" alt="分区"></p><p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p><p>那比较简单(就算有多个也没啥)</p><p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p><p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p><p>然后你就点击吧…</p><p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p><blockquote><p>引导的挂载点: /boot/efi</p></blockquote><p>记得标记点为:boot 和 esp</p><blockquote><p>根目录的挂载点: /</p></blockquote><p>记得标记点为:root</p><blockquote><p>主目录的挂载点: /home</p></blockquote><p><img src="/2019/04/23/ManjaroLinux的安装过程/分区标识.png" alt="分区标识"></p><p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p><p>要注意的是主目录要选择扩展分区。</p><p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p><ul><li><p>用户名首字母不要大写</p></li><li><p>密码不要太简单</p></li></ul><p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/摘要.png" alt="摘要"></p><p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p><h2 id="设置镜像源"><a href="#设置镜像源" class="headerlink" title="设置镜像源"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p><h3 id="官方软件包源"><a href="#官方软件包源" class="headerlink" title="官方软件包源"></a>官方软件包源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class="line"><span class="meta">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>随便选一个就好，推荐中科大的(USTC).</p><h3 id="Aur软件包源"><a href="#Aur软件包源" class="headerlink" title="Aur软件包源"></a>Aur软件包源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>在最后一行输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>安装签名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><h3 id="npm国内源"><a href="#npm国内源" class="headerlink" title="npm国内源"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure><p>打开终端输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>测试是否成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure><p>如果看到上面这个链接就对了</p><h3 id="pip国内源"><a href="#pip国内源" class="headerlink" title="pip国内源"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p><p>(没有则创建)</p><p>修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p><p>你也可以使用其他的源</p><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">清华</a></p><p><a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">阿里云</a></p><p><a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">中国科技大学</a></p><p><a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">豆瓣</a></p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p><p>Install Yay</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure><p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p><p>Install Vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure><p>Install VSCode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure><p>Install OracleJDK8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure><p>Install 搜狗输入法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>再编辑配置文件~/.xprofile(若没有创建即可)</p><p>修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure><p>注销后就能使用搜狗输入法了</p><p>Install IDEA</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class="line"><span class="meta">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure><p>Install CLion</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S CLion</span><br></pre></td></tr></table></figure><p>Install 网易云音乐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure><p>Install Chrome</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><p>这样就能完成基本的日常使用啦~</p><h2 id="使用体验总结"><a href="#使用体验总结" class="headerlink" title="使用体验总结"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p><p>最终还是选择了Manjaro-kde</p><p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p><p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png" alt="Manjaro安装过程编写文章时截图"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/04/23/ManjaroLinux的安装过程/桌面.png&quot; alt=&quot;桌面&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/a&gt;获取镜像&lt;/h2&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="折腾" scheme="https://evanmeek.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="软件使用" scheme="https://evanmeek.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
