<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>今天你女装了吗？</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evanmeek.github.io/"/>
  <updated>2019-04-30T11:11:25.677Z</updated>
  <id>https://evanmeek.github.io/</id>
  
  <author>
    <name>EvanMeek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用hexo+github-pages搭建博客</title>
    <link href="https://evanmeek.github.io/2019/04/29/%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://evanmeek.github.io/2019/04/29/如何用hexo-github-pages搭建博客/</id>
    <published>2019-04-29T14:56:54.000Z</published>
    <updated>2019-04-30T11:11:25.677Z</updated>
    
    <content type="html"><![CDATA[<p><strong>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</strong></p><a id="more"></a><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg" alt="逆光"></p><h1 id="为何选择hexo"><a href="#为何选择hexo" class="headerlink" title="为何选择hexo"></a>为何选择hexo</h1><ul><li><p>hexo博客框架的网上资料较多，技术较为成熟.</p></li><li><p>hexo使用Makrdown进行渲染.</p></li><li><p>hexo只需几部就可部署博客.</p></li><li><p>hexo具有丰富的主题/插件可选.</p></li></ul><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><h2 id="安装Nodejs-Git"><a href="#安装Nodejs-Git" class="headerlink" title="安装Nodejs,Git"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p><p>大部分发行版自带Git,Nodejs只需要一条命令:</p><p><strong>apt</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure><p><strong>pacman</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure><h2 id="配置Nodejs"><a href="#配置Nodejs" class="headerlink" title="配置Nodejs"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p><p>在任意目录下执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm config get registry</span><br></pre></td></tr></table></figure><h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><h3 id="注册Github"><a href="#注册Github" class="headerlink" title="注册Github"></a><strong>注册Github</strong></h3><p><a href="https://github.com/join" target="_blank" rel="noopener">注册Github</a></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a><strong>创建仓库</strong></h3><p><a href="https://github.com/new" target="_blank" rel="noopener">创建Github仓库</a></p><p>注意: 仓库名必须是<strong>name.github.io</strong></p><p>例如我的 evanmeek.github.io</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png" alt="创建Github仓库"></p><p>需要设置两点:</p><ul><li>Git身份标识</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.email "你的邮箱"</span><br><span class="line"><span class="meta">$</span> git config --global user.name "你的名字"</span><br></pre></td></tr></table></figure><p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p><ul><li>SSH密钥</li></ul><p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure><p>若没有则创建新的密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "你的邮箱"</span><br></pre></td></tr></table></figure><p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p><p>创建完成后，你会在~/.ssh内看到两个文件</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png" alt="ssh目录"></p><p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p><p>下一步则是需要在Github中添加刚刚生成的密钥</p><p>首先登陆Github,打开设置.</p><p>如图所示：</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png" alt="登陆Github"></p><p>下一步找到SSH选项</p><p>如图所示：</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png" alt="设置SSH"></p><p>下一步导入公钥</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png" alt="导入密钥"></p><p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="安装hexo-1"><a href="#安装hexo-1" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p><p><strong>要使用sudo提权</strong></p><p>执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>看到Done!之后则为安装成功.</p><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="初始化hexo博客"><a href="#初始化hexo博客" class="headerlink" title="初始化hexo博客"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png" alt="hexoinit"></p><p>初始化完成之后目录结构大概是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>下面分别讲下这些文件或目录分别存放了些什么。</p><p>主配置文件: <strong>_config.yml</strong></p><blockquote><p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p></blockquote><p>插件信息: <strong>package.json</strong></p><blockquote><p>包含了当前hexo博客中安装了哪些插件.</p></blockquote><p>模板目录: <strong>scaffolds/</strong></p><blockquote><p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p></blockquote><p>资源目录: <strong>source/</strong></p><blockquote><p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p></blockquote><p>主题目录: <strong>themes/</strong></p><blockquote><p>主题目录，所有的主题都丢在这里。</p></blockquote><hr><h2 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo n "文章名"</span><br></pre></td></tr></table></figure><p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p><p>这一步用于生成静态文件(就是把md转为html的操作)</p><p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo generate</span><br></pre></td></tr></table></figure><p>这个命令可以简化，并且还可以带两个参数</p><p>简化+参数:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p><hr><h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p><p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p><p>找到deploy项</p><p>修改为:</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png" alt="deploy"></p><hr><h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p><p><strong>本地部署</strong></p><p>执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo s</span><br></pre></td></tr></table></figure><p>执行完后可以通过localhost:4000进行<a href="localhost:4000" target="_blank" rel="noopener">查看</a>.</p><p><img src="/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png" alt="本地部署"></p><p><strong>部署到Github</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo d</span><br></pre></td></tr></table></figure><p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p><h1 id="寻找主题"><a href="#寻找主题" class="headerlink" title="寻找主题"></a>寻找主题</h1><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题</a></p><p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href="mailto:the_lty_mail@foxmail.com" target="_blank" rel="noopener">the_lty_mail@foxmail.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记录" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hexo" scheme="https://evanmeek.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://evanmeek.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客文章插入图片</title>
    <link href="https://evanmeek.github.io/2019/04/29/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>https://evanmeek.github.io/2019/04/29/hexo博客文章插入图片/</id>
    <published>2019-04-29T07:15:29.000Z</published>
    <updated>2019-04-29T08:43:07.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p><a id="more"></a><h1 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>如果安装速度很慢可以把npm源改为国内源。</p><p><a href="https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/">点击打开npm源改为国内源的方法</a></p><p>在设置镜像源-&gt;npm国内源下</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p><p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p><p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo n "test"</span><br><span class="line"><span class="meta">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure><p>插入图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址)</span><br><span class="line"></span><br><span class="line"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记录" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hexo" scheme="https://evanmeek.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++函数探幽</title>
    <link href="https://evanmeek.github.io/2019/04/24/C-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/"/>
    <id>https://evanmeek.github.io/2019/04/24/C-函数探幽/</id>
    <published>2019-04-23T22:38:43.000Z</published>
    <updated>2019-04-29T09:49:28.980Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本章内容</strong></p><ul><li>内联函数</li><li>引用变量</li><li>如何按引用传递函数参数</li><li>默认参数</li><li>函数重载</li><li>函数模板</li><li>函数模板具体化</li></ul><p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p><hr><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3></blockquote><p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p><p>那么，我们现在就深入到程序内部．</p><p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p><p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p><p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p><p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p><p><strong>所以</strong></p><p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p><p>相当于编译器将使用相应的函数代码替换函数调用．</p><p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p><p><strong>但是</strong></p><p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p><p><strong>结论</strong></p><p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p><p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p><p>_除非_　:该函数被经常调用</p><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3></blockquote><p>使用内联函数只需要做到以下两点即可：</p><ul><li><p>在函数声明前加上关键字<strong>inline</strong>;</p></li><li><p>在函数定义前加上关键字<strong>inline</strong>;</p></li></ul><p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p><p><strong>可能遇到的问题</strong></p><p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p><ul><li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p></li><li><p>有些编译器没有启动或实现这种特性．</p></li></ul><blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    double a(2.0), b(5.0), c(0);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">" \tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    square(a);</span><br><span class="line">    b = square(b);</span><br><span class="line">    c = square(<span class="number">7</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时a=2b=5c=0</span><br><span class="line">此时a=4b=25c=64</span><br></pre></td></tr></table></figure><p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p><p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p><p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p><p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p><p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p><h3 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h3><p>inline是C++新增的特性.</p><p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p><p>例如下面这个例子.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line">a = SQUARE(<span class="number">2.0</span>);</span><br><span class="line">b = SQUARE(<span class="number">3.2</span>++);</span><br><span class="line">c = SQUARE(<span class="number">1</span>+<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure><p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p><hr><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p><p>引用是为已定义的变量创建了一个别名．</p><p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p><p>引用变量通常的使用场景是作为函数的形参．</p><p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p><hr><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p><p>当&amp;为声明引用时可有这样的一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure><p>是否感觉跟指针有点相像呢？</p><p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p><p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p><p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"a-address:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b-address:"</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:1</span><br><span class="line">b:1</span><br><span class="line">a:2</span><br><span class="line">b:2</span><br><span class="line">a-address:0x7ffdd4c4ae74</span><br><span class="line">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure><p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p><p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p><p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a-address:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此时的&amp;代表的就是地址运算符。</p><p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,*p;</span><br><span class="line"><span class="keyword">int</span> b,*p2(&amp;b);</span><br><span class="line">*p = a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以编译通过的。</p><p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,&amp;b;</span><br><span class="line">    b = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码是这样，那么则编译不通过。</p><p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p><p>也就是说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure><p><strong>仅在表示上等同于</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">p</span><span class="params">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure><p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">int a(10),&amp;b(a);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">b = c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"c:"</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:10</span><br><span class="line">b:10</span><br><span class="line">c:20</span><br><span class="line">a:20</span><br><span class="line">b:20</span><br></pre></td></tr></table></figure><p>可以看到最初b引用的是a，但随后b作为c的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br></pre></td></tr></table></figure><p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p><p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = c;</span><br></pre></td></tr></table></figure><p>也就是说，这意味着”将c变量的值赋给a变量“。</p><p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p><p>下面有一段有趣的代码，你们可以看看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p =&amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;b = *p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">*p = &amp;c;</span><br></pre></td></tr></table></figure><p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本章内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内联函数&lt;/li&gt;
&lt;li&gt;引用变量&lt;/li&gt;
&lt;li&gt;如何按引用传递函数参数&lt;/li&gt;
&lt;li&gt;默认参数&lt;/li&gt;
&lt;li&gt;函数重载&lt;/li&gt;
&lt;li&gt;函数模板&lt;/li&gt;
&lt;li&gt;函数模板具体化&lt;/li
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://evanmeek.github.io/tags/C/"/>
    
      <category term="编程" scheme="https://evanmeek.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ManjaroLinux的安装过程</title>
    <link href="https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
    <id>https://evanmeek.github.io/2019/04/23/ManjaroLinux的安装过程/</id>
    <published>2019-04-23T08:37:18.000Z</published>
    <updated>2019-04-29T09:49:28.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/23/ManjaroLinux的安装过程/桌面.png" alt="桌面"></p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p><ul><li>XFCE </li></ul><p>特点</p><blockquote><p>系统资源低耗，快速</p></blockquote><ul><li>KDE</li></ul><p>特点</p><blockquote><p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p></blockquote><ul><li>GNOME</li></ul><p>特点</p><blockquote><p>简单易用，可定制化，美化较为简单，内存占用大</p></blockquote><p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/" target="_blank" rel="noopener">清华大学</a></li><li><a href="http://mirrors.ustc.edu.cn/manjaro-cd/" target="_blank" rel="noopener">中科大</a></li><li><a href="https://mirrors.huaweicloud.com/manjaro-cd/" target="_blank" rel="noopener">华为</a></li><li><a href="http://mirrors.zju.edu.cn/manjaro/" target="_blank" rel="noopener">浙江大学</a></li></ul><p>我们也可以直接使用官方的镜像源获取镜像<a href="https://manjaro.org/get-manjaro/" target="_blank" rel="noopener">Manjaro</a></p><p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p><strong>Windows:</strong></p><p>推荐使用<a href="https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe" target="_blank" rel="noopener">Rufus</a>进行制作启动盘。</p><p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p><p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p><hr><p><strong>Linux:</strong></p><p>只需要执行这几条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure><p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p><p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure><p>取消挂载之后就可以进行格式化了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure><p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure><p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png" alt="安装选择界面"></p><p><strong>keytable</strong>————设置键盘布局</p><p>通常默认即可</p><p><strong>lang</strong>————设置语言</p><p>设置为zh_CN，代表汉语</p><p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p><p>笔记本双显卡，想省电可以用free。</p><p>台式机单显卡，推荐nofree。</p><p><strong>Boot</strong>————选择这个就开始安装了</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/开始安装.png" alt="开始安装-01"></p><p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p><p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p><p>点击后还可以设置一次语言，默认为中文了</p><p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p><p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p><p>再下一步就是分区了，这一步是挺重要的，请认真看。</p><p>默认情况下有两种选项:</p><p><strong>抹除磁盘</strong></p><p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p><p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p><p><strong>手动分区</strong></p><p>选择手动分区之后，你将看到:</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/分区.png" alt="分区"></p><p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p><p>那比较简单(就算有多个也没啥)</p><p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p><p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p><p>然后你就点击吧…</p><p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p><blockquote><p>引导的挂载点: /boot/efi</p></blockquote><p>记得标记点为:boot 和 esp</p><blockquote><p>根目录的挂载点: /</p></blockquote><p>记得标记点为:root</p><blockquote><p>主目录的挂载点: /home</p></blockquote><p><img src="/2019/04/23/ManjaroLinux的安装过程/分区标识.png" alt="分区标识"></p><p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p><p>要注意的是主目录要选择扩展分区。</p><p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p><ul><li><p>用户名首字母不要大写</p></li><li><p>密码不要太简单</p></li></ul><p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/摘要.png" alt="摘要"></p><p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p><h2 id="设置镜像源"><a href="#设置镜像源" class="headerlink" title="设置镜像源"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p><h3 id="官方软件包源"><a href="#官方软件包源" class="headerlink" title="官方软件包源"></a>官方软件包源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class="line"><span class="meta">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>随便选一个就好，推荐中科大的(USTC).</p><h3 id="Aur软件包源"><a href="#Aur软件包源" class="headerlink" title="Aur软件包源"></a>Aur软件包源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>在最后一行输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>安装签名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><h3 id="npm国内源"><a href="#npm国内源" class="headerlink" title="npm国内源"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure><p>打开终端输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>测试是否成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure><p>如果看到上面这个链接就对了</p><h3 id="pip国内源"><a href="#pip国内源" class="headerlink" title="pip国内源"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p><p>(没有则创建)</p><p>修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p><p>你也可以使用其他的源</p><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">清华</a></p><p><a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">阿里云</a></p><p><a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">中国科技大学</a></p><p><a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">豆瓣</a></p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p><p>Install Yay</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure><p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p><p>Install Vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure><p>Install VSCode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure><p>Install OracleJDK8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure><p>Install 搜狗输入法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>再编辑配置文件~/.xprofile(若没有创建即可)</p><p>修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure><p>注销后就能使用搜狗输入法了</p><p>Install IDEA</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class="line"><span class="meta">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure><p>Install CLion</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yay -S CLion</span><br></pre></td></tr></table></figure><p>Install 网易云音乐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure><p>Install Chrome</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><p>这样就能完成基本的日常使用啦~</p><h2 id="使用体验总结"><a href="#使用体验总结" class="headerlink" title="使用体验总结"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p><p>最终还是选择了Manjaro-kde</p><p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p><p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p><p><img src="/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png" alt="Manjaro安装过程编写文章时截图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/04/23/ManjaroLinux的安装过程/桌面.png&quot; alt=&quot;桌面&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/a&gt;获取镜像&lt;/h2&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="折腾" scheme="https://evanmeek.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="软件使用" scheme="https://evanmeek.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
