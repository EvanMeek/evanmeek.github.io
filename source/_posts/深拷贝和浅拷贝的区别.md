---
title: 深拷贝和浅拷贝的区别
copyright: true
date: 2019-05-14 22:55:24
categories: 学习笔记
tags:
 - C++
 - 经典案例
---

虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。

<!--more-->

# 浅拷贝

我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。

**那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。**

那什么是拷贝构造函数呢?

**拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象**

下面看个例子:

~~~C++
#include <iostream>

using namespace std;

class Human {
public:
    string name;
    int age;

    //默认构造函数
    Human() {
        cout << "Human默认构造函数调用." << endl;
    }

    //有参构造函数
    Human(string f_name, int f_age) {
        name = f_name;
        age = f_age;
        cout << "Human有参构造函数调用." << endl;
    }

    //析构函数
    ~Human() {
        cout << "Human析构函数调用." << endl;
    }
};

int main() {
    Human h1("李四", 18);
    cout << h1.name << "的年龄为:" << h1.age << endl;
    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2
    Human h2(h1);
    cout << h2.name << "的年龄为:" << h2.age << endl;
    return 0;
}
~~~

输出结果为:

~~~
Human有参构造函数调用.
李四的年龄为:18
李四的年龄为:18
Human析构函数调用.
Human析构函数调用.

Process finished with exit code 0
~~~

根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，**这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。**

浅拷贝的具体代码实现是怎样的呢？请看下面的代码:

~~~C++
    //默认的拷贝构造函数
    Human(const Human & h){
        name = h.name;
        age = h.age;
    }
~~~

可与看出，它只是简单的将对象属性的值，进行拷贝。

大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？

答案是否定的，下面看下深拷贝。


# 深拷贝

什么是深拷贝?

**深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.**

下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:

~~~C++
#include <iostream>

using namespace std;

class Human {
public:
    string name;
    int *age;

    //默认构造函数
    Human() {
        cout << "Human默认构造函数调用." << endl;
    }

    //有参构造函数
    Human(string f_name, int f_age) {
        name = f_name;
        //动态分配内存空间，将age的数据存入堆区
        age = new int(f_age);
        cout << "Human有参构造函数调用." << endl;
    }

    //析构函数
    ~Human() {
        //如果age指针变量是空，则释放
        if(age !=NULL){
            delete age;
            //防止指针变量成为野指针
            age = NULL;
        }
        cout << "Human析构函数调用." << endl;
    }
};

int main() {
    Human h1("李四", 18);
    cout << h1.name << "的年龄为:" <<*h1.age << endl;
    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2
    Human h2(h1);
    cout << h2.name << "的年龄为:" <<*h2.age << endl;
    return 0;
}
~~~

输出结果为:

~~~
free(): double free detected in tcache 2
Human有参构造函数调用.
李四的年龄为:18
李四的年龄为:18
Human析构函数调用.

Process finished with exit code 134 (interrupted by signal 6: SIGABRT)
~~~

通过输出结果，我们发现，程序发生了错误。

因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。

上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。

由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。

然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。

既然问题找到了，我们就需要进行修改，将这个问题解决。

下面通过深拷贝的方式，让这个bug被修复:

~~~C++
#include <iostream>

using namespace std;

class Human {
public:
    string name;
    int *age;

    //默认构造函数
    Human() {
        cout << "Human默认构造函数调用." << endl;
    }

    //有参构造函数
    Human(string f_name, int f_age) {
        name = f_name;
        //动态分配内存空间，将age的数据存入堆区
        age = new int(f_age);
        cout << "Human有参构造函数调用." << endl;
    }

    //拷贝构造函数
    Human(const Human & h){
        name = h.name;
        //新开辟内存空间到堆区，存放age所指向的数据。
        age = new int(*h.age);
        cout<<"Human拷贝构造函数调用."<<endl;
    }

    //析构函数
    ~Human() {
        //如果age指针变量是空，则释放
        if(age !=NULL){
            delete age;
            //防止指针变量成为野指针
            age = NULL;
        }
        cout << "Human析构函数调用." << endl;
    }
};

int main() {
    Human h1("李四", 18);
    cout << h1.name << "的年龄为:" <<*h1.age << endl;
    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2
    Human h2(h1);
    cout << h2.name << "的年龄为:" <<*h2.age << endl;
    return 0;
}
~~~

输出结果为:

~~~
Human有参构造函数调用.
李四的年龄为:18
Human拷贝构造函数调用.
李四的年龄为:18
Human析构函数调用.
Human析构函数调用.

Process finished with exit code 0
~~~

程序没有报错，说明我们的bug成功解决了。

上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。

深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。

为什么能避免？

原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。

# 两者该如何选择?

**说得绝对点：**

若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。

这时需要使用深拷贝。

**说的不那么绝对:**

若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。
