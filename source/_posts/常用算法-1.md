---
title: 常用算法-1
copyright: true
date: 2019-05-27 12:14:16
categories: 学习笔记
tags:
  - 算法
---

这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.

<!--more-->

# 常用算法

> 本页理解几个常用的算法

---

## 冒泡排序

**冒泡排序是一种稳定的排序算法**
> 稳定即是，如果相邻的元素相同，不会再去进行调换位置

冒排的运作是(从后往前)。

我们操作数组来进行演示。

我们首先定义一个整型数组里面存储几个整型数据

```Java
//待排序的数列
int[] nums = {9,6,4,3,10,25};
```

>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。

**每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。**

我们尝试先用大脑来演示排序的过程
```
//未排序时
9 6 4 3 10 25

6 9 3 4 10 25 //第一轮 调换了2次
6 3 4 9 10 //第二轮 调换了2次
3 4 6 9 //第三轮 调换了2次
3 4 6 //第四轮 调换了0次
3 4 //第五轮 调换了0次
```

我们可以看到我们这组数据只需要排序三轮就可以排序成功，**排序轮数是数组长度-1轮**，调换次数是看数组相邻元素的大小关系，这个我们不用知道，__我们只需要记住，排序轮数是数组长度-1就好。__

那么在代码中我们要如何将其进行调换呢？

有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。

> 了解了基本思路，我们直接进行代码编写吧！

```Java
public class Demo{
    public static void main(String args[]){
        //待排序的数列
        int[] nums = {9,6,4,3,10,25};
        //临时变量，用于调换位置
        int temp;
        //第一层循环，控制轮数
        for(int i = 0;i <nums.length;i++){
            //第二层，控制每轮要进行排序的元素数量
            for(int j = 0;j<nums.length-1-i;j++){
                //如果当前元素比后一个元素大那么则调换元素值
                if(nums[j]>nums[j+1]){
                    //我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖
                    temp = nums[j+1];
                    //把当前元素的值覆盖后一个元素
                    nums[j+1] = nums[j];
                    //再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)
                    nums[j] = temp;
                }
            }
        }
        //遍历输出
        for(int num:nums){
            System.out.println(num);
        }
    }
}
```

刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。

**引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码**

```Java
    /*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/

    //这个if不用加，我只是让你们知道是哪些代码
    if(nums[j]>nums[j+1]){
        //当前元素的值是与后一个元素值的和
        nums[j] = nums[j]+nums[j+1];

        //上一行代码等同于 nums[j] = 9 + 6
        //执行完上一行代码，nums[j] = 15;

        //执行完此行代码nums[j+1] = 9
        //等价于 nums[j+1]= 15 - 6
        nums[j+1] = nums[j]-nums[j+1];

        //执行完此行代码nums[j] = 6
        //等价于 nums[j] = 15 - 9
        nums[j] = nums[j] - nums[j+1];
    }
```

第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！


下一记: **选择排序算法**

---

## 选择排序算法

> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。

上面这个引用是网上随便抄的一个思路。

这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。

我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。

下面我们直接看代码

```Java
public class Main {
    public static void main(String[] args) {
        //需要排序的数组
        int[] nums = {6, 9, 4, 4, 25, 10};
        //记录每轮排序时最小元素的下标
        int minIndex;
        //第一层循环控制轮数
        for (int i = 0; i < nums.length - 1; i++) {
            minIndex = i;//假设当前轮最小元素下标为i
            //内层循环要记录出当前轮最小元素的下标
            for (int j = i + 1; j < nums.length; j++) {
                //比较两个相邻元素的大小
                if (nums[minIndex] > nums[j]) {
                    //由于找到新的最小值，所以记录一下
                    minIndex = j;
                }
            }
            //如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置
            if (minIndex != i) {
                //下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大
                nums[minIndex] += nums[i];
                nums[i] = nums[minIndex] - nums[i];
                nums[minIndex] -= nums[i];
            }
        }
        //遍历输出排序后的结果
        for (int num : nums) {
            System.out.println(num);
        }
    }
}
```

小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。

下一节，二分查找算法

---

## 二分查找法

> 这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。

二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:

- 定义起始查找位，结束查找位
- 求得数组长度中间值都
- 如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。
- 如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。
- 如果要查找的值等于中间值，那么直接返回中间值的下标即可
- 如果都没找到，那么返回-1.

看了这个概念，我们还得注意几点

需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。

好了，我们直接看代码吧！

```Java
public class Main {
    public static void main(String[] args) {
        int nums[] = {1,3,5,78,90,100,300};
        System.out.println(binarySearch(nums,1));
    }
    /**
     * 二分查找法
     * @param nums　要查找的数列
     * @param key　要查找的值
     * @return
     */
    static int binarySearch(int[] nums,int key){
        //起始下标
        int start = 0;
        //结束下标
        int end = nums.length-1;
        //起始查询的下标不能超过结束下标
        while(start<=end){
            //中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值
            int middle = (start+end)/2;
            //如果中间下标的值比要查找的值大
            if(nums[middle]>key){
                //要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找
                end = middle-1;
            }else if(nums[middle]<key){
                //二分的右边开始查找
                start = middle+1;
            }else{
                //如果要查找的值就是二分下标的值，那么直接返回即可
                return middle;
            }
        }
        //如果没有查找到那么则返回-1代表没有查找到
        return -1;
    }
}
```

---
