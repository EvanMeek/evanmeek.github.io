---
title: C++函数探幽
date: 2019-04-24 06:38:43
categories: 学习笔记
tags:
  - C++
  - 编程
---

**本章内容**
- 内联函数
- 引用变量
- 如何按引用传递函数参数
- 默认参数
- 函数重载
- 函数模板
- 函数模板具体化

本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．

---

## C++内联函数

> ### **说明**

内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．

那么，我们现在就深入到程序内部．

首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．

当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．

执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．

那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．


**所以**

C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．

相当于编译器将使用相应的函数代码替换函数调用．

对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．

**但是**

虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．

**结论**

我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．

另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．

_除非_　:该函数被经常调用

> ### **使用**

使用内联函数只需要做到以下两点即可：

- 在函数声明前加上关键字**inline**;

- 在函数定义前加上关键字**inline**;

通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．

**可能遇到的问题**

在我们编写函数为内联函数时，编译器不一定满足这种要求．

- 编译器认为该函数过大或识别到函数调用了自己 ***(内联函数不能递归)*** .

- 有些编译器没有启动或实现这种特性．

> ### **案例**

~~~C++

#include <iostream>

using namespace std;

inline double square(double x) { return x * x; }

int main() {
    double a(2.0), b(5.0), c(0);
    cout << "此时a=" << a << "\tb=" << b << " \tc=" << c << endl;
    square(a);
    b = square(b);
    c = square(7 + 1);
    cout << "此时a=" << a << "\tb=" << b << "\tc=" << c << endl;
    return 0;
}

~~~

该程序的输出为:

~~~
此时a=2	b=5	c=0
此时a=4	b=25	c=64
~~~

看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．

也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.

**这使得C++的内联功能远远胜过C语言的宏定义**

__尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.__

__这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参__

### 内联与宏

inline是C++新增的特性.

C语言使用预处理语句#define来提供宏－－内联代码的原始实现．

例如下面这个例子.

~~~C
#define SQUARE(X) X*X

a = SQUARE(2.0);
b = SQUARE(3.2++);
c = SQUARE(1+2.3);
~~~

上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．

---

## 引用变量

引用变量是C++新增的一种复合类型.

引用是为已定义的变量创建了一个别名．

例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.

引用变量通常的使用场景是作为函数的形参．

通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．

---

### 创建引用变量

C++使用 **&** 用于声明引用，但是它还有另外一个作用：地址运算符。

当&为声明引用时可有这样的一个例子:

~~~C++
int a;
int & b = a;
~~~

是否感觉跟指针有点相像呢？

是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&是指指向int的引用。

上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。

下面再看一个例子，你将懂得C++中使用&时引用和地址运算符的区别。

~~~C++
#include <iostream>

using namespace std;

int main(){
	int a=1;
	int & b = a;

	cout<<"a:"<<a<<endl;
	cout<<"b:"<<b<<endl;

	b = 2;

	cout<<"a:"<<a<<endl;
	cout<<"b:"<<b<<endl;

        cout<<"a-address:"<<&a<<endl;
        cout<<"b-address:"<<&b<<endl;
	return 0;
}
~~~

输出结果为:

~~~
a:1
b:1
a:2
b:2
a-address:0x7ffdd4c4ae74
b-address:0x7ffdd4c4ae74
~~~

首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。

然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。

再然后，我们输出的不是a和b的值了而是输出它们的地址:

~~~C++
cout<<"a-address:"<<&a<<endl;
~~~

此时的&代表的就是地址运算符。

经过上面的一些小例子，读者们可能认为C++中&为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。

~~~C++
#include <iostream>

using namespace std;

int main(){
	int a,*p;
	int b,*p2(&b);
	*p = a;
	return 0;
}
~~~

上述代码是可以编译通过的。

**指针在声明时编译器允许不为其进行初始化值**

~~~C++
#include <iostream>

using namespace std;

int main(){
    int a,&b;
    b = a;
    return 0;
}
~~~

如果代码是这样，那么则编译不通过。

**我们可以把引用看成cosnt指针**，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。

也就是说：

~~~C++
int a,&b(a);
~~~

**仅在表示上等同于**

~~~C++
int a;
const int *p(&a);
~~~

上面提到“仅在表示上等同于“为什么呢，请看下面的例子。

~~~C++
#include <iostream>

using namespace std;

int main(){
	int a(10),&b(a);
	cout<<"a:"<<a<<endl;
	cout<<"b:"<<b<<endl;
	int c(20);
	b = c;
	cout<<"c:"<<c<<endl;
	cout<<"a:"<<a<<endl;
	cout<<"b:"<<b<<endl;
	return 0;
}
~~~

输出结果为:

~~~
a:10
b:10
c:20
a:20
b:20
~~~

可以看到最初b引用的是a，但随后b作为c的引用：

~~~C++
b = c;
~~~

**这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.**

我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:

~~~C++
a = c;
~~~

也就是说，这意味着”将c变量的值赋给a变量“。

简而言之，**可以通过初始化声明来设置引用，但不能通过赋值来设置。**

下面有一段有趣的代码，你们可以看看。

~~~C++
int a(10);
int *p =&a;
int &b = *p;
int c(20);
*p = &c;
~~~

上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。
