---
title: 《GNU Emacs Lisp编程入门》读书笔记
copyright: true
date: 2019-12-21 16:17:25
categories: Lisp
tags:
 - EmacsLisp
---

借了本Elisp的书，不厚，200多页，大概一周就能看完吧!

<!--more-->

# 第一章 列表处理 #

列表是Lisp的基础。

## Lisp列表 ##
### 介绍 ###

简单的Lisp列表书写形式:

``` emacs-lisp
'(rose violet daisy buttercup) ;; => (rose violet daisy buttercup)
```

这个简单的列表中的四个元素时四种不同花的名称。**元素之间用空格隔开，并且被括号包住。**

另有一种在elisp中常用到的写法:

 
```emacs-lisp
(+ 2 2) ;; => 4
```

这种写法是Lisp的一个特性————**数据和代码都用相同的方式表示**。

**列表还允许嵌套列表，也就是说列表的元素也可以是列表**。

### Lisp原子 ###


原子意味着"不可再分"。例如刚刚列表内的'2'或者是'rose'等等，这些都是原子。

而列表却不是原子，因为**列表是由CAR和CDR与CONS构成的**。

技术上说，Lisp的列表有三种组合方式:
  * 括号和括号中由空格分隔的原子
  * 括号和括号中的其他列表
  * 括号和括号中的其他列表和原子

**一个列表可以仅有一个原子或完全没有原子**

无任何原子的列表称作空列表: `()`。你可以把空列表看为原子或列表。

*原子和列表可以被称为**符号表达式**(symbolic expression)，又可称为**S-表达式** *。

Lisp编程几乎都是关于列表中的符号的(且有时是关于数字的).

**双引号中的文本，都是单个原子**:`'(Info "Name:EvanMeek Age:18 Sex:Men**)`

这种被双引号括起来的文本叫做**字符串(string)**。

### 列表中的空格 ###

Lisp中括号的数量无关紧要。下面两个的列表是完全相同的。

括号多
``` emacs-lisp
'(1 2 3 4      5       6) ;; => (1 2 3 4 5 6)
```

括号少
``` emacs-lisp
'(1 2 3 4 5 6) ;; => (1 2 3 4 5 6)
```

适当的在列表中加入一些空格以及换行符可以提高可读性。


### GNU Emacs帮助你输入列表 ###

在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用`Tab`按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是`C-M-\`

并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。

有兴趣的可以看下这个知乎提问。<https://www.zhihu.com/question/356026550>

## 运行一个程序 ##

如果你想运行一段Lisp程序，那么计算机可能会做三种事:
* 只返回列表本身;
* 提示出错信息;
* 将列表中第一个符号作为要执行的命令;
大多数情况，我们希望计算机做的是第三件事

前面我们看到过一些列表的前面有一个单引号"'"，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。

``` emacs-lisp
'(只是返回本身 即可) ;; => (只是返回本身 即可)
```

而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。

``` emacs-lisp
(+ 1 2 3 4) ;; => 10
```

Emacs中可以将光标放置一对S-表达式后按 `C-x C-e`就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 `mini buffer`。

也可以对原子(没有被括号括起来)求值

## 产生错误消息 ##

编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。

下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。

``` emacs-lisp
(Just Error!) ;; => Symbol's function definition is void: Just
```
这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将`(Just Error!)`当成类似`(+ 1 2)`这种列表进行求值，但由于后者的第一个元素"+"是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素"Just"是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。


 ##

我们已经讨论过一些符号或函数，例如"+"。就以"+"为例子，当我们对`(+ 2 2)`表达式求值时，计算机并不是执行的"+"这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把"+"改为"Plus"。





## Lisp解释器 ##

下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。
* 首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。
* 若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。
* 若没有则提示错误消息。
以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。

* 第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。
* 第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。
* 第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。

否则Lisp解释器将会从左往右依次执行。

### 字节编译 ###

Lisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。

被编译成字节码后的源码叫做elc，可以通过命令`(byte-compile-file)`进行编译。


## 求值 ##

前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。

解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。

解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。

### 对一个内部列表求值

上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。

下面通过一个例子了解这个求值的过程。

``` emacs-lisp
(+ 1 (+ 2 3))
```

我们知道使用快捷键`C-x C-e`可以对一个表达式求值，那么我们将光标放置`(+ 2 3)`表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值`5`，那么再将光标放置整个表达式之后，按下快捷键得到返回值`6`。这就很好的解释了Lisp解释器对嵌套列表的求值过程。

我们可以通过快捷键`C-h k`然后键入`C-x C-e`查看这个快捷键所对应的符号(命令\函数)，也就是`eval-last-sexp`。 这个函数的作用是**对最近的一个表达式进行求值，并且将结果打印至输出区域**。





## 变量 ##

其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)?

**在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)**，并且符号的值是可变的，我们把一个有值的符号称为变量。

前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。**Lisp的符号可以同时具有一个函数定义和一个值。**我们可以把这种概念想象成具有多个抽屉的柜子。

例如变量`fill-column`是一个有值的符号，对它求值可以获取自动换行的字符数。

任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。

`fill-column`只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。

``` emacs-lisp
(fill-column) ;; => Symbol's function definition is void: fill-column
```
这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。

### 符号无值时的错误信息 ###

下面我对一个没有赋值的符号进行求值。
``` emacs-lisp
(+ 2 2) ;; => 4
```
很显然，如果是在这个表达式右括号后执行`eval-last-sexp`将不会有任何问题，但我们现在将光标移动至`+`后，执行`eval-last-sexp`，会引发这个报错提示:`Symbol's value as variable void: +`。

这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于`+`的变量，只找到了函数定义，因为就报错了。

## 参量 ##

参量对应着`argument`，也就是其他语言中参数的意思。例如`(+ 2 3**`这个列表的参数就是`2`和`3`，而这个`+`则是函数，`+`允许由多个参量。

**不同的函数需要不同数目的参量，有些函数甚至不需要参量。**

### 参量的数据类型 ###

函数所接收的参量也是有数据类型的限制的，例如`+`函数就规定其参量的值必须是数字。

有些函数允许有任意数量个参量，例如`concat`函数，它将任意多个字符串类型的参量合并为一个字符串。

``` emacs-lisp
(concat "My name is:" "EvanMeek") ;; => "My name is: EvanMeek"
```

**请注意，`concat`函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。**

例如我们可以在`concat`的参量中写上`substring`函数。

``` emacs-lisp
(concat "Nice to meet " (substring "fuck you" 5 8))
```
上面的`concat`是一个参量必须都为字符串类型且任意数量的函数，而`substring`是一个可变数量参量且有多种参量类型的函数。
`substring`是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称`原子分裂机`。





### 作为变量和列表的值的参量 ###

> 上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。

这一节，我们将谈谈函数的参量还支持那些。

函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如:

``` emacs-lisp
;; 结果可能不同，取决于你的Emacs配置。
(+ 2 fill-column) ;; => 82
```

并且参量还可以是一个列表，例如:

``` emacs-lisp
(+ 2 (+ 3 (+ 4))) ;; =>  9
```


### 数目可变的参量 ###
前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的`+`函数:

``` emacs-lisp
(+) ;; => 0
(+ 2) ;; => 2
```
又或是`\*`函数:

``` emacs-lisp
(*) ;; => 1
(* 2) ;; => 2
```

所以它们都具有一个特性————参量数量可变。

``` emacs-lisp
(* 1 2 3) ;; => 66
(+ 1 2 3) ;; => 6
```



### 用一个错误类型的数据对象作为参量 ###

试想下，如果我们对函数提供了错误类型的参量会发生什么？

``` emacs-lisp
(+ 2 'hello) ;; => Wrong type argument: number-or-marker-p,hello
```
我们知道`+`函数的参量必须是数字，而我们传入的参量2的`'hello`被Lisp解释器操作时会试图将`2`和`'hello`的返回值相加，但是`'hello`的返回值不是一个数字，所以就会引发这个错误。

让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号`number-or-marker-p`这个符号意味着:Lisp解释器提示我们`+`函数的参量所需的数据类型，`number`也就是数字，而`marker`是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而`p`则是Lisp的一个历史问题(早期Lisp程序员中用"p"替代"predicate"用于表示是否为真)，类似的有`zerop`用于判断参量值是否为零。最后的`hello`则是我们传给`+`函数出错的参量的值。

### message函数 ###
`message`函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个`FORMAT STRING`(可格式化字符串)。

``` emacs-lisp
(message "Should you sleep now?") ;; => Should you sleep now?
```
双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。

``` emacs-lisp
(message "The name of this buffer is: %s" (buffer-name)) ;; => "The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md"
```
这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串`%s`，`message`函数的第二个参量的值将用于它，这个`%s`代表了接收一段字符传，类似的还有`%d`用于接收一个十进制数。

``` emacs-lisp
(message "The value of fill-column is %d" fill-column) ;; => "The value of fill-column is 80"
```

这些特殊子串都支持变量、列表或符号，例如：

``` emacs-lisp
(message "我想吃%s，各来%d斤!" (concat "苹果、" "梨子、" "葡萄") (+ 1 1)) ;; => "我想吃苹果、梨子、葡萄，各来2斤!"
```

从第二个参量开始将会一次取代第一个参量中特殊子串的位置。
