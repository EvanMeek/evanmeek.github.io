{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatPay.png","path":"images/wechatPay.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/dynamic_bg.js","path":"js/src/dynamic_bg.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/aliPay.png","path":"images/aliPay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/background.png","path":"images/background.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/card.png","path":"images/card.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/background2.png","path":"images/background2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/img.jpg","path":"images/img.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"27aa8fc6a4fd4146edd797dfcbb167a00bbf8664","modified":1579405791363},{"_id":"themes/next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1579405791413},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1579405791413},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1579405791413},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1579405791413},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1579405791413},{"_id":"themes/next/.gitignore","hash":"3558a8b174618c7a643aceb13233edd729813f9a","modified":1579405791413},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1579405791413},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1579405791413},{"_id":"themes/next/_config.yml","hash":"20eec61fc974bbd7bc1096174105465296ef3dc7","modified":1579405791413},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1579405791413},{"_id":"themes/next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1579405791413},{"_id":"themes/next/package.json","hash":"888bcacea284ec536a1428ad957a78dfb3ec255d","modified":1579405791417},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1579405791413},{"_id":"themes/next/bower.json","hash":"8fa4f26f5205cbc64d33318d1be5d35b2667398c","modified":1579405791413},{"_id":"themes/next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1579405791413},{"_id":"source/DoomEmacs/index.md","hash":"a60da2bbdd3278d9d6f105df0f8f0912aed14464","modified":1579405791363},{"_id":"source/categories/index.md","hash":"c253f6262eddb81f50f7e92baa7d4a0185acdbf2","modified":1579405791410},{"_id":"source/Linux/index.md","hash":"12d42624cb044a247076068a736bba6530f4832a","modified":1579405791363},{"_id":"source/Python/index.md","hash":"74e0a672981fe51924e066deff9766a7b802ab4f","modified":1579405791363},{"_id":"source/TODO/index.md","hash":"b03b4292d554a2956bacffd3ca71f5df51e55324","modified":1579405791363},{"_id":"source/_posts/2008年5月12日14时28分04秒.md","hash":"c5ea941e3cf7a39609098a2dd898c51c3a5bd0dd","modified":1579405791363},{"_id":"source/_posts/.DS_Store","hash":"12482962147843fd5479eab9ca741d26b7fd0f84","modified":1579405791363},{"_id":"source/_posts/2019年的规划.md","hash":"e1a6eeaac7854e8fbb7547a19addb2429a06d714","modified":1579405791363},{"_id":"source/_posts/C-内存四区之堆区.md","hash":"e15526c51ce83aae48d53fed6cfbafc4709f1432","modified":1579405791363},{"_id":"source/_posts/C-内存四区之代码区与全局区.md","hash":"83c3e9f6d0e2a8816edfbe6d1fe4a20f80a67bed","modified":1579405791363},{"_id":"source/_posts/Boring-Article.md","hash":"d7b0107b568ab3908568e0005624a7b223fc8997","modified":1579405791363},{"_id":"source/_posts/C-内存四区之栈区.md","hash":"b0672471c16c837a98ffff19eb7157d041f6288a","modified":1579405791367},{"_id":"source/_posts/C-函数探幽.md","hash":"2a87dc1c4e79a5ddaccb5ec6d63b672f6ca0966c","modified":1579405791367},{"_id":"source/_posts/C-友元.md","hash":"3b1582401978a7783c9cdad7fd084250221d764c","modified":1579405791367},{"_id":"source/_posts/C-指针-基础01.md","hash":"efe160c3d372e21f9859c3490b819fb0b7f5a381","modified":1579405791367},{"_id":"source/_posts/C-指针-基础02.md","hash":"5c33a68bef7c0ee36e11753bbd16a3c8a5ea450e","modified":1579405791367},{"_id":"source/_posts/Doom-Emacs-Tramp-Sending卡死问题.md","hash":"f4da01f264945f87a826c11a8d36a887f421d032","modified":1579660351588},{"_id":"source/_posts/C-的命名空间与作用域.md","hash":"e7541a53f2f0e02ae0667c23ba4510a3a3a3a837","modified":1579405791367},{"_id":"source/_posts/Fraudster-Shop-坑爹商店.md","hash":"1e838a323cb81eeb73398ab6f82ed7bbc526c724","modified":1579405791367},{"_id":"source/_posts/C-读写文件.md","hash":"9a7850229a5ffa7ff0f025b66d1a9cee48694796","modified":1579405791367},{"_id":"source/_posts/Emacs-is-sexy.md","hash":"1e81aaca501d79c2e0b6feb1cbc9b3e36d467bd5","modified":1579405791367},{"_id":"source/_posts/Do-you-know-Linux.md","hash":"9d89df01bedfd410e3bd3aa49a3a1d59edd25f6f","modified":1579405791367},{"_id":"source/_posts/Happiness-from-the-heart.md","hash":"0a9e1c48164684a98537060176532b8571a420f1","modified":1579405791367},{"_id":"source/_posts/FuShou-Mountain-Day-Trip.md","hash":"e2b767bb9d1e1875fd9ad618362942e63de25fb3","modified":1579405791367},{"_id":"source/_posts/Learn-Qt5-Qt模块简介.md","hash":"b8fec99cf4bca9c5a642c8e35a73bc840dda058a","modified":1579405791370},{"_id":"source/_posts/Learn-Qt5-HelloWorld.md","hash":"89630e4f7d4571f85dbb3c86c1ff2d8bd5c4c4aa","modified":1579405791367},{"_id":"source/_posts/Learn-Qt5-信号槽.md","hash":"7ad5053a4e308340b501ea13789f4b1dc4613f64","modified":1579405791370},{"_id":"source/_posts/Learn-Qt5-自定义信号槽.md","hash":"1b0e1dce8ce9fd4a1dcb3e9b22a7808ed519f069","modified":1579405791370},{"_id":"source/_posts/Linux-Linux命令行简介-man命令.md","hash":"941310704c0904abe71df533dd5cf0cd02b294cf","modified":1579405791370},{"_id":"source/_posts/Linux-文件和目录操作命令-1.md","hash":"293e26b0281855f53729ed6c45f4c1d79005305e","modified":1579405791370},{"_id":"source/_posts/Linux-Linux命令行简介-0.md","hash":"d3a67721f2aa3b0b04e7f18b4142c9bf26023e35","modified":1579405791370},{"_id":"source/_posts/Linux-文件和目录操作命令-find命令.md","hash":"37504f73abf2f404cb51f923a79d5eec0faafcaa","modified":1579405791370},{"_id":"source/_posts/Linux-文件过滤及内容编辑处理命令-2.md","hash":"08b16fa8251bf1428fff351128f905ffade0ea4f","modified":1579405791370},{"_id":"source/_posts/Linux-文本处理三剑客-3.md","hash":"b6a3d1184f54bcffcc91dddea12d9b0ef4304e7f","modified":1579405791370},{"_id":"source/_posts/Linux中的解压与压缩.md","hash":"315c8b0781112d2f49a59de124926b8e943ecda4","modified":1579405791370},{"_id":"source/_posts/Mac下安装Rust.md","hash":"9c04e3202068a24aee3c9639055524adfd4c3b73","modified":1579405791370},{"_id":"source/_posts/Mac下超好用的风扇控制与温度监控软件————TG-Pro.md","hash":"88dd7f49603ae2e7973b95e1f34744f6037c36fd","modified":1579405791370},{"_id":"source/_posts/ManjaroLinuxTG讨论群组.md","hash":"d07e8516f78dadabdd29ebef18cc96a715769420","modified":1579405791377},{"_id":"source/_posts/ManjaroLinux的安装过程.md","hash":"f4423ac85352f5c4c1c05cf3b4f0e7d1c07fdda7","modified":1579405791377},{"_id":"source/_posts/My-Monitor.md","hash":"21de167dc06f719b4db0dee96576283c571f7ea2","modified":1579405791383},{"_id":"source/_posts/MyCollegeLife.md","hash":"08bc930df78c488c9a9ca3c211cc9da78e35f1ad","modified":1579405791383},{"_id":"source/_posts/MyCuteSister-0.md","hash":"b8b4518dabe2cea0a8f64ceb4066ac70715e77c4","modified":1579405791383},{"_id":"source/_posts/MyCuteSister-1.md","hash":"d3170ba63ca06f5b50488cfe462da03417e31fde","modified":1579405791383},{"_id":"source/_posts/ProxyChains入门使用教程.md","hash":"5c819c62093da058028a3abd317e5f3debe596f2","modified":1579405791383},{"_id":"source/_posts/Python-01-Python教程基础.md","hash":"42f5d52b2274962a1e4a03bf5e9d23c4e0253839","modified":1579405791383},{"_id":"source/_posts/Python-02-Python初探.md","hash":"7be1f78d843bcad58804f3f4aa2327e2ad9669f8","modified":1579405791387},{"_id":"source/_posts/Python-03-Python变量类型和运算符.md","hash":"904341173301dbe2501783f16a1356251f484b8a","modified":1579405791390},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合.md","hash":"4548db895c049ebc7df9b1d5c41b16ad3be0251d","modified":1579405791390},{"_id":"source/_posts/Python-05-Python字符串常用方法详解.md","hash":"84bfc1f9f6e6364208ac0a4cae834fc355f9df28","modified":1579405791393},{"_id":"source/_posts/Python-07-Python函数和Lambda表达式.md","hash":"8ff170b448d7c96827853eea7971e6cb2b43d4bb","modified":1579405791393},{"_id":"source/_posts/Rust-理解所有权.md","hash":"e0119218bacb2e34ef7ea1a2eb6219259e2f72b1","modified":1579405791393},{"_id":"source/_posts/Python-06-Python流程控制.md","hash":"f87b703a57a9e3db7cedc061e55d517fc2f303e7","modified":1579405791393},{"_id":"source/_posts/Serimu-Lake-Day-Trip.md","hash":"55525445f07ce82ce74bcf3416fadb7fba3040a8","modified":1579405791393},{"_id":"source/_posts/The-process-of-purchasing-MacBook-Pro.md","hash":"2a995e0dd018102c401a727c1f42453af4f54996","modified":1579405791393},{"_id":"source/_posts/What-is-Vim.md","hash":"3adb8b532037717c8986ed801a62d1b218b0a0f5","modified":1579405791397},{"_id":"source/_posts/hexo-next插入网易云音乐.md","hash":"14e906fb89646ca557003f1e4dfd335e51bb2b62","modified":1579405791400},{"_id":"source/_posts/fcitx5安装与配置.md","hash":"ab5249c6f80a3f4ac8e2a17fedafd5766745379f","modified":1579405791397},{"_id":"source/_posts/hexo博客文章插入图片.md","hash":"558f15f9aba7a586f16cb3dc4b6be67043d88e0c","modified":1579405791400},{"_id":"source/_posts/使用两天MacBookPro真实感受.md","hash":"4c308b3a135bf4d0ebca5c2fce36f544e5edd11c","modified":1579405791400},{"_id":"source/_posts/功能强大-基于GPU加速-Kitty终端.md","hash":"a25003d41cb842e60450ee658c6986ef72c9e651","modified":1579405791400},{"_id":"source/_posts/参加广州LUG线下见面会.md","hash":"31fe90878c600d17f7d7fd4703cfa487f4125abc","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客.md","hash":"3914749b99ea79f5e84920cf507723692e986c71","modified":1579405791400},{"_id":"source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md","hash":"dc7e1da0e1a651487e8b6786ebafb691b525c67a","modified":1579565635418},{"_id":"source/_posts/如何自学编程.md","hash":"e10482035620aab36ee98acae72ed6b8b8e68fc2","modified":1579405791403},{"_id":"source/_posts/常用算法-1.md","hash":"bb94988d1671d648d275acad6031ebc2eca6437b","modified":1579405791403},{"_id":"source/_posts/我儿子的博客.md","hash":"f0af5adf03a78befaeded83a43f47d14bd1cbb65","modified":1579405791407},{"_id":"source/_posts/平铺式桌面-从入门到入坟.md","hash":"48fde747aa88d37ba74f804fb8453c047992af68","modified":1579405791403},{"_id":"source/_posts/我的Linux之路.md","hash":"98695246419a1381a04c23cf514995fe1f6cfba4","modified":1579405791407},{"_id":"source/_posts/我的VIM配置详解.md","hash":"e394bb2804377b945f0ebdf3001573184f7e93c8","modified":1579405791407},{"_id":"source/_posts/最快-GPU加速-Alacritty终端.md","hash":"d6af7877b2c3c013cb15884f4d0709b38da1236a","modified":1579405791407},{"_id":"source/_posts/深拷贝和浅拷贝的区别.md","hash":"4df9447000917c6f6f08e727f3b598e8ac01752b","modified":1579405791410},{"_id":"source/_posts/终端多窗口神器——Screen.md","hash":"b99e62af0cc6e8d128ed650502921f24c4459a24","modified":1579405791410},{"_id":"source/_posts/自我反省.md","hash":"57c00f4649c7e728340414080d727c7408cb99aa","modified":1579405791410},{"_id":"source/_posts/解决KDE下部分应用不能使用fctix中文输入法的问题.md","hash":"4c13009cf28143e7192350a99ebf3e89b0bfd5a9","modified":1579405791410},{"_id":"source/_posts/趣学Haskell-01.md","hash":"a6f799527d4cf7d0c7b15c84f7fef1dac8b694e4","modified":1579405791410},{"_id":"source/_posts/超酷-字符文件管理-ranger.md","hash":"b83998f688612269b88da2c997ed73ac4955a516","modified":1579405791410},{"_id":"source/_posts/读《笨方法学习VimScript》所学.md","hash":"6f8384d579f281d7321621f8028ee0ca781ce181","modified":1579405791410},{"_id":"source/关于我/index.md","hash":"79b4413771a55fb666ab8449a0dc4cba88b4a6dc","modified":1579405791410},{"_id":"source/tags/index.md","hash":"603136cef8b46b91aa07a80a7abd0716b1217709","modified":1579405791410},{"_id":"source/话/index.md","hash":"dc01aa3b205e69fc9a4bcdd3f259f9a4cadc4a24","modified":1579405791413},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1579405791413},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"492b2c159d871e5b5d4c70d259f36e603afe192d","modified":1579405791413},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"285a95aca36e0ac770bcde2b35e3b572d45d1518","modified":1579405791413},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1579405791413},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1579405791413},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1579405791413},{"_id":"themes/next/.github/release-drafter.yml","hash":"b4476ada5c62ee7d63ba2e59ead2ec4897086e3c","modified":1579405791413},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1579405791413},{"_id":"themes/next/.github/mergeable.yml","hash":"8e3a6abc74b5cba57f9586fe6d98762fd4fc9b04","modified":1579405791413},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1579405791413},{"_id":"themes/next/.github/weekly-digest.yml","hash":"404e4ccb7fcd6587bc9b0247a7a7ff256d21f2cb","modified":1579405791413},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1579405791413},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1579405791413},{"_id":"themes/next/layout/_layout.swig","hash":"42323c036d71e040bd018ecc52e07ce6b24c803f","modified":1579405791417},{"_id":"themes/next/.github/topissuebot.yml","hash":"10665bf2b5aba351725715c71e94ad183a0e8f18","modified":1579405791413},{"_id":"themes/next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1579405791417},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1579405791417},{"_id":"themes/next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1579405791417},{"_id":"themes/next/layout/page.swig","hash":"d8a6cbf6f611c5d68d5da430cb6dc7010ff2c7e0","modified":1579405791417},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1579405791417},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1579405791417},{"_id":"themes/next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1579405791417},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1579405791413},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1579405791413},{"_id":"themes/next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1579405791413},{"_id":"themes/next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1579405791413},{"_id":"themes/next/languages/fr.yml","hash":"7005c2b42c2c6e82bd7a1be5cc2f443b5fc79105","modified":1579405791413},{"_id":"themes/next/languages/es.yml","hash":"1752429687861b5cedd063c6ebe5dacefbe7e5a7","modified":1579405791413},{"_id":"themes/next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1579405791413},{"_id":"themes/next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1579405791413},{"_id":"themes/next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1579405791413},{"_id":"themes/next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1579405791413},{"_id":"themes/next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1579405791417},{"_id":"themes/next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1579405791417},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1579405791417},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1579405791417},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1579405791417},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1579405791417},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1579405791417},{"_id":"themes/next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1579405791417},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1579405791417},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1579405791413},{"_id":"themes/next/docs/AUTHORS.md","hash":"50286d088a30b3496bc837cce1bb38a6476dc93e","modified":1579405791413},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1579405791413},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1579405791413},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1579405791413},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1579405791413},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1579405791417},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1579405791417},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1579405791413},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1579405791413},{"_id":"themes/next/source/404.html","hash":"a5991bb3598c5d934bd97e3bc4ed14b71ebf1e62","modified":1579405791417},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1579405791413},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1579405791450},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1579405791450},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1579405791450},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579405791420},{"_id":"source/_posts/2008年5月12日14时28分04秒/空降.webp","hash":"9a4e00e6b4f76fcef94423bfa1910da06a01364f","modified":1579405791363},{"_id":"source/_posts/2008年5月12日14时28分04秒/操场.webp","hash":"84b7577e7d9c8c41cde1d1a41606d9077e4c682d","modified":1579405791363},{"_id":"source/_posts/C-内存四区之代码区与全局区/代码区示意图.png","hash":"2a6b0689ddce4a392d7682b7cc097553ba275324","modified":1579405791363},{"_id":"source/_posts/2008年5月12日14时28分04秒/流量图.webp","hash":"27c7ab59ae1f74cfea9a7cb67f9502ff3f4144be","modified":1579405791363},{"_id":"source/_posts/C-内存四区之堆区/test.png","hash":"23c51bc2893f2c2b8828d47a5d531ac10111c300","modified":1579405791363},{"_id":"source/_posts/C-读写文件/二进制文件.png","hash":"5fce0c55af8a1d1a375ab1dd71c7b06f3416e13c","modified":1579405791367},{"_id":"source/_posts/C-指针-基础02/指针位偏移.png","hash":"156676e17c34db6889b740035c5afebc560c79f4","modified":1579405791367},{"_id":"source/_posts/Linux-Linux命令行简介-0/1.1.2-0","hash":"8c8736d267902d23fd9defe497df7bb07e753d62","modified":1579405791370},{"_id":"source/_posts/The-process-of-purchasing-MacBook-Pro/配置图.jpg","hash":"794694e353179a1fca2e48a9e60a7bd0bd996743","modified":1579405791393},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/Python集合示意图.png","hash":"a097f730796a4912058a27ef012aae094020203a","modified":1579405791393},{"_id":"source/_posts/hexo-next插入网易云音乐/插哪.png","hash":"8928d6bd2393fb9cebf22a137d4f198a1bca8f1f","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/ssh目录.png","hash":"6929462dbbece6c66d66111337bc50954f3420e1","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/导入密钥.png","hash":"eb1ed1a6da91cf7a446f714ca7ad95edde7a4545","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/打开设置.png","hash":"a277cee3b835adfc37ce01e798a5302a5ae70e02","modified":1579405791400},{"_id":"source/_posts/终端多窗口神器——Screen/detachedInfo.png","hash":"39337b8922e262fb456a13464188e1d145199b97","modified":1579405791410},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1579405791413},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1579405791413},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1579405791413},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1579405791413},{"_id":"themes/next/layout/_partials/footer.swig","hash":"589f545333e21a8c7823bce89ab45cf1eb7db6e2","modified":1579405791417},{"_id":"themes/next/layout/_partials/comments.swig","hash":"09a01a124bc1cf4ba369fa6101f547906b68edc2","modified":1579405791417},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1579405791417},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1579405791417},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1579405791417},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1579405791417},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1579405791417},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"f29b50d83bcdc9e70696b6a8a8917d8b2ad4be10","modified":1579405791417},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1579405791417},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"b787d5c965ffe1a9cb8c3fbfa767f3a62bfe2ea0","modified":1579405791417},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1579405791417},{"_id":"themes/next/layout/_macro/post.swig","hash":"06c586ee180ee66989804dad666a7951c34f93fc","modified":1579405791417},{"_id":"themes/next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1579405791417},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1579405791417},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"23b9dacfac1e5a137b1f4687a3eddb5d2c0fc7bf","modified":1579405791417},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1579405791417},{"_id":"themes/next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1579405791417},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1579405791417},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1579405791417},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1579405791417},{"_id":"themes/next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1579405791417},{"_id":"themes/next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1579405791417},{"_id":"themes/next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1579405791417},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1579405791417},{"_id":"themes/next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1579405791417},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1579405791417},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1579405791417},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1579405791417},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1579405791417},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1579405791417},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1579405791417},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1579405791417},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1579405791417},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"83470eb401f78f4683907c48ad6760b90730daa3","modified":1579405791417},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1579405791417},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1579405791417},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"01ded5e1bad89a6f8d64cd063e3e4e42c20d33bc","modified":1579405791417},{"_id":"themes/next/layout/_third-party/chatra.swig","hash":"eefb68b69b4b0ed558ee0324ccd711990059b20d","modified":1579405791417},{"_id":"themes/next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1579405791417},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1579405791417},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1579405791417},{"_id":"themes/next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1579405791417},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1579405791417},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1579405791413},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1579405791417},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1579405791413},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1579405791413},{"_id":"themes/next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bc43beb3af74d64fbd3920539d08861e4cadb9a0","modified":1579405791413},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5db80e8d7ea3f29e998320f79508f7e14342a33c","modified":1579405791417},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b76ccbc658024e86639cfa5f8a3817647fc8d651","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/README.md","hash":"1b5bd6ae5781137d81dc8667e912d3df6eeab260","modified":1579405791413},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1579405791413},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1579405791417},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1579405791420},{"_id":"themes/next/source/css/style.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1579405791420},{"_id":"themes/next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1579405791420},{"_id":"themes/next/source/images/alipay.jpg","hash":"ac4b5bc8f3ae1a8a512b0d0663e2abf0bfea246d","modified":1579405791420},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1579405791420},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1579405791420},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1579405791433},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1579405791433},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1579405791433},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1579405791433},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1579405791433},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1579405791433},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1579405791433},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1579405791433},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1579405791433},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1579405791450},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579405791450},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579405791450},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1579405791450},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1579405791450},{"_id":"themes/next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1579405791450},{"_id":"themes/next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1579405791450},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1579405791450},{"_id":"themes/next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1579405791450},{"_id":"themes/next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1579405791450},{"_id":"themes/next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1579405791450},{"_id":"themes/next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1579405791450},{"_id":"themes/next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1579405791450},{"_id":"themes/next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1579405791450},{"_id":"themes/next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1579405791450},{"_id":"themes/next/source/js/utils.js","hash":"3c987de7cfb944c33e9e527f1214724c7aafc796","modified":1579405791450},{"_id":"source/_posts/ManjaroLinux的安装过程/分区.png","hash":"6a54d049cbfe3fc4d65d6a027b36ad758ed61b6c","modified":1579405791377},{"_id":"source/_posts/ManjaroLinux的安装过程/分区标识.png","hash":"675089cbcbe932471d6ce5c7b3a8671ee689c8c2","modified":1579405791377},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python位运算符.png","hash":"c933c9d40fb3d0f1dc2b65589a896f4775b8d9b3","modified":1579405791390},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python比较运算符.png","hash":"c933c9d40fb3d0f1dc2b65589a896f4775b8d9b3","modified":1579405791390},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python常用算术运算符.png","hash":"ea81e2bc21ec46b983868c7a094b9b41c4c84176","modified":1579405791390},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png","hash":"ee19d4324f0249e81bef83b4648d08d4c66021d3","modified":1579405791390},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/Python集合运算.png","hash":"ad1f29402fe7ee428252573f8791baddd87ea8c7","modified":1579405791393},{"_id":"source/_posts/hexo-next插入网易云音乐/01.png","hash":"f1bbad3d02ccb53b8898fc7ad337ef5ea368b2ae","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/deploy.png","hash":"e7b85d668727ff191542d33f0f8b7fd4626216d9","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/创建仓库.png","hash":"2008592b8eda92867b78f6deb69971dce00c7b13","modified":1579405791400},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/设置SSH.png","hash":"e9f200e3559e93a06fa4e8b9c37a486949081a45","modified":1579405791403},{"_id":"source/_posts/最快-GPU加速-Alacritty终端/error.png","hash":"3475f3657a4b6a5fa9fcacf8c82fe1472073034b","modified":1579405791407},{"_id":"source/_posts/终端多窗口神器——Screen/DefalutCommandKey.png","hash":"6a5a12569b253f7bec7087f7f6ad3eea3791218c","modified":1579405791410},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579405791420},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579405791420},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579405791420},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579405791420},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579405791420},{"_id":"themes/next/source/images/wechatPay.png","hash":"69539f4644858fc6e2fbeb6a5d187a7244c89506","modified":1579405791450},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"38959a2b517f6c0b7c851b288ed0339d9bc62f76","modified":1579405791450},{"_id":"source/_posts/ManjaroLinux的安装过程/安装选择界面.png","hash":"25d2152a8bb8e8e2eb904610ef7068576c9b7d11","modified":1579405791377},{"_id":"source/_posts/ManjaroLinux的安装过程/开始安装.png","hash":"2ac6b5ee42b758265b9c4d130d303e2050e8a929","modified":1579405791380},{"_id":"source/_posts/ManjaroLinux的安装过程/摘要.png","hash":"763ba8b64bc381afc7eb4b0166db36741399872a","modified":1579405791380},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python常用赋值运算符.png","hash":"bb80a58d7f6878e918f36adfd52853e3845488d0","modified":1579405791390},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python运算符优先级.png","hash":"c5d2ea6429f3003213a50c49b3b4f9a3fec7348a","modified":1579405791390},{"_id":"source/_posts/Python-02-Python初探/python2运行.png","hash":"a40cf03fc343c11f61830fdc6586c265a24a7421","modified":1579405791387},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/Python序列内置函数.png","hash":"aaf010d6f02c47b3519712bf3f6dd14a63a7dcbd","modified":1579405791393},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1579405791417},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1579405791417},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1579405791417},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1579405791417},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"6f19e5268201d166fc9246edd1b5d755fcad0471","modified":1579405791417},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1579405791417},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1579405791417},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1579405791417},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1579405791417},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1579405791417},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1579405791417},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1579405791417},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1579405791417},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1579405791417},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1579405791417},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1579405791417},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1579405791417},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1579405791417},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1579405791417},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1579405791417},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1579405791417},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1579405791417},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1579405791417},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1579405791417},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1579405791417},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1579405791417},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"d422beaf35a5d2646feaa098bc3e5adf691c7565","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1579405791417},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"c77a2e7ef5f449a445fb4d36b055721fba4a81af","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"388efc86af7f19c05ad0e26720cd24ee012d20b9","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"2cbaae65a020bbb0e9265364488aff8bf84fa48d","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1579405791417},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4a908b613518878b9b69576c5dba4a5185f552ab","modified":1579405791417},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1579405791417},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1579405791417},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1579405791417},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1579405791417},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1579405791417},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1579405791417},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1579405791420},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1579405791420},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"2036bbb73afd43251982ce824f06c6e88d35a2ef","modified":1579405791420},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"30c27ed8eeebedcba702a4cb7310a315f4149bcc","modified":1579405791420},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1579405791420},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1579405791420},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1579405791420},{"_id":"themes/next/source/css/_variables/base.styl","hash":"640f25a63770af5566ccc9cec79c40a4f1c0b29e","modified":1579405791420},{"_id":"themes/next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1579405791450},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1579405791450},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1579405791450},{"_id":"themes/next/source/js/src/dynamic_bg.js","hash":"1256018865f3c8a9cee5dbd2c3db6c9d72cd47e0","modified":1579405791450},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1579405791450},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1579405791450},{"_id":"source/_posts/如何自学编程/群组.png","hash":"41dcf8a1a81a79580dd7a9b35edd424d54c1e79d","modified":1579405791403},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1579405791450},{"_id":"source/_posts/fcitx5安装与配置/kcm.png","hash":"0ecc38623c9d9e5194317468e871c9176667f1df","modified":1579405791397},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/dict()函数创建字典.png","hash":"a70ba2696eff3256543bdb56180d001276b81437","modified":1579405791393},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/逆光.jpg","hash":"e31908ec199b23699ac587a1963a54bce16d362a","modified":1579405791403},{"_id":"source/_posts/我儿子的博客/预览.png","hash":"127d112dee5632a53e88a5e6888bd0acb94404ab","modified":1579405791407},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"fe5ff961b86004a306778c7d33a85b32e5e00e48","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"c8b3225396cb444d8baeb94bac78e5216b992a81","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"ea7ae16562c619a589bcddde57a061b883f6c6bc","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/gitment.styl","hash":"a22797865d5266e6f8560570c1e874bb87da552b","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1579405791420},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1579405791420},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1579405791420},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1579405791420},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"a5305a2fa0b03b1dc1dfd156bb1a590b4819f1f3","modified":1579405791420},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1579405791420},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"33456264a74d1bba38264d14713544d67d003733","modified":1579405791420},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"57044a6d19eb418c1c3d28787e82c69efa9e0ca6","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1579405791420},{"_id":"source/_posts/fcitx5安装与配置/输入.gif","hash":"5a875cd145cc0be553fbbd9f3b75ad6637efa0c1","modified":1579405791400},{"_id":"themes/next/source/images/aliPay.png","hash":"61750b1d63b30ca8ac5bcbec79664d541223b879","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"6c4990d375b640ee4551e62c48c1cbe4c3d62212","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e9dd8de7d98f1478ac7d351624fffd3d8738c905","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"1a510f995e665b28d85ba4d169b824276c40e4f3","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1579405791417},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"1385862a5c0bd845015d165aadbd1a6add7b72d7","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b082d07b13a3d55b4c032fd351dfa9a4fd74edec","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"473dd49e73f4356b93699904f4daa64c43bc2430","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"fcda60fecff1479adaf6521cf629cda2506337a8","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"f1d9ee1f86a179741f2478f8c70ca11ab578810e","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"03c4fa9573fddd930552784cf484fd2ee7825323","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cc83816614f21c7e1d8d3f867d547ff7c658cec4","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c01609176929590f8f347075a9a12b661acd661e","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1579405791420},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1579405791420},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1579405791420},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1579405791450},{"_id":"source/_posts/Learn-Qt5-HelloWorld/newProject.gif","hash":"1e02a369607b0aac39283e7779f54df5304f552d","modified":1579405791370},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/本地部署.png","hash":"0cfadb0ae6808ba58c821653ca76e8099819e98d","modified":1579405791403},{"_id":"source/_posts/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png","hash":"707bf8b1db79a27bf3ff12f1765d9b3b8f9f0803","modified":1579405791377},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/hexoinit.png","hash":"46b6d53a445cc3e15cc45ab9afd916486e3a5d7a","modified":1579405791400},{"_id":"source/_posts/最快-GPU加速-Alacritty终端/ponysay.png","hash":"98434022f4c023acb2033aa187531888da540de3","modified":1579405791410},{"_id":"source/_posts/ManjaroLinux的安装过程/编辑文章时截图.png","hash":"3557732a051927d718f9bdff7c4bd3f98a8bbe52","modified":1579405791383},{"_id":"source/_posts/Python-02-Python初探/python3运行.png","hash":"50299451bcc0cc7192c905c1686f8ef2c2d8b098","modified":1579405791390},{"_id":"source/_posts/超酷-字符文件管理-Ranger/ranger-pre.png","hash":"4f5871f3889bac4d6d1cc16435d3df721c0762f8","modified":1579405791410},{"_id":"source/_posts/Python-01-Python教程基础/Python知识体系框架.png","hash":"1a958d404040d05d684c98010013650c68ed73ac","modified":1579405791387},{"_id":"source/_posts/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png","hash":"458be78aaf2f28c9b20c84f5a866a1514b7992bb","modified":1579405791373},{"_id":"source/_posts/What-is-Vim/VIM.png","hash":"43d640a02b4f79ff640ddf9661cf3c4b10f870ad","modified":1579405791397},{"_id":"source/_posts/ManjaroLinux的安装过程/桌面.png","hash":"99a28838b2ba8cf7fdce7f3f997723c185326fdf","modified":1579405791380},{"_id":"source/_posts/平铺式桌面-从入门到入坟/桌面预览.png","hash":"6274db4e2b3c9743fc071721a87a4550d035a8ba","modified":1579405791407},{"_id":"themes/next/source/images/background.png","hash":"a0ec840a777b3b18ca80b71b3d23553311008191","modified":1579405791423},{"_id":"themes/next/source/images/card.png","hash":"08e8213581ac3fac8c119440a124643b05ef716a","modified":1579405791433},{"_id":"themes/next/source/images/background2.png","hash":"8611760e073872829af4a22dbeb38cd5ccf2144a","modified":1579405791430},{"_id":"themes/next/source/images/img.jpg","hash":"f84efb620744db1c422800669c4fcb852e03998d","modified":1579405791450},{"_id":"public/atom.xml","hash":"256b56a2e2a6c4c079e01c0cba3926c68257b9bc","modified":1579660363065},{"_id":"public/search.xml","hash":"770981a796cd7f386e6eb00d491ae85e55293687","modified":1579660363065},{"_id":"public/sitemap.xml","hash":"541527de20692df58cd749727c22a2e087f7cf97","modified":1579660363066},{"_id":"public/DoomEmacs/index.html","hash":"a69dcdf34a217e04f9e2e20062014396b8977643","modified":1579660363221},{"_id":"public/Linux/index.html","hash":"de7ef6979f4760771c76ed8694700904528cc007","modified":1579660363221},{"_id":"public/categories/index.html","hash":"4dadea81a7d7c028e79d874b8c011f8d1c2fa0bc","modified":1579660363221},{"_id":"public/Python/index.html","hash":"fa2596a511326d2515adca3aefdfc342edeec3ad","modified":1579660363221},{"_id":"public/TODO/index.html","hash":"0fcaead2acc95e0c5c4db7a5de09ae01bc68ac6f","modified":1579660363222},{"_id":"public/tags/index.html","hash":"667434adfffb1b34cc36845c8c8411c3da3b55ab","modified":1579660363222},{"_id":"public/关于我/index.html","hash":"16231e67ec364c861585f33d2127d75bb56717d2","modified":1579660363222},{"_id":"public/话/index.html","hash":"138c57b3b4e1ea6072b9f7bdb48b8949c4134812","modified":1579660363222},{"_id":"public/2020/01/07/ProxyChains入门使用教程/index.html","hash":"199e943bb27c73fdc3a6b580f9cd6056c37ef4c0","modified":1579660363222},{"_id":"public/2019/12/15/参加广州LUG线下见面会/index.html","hash":"591b9c52aaacf044999d60302440b9427ca0e33d","modified":1579660363222},{"_id":"public/2019/12/12/Linux-文本处理三剑客-3/index.html","hash":"c1a9f6aa12bd00ff058a631f9be394b52341f5a0","modified":1579660363222},{"_id":"public/2019/12/21/《GNU-Emacs-Lisp编程入门》读书笔记/index.html","hash":"dd59de8319409e2c2dd876750940a8abe7f8ada8","modified":1579660363222},{"_id":"public/2019/09/28/Python-06-Python流程控制/index.html","hash":"7be01145663ea1c4ba44c6d415ca1cc5f18b7b2e","modified":1579660363222},{"_id":"public/2019/09/27/读《笨方法学习VimScript》所学/index.html","hash":"bd16283174183cf4cd4fc3b827ce28a846ba9c73","modified":1579660363222},{"_id":"public/2019/10/09/Python-07-Python函数和Lambda表达式/index.html","hash":"850521ae4f54c4953a73d6f9887e001f0aa03aa8","modified":1579660363222},{"_id":"public/2019/09/26/功能强大-基于GPU加速-Kitty终端/index.html","hash":"486f486eec92249f86525342186fe9f5dc480a11","modified":1579660363222},{"_id":"public/2019/09/08/Python-04-Python列表、元组、字典和集合/index.html","hash":"27fabaf3d0138a94de2d298b4aabcf6d2aa679b2","modified":1579660363222},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/index.html","hash":"8ecd3c0a9c5e46641388954c7e03c5b9faf5b790","modified":1579660363222},{"_id":"public/2019/08/29/Python-02-Python初探/index.html","hash":"73c5b763f046788ca5627c94eaf7e4f60fb3f18e","modified":1579660363222},{"_id":"public/2019/08/29/Python-01-Python教程基础/index.html","hash":"51296eb20e0c3d40ae7a4b7c2f781217831a0345","modified":1579660363222},{"_id":"public/2019/09/26/趣学Haskell-01/index.html","hash":"bdf49d582fed3e4889d44fd9c72db08167a494fa","modified":1579660363222},{"_id":"public/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/index.html","hash":"6f8e8b66589be97bd9ec3ea6f042a38259772e02","modified":1579660363222},{"_id":"public/2019/08/20/Mac下安装Rust/index.html","hash":"8105cebec66241d33a32c5f3d9aa86d7e4c37bd5","modified":1579660363222},{"_id":"public/2019/09/23/自我反省/index.html","hash":"6fc45a255a4aa4f007192fc2da3d1341ea2cfc8a","modified":1579660363223},{"_id":"public/2019/08/02/The-process-of-purchasing-MacBook-Pro/index.html","hash":"a76aec1a51f106e946a5a65b47e6103919106e53","modified":1579660363223},{"_id":"public/2019/09/23/Python-05-Python字符串常用方法详解/index.html","hash":"37e4426baab70bf47ccc8160798007d20251630d","modified":1579660363223},{"_id":"public/2019/08/11/Happiness-from-the-heart/index.html","hash":"581994d5a24b7f0f7040247dd1955d5efaf0e20f","modified":1579660363223},{"_id":"public/2019/08/17/使用两天MacBookPro真实感受/index.html","hash":"ce42e0d89fbd2cbbb5c5d692e00564196dce7956","modified":1579660363223},{"_id":"public/2019/07/30/Rust-理解所有权/index.html","hash":"1934f21b9e73bf65744d6c1d1e3e422fbf2861ff","modified":1579660363223},{"_id":"public/2019/07/26/Emacs-is-sexy/index.html","hash":"53fafd7a5fd47959923feab2c6426a4eedf2c75e","modified":1579660363223},{"_id":"public/2019/07/23/FuShou-Mountain-Day-Trip/index.html","hash":"c487a526082b2bf8bde81a5a414cd67cb765d5f5","modified":1579660363223},{"_id":"public/2019/07/14/What-is-Vim/index.html","hash":"a42e42bffb47b171d2240aa3c3a231f4b8680f38","modified":1579660363223},{"_id":"public/2019/07/12/平铺式桌面-从入门到入坟/index.html","hash":"810cb4e55ba588a7867c833cb8525d99c9f22672","modified":1579660363223},{"_id":"public/2019/07/20/My-Monitor/index.html","hash":"6df12a35a30ab50cb9744d2795ea6d4f71b7a26d","modified":1579660363223},{"_id":"public/2019/07/20/Serimu-Lake-Day-Trip/index.html","hash":"26ed091c5630d2e370dfe1abe86e7a27f5ecf599","modified":1579660363223},{"_id":"public/2019/07/17/Do-you-know-Linux/index.html","hash":"097d001658c42fd6018178abe4306843177c7ef3","modified":1579660363223},{"_id":"public/2019/07/12/Boring-Article/index.html","hash":"8735359ff28ccb606fc608ca5be0b0904303db8c","modified":1579660363223},{"_id":"public/2019/07/10/MyCuteSister-1/index.html","hash":"ebd5a35e87c938d0a7e66126a0804e51933845ba","modified":1579660363223},{"_id":"public/2019/07/09/MyCuteSister-0/index.html","hash":"facaf85c6d6f31b0b666ebffa5011bfd412aace9","modified":1579660363223},{"_id":"public/2019/07/05/Fraudster-Shop-坑爹商店/index.html","hash":"4ef57d78fc354e3ab41dbc07c0f865f00617dc20","modified":1579660363223},{"_id":"public/2019/07/03/最快-GPU加速-Alacritty终端/index.html","hash":"3c94761e95a84d4eb36c1749994f5be7a45d22a2","modified":1579660363223},{"_id":"public/2019/07/05/MyCollegeLife/index.html","hash":"e264f0b9e9d66dbebeccf4c654667ae547789d6e","modified":1579660363223},{"_id":"public/2019/07/03/超酷-字符文件管理-ranger/index.html","hash":"3b466224667e6ee45748c01df74b4baf8f57e284","modified":1579660363224},{"_id":"public/2019/06/30/Linux-文件过滤及内容编辑处理命令-2/index.html","hash":"65a246c94215cc3fa5c523a33961dafd5e2ac69b","modified":1579660363224},{"_id":"public/2019/06/21/Linux-文件和目录操作命令-find命令/index.html","hash":"14fe10205e582c953e3c25226a3137cf0ee50128","modified":1579660363224},{"_id":"public/2019/06/21/我的VIM配置详解/index.html","hash":"9c2e8c143dc1d8b6bfef79ef34806256ea6cf437","modified":1579660363224},{"_id":"public/2019/06/15/Linux-Linux命令行简介-0/index.html","hash":"a64ac1131864326f74212ff7886c01a1d0ef67bc","modified":1579660363224},{"_id":"public/2019/06/14/fcitx5安装与配置/index.html","hash":"90a8b16f8b7c2e70a9dae632bc94403cc3460096","modified":1579660363224},{"_id":"public/2019/06/16/Linux-文件和目录操作命令-1/index.html","hash":"d64c33d028bc9d818e52a635f1687b63b9bc0e54","modified":1579660363224},{"_id":"public/2019/06/15/Linux-Linux命令行简介-man命令/index.html","hash":"1b4e28041b0cee1dd94b6c99bd5bf9f954137e02","modified":1579660363224},{"_id":"public/2019/06/12/Learn-Qt5-Qt模块简介/index.html","hash":"ef0f2ef41dca39ae31e2962c578e54e8a8b3b69d","modified":1579660363224},{"_id":"public/2019/06/08/Learn-Qt5-HelloWorld/index.html","hash":"a9cec722321149c069512b35a8570dfd34e24bec","modified":1579660363224},{"_id":"public/2019/06/09/2019年的规划/index.html","hash":"0ecf615e48a9316aecb203d734eb223d179e0bc2","modified":1579660363224},{"_id":"public/2019/06/11/Learn-Qt5-自定义信号槽/index.html","hash":"51eac916a0ca5dbc4641adecab09da83d35a12c7","modified":1579660363224},{"_id":"public/2019/06/10/Learn-Qt5-信号槽/index.html","hash":"2a01cf90910679eaeb2943338453d4c4a23c4a63","modified":1579660363224},{"_id":"public/2019/05/23/如何自学编程/index.html","hash":"4179ea8cd5dfc074e247419f17f2dbd4c2f6a9e7","modified":1579660363224},{"_id":"public/2019/05/22/C-读写文件/index.html","hash":"92c422fe144b6a804273dc42588e9d26577793dc","modified":1579660363224},{"_id":"public/2019/05/21/我儿子的博客/index.html","hash":"3b38e2df7eb06f201348d074977f18f116e25106","modified":1579660363224},{"_id":"public/2019/05/30/C-的命名空间与作用域/index.html","hash":"5693dba32b6639d6a8a143fd57232d75c0eb08dd","modified":1579660363224},{"_id":"public/2019/05/27/常用算法-1/index.html","hash":"977bcde908763e61756bd5ad2d26358cc94ebf96","modified":1579660363224},{"_id":"public/2019/05/19/解决KDE下部分应用不能使用fctix中文输入法的问题/index.html","hash":"3592256e9f2be9bb8444b0d59797074db8b63083","modified":1579660363224},{"_id":"public/2019/05/17/C-友元/index.html","hash":"796bb7ac569b72b82d483f2b277bdb651d36b78c","modified":1579660363224},{"_id":"public/2019/05/12/2008年5月12日14时28分04秒/index.html","hash":"dc0ba2356e207e4aa29d38f8be43b7e8ca331ff7","modified":1579660363225},{"_id":"public/2019/05/11/C-内存四区之代码区与全局区/index.html","hash":"05d4b4c265e403e2a9bc9c6044d228325d5c824e","modified":1579660363225},{"_id":"public/2019/05/10/C-内存四区之堆区/index.html","hash":"caf40590dadc673a59276431853d3a1cd90d6aa1","modified":1579660363225},{"_id":"public/2019/05/16/ManjaroLinuxTG讨论群组/index.html","hash":"ea8635300b63c1dae923217732abee6f005da762","modified":1579660363225},{"_id":"public/2019/05/15/我的Linux之路/index.html","hash":"2417342a74f1cabde432d42e41144f3cf1fa2440","modified":1579660363225},{"_id":"public/2019/05/09/终端多窗口神器——Screen/index.html","hash":"93ecd6321fdcea17417e5766df5b1bdfaa733d85","modified":1579660363225},{"_id":"public/2019/05/06/C-指针-基础02/index.html","hash":"b12dfbcab9399aa912ab9c971c00309b32b9ef88","modified":1579660363225},{"_id":"public/2019/05/10/C-内存四区之栈区/index.html","hash":"d540ed25047ede238fd2f0db5011403826c7b12e","modified":1579660363225},{"_id":"public/2019/05/14/深拷贝和浅拷贝的区别/index.html","hash":"ed23884f9bf52c93a1fd2cfb731a8e04c006b7ac","modified":1579660363225},{"_id":"public/2019/05/06/C-指针-基础01/index.html","hash":"4d3d98dfbcaf26ee3d90f3838f128725882e3379","modified":1579660363225},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/index.html","hash":"4575f6a53b54d6a63543b047979fcf61a3c68b44","modified":1579660363225},{"_id":"public/2019/04/30/hexo-next插入网易云音乐/index.html","hash":"af557b2ec6e892bc05d562c1a823729252891e85","modified":1579660363225},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/index.html","hash":"2780c60db728cb7d0aa4cd693d3fac672e6dc6c8","modified":1579660363225},{"_id":"public/2019/05/08/Linux中的解压与压缩/index.html","hash":"ea457c5abb3e65d1603e6204f6dc7cfa76b16f37","modified":1579660363225},{"_id":"public/2019/04/29/hexo博客文章插入图片/index.html","hash":"55d6d4ff3db10e8c594278afde6e33b497a63f58","modified":1579660363225},{"_id":"public/archives/index.html","hash":"216080cc8ea0a03ae97dc1228f74cc0aa00bc42a","modified":1579660363225},{"_id":"public/2019/04/24/C-函数探幽/index.html","hash":"34561ed9b2d48ebfa7593cea90263714117b5d3d","modified":1579660363225},{"_id":"public/archives/page/2/index.html","hash":"85052f44de6fe91dc3f61f0f3148acaed6472f79","modified":1579660363225},{"_id":"public/archives/page/5/index.html","hash":"1f4ca24efcbb85cf0fe4852875809cc6302a42da","modified":1579660363226},{"_id":"public/archives/page/3/index.html","hash":"e6f92d486f66f1ab5a177e6ced77b7bd26c2826b","modified":1579660363226},{"_id":"public/archives/page/4/index.html","hash":"5565c94445625f6f844a3957c3bb9d7363272306","modified":1579660363226},{"_id":"public/archives/2019/index.html","hash":"02f1a875e6064ba3ec7bc66205a748198995580b","modified":1579660363226},{"_id":"public/archives/page/6/index.html","hash":"d72f17841139f148a5e881bcbbdd9ccb3eeac113","modified":1579660363226},{"_id":"public/archives/page/7/index.html","hash":"6b1d0e21ea6addacab05bfb973def4f5240d3222","modified":1579660363226},{"_id":"public/archives/2019/page/3/index.html","hash":"07177b686058207c2df0d32df5bf56e6ee61fcf8","modified":1579660363226},{"_id":"public/archives/2019/page/2/index.html","hash":"48af7e72ce1c2943fd4e563fef49d9c0dcda5895","modified":1579660363226},{"_id":"public/archives/2019/page/4/index.html","hash":"7a7b461a3eac45f749f12bbe78f863f13e6c4482","modified":1579660363226},{"_id":"public/archives/2019/page/5/index.html","hash":"de3e59d1009d21aff5dbcc66e1e1781761b3d51c","modified":1579660363226},{"_id":"public/archives/2019/page/6/index.html","hash":"ac00f05c7af9a5cc653bba1dd9f90340f3c5b610","modified":1579660363226},{"_id":"public/archives/2019/04/index.html","hash":"60aabca5613ed454f44055e6319a4709da4d6dc7","modified":1579660363226},{"_id":"public/archives/2019/page/7/index.html","hash":"b1b735df569122dac8d041a4d3def4433b3e66d2","modified":1579660363226},{"_id":"public/archives/2019/05/index.html","hash":"43b01853ac827fe61842830af9a64d2e07d99d2d","modified":1579660363226},{"_id":"public/archives/2019/06/index.html","hash":"9e3fd49a141e055f30cdb96d8b80c4741358d785","modified":1579660363226},{"_id":"public/archives/2019/07/index.html","hash":"e9f5f340e932adfe2fafb80a0e5db6bb9be77b8a","modified":1579660363227},{"_id":"public/archives/2019/05/page/2/index.html","hash":"1c45a502069034a8b6a34b6d1510c9d7d718848c","modified":1579660363228},{"_id":"public/archives/2019/08/index.html","hash":"1881f15e4c25d689feb83785cce367b37670129f","modified":1579660363228},{"_id":"public/archives/2019/09/index.html","hash":"be9a206e6933fd7f9e46b8c5599e4f20e00951bc","modified":1579660363228},{"_id":"public/archives/2019/07/page/2/index.html","hash":"7fbccb3422d1baed216a1dd8cd7c4ac700e338f5","modified":1579660363228},{"_id":"public/archives/2019/10/index.html","hash":"8394c35076ffeb002c958b7776461eb044b43cb6","modified":1579660363228},{"_id":"public/archives/2019/06/page/2/index.html","hash":"5840874d45d01bb8aefc015c21d369fa3da909f3","modified":1579660363228},{"_id":"public/archives/2019/12/index.html","hash":"526525ec12d0f5f4ed9033164b4e63c2fd727419","modified":1579660363228},{"_id":"public/archives/2020/index.html","hash":"e1b2e7d34a391bf7ad436af7ff4f3319ade3a266","modified":1579660363228},{"_id":"public/categories/转载/index.html","hash":"df24895e230ca1f81fe770c353e50b71759a8335","modified":1579660363228},{"_id":"public/categories/分享/index.html","hash":"653f773f2959b595090b24a8acd278be7a3d536a","modified":1579660363228},{"_id":"public/categories/学习笔记/index.html","hash":"204e8b30a7bf37f342a1a3c0699ffb7f48fec04e","modified":1579660363229},{"_id":"public/archives/2020/01/index.html","hash":"60d8ce139cf19b281190a5ef5ca2c965a32c2789","modified":1579660363229},{"_id":"public/categories/英文文章/index.html","hash":"bd890287289ce077497d3f04886a1b277c597c8a","modified":1579660363229},{"_id":"public/categories/学习笔记/page/3/index.html","hash":"6309c94df8236ff898098ebd672fd28a00dc3f9b","modified":1579660363229},{"_id":"public/categories/学习笔记/page/2/index.html","hash":"85c737247ea8efd39feb0b0b114f33398360628d","modified":1579660363229},{"_id":"public/categories/Linux系列/index.html","hash":"37e3eaec818a8f97b5d06ebdecd41bc94f47bb6d","modified":1579660363229},{"_id":"public/categories/折腾日记/index.html","hash":"92ecb858efc19829f187c3e6d889e2ec8a46daae","modified":1579660363229},{"_id":"public/categories/软件分享/index.html","hash":"44061606ccd2967f4b97b2101f74cd1d392a5424","modified":1579660363229},{"_id":"public/categories/英文文章/page/2/index.html","hash":"5e29b21ad5b9cef5f1766027fbdb06f52b248420","modified":1579660363229},{"_id":"public/categories/Python/index.html","hash":"70cd404b6563c8f1e604faeb20dee9d091a593c7","modified":1579660363229},{"_id":"public/categories/折腾记录/index.html","hash":"4162f4cf1a3aea7f921901d1cde9bbfaee48454a","modified":1579660363229},{"_id":"public/categories/个人感想/index.html","hash":"cb5d719f84e1da3fdcda2895314dfa50f907f55f","modified":1579660363229},{"_id":"public/index.html","hash":"fbb187013e48cd4c45dadf0c23d7805cc509a17b","modified":1579660363230},{"_id":"public/categories/Lisp/index.html","hash":"7893ea477e33437210b20e0885e36283c1894747","modified":1579660363230},{"_id":"public/categories/折腾日志/index.html","hash":"5ebb7281d238a151aeff8712679d6dff9883c29b","modified":1579660363230},{"_id":"public/categories/学习记录/index.html","hash":"420c80b76240ed5d51b91361ed662bdaddfac765","modified":1579660363230},{"_id":"public/page/4/index.html","hash":"0613f919d7d1c3193c5fb704c771410d5bf7357d","modified":1579660363230},{"_id":"public/page/5/index.html","hash":"a219949fb131cd092e68173d2b254096e8e1c1e2","modified":1579660363230},{"_id":"public/page/2/index.html","hash":"0b26fd7a310d0c5ce9fe7d4c75dd4e99f05588e4","modified":1579660363230},{"_id":"public/page/3/index.html","hash":"335974963e0c973b9e4ba10552714f3ea81fd0c7","modified":1579660363230},{"_id":"public/page/6/index.html","hash":"bd57bc6f233c95674c6f22f432c4f62f9cebe7f7","modified":1579660363230},{"_id":"public/page/7/index.html","hash":"4797729749c5bc9e9fae9a296f219349acf255c2","modified":1579660363230},{"_id":"public/tags/社会事件/index.html","hash":"58f64adcc668dd5cf6a56a8d287a2f9fb410d3b5","modified":1579660363230},{"_id":"public/tags/C/index.html","hash":"be342fda820bfe4838ee5a74475992c700fa9d6e","modified":1579660363230},{"_id":"public/tags/个人感想/index.html","hash":"d8f4f45f3425a7e65e765e10831ec5459ae4b80a","modified":1579660363230},{"_id":"public/tags/编程/index.html","hash":"4ef6cbf10c450cc9d0311732551648d7a5a5e285","modified":1579660363230},{"_id":"public/tags/指针/index.html","hash":"a0281fca3fafe29fc50d5fe70a18a2eb204ff900","modified":1579660363231},{"_id":"public/tags/C/page/2/index.html","hash":"2ae4cb82263b5a626b4dd81ce30446c92d79b303","modified":1579660363231},{"_id":"public/tags/学习笔记/index.html","hash":"af13d8cc64bcf1d811df99f66152925b61b646c4","modified":1579660363231},{"_id":"public/tags/个人感想/page/2/index.html","hash":"b534040a2a0324ae47d931134df27803c47c8add","modified":1579660363231},{"_id":"public/tags/基础/index.html","hash":"7cccfc4aabb332e40a140558e84e03bbd6e705a4","modified":1579660363231},{"_id":"public/tags/转载/index.html","hash":"cacebcf200a76575f543d92c107fa33767d2e690","modified":1579660363231},{"_id":"public/tags/日常/index.html","hash":"cda4115e7430e6e6a087a4aefa42daa9954aaab4","modified":1579660363231},{"_id":"public/tags/Qt5/index.html","hash":"7386a514d8ea7097393fc1124f4f29f1c005bdf5","modified":1579660363231},{"_id":"public/tags/Qt/index.html","hash":"112af02afdbf652ad14bc83a16465ff267d1fefd","modified":1579660363231},{"_id":"public/tags/Linux/index.html","hash":"a1d8207775b1939d6b2f96b8a0872c2becfd183c","modified":1579660363231},{"_id":"public/tags/Rust/index.html","hash":"c65805e14dcff3b5095aa3f47e606cdcc2e558d5","modified":1579660363231},{"_id":"public/tags/软件分享/index.html","hash":"6861a31052905f3c71635ec72b8131159a47dacb","modified":1579660363231},{"_id":"public/tags/Telegram/index.html","hash":"96bf7ec09928d106529ef30768320988e774949a","modified":1579660363231},{"_id":"public/tags/软件使用/index.html","hash":"fa60aad19b7ea26958b766c2eac40033e017b1e8","modified":1579660363231},{"_id":"public/tags/折腾/index.html","hash":"66240f5d83244fe7bce2d0b944d6f1c9c40f65bf","modified":1579660363231},{"_id":"public/tags/Linux/page/2/index.html","hash":"cfe9c9530f022eb24c1ec4c2fdc3981be273a307","modified":1579660363231},{"_id":"public/tags/Python系列/index.html","hash":"5985b2cc757de97a4ef3a1edde4354c576a44854","modified":1579660363231},{"_id":"public/tags/购物体验/index.html","hash":"f8bab2683f7a13acc1375bbe3cf11d00a49e4a38","modified":1579660363231},{"_id":"public/tags/VIM/index.html","hash":"347a164e5d0442a3b40ce1f4f37c16f3a8d359ca","modified":1579660363231},{"_id":"public/tags/hexo/index.html","hash":"70b7087517022e4a457afbaffa1800b7337b8d6d","modified":1579660363231},{"_id":"public/tags/fcitx5/index.html","hash":"7b93b0f43d8de0d7fecf343fc0d9148eeb2ff278","modified":1579660363231},{"_id":"public/tags/软件折腾/index.html","hash":"5b4c9d2ab8764dc7d6676fe363fa590e17a62b15","modified":1579660363231},{"_id":"public/tags/网易云音乐/index.html","hash":"a24c79ee654c103e36c4b2fdfbe3791fecb802cb","modified":1579660363232},{"_id":"public/tags/博客/index.html","hash":"4d343f7031de23f4e8c9579d85b37b514720a5e5","modified":1579660363232},{"_id":"public/tags/EmacsLisp/index.html","hash":"a840f6943c7658044c1d8893d32cce5e9786f61d","modified":1579660363232},{"_id":"public/tags/欢乐时光/index.html","hash":"589fdfce470eca979f04554072b8ba4abb41f724","modified":1579660363232},{"_id":"public/tags/i3/index.html","hash":"3d7bd11702bfb63840bf92eb90e1c79a102ca119","modified":1579660363232},{"_id":"public/tags/算法/index.html","hash":"ec3725db08ceed7a147066570fa6c92c06c73727","modified":1579660363232},{"_id":"public/tags/经典案例/index.html","hash":"4e40e8e1518df8f22d33fbcd9de4151cf4f65bcc","modified":1579660363232},{"_id":"public/tags/KDE/index.html","hash":"759c072248ef87a9a94c1be7c11ba17ca920c55e","modified":1579660363232},{"_id":"public/tags/Vim/index.html","hash":"326a46ac81a6db526e9c793c1cda0861e1015652","modified":1579660363232},{"_id":"public/2020/01/22/Doom-Emacs-Tramp-Sending卡死问题/index.html","hash":"e352142e2bc868876f27b2ac236ed9a3ed6cbaf9","modified":1579660363239},{"_id":"public/archives/page/8/index.html","hash":"67f55afbe1373eca0c00ecb6f676c3f9f7b1fb65","modified":1579660363239},{"_id":"public/page/8/index.html","hash":"7bc7bc6c95c8fa0216bdc3911b722d73fa517cd0","modified":1579660363239},{"_id":"public/tags/Emacs/index.html","hash":"d1c52505ebeb5edb8dcbcbb26975c0b4dc72726d","modified":1579660363239},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1579660363239},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1579660363239},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1579660363239},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1579660363239},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1579660363239},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1579660363239},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1579660363239},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1579660363239},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1579660363240},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1579660363240},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1579660363240},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1579660363240},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1579660363240},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579660363240},{"_id":"public/images/alipay.jpg","hash":"ac4b5bc8f3ae1a8a512b0d0663e2abf0bfea246d","modified":1579660363240},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1579660363240},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579660363240},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1579660363240},{"_id":"public/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1579660363240},{"_id":"public/2019/05/10/C-内存四区之堆区/test.png","hash":"23c51bc2893f2c2b8828d47a5d531ac10111c300","modified":1579660363240},{"_id":"public/2019/05/06/C-指针-基础02/指针位偏移.png","hash":"156676e17c34db6889b740035c5afebc560c79f4","modified":1579660363240},{"_id":"public/2019/05/22/C-读写文件/二进制文件.png","hash":"5fce0c55af8a1d1a375ab1dd71c7b06f3416e13c","modified":1579660363240},{"_id":"public/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png","hash":"2a6b0689ddce4a392d7682b7cc097553ba275324","modified":1579660363240},{"_id":"public/2019/06/15/Linux-Linux命令行简介-0/1.1.2-0","hash":"8c8736d267902d23fd9defe497df7bb07e753d62","modified":1579660363240},{"_id":"public/2019/08/02/The-process-of-purchasing-MacBook-Pro/配置图.jpg","hash":"794694e353179a1fca2e48a9e60a7bd0bd996743","modified":1579660363240},{"_id":"public/2019/04/30/hexo-next插入网易云音乐/插哪.png","hash":"8928d6bd2393fb9cebf22a137d4f198a1bca8f1f","modified":1579660363240},{"_id":"public/2019/05/09/终端多窗口神器——Screen/detachedInfo.png","hash":"39337b8922e262fb456a13464188e1d145199b97","modified":1579660363537},{"_id":"public/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合示意图.png","hash":"a097f730796a4912058a27ef012aae094020203a","modified":1579660363537},{"_id":"public/2019/05/12/2008年5月12日14时28分04秒/流量图.webp","hash":"27c7ab59ae1f74cfea9a7cb67f9502ff3f4144be","modified":1579660363539},{"_id":"public/2019/05/12/2008年5月12日14时28分04秒/空降.webp","hash":"9a4e00e6b4f76fcef94423bfa1910da06a01364f","modified":1579660363539},{"_id":"public/2019/05/12/2008年5月12日14时28分04秒/操场.webp","hash":"84b7577e7d9c8c41cde1d1a41606d9077e4c682d","modified":1579660363539},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png","hash":"e7b85d668727ff191542d33f0f8b7fd4626216d9","modified":1579660363539},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png","hash":"6929462dbbece6c66d66111337bc50954f3420e1","modified":1579660363539},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png","hash":"eb1ed1a6da91cf7a446f714ca7ad95edde7a4545","modified":1579660363539},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png","hash":"a277cee3b835adfc37ce01e798a5302a5ae70e02","modified":1579660363539},{"_id":"public/images/wechatPay.png","hash":"69539f4644858fc6e2fbeb6a5d187a7244c89506","modified":1579660363539},{"_id":"public/images/wechatpay.jpg","hash":"38959a2b517f6c0b7c851b288ed0339d9bc62f76","modified":1579660363539},{"_id":"public/2019/04/30/hexo-next插入网易云音乐/01.png","hash":"f1bbad3d02ccb53b8898fc7ad337ef5ea368b2ae","modified":1579660363539},{"_id":"public/2019/07/03/最快-GPU加速-Alacritty终端/error.png","hash":"3475f3657a4b6a5fa9fcacf8c82fe1472073034b","modified":1579660363539},{"_id":"public/css/style.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579660363546},{"_id":"public/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1579660363546},{"_id":"public/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1579660363546},{"_id":"public/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1579660363546},{"_id":"public/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1579660363546},{"_id":"public/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1579660363547},{"_id":"public/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1579660363547},{"_id":"public/js/utils.js","hash":"3c987de7cfb944c33e9e527f1214724c7aafc796","modified":1579660363547},{"_id":"public/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1579660363547},{"_id":"public/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1579660363547},{"_id":"public/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1579660363547},{"_id":"public/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1579660363547},{"_id":"public/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1579660363547},{"_id":"public/js/src/dynamic_bg.js","hash":"1256018865f3c8a9cee5dbd2c3db6c9d72cd47e0","modified":1579660363547},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1579660363547},{"_id":"public/404.html","hash":"8cd85c6ad127516ea27549d59fbe7364ecc27e8d","modified":1579660363547},{"_id":"public/css/main.css","hash":"2c06bd42cde8388e37f88cf6def5160a2acff6c7","modified":1579660363547},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1579660363547},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1579660363547},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1579660363547},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1579660363548},{"_id":"public/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png","hash":"6a5a12569b253f7bec7087f7f6ad3eea3791218c","modified":1579660363548},{"_id":"public/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合运算.png","hash":"ad1f29402fe7ee428252573f8791baddd87ea8c7","modified":1579660363548},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/Python位运算符.png","hash":"c933c9d40fb3d0f1dc2b65589a896f4775b8d9b3","modified":1579660363548},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/Python常用赋值运算符.png","hash":"bb80a58d7f6878e918f36adfd52853e3845488d0","modified":1579660363548},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/Python常用算术运算符.png","hash":"ea81e2bc21ec46b983868c7a094b9b41c4c84176","modified":1579660363548},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png","hash":"ee19d4324f0249e81bef83b4648d08d4c66021d3","modified":1579660363548},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/Python运算符优先级.png","hash":"c5d2ea6429f3003213a50c49b3b4f9a3fec7348a","modified":1579660363549},{"_id":"public/2019/08/31/Python-03-Python变量类型和运算符/Python比较运算符.png","hash":"c933c9d40fb3d0f1dc2b65589a896f4775b8d9b3","modified":1579660363549},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png","hash":"25d2152a8bb8e8e2eb904610ef7068576c9b7d11","modified":1579660363549},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/分区.png","hash":"6a54d049cbfe3fc4d65d6a027b36ad758ed61b6c","modified":1579660363549},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/分区标识.png","hash":"675089cbcbe932471d6ce5c7b3a8671ee689c8c2","modified":1579660363549},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png","hash":"2008592b8eda92867b78f6deb69971dce00c7b13","modified":1579660363549},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png","hash":"e9f200e3559e93a06fa4e8b9c37a486949081a45","modified":1579660363549},{"_id":"public/2019/05/23/如何自学编程/群组.png","hash":"41dcf8a1a81a79580dd7a9b35edd424d54c1e79d","modified":1579660363549},{"_id":"public/2019/08/29/Python-02-Python初探/python2运行.png","hash":"a40cf03fc343c11f61830fdc6586c265a24a7421","modified":1579660363550},{"_id":"public/2019/09/08/Python-04-Python列表、元组、字典和集合/Python序列内置函数.png","hash":"aaf010d6f02c47b3519712bf3f6dd14a63a7dcbd","modified":1579660363567},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/开始安装.png","hash":"2ac6b5ee42b758265b9c4d130d303e2050e8a929","modified":1579660363567},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/摘要.png","hash":"763ba8b64bc381afc7eb4b0166db36741399872a","modified":1579660363567},{"_id":"public/2019/09/08/Python-04-Python列表、元组、字典和集合/dict()函数创建字典.png","hash":"a70ba2696eff3256543bdb56180d001276b81437","modified":1579660363567},{"_id":"public/2019/05/21/我儿子的博客/预览.png","hash":"127d112dee5632a53e88a5e6888bd0acb94404ab","modified":1579660363579},{"_id":"public/2019/06/14/fcitx5安装与配置/输入.gif","hash":"5a875cd145cc0be553fbbd9f3b75ad6637efa0c1","modified":1579660363579},{"_id":"public/2019/06/14/fcitx5安装与配置/kcm.png","hash":"0ecc38623c9d9e5194317468e871c9176667f1df","modified":1579660363583},{"_id":"public/images/aliPay.png","hash":"61750b1d63b30ca8ac5bcbec79664d541223b879","modified":1579660363586},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg","hash":"e31908ec199b23699ac587a1963a54bce16d362a","modified":1579660363586},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png","hash":"46b6d53a445cc3e15cc45ab9afd916486e3a5d7a","modified":1579660363588},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png","hash":"0cfadb0ae6808ba58c821653ca76e8099819e98d","modified":1579660363588},{"_id":"public/2019/06/08/Learn-Qt5-HelloWorld/newProject.gif","hash":"1e02a369607b0aac39283e7779f54df5304f552d","modified":1579660363588},{"_id":"public/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png","hash":"707bf8b1db79a27bf3ff12f1765d9b3b8f9f0803","modified":1579660363589},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png","hash":"3557732a051927d718f9bdff7c4bd3f98a8bbe52","modified":1579660363590},{"_id":"public/2019/08/29/Python-02-Python初探/python3运行.png","hash":"50299451bcc0cc7192c905c1686f8ef2c2d8b098","modified":1579660363592},{"_id":"public/2019/07/03/最快-GPU加速-Alacritty终端/ponysay.png","hash":"98434022f4c023acb2033aa187531888da540de3","modified":1579660363592},{"_id":"public/2019/08/29/Python-01-Python教程基础/Python知识体系框架.png","hash":"1a958d404040d05d684c98010013650c68ed73ac","modified":1579660363596},{"_id":"public/2019/07/14/What-is-Vim/VIM.png","hash":"43d640a02b4f79ff640ddf9661cf3c4b10f870ad","modified":1579660363604},{"_id":"public/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png","hash":"458be78aaf2f28c9b20c84f5a866a1514b7992bb","modified":1579660363606},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/桌面.png","hash":"99a28838b2ba8cf7fdce7f3f997723c185326fdf","modified":1579660363612},{"_id":"public/2019/07/12/平铺式桌面-从入门到入坟/桌面预览.png","hash":"6274db4e2b3c9743fc071721a87a4550d035a8ba","modified":1579660363613},{"_id":"public/images/background.png","hash":"a0ec840a777b3b18ca80b71b3d23553311008191","modified":1579660363621},{"_id":"public/images/card.png","hash":"08e8213581ac3fac8c119440a124643b05ef716a","modified":1579660363624},{"_id":"public/images/background2.png","hash":"8611760e073872829af4a22dbeb38cd5ccf2144a","modified":1579660363632},{"_id":"public/images/img.jpg","hash":"f84efb620744db1c422800669c4fcb852e03998d","modified":1579660363645}],"Category":[{"name":"转载","_id":"ck5oozoay0004omoo4wk7f47m"},{"name":"分享","_id":"ck5oozob3000comoor175qoki"},{"name":"学习笔记","_id":"ck5oozob6000komooxs4556zu"},{"name":"英文文章","_id":"ck5oozobi000zomoojnk7hhf1"},{"name":"折腾日记","_id":"ck5oozoby001nomoofd08b7if"},{"name":"Linux系列","_id":"ck5oozoc4002comoog1p8mvm2"},{"name":"软件分享","_id":"ck5oozocf0034omoodjvumw63"},{"name":"Python","_id":"ck5oozoco003uomookifni6gt"},{"name":"折腾记录","_id":"ck5oozocz004zomooinj9gv41"},{"name":"个人感想","_id":"ck5oozod6005iomookeoshlqz"},{"name":"Lisp","_id":"ck5oozoda005romoo4343h5qr"},{"name":"折腾日志","_id":"ck5oozodd0063omoo9nvkqb3v"},{"name":"学习记录","_id":"ck5oozodl006xomoo7ro4ay5a"}],"Data":[],"Page":[{"title":"DoomEmacs","date":"2019-11-04T17:58:29.000Z","_content":"\n## 前言\n\n此系列用于记录我使用`Doom Emacs`所遇到的所有坑，以及所有知识点。\n    \n# 菜单\n\n这里的`菜单`是指`DoomEmacs`中按下`SPC`所展示的功能列表。我将会一一探索，将每一个\n功能用个人的理解写出来。\n\n> 由于我也是从零开始使用Emacs和Doom Emacs，并且英语也不咋地，所以可能会有很多问\n> 题，请大家谅解，如有疑问可以去About关于页面找到我的联系方式或发起issue，非常感\n> 谢!\n\n# 模块\n\n\n","source":"DoomEmacs/index.md","raw":"---\ntitle: DoomEmacs\ndate: 2019-11-05 01:58:29\n---\n\n## 前言\n\n此系列用于记录我使用`Doom Emacs`所遇到的所有坑，以及所有知识点。\n    \n# 菜单\n\n这里的`菜单`是指`DoomEmacs`中按下`SPC`所展示的功能列表。我将会一一探索，将每一个\n功能用个人的理解写出来。\n\n> 由于我也是从零开始使用Emacs和Doom Emacs，并且英语也不咋地，所以可能会有很多问\n> 题，请大家谅解，如有疑问可以去About关于页面找到我的联系方式或发起issue，非常感\n> 谢!\n\n# 模块\n\n\n","updated":"2020-01-19T03:49:51.363Z","path":"DoomEmacs/index.html","comments":1,"layout":"page","_id":"ck5oozoar0000omooc62bnpby","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>此系列用于记录我使用<code>Doom Emacs</code>所遇到的所有坑，以及所有知识点。</p>\n<h1 id=\"菜单\"><a href=\"#菜单\" class=\"headerlink\" title=\"菜单\"></a>菜单</h1><p>这里的<code>菜单</code>是指<code>DoomEmacs</code>中按下<code>SPC</code>所展示的功能列表。我将会一一探索，将每一个<br>功能用个人的理解写出来。</p>\n<blockquote>\n<p>由于我也是从零开始使用Emacs和Doom Emacs，并且英语也不咋地，所以可能会有很多问<br>题，请大家谅解，如有疑问可以去About关于页面找到我的联系方式或发起issue，非常感<br>谢!</p>\n</blockquote>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>此系列用于记录我使用<code>Doom Emacs</code>所遇到的所有坑，以及所有知识点。</p>\n<h1 id=\"菜单\"><a href=\"#菜单\" class=\"headerlink\" title=\"菜单\"></a>菜单</h1><p>这里的<code>菜单</code>是指<code>DoomEmacs</code>中按下<code>SPC</code>所展示的功能列表。我将会一一探索，将每一个<br>功能用个人的理解写出来。</p>\n<blockquote>\n<p>由于我也是从零开始使用Emacs和Doom Emacs，并且英语也不咋地，所以可能会有很多问<br>题，请大家谅解，如有疑问可以去About关于页面找到我的联系方式或发起issue，非常感<br>谢!</p>\n</blockquote>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1>"},{"title":"文章分类","date":"2019-04-23T08:03:29.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-04-23 16:03:29\ntype: \"categories\"\n---\n","updated":"2020-01-19T03:49:51.410Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck5oozoav0002omooohy9n7v3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Linux","date":"2019-06-12T13:22:22.000Z","_content":"\n# 前言\n\n本系列根据《跟老男孩学Linux运维》系列丛书进行个人笔记整理，由于《跟老男孩学Linux运维》分为三个系列，分别是:\n\n- 核心系统命令实践\n\n- Shell编程实战\n\n- Web集群实战\n\n我将会依次的进行笔记整理以及学习，并且分享至博客。\n\n> 曾经的《Linux系统管理完全手册》由于教材太旧，很多技术点都已过时，但是其中却有很多关乎管理方面的智慧，我只好放弃那一系列，但其中的管理之道会在日后补上。\n\n# 核心系统命令实践\n\n## 目录索引\n\n  - [第1章-Linux命令行简介](/2019/06/15/Linux-Linux命令行简介-0/) [√] \n\n  - [第2章-文件和目录操作命令](/2019/06/16/Linux-文件和目录操作命令-1) [√] \n\n  - [第3章-文件过滤及内容编辑处理命令](/2019/06/30/Linux-文件过滤及内容编辑处理命令-2) [√] \n\n  - [第4章-文本处理三剑客]() [ ] \n\n  - [第5章-Linux信息显示与搜索文件命令]() [ ] \n\n  - [第6章-文件备份与压缩命令]() [ ] \n\n  - [第7章-Linux用户管理及用户信息查询命令]() [ ] \n\n  - [第8章-Linux磁盘与文件系统管理命令]() [ ] \n\n  - [第9章-Linux进程管理命令]() [ ]\n\n  - [第10章-Linux网络管理命令]() [ ] \n\n  - [第11章-Linux系统管理命令]() [ ] \n\n  - [第12章-Linux系统常用内置命令]() [ ] \n\n\n# Shell编程实战\n\n## 目录索引\n\n__暂未开始__\n\n# Web集群实战\n\n## 目录索引\n\n__暂未开始___\n","source":"Linux/index.md","raw":"---\ntitle: Linux\ndate: 2019-06-12 21:22:22\n---\n\n# 前言\n\n本系列根据《跟老男孩学Linux运维》系列丛书进行个人笔记整理，由于《跟老男孩学Linux运维》分为三个系列，分别是:\n\n- 核心系统命令实践\n\n- Shell编程实战\n\n- Web集群实战\n\n我将会依次的进行笔记整理以及学习，并且分享至博客。\n\n> 曾经的《Linux系统管理完全手册》由于教材太旧，很多技术点都已过时，但是其中却有很多关乎管理方面的智慧，我只好放弃那一系列，但其中的管理之道会在日后补上。\n\n# 核心系统命令实践\n\n## 目录索引\n\n  - [第1章-Linux命令行简介](/2019/06/15/Linux-Linux命令行简介-0/) [√] \n\n  - [第2章-文件和目录操作命令](/2019/06/16/Linux-文件和目录操作命令-1) [√] \n\n  - [第3章-文件过滤及内容编辑处理命令](/2019/06/30/Linux-文件过滤及内容编辑处理命令-2) [√] \n\n  - [第4章-文本处理三剑客]() [ ] \n\n  - [第5章-Linux信息显示与搜索文件命令]() [ ] \n\n  - [第6章-文件备份与压缩命令]() [ ] \n\n  - [第7章-Linux用户管理及用户信息查询命令]() [ ] \n\n  - [第8章-Linux磁盘与文件系统管理命令]() [ ] \n\n  - [第9章-Linux进程管理命令]() [ ]\n\n  - [第10章-Linux网络管理命令]() [ ] \n\n  - [第11章-Linux系统管理命令]() [ ] \n\n  - [第12章-Linux系统常用内置命令]() [ ] \n\n\n# Shell编程实战\n\n## 目录索引\n\n__暂未开始__\n\n# Web集群实战\n\n## 目录索引\n\n__暂未开始___\n","updated":"2020-01-19T03:49:51.363Z","path":"Linux/index.html","comments":1,"layout":"page","_id":"ck5oozoaz0006omoopflczhuf","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本系列根据《跟老男孩学Linux运维》系列丛书进行个人笔记整理，由于《跟老男孩学Linux运维》分为三个系列，分别是:</p>\n<ul>\n<li><p>核心系统命令实践</p>\n</li>\n<li><p>Shell编程实战</p>\n</li>\n<li><p>Web集群实战</p>\n</li>\n</ul>\n<p>我将会依次的进行笔记整理以及学习，并且分享至博客。</p>\n<blockquote>\n<p>曾经的《Linux系统管理完全手册》由于教材太旧，很多技术点都已过时，但是其中却有很多关乎管理方面的智慧，我只好放弃那一系列，但其中的管理之道会在日后补上。</p>\n</blockquote>\n<h1 id=\"核心系统命令实践\"><a href=\"#核心系统命令实践\" class=\"headerlink\" title=\"核心系统命令实践\"></a>核心系统命令实践</h1><h2 id=\"目录索引\"><a href=\"#目录索引\" class=\"headerlink\" title=\"目录索引\"></a>目录索引</h2><ul>\n<li><p><a href=\"/2019/06/15/Linux-Linux命令行简介-0/\">第1章-Linux命令行简介</a> [√] </p>\n</li>\n<li><p><a href=\"/2019/06/16/Linux-文件和目录操作命令-1\">第2章-文件和目录操作命令</a> [√] </p>\n</li>\n<li><p><a href=\"/2019/06/30/Linux-文件过滤及内容编辑处理命令-2\">第3章-文件过滤及内容编辑处理命令</a> [√] </p>\n</li>\n<li><p><a href>第4章-文本处理三剑客</a> [ ] </p>\n</li>\n<li><p><a href>第5章-Linux信息显示与搜索文件命令</a> [ ] </p>\n</li>\n<li><p><a href>第6章-文件备份与压缩命令</a> [ ] </p>\n</li>\n<li><p><a href>第7章-Linux用户管理及用户信息查询命令</a> [ ] </p>\n</li>\n<li><p><a href>第8章-Linux磁盘与文件系统管理命令</a> [ ] </p>\n</li>\n<li><p><a href>第9章-Linux进程管理命令</a> [ ]</p>\n</li>\n<li><p><a href>第10章-Linux网络管理命令</a> [ ] </p>\n</li>\n<li><p><a href>第11章-Linux系统管理命令</a> [ ] </p>\n</li>\n<li><p><a href>第12章-Linux系统常用内置命令</a> [ ] </p>\n</li>\n</ul>\n<h1 id=\"Shell编程实战\"><a href=\"#Shell编程实战\" class=\"headerlink\" title=\"Shell编程实战\"></a>Shell编程实战</h1><h2 id=\"目录索引-1\"><a href=\"#目录索引-1\" class=\"headerlink\" title=\"目录索引\"></a>目录索引</h2><p><strong>暂未开始</strong></p>\n<h1 id=\"Web集群实战\"><a href=\"#Web集群实战\" class=\"headerlink\" title=\"Web集群实战\"></a>Web集群实战</h1><h2 id=\"目录索引-2\"><a href=\"#目录索引-2\" class=\"headerlink\" title=\"目录索引\"></a>目录索引</h2><p><strong>暂未开始_</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本系列根据《跟老男孩学Linux运维》系列丛书进行个人笔记整理，由于《跟老男孩学Linux运维》分为三个系列，分别是:</p>\n<ul>\n<li><p>核心系统命令实践</p>\n</li>\n<li><p>Shell编程实战</p>\n</li>\n<li><p>Web集群实战</p>\n</li>\n</ul>\n<p>我将会依次的进行笔记整理以及学习，并且分享至博客。</p>\n<blockquote>\n<p>曾经的《Linux系统管理完全手册》由于教材太旧，很多技术点都已过时，但是其中却有很多关乎管理方面的智慧，我只好放弃那一系列，但其中的管理之道会在日后补上。</p>\n</blockquote>\n<h1 id=\"核心系统命令实践\"><a href=\"#核心系统命令实践\" class=\"headerlink\" title=\"核心系统命令实践\"></a>核心系统命令实践</h1><h2 id=\"目录索引\"><a href=\"#目录索引\" class=\"headerlink\" title=\"目录索引\"></a>目录索引</h2><ul>\n<li><p><a href=\"/2019/06/15/Linux-Linux命令行简介-0/\">第1章-Linux命令行简介</a> [√] </p>\n</li>\n<li><p><a href=\"/2019/06/16/Linux-文件和目录操作命令-1\">第2章-文件和目录操作命令</a> [√] </p>\n</li>\n<li><p><a href=\"/2019/06/30/Linux-文件过滤及内容编辑处理命令-2\">第3章-文件过滤及内容编辑处理命令</a> [√] </p>\n</li>\n<li><p><a href>第4章-文本处理三剑客</a> [ ] </p>\n</li>\n<li><p><a href>第5章-Linux信息显示与搜索文件命令</a> [ ] </p>\n</li>\n<li><p><a href>第6章-文件备份与压缩命令</a> [ ] </p>\n</li>\n<li><p><a href>第7章-Linux用户管理及用户信息查询命令</a> [ ] </p>\n</li>\n<li><p><a href>第8章-Linux磁盘与文件系统管理命令</a> [ ] </p>\n</li>\n<li><p><a href>第9章-Linux进程管理命令</a> [ ]</p>\n</li>\n<li><p><a href>第10章-Linux网络管理命令</a> [ ] </p>\n</li>\n<li><p><a href>第11章-Linux系统管理命令</a> [ ] </p>\n</li>\n<li><p><a href>第12章-Linux系统常用内置命令</a> [ ] </p>\n</li>\n</ul>\n<h1 id=\"Shell编程实战\"><a href=\"#Shell编程实战\" class=\"headerlink\" title=\"Shell编程实战\"></a>Shell编程实战</h1><h2 id=\"目录索引-1\"><a href=\"#目录索引-1\" class=\"headerlink\" title=\"目录索引\"></a>目录索引</h2><p><strong>暂未开始</strong></p>\n<h1 id=\"Web集群实战\"><a href=\"#Web集群实战\" class=\"headerlink\" title=\"Web集群实战\"></a>Web集群实战</h1><h2 id=\"目录索引-2\"><a href=\"#目录索引-2\" class=\"headerlink\" title=\"目录索引\"></a>目录索引</h2><p><strong>暂未开始_</strong></p>\n"},{"title":"Python","date":"2019-08-28T06:21:35.000Z","_content":"\n# 前言\n\n本系列根据`C语言中文网`的Python基础基础教程进行记录编写。\n\n[Python基础教程](\"http://c.biancheng.net/python/\")\n\n> 暂时停止更新! mmp这个教程原本还免费，现在就收费了!\n\n# 目录\n\n> [第一章----Python教程基础](https://evanmeek.github.io/2019/08/29/Python-01-Python%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80/)\n\n> [第二章----Python初探](https://evanmeek.github.io/2019/08/29/Python-02-Python%E5%88%9D%E6%8E%A2/)\n\n> [第三章----变量类型和运算符](https://evanmeek.github.io/2019/08/31/Python-03-Python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/)\n\n> [第四章----列表、元组、字典和集合](https://evanmeek.github.io/2019/09/08/Python-04-Python%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/)\n\n> [第五章----Python字符串常用方法](https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/)\n\n> [第六章----Python流程控制](https://evanmeek.github.io/2019/09/28/Python-06-Python流程控制/)\n\n> [第七章----函数和lambda表达式]()\n\n> [第八章----Python类和对象]()\n\n> [第九章----Python异常处理机制]()\n\n> [第十章----类特殊成员（属性和方法）]()\n\n> [第十一章----Python模块和包]()\n\n> [第十二章----Python常见模块]()\n\n> [第十三章----Tkinter]()\n\n> [第十四章----Python文件操作(I/O)]()\n\n> [第十五章----Python数据库编程]()\n\n> [第十六章----Python并发编程]()\n\n> [第十七章----Python网络编程]()\n\n> [第十八章----Python文档和测试]()\n\n> [第十九章----Python打包和发布]()\n\n> [第二十章----Python数据可视化]()\n\n> [第二十一章----Python Scrapy网络爬虫]()\n","source":"Python/index.md","raw":"---\ntitle: Python\ndate: 2019-08-28 14:21:35\n---\n\n# 前言\n\n本系列根据`C语言中文网`的Python基础基础教程进行记录编写。\n\n[Python基础教程](\"http://c.biancheng.net/python/\")\n\n> 暂时停止更新! mmp这个教程原本还免费，现在就收费了!\n\n# 目录\n\n> [第一章----Python教程基础](https://evanmeek.github.io/2019/08/29/Python-01-Python%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80/)\n\n> [第二章----Python初探](https://evanmeek.github.io/2019/08/29/Python-02-Python%E5%88%9D%E6%8E%A2/)\n\n> [第三章----变量类型和运算符](https://evanmeek.github.io/2019/08/31/Python-03-Python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/)\n\n> [第四章----列表、元组、字典和集合](https://evanmeek.github.io/2019/09/08/Python-04-Python%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/)\n\n> [第五章----Python字符串常用方法](https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/)\n\n> [第六章----Python流程控制](https://evanmeek.github.io/2019/09/28/Python-06-Python流程控制/)\n\n> [第七章----函数和lambda表达式]()\n\n> [第八章----Python类和对象]()\n\n> [第九章----Python异常处理机制]()\n\n> [第十章----类特殊成员（属性和方法）]()\n\n> [第十一章----Python模块和包]()\n\n> [第十二章----Python常见模块]()\n\n> [第十三章----Tkinter]()\n\n> [第十四章----Python文件操作(I/O)]()\n\n> [第十五章----Python数据库编程]()\n\n> [第十六章----Python并发编程]()\n\n> [第十七章----Python网络编程]()\n\n> [第十八章----Python文档和测试]()\n\n> [第十九章----Python打包和发布]()\n\n> [第二十章----Python数据可视化]()\n\n> [第二十一章----Python Scrapy网络爬虫]()\n","updated":"2020-01-19T03:49:51.363Z","path":"Python/index.html","comments":1,"layout":"page","_id":"ck5oozob00008omooc510184z","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本系列根据<code>C语言中文网</code>的Python基础基础教程进行记录编写。</p>\n<p><a href=\"&quot;http://c.biancheng.net/python/&quot;\">Python基础教程</a></p>\n<blockquote>\n<p>暂时停止更新! mmp这个教程原本还免费，现在就收费了!</p>\n</blockquote>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/08/29/Python-01-Python%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80/\">第一章—-Python教程基础</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/08/29/Python-02-Python%E5%88%9D%E6%8E%A2/\">第二章—-Python初探</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/08/31/Python-03-Python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/\">第三章—-变量类型和运算符</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/09/08/Python-04-Python%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/\">第四章—-列表、元组、字典和集合</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/\">第五章—-Python字符串常用方法</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/09/28/Python-06-Python流程控制/\">第六章—-Python流程控制</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第七章—-函数和lambda表达式</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第八章—-Python类和对象</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第九章—-Python异常处理机制</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十章—-类特殊成员（属性和方法）</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十一章—-Python模块和包</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十二章—-Python常见模块</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十三章—-Tkinter</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十四章—-Python文件操作(I/O)</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十五章—-Python数据库编程</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十六章—-Python并发编程</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十七章—-Python网络编程</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十八章—-Python文档和测试</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十九章—-Python打包和发布</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第二十章—-Python数据可视化</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第二十一章—-Python Scrapy网络爬虫</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本系列根据<code>C语言中文网</code>的Python基础基础教程进行记录编写。</p>\n<p><a href=\"&quot;http://c.biancheng.net/python/&quot;\">Python基础教程</a></p>\n<blockquote>\n<p>暂时停止更新! mmp这个教程原本还免费，现在就收费了!</p>\n</blockquote>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/08/29/Python-01-Python%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80/\">第一章—-Python教程基础</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/08/29/Python-02-Python%E5%88%9D%E6%8E%A2/\">第二章—-Python初探</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/08/31/Python-03-Python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/\">第三章—-变量类型和运算符</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/09/08/Python-04-Python%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/\">第四章—-列表、元组、字典和集合</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/\">第五章—-Python字符串常用方法</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://evanmeek.github.io/2019/09/28/Python-06-Python流程控制/\">第六章—-Python流程控制</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第七章—-函数和lambda表达式</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第八章—-Python类和对象</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第九章—-Python异常处理机制</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十章—-类特殊成员（属性和方法）</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十一章—-Python模块和包</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十二章—-Python常见模块</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十三章—-Tkinter</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十四章—-Python文件操作(I/O)</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十五章—-Python数据库编程</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十六章—-Python并发编程</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十七章—-Python网络编程</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十八章—-Python文档和测试</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第十九章—-Python打包和发布</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第二十章—-Python数据可视化</a></p>\n</blockquote>\n<blockquote>\n<p><a href>第二十一章—-Python Scrapy网络爬虫</a></p>\n</blockquote>\n"},{"title":"TODO","date":"2019-08-28T19:24:45.000Z","_content":"\n本页用于管理我近期所需完成的重要事项\n\nToday TODO(19/8/29):\n\n  完成Python基础-02-Python初探 []\n\n  将社团传单制作完成 []\n\n  收拾行李，准备回校 []\n\n","source":"TODO/index.md","raw":"---\ntitle: TODO\ndate: 2019-08-29 03:24:45\n---\n\n本页用于管理我近期所需完成的重要事项\n\nToday TODO(19/8/29):\n\n  完成Python基础-02-Python初探 []\n\n  将社团传单制作完成 []\n\n  收拾行李，准备回校 []\n\n","updated":"2020-01-19T03:49:51.363Z","path":"TODO/index.html","comments":1,"layout":"page","_id":"ck5oozob2000aomoogp20dk23","content":"<p>本页用于管理我近期所需完成的重要事项</p>\n<p>Today TODO(19/8/29):</p>\n<p>  完成Python基础-02-Python初探 []</p>\n<p>  将社团传单制作完成 []</p>\n<p>  收拾行李，准备回校 []</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本页用于管理我近期所需完成的重要事项</p>\n<p>Today TODO(19/8/29):</p>\n<p>  完成Python基础-02-Python初探 []</p>\n<p>  将社团传单制作完成 []</p>\n<p>  收拾行李，准备回校 []</p>\n"},{"title":"关于我","date":"2019-05-01T12:58:42.000Z","_content":"\n# Q: 你是谁?\n\n# A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\n\n---\n\n# Q: 你是做什么的?\n\n# A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\n\n---\n\n# Q: 如何联系你?\n\n# A: 你可以通过如下途径联系我:\n\n---\n\n# Q: 你为什么在图书上批注?\n\n# A: 实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\n\n- email: the_lty_mail@foxmail.com\n\n- wechat: A2-B0x\n\n- tencentQQ: 2864011679\n\n- GitHub-Issue: [点击提交反馈](https://github.com/EvanMeek/evanmeek.github.io/issues/new)\n","source":"关于我/index.md","raw":"---\ntitle: 关于我\ndate: 2019-05-01 20:58:42\n---\n\n# Q: 你是谁?\n\n# A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\n\n---\n\n# Q: 你是做什么的?\n\n# A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\n\n---\n\n# Q: 如何联系你?\n\n# A: 你可以通过如下途径联系我:\n\n---\n\n# Q: 你为什么在图书上批注?\n\n# A: 实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\n\n- email: the_lty_mail@foxmail.com\n\n- wechat: A2-B0x\n\n- tencentQQ: 2864011679\n\n- GitHub-Issue: [点击提交反馈](https://github.com/EvanMeek/evanmeek.github.io/issues/new)\n","updated":"2020-01-19T03:49:51.410Z","path":"关于我/index.html","comments":1,"layout":"page","_id":"ck5oozob4000fomoomdwserlv","content":"<h1 id=\"Q-你是谁\"><a href=\"#Q-你是谁\" class=\"headerlink\" title=\"Q: 你是谁?\"></a>Q: 你是谁?</h1><h1 id=\"A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"><a href=\"#A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\" class=\"headerlink\" title=\"A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"></a>A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。</h1><hr>\n<h1 id=\"Q-你是做什么的\"><a href=\"#Q-你是做什么的\" class=\"headerlink\" title=\"Q: 你是做什么的?\"></a>Q: 你是做什么的?</h1><h1 id=\"A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"><a href=\"#A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\" class=\"headerlink\" title=\"A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"></a>A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。</h1><hr>\n<h1 id=\"Q-如何联系你\"><a href=\"#Q-如何联系你\" class=\"headerlink\" title=\"Q: 如何联系你?\"></a>Q: 如何联系你?</h1><h1 id=\"A-你可以通过如下途径联系我\"><a href=\"#A-你可以通过如下途径联系我\" class=\"headerlink\" title=\"A: 你可以通过如下途径联系我:\"></a>A: 你可以通过如下途径联系我:</h1><hr>\n<h1 id=\"Q-你为什么在图书上批注\"><a href=\"#Q-你为什么在图书上批注\" class=\"headerlink\" title=\"Q: 你为什么在图书上批注?\"></a>Q: 你为什么在图书上批注?</h1><h1 id=\"A-实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\"><a href=\"#A-实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\" class=\"headerlink\" title=\"A: 实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\"></a>A: 实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。</h1><ul>\n<li><p>email: <a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n</li>\n<li><p>wechat: A2-B0x</p>\n</li>\n<li><p>tencentQQ: 2864011679</p>\n</li>\n<li><p>GitHub-Issue: <a href=\"https://github.com/EvanMeek/evanmeek.github.io/issues/new\" target=\"_blank\" rel=\"noopener\">点击提交反馈</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Q-你是谁\"><a href=\"#Q-你是谁\" class=\"headerlink\" title=\"Q: 你是谁?\"></a>Q: 你是谁?</h1><h1 id=\"A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"><a href=\"#A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\" class=\"headerlink\" title=\"A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"></a>A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。</h1><hr>\n<h1 id=\"Q-你是做什么的\"><a href=\"#Q-你是做什么的\" class=\"headerlink\" title=\"Q: 你是做什么的?\"></a>Q: 你是做什么的?</h1><h1 id=\"A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"><a href=\"#A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\" class=\"headerlink\" title=\"A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"></a>A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。</h1><hr>\n<h1 id=\"Q-如何联系你\"><a href=\"#Q-如何联系你\" class=\"headerlink\" title=\"Q: 如何联系你?\"></a>Q: 如何联系你?</h1><h1 id=\"A-你可以通过如下途径联系我\"><a href=\"#A-你可以通过如下途径联系我\" class=\"headerlink\" title=\"A: 你可以通过如下途径联系我:\"></a>A: 你可以通过如下途径联系我:</h1><hr>\n<h1 id=\"Q-你为什么在图书上批注\"><a href=\"#Q-你为什么在图书上批注\" class=\"headerlink\" title=\"Q: 你为什么在图书上批注?\"></a>Q: 你为什么在图书上批注?</h1><h1 id=\"A-实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\"><a href=\"#A-实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\" class=\"headerlink\" title=\"A: 实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。\"></a>A: 实在抱歉，我想要为同仁们整理一些笔记，希望能帮到他们。若有冒犯，在这里说声对不起。全部使用铅笔只在书本一处进行批注，可用橡皮擦进行擦除。</h1><ul>\n<li><p>email: <a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n</li>\n<li><p>wechat: A2-B0x</p>\n</li>\n<li><p>tencentQQ: 2864011679</p>\n</li>\n<li><p>GitHub-Issue: <a href=\"https://github.com/EvanMeek/evanmeek.github.io/issues/new\" target=\"_blank\" rel=\"noopener\">点击提交反馈</a></p>\n</li>\n</ul>\n"},{"title":"tags","date":"2019-04-23T08:06:47.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-04-23 16:06:47\ntype: \"tags\"\n---\n","updated":"2020-01-19T03:49:51.410Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck5oozob5000homooqnj762mz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"话","date":"2019-07-01T10:31:03.000Z","_content":"\n# 2019/7/1\n\n朋友之间应该保持联系，但保持联系却又是并不仅仅只是四个字如此简单。\n\n想当李白，越来越像李白。\n","source":"话/index.md","raw":"---\ntitle: 话\ndate: 2019-07-01 18:31:03\n---\n\n# 2019/7/1\n\n朋友之间应该保持联系，但保持联系却又是并不仅仅只是四个字如此简单。\n\n想当李白，越来越像李白。\n","updated":"2020-01-19T03:49:51.413Z","path":"话/index.html","comments":1,"layout":"page","_id":"ck5oozob7000nomoouw19dnav","content":"<h1 id=\"2019-7-1\"><a href=\"#2019-7-1\" class=\"headerlink\" title=\"2019/7/1\"></a>2019/7/1</h1><p>朋友之间应该保持联系，但保持联系却又是并不仅仅只是四个字如此简单。</p>\n<p>想当李白，越来越像李白。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2019-7-1\"><a href=\"#2019-7-1\" class=\"headerlink\" title=\"2019/7/1\"></a>2019/7/1</h1><p>朋友之间应该保持联系，但保持联系却又是并不仅仅只是四个字如此简单。</p>\n<p>想当李白，越来越像李白。</p>\n"}],"Post":[{"title":"2008年5月12日14时28分04秒","copyright":false,"date":"2019-05-12T14:53:06.000Z","_content":"\n![空降](2008年5月12日14时28分04秒/空降.webp)\n\n  图为汶川大地震时某部队空降救灾  \n\n<!--more-->\n\n# 0x00  \n\n5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。\n\n此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。\n\n伤亡人数：69227人遇难，374643人受伤，17923人失踪。\n\n以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。\n\n# 0x01   \n\n每年的这个时刻，我都不由自主的想起这个事情。\n\n2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。\n\n那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，\n\n突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。\n\n这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！\n\n跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。\n\n宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。\n\n因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。\n\n大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。\n\n晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。\n\n学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。\n\n天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。\n\n![操场](2008年5月12日14时28分04秒/操场.webp)\n\n# 0x02   \n2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。\n\n我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。\n\n两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。\n\n![流量](2008年5月12日14时28分04秒/流量图.webp)\n\n这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。\n\n这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。\n\n谷歌当时的博文说道：\n\n“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”\n\n几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。\n\n全世界的中华儿女在这三分钟连在了一起。\n\n# 0x03   \n\n在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。\n\n大家那时候就只有一个身份，就叫中国人。\n\n那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。\n\n   况且古往今来，历史诚不欺我。   \n\n> 知乎 ———— 小小白告\n\n\n\n汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。\n\n打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。\n\n最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。\n\n  多年过去，讲起这个故事，仍旧热泪盈眶。  \n\n> 知乎 ———— 匿名用户\n\n\n\n昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。\n\n她给我看她们初中的学校。\n\n我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。\n\n我听了这句话瞬间眼睛红了，那年她初二，今年她研二。\n\n   活着，本身就意味着一切。   \n\n> 知乎 ———— 匿名用户\n\n\n\n推荐25分钟纪录片:《为了生命》。\n\n---\n\n本篇文章转载于：[阅读原文](https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##)\n作者：纯洁的微笑(一个有故事的程序员)\n\n\n\n","source":"_posts/2008年5月12日14时28分04秒.md","raw":"---\ntitle: 2008年5月12日14时28分04秒\ncopyright: false\ndate: 2019-05-12 22:53:06\ncategories: 转载\ntags:\n - 社会事件\n---\n\n![空降](2008年5月12日14时28分04秒/空降.webp)\n\n  图为汶川大地震时某部队空降救灾  \n\n<!--more-->\n\n# 0x00  \n\n5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。\n\n此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。\n\n伤亡人数：69227人遇难，374643人受伤，17923人失踪。\n\n以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。\n\n# 0x01   \n\n每年的这个时刻，我都不由自主的想起这个事情。\n\n2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。\n\n那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，\n\n突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。\n\n这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！\n\n跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。\n\n宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。\n\n因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。\n\n大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。\n\n晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。\n\n学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。\n\n天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。\n\n![操场](2008年5月12日14时28分04秒/操场.webp)\n\n# 0x02   \n2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。\n\n我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。\n\n两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。\n\n![流量](2008年5月12日14时28分04秒/流量图.webp)\n\n这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。\n\n这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。\n\n谷歌当时的博文说道：\n\n“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”\n\n几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。\n\n全世界的中华儿女在这三分钟连在了一起。\n\n# 0x03   \n\n在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。\n\n大家那时候就只有一个身份，就叫中国人。\n\n那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。\n\n   况且古往今来，历史诚不欺我。   \n\n> 知乎 ———— 小小白告\n\n\n\n汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。\n\n打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。\n\n最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。\n\n  多年过去，讲起这个故事，仍旧热泪盈眶。  \n\n> 知乎 ———— 匿名用户\n\n\n\n昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。\n\n她给我看她们初中的学校。\n\n我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。\n\n我听了这句话瞬间眼睛红了，那年她初二，今年她研二。\n\n   活着，本身就意味着一切。   \n\n> 知乎 ———— 匿名用户\n\n\n\n推荐25分钟纪录片:《为了生命》。\n\n---\n\n本篇文章转载于：[阅读原文](https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##)\n作者：纯洁的微笑(一个有故事的程序员)\n\n\n\n","slug":"2008年5月12日14时28分04秒","published":1,"updated":"2020-01-19T03:49:51.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoas0001omoo0he5grvj","content":"<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/空降.webp\" alt=\"空降\"></p>\n<p>  图为汶川大地震时某部队空降救灾  </p>\n<a id=\"more\"></a>\n<h1 id=\"0x00\"><a href=\"#0x00\" class=\"headerlink\" title=\"0x00\"></a>0x00</h1><p>5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。</p>\n<p>此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。</p>\n<p>伤亡人数：69227人遇难，374643人受伤，17923人失踪。</p>\n<p>以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。</p>\n<h1 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"></a>0x01</h1><p>每年的这个时刻，我都不由自主的想起这个事情。</p>\n<p>2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。</p>\n<p>那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，</p>\n<p>突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。</p>\n<p>这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！</p>\n<p>跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。</p>\n<p>宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。</p>\n<p>因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。</p>\n<p>大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。</p>\n<p>晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。</p>\n<p>学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。</p>\n<p>天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/操场.webp\" alt=\"操场\"></p>\n<h1 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"></a>0x02</h1><p>2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。</p>\n<p>我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。</p>\n<p>两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/流量图.webp\" alt=\"流量\"></p>\n<p>这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。</p>\n<p>这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。</p>\n<p>谷歌当时的博文说道：</p>\n<p>“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”</p>\n<p>几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。</p>\n<p>全世界的中华儿女在这三分钟连在了一起。</p>\n<h1 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"></a>0x03</h1><p>在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。</p>\n<p>大家那时候就只有一个身份，就叫中国人。</p>\n<p>那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。</p>\n<p>   况且古往今来，历史诚不欺我。   </p>\n<blockquote>\n<p>知乎 ———— 小小白告</p>\n</blockquote>\n<p>汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。</p>\n<p>打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。</p>\n<p>最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。</p>\n<p>  多年过去，讲起这个故事，仍旧热泪盈眶。  </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。</p>\n<p>她给我看她们初中的学校。</p>\n<p>我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。</p>\n<p>我听了这句话瞬间眼睛红了，那年她初二，今年她研二。</p>\n<p>   活着，本身就意味着一切。   </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>推荐25分钟纪录片:《为了生命》。</p>\n<hr>\n<p>本篇文章转载于：<a href=\"https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##\" target=\"_blank\" rel=\"noopener\">阅读原文</a><br>作者：纯洁的微笑(一个有故事的程序员)</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/空降.webp\" alt=\"空降\"></p>\n<p>  图为汶川大地震时某部队空降救灾  </p>","more":"<h1 id=\"0x00\"><a href=\"#0x00\" class=\"headerlink\" title=\"0x00\"></a>0x00</h1><p>5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。</p>\n<p>此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。</p>\n<p>伤亡人数：69227人遇难，374643人受伤，17923人失踪。</p>\n<p>以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。</p>\n<h1 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"></a>0x01</h1><p>每年的这个时刻，我都不由自主的想起这个事情。</p>\n<p>2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。</p>\n<p>那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，</p>\n<p>突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。</p>\n<p>这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！</p>\n<p>跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。</p>\n<p>宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。</p>\n<p>因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。</p>\n<p>大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。</p>\n<p>晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。</p>\n<p>学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。</p>\n<p>天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/操场.webp\" alt=\"操场\"></p>\n<h1 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"></a>0x02</h1><p>2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。</p>\n<p>我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。</p>\n<p>两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/流量图.webp\" alt=\"流量\"></p>\n<p>这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。</p>\n<p>这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。</p>\n<p>谷歌当时的博文说道：</p>\n<p>“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”</p>\n<p>几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。</p>\n<p>全世界的中华儿女在这三分钟连在了一起。</p>\n<h1 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"></a>0x03</h1><p>在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。</p>\n<p>大家那时候就只有一个身份，就叫中国人。</p>\n<p>那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。</p>\n<p>   况且古往今来，历史诚不欺我。   </p>\n<blockquote>\n<p>知乎 ———— 小小白告</p>\n</blockquote>\n<p>汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。</p>\n<p>打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。</p>\n<p>最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。</p>\n<p>  多年过去，讲起这个故事，仍旧热泪盈眶。  </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。</p>\n<p>她给我看她们初中的学校。</p>\n<p>我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。</p>\n<p>我听了这句话瞬间眼睛红了，那年她初二，今年她研二。</p>\n<p>   活着，本身就意味着一切。   </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>推荐25分钟纪录片:《为了生命》。</p>\n<hr>\n<p>本篇文章转载于：<a href=\"https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##\" target=\"_blank\" rel=\"noopener\">阅读原文</a><br>作者：纯洁的微笑(一个有故事的程序员)</p>"},{"title":"2019年的规划","copyright":true,"date":"2019-06-09T14:23:53.000Z","_content":"\n2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。\n\n<!--more-->\n\n# 书籍\n\n《标准C++入门与编程实践》————————————————————已读完\n《Linux系统管理完全手册》————————————————————在读\n《Vim实用技巧》——————————————————————————————未读\n《计算机网络教程》———————————————————————————未读\n《Qt5编程入门》——————————————————————————————在读\n\n# 想学但未学\n\nAdobe Photoshop\nAdobe AfterEffects \nAdobe Primiere\n\n# 生活\n\n想多拿起相机拍拍美好的世界，\n\n想找个女朋友，\n\n想减肥，\n\n想写操作系统....\n\n","source":"_posts/2019年的规划.md","raw":"---\ntitle: 2019年的规划\ncopyright: true\ndate: 2019-06-09 22:23:53\ncategories: 分享\ntags:\n---\n\n2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。\n\n<!--more-->\n\n# 书籍\n\n《标准C++入门与编程实践》————————————————————已读完\n《Linux系统管理完全手册》————————————————————在读\n《Vim实用技巧》——————————————————————————————未读\n《计算机网络教程》———————————————————————————未读\n《Qt5编程入门》——————————————————————————————在读\n\n# 想学但未学\n\nAdobe Photoshop\nAdobe AfterEffects \nAdobe Primiere\n\n# 生活\n\n想多拿起相机拍拍美好的世界，\n\n想找个女朋友，\n\n想减肥，\n\n想写操作系统....\n\n","slug":"2019年的规划","published":1,"updated":"2020-01-19T03:49:51.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoaw0003omoo4hl6t0bx","content":"<p>2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。</p>\n<a id=\"more\"></a>\n<h1 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h1><p>《标准C++入门与编程实践》————————————————————已读完<br>《Linux系统管理完全手册》————————————————————在读<br>《Vim实用技巧》——————————————————————————————未读<br>《计算机网络教程》———————————————————————————未读<br>《Qt5编程入门》——————————————————————————————在读</p>\n<h1 id=\"想学但未学\"><a href=\"#想学但未学\" class=\"headerlink\" title=\"想学但未学\"></a>想学但未学</h1><p>Adobe Photoshop<br>Adobe AfterEffects<br>Adobe Primiere</p>\n<h1 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h1><p>想多拿起相机拍拍美好的世界，</p>\n<p>想找个女朋友，</p>\n<p>想减肥，</p>\n<p>想写操作系统….</p>\n","site":{"data":{}},"excerpt":"<p>2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。</p>","more":"<h1 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h1><p>《标准C++入门与编程实践》————————————————————已读完<br>《Linux系统管理完全手册》————————————————————在读<br>《Vim实用技巧》——————————————————————————————未读<br>《计算机网络教程》———————————————————————————未读<br>《Qt5编程入门》——————————————————————————————在读</p>\n<h1 id=\"想学但未学\"><a href=\"#想学但未学\" class=\"headerlink\" title=\"想学但未学\"></a>想学但未学</h1><p>Adobe Photoshop<br>Adobe AfterEffects<br>Adobe Primiere</p>\n<h1 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h1><p>想多拿起相机拍拍美好的世界，</p>\n<p>想找个女朋友，</p>\n<p>想减肥，</p>\n<p>想写操作系统….</p>"},{"title":"C++内存四区之堆区","copyright":true,"date":"2019-05-10T03:13:46.000Z","_content":"\n# 什么是堆区\n\n由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．\n\n# 如何将数据放在堆区\n\n在C++中由**new**关键字在堆区中开辟内存。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint* func(){\n    //创建局部指针变量，但是数据是存放在堆区的。\n    int *a_p= new int(10);\n\n    return a_p;\n} \n\nint main(){\n    int *p = func();\n\n    cout<<*p<<endl;\n\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\n10\n~~~\n\n看到上述代码的**创建局部指针变量，但数据存放在栈区**是什么意思呢?\n\n其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。\n\n![堆区](C-内存四区之堆区/test.png)\n\n也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。\n\n---\n","source":"_posts/C-内存四区之堆区.md","raw":"---\ntitle: C++内存四区之堆区\ncopyright: true\ndate: 2019-05-10 11:13:46\ncategories: 学习笔记\ntags:\n - C++\n---\n\n# 什么是堆区\n\n由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．\n\n# 如何将数据放在堆区\n\n在C++中由**new**关键字在堆区中开辟内存。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint* func(){\n    //创建局部指针变量，但是数据是存放在堆区的。\n    int *a_p= new int(10);\n\n    return a_p;\n} \n\nint main(){\n    int *p = func();\n\n    cout<<*p<<endl;\n\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\n10\n~~~\n\n看到上述代码的**创建局部指针变量，但数据存放在栈区**是什么意思呢?\n\n其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。\n\n![堆区](C-内存四区之堆区/test.png)\n\n也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。\n\n---\n","slug":"C-内存四区之堆区","published":1,"updated":"2020-01-19T03:49:51.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoaz0007omoo8n2b0n72","content":"<h1 id=\"什么是堆区\"><a href=\"#什么是堆区\" class=\"headerlink\" title=\"什么是堆区\"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p>\n<h1 id=\"如何将数据放在堆区\"><a href=\"#如何将数据放在堆区\" class=\"headerlink\" title=\"如何将数据放在堆区\"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a_p= <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a_p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p>\n<p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p>\n<p><img src=\"/2019/05/10/C-内存四区之堆区/test.png\" alt=\"堆区\"></p>\n<p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是堆区\"><a href=\"#什么是堆区\" class=\"headerlink\" title=\"什么是堆区\"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p>\n<h1 id=\"如何将数据放在堆区\"><a href=\"#如何将数据放在堆区\" class=\"headerlink\" title=\"如何将数据放在堆区\"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a_p= <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a_p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p>\n<p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p>\n<p><img src=\"/2019/05/10/C-内存四区之堆区/test.png\" alt=\"堆区\"></p>\n<p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p>\n<hr>\n"},{"title":"C++内存四区之代码区与全局区","copyright":true,"date":"2019-05-11T12:52:44.000Z","_content":"\n其实这一篇应该是作为\"C++内存四区\"的第一篇的。\n\n<!--more-->\n\n# 0x00 内存分区模型\n\nC++程序在执行时，内存大方向的可划分为 *****************四个区域**\n\n   - 代码区: 存放代码的二进制代码，由操作系统进行管理。\n\n   - 全局区: 存放全局变量和静态变量以及常量。\n\n   - 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。\n\n   - 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。\n\n## 内存四区的意义:\n\n不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。\n\n# 0x01 程序运行前\n\n在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域\n\n代码区:\n\n   存放CPU执行的机器指令\n   \n   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。\n\n   只读的，为了防止程序意外修改代码的指令，所以有了只读。\n\n![代码区示意图](C-内存四区之代码区与全局区/代码区示意图.png)\n\n如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,\n\n而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。\n\n---\n\n","source":"_posts/C-内存四区之代码区与全局区.md","raw":"---\ntitle: C++内存四区之代码区与全局区\ncopyright: true\ndate: 2019-05-11 20:52:44\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n其实这一篇应该是作为\"C++内存四区\"的第一篇的。\n\n<!--more-->\n\n# 0x00 内存分区模型\n\nC++程序在执行时，内存大方向的可划分为 *****************四个区域**\n\n   - 代码区: 存放代码的二进制代码，由操作系统进行管理。\n\n   - 全局区: 存放全局变量和静态变量以及常量。\n\n   - 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。\n\n   - 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。\n\n## 内存四区的意义:\n\n不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。\n\n# 0x01 程序运行前\n\n在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域\n\n代码区:\n\n   存放CPU执行的机器指令\n   \n   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。\n\n   只读的，为了防止程序意外修改代码的指令，所以有了只读。\n\n![代码区示意图](C-内存四区之代码区与全局区/代码区示意图.png)\n\n如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,\n\n而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。\n\n---\n\n","slug":"C-内存四区之代码区与全局区","published":1,"updated":"2020-01-19T03:49:51.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozob10009omoo91rvkdrr","content":"<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p>\n<a id=\"more\"></a>\n<h1 id=\"0x00-内存分区模型\"><a href=\"#0x00-内存分区模型\" class=\"headerlink\" title=\"0x00 内存分区模型\"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p>\n<ul>\n<li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p>\n</li>\n<li><p>全局区: 存放全局变量和静态变量以及常量。</p>\n</li>\n<li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p>\n</li>\n<li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>\n</li>\n</ul>\n<h2 id=\"内存四区的意义\"><a href=\"#内存四区的意义\" class=\"headerlink\" title=\"内存四区的意义:\"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p>\n<h1 id=\"0x01-程序运行前\"><a href=\"#0x01-程序运行前\" class=\"headerlink\" title=\"0x01 程序运行前\"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p>\n<p>代码区:</p>\n<p>   存放CPU执行的机器指令</p>\n<p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>\n<p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p>\n<p><img src=\"/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png\" alt=\"代码区示意图\"></p>\n<p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p>\n<p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p>","more":"<h1 id=\"0x00-内存分区模型\"><a href=\"#0x00-内存分区模型\" class=\"headerlink\" title=\"0x00 内存分区模型\"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p>\n<ul>\n<li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p>\n</li>\n<li><p>全局区: 存放全局变量和静态变量以及常量。</p>\n</li>\n<li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p>\n</li>\n<li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>\n</li>\n</ul>\n<h2 id=\"内存四区的意义\"><a href=\"#内存四区的意义\" class=\"headerlink\" title=\"内存四区的意义:\"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p>\n<h1 id=\"0x01-程序运行前\"><a href=\"#0x01-程序运行前\" class=\"headerlink\" title=\"0x01 程序运行前\"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p>\n<p>代码区:</p>\n<p>   存放CPU执行的机器指令</p>\n<p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>\n<p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p>\n<p><img src=\"/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png\" alt=\"代码区示意图\"></p>\n<p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p>\n<p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p>\n<hr>"},{"title":"Boring Article","copyright":true,"date":"2019-07-12T09:16:36.000Z","_content":"\nSince I returned to Xinjiang,I have to eat and sleep everyday.I was so __bored__,then I had this article.\n\n<!--more-->\n\n&emsp;Befor I came to Xinjiang,I hope I can take many beatuiful pictures,eat my favorite food and do what I want to do.But now the only way to take pictures just can with mobile phone,Cameras can not be used.Every day.I eat with my parents.butI can not eat what I want.Finally,I care too much about me .I thought that home is to be free and easy to call home.I always manage my family,which is called cage!\n\n&emsp;In fact.this article is a __dissemination of negative energy__.If you are unhappy,I am sorry.My father just came back,he said that his business is finished.the __rest of the time__ can enjoy.I hope the next summer life will be __enriched__!\n","source":"_posts/Boring-Article.md","raw":"---\ntitle: Boring Article\ncopyright: true\ndate: 2019-07-12 17:16:36\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\nSince I returned to Xinjiang,I have to eat and sleep everyday.I was so __bored__,then I had this article.\n\n<!--more-->\n\n&emsp;Befor I came to Xinjiang,I hope I can take many beatuiful pictures,eat my favorite food and do what I want to do.But now the only way to take pictures just can with mobile phone,Cameras can not be used.Every day.I eat with my parents.butI can not eat what I want.Finally,I care too much about me .I thought that home is to be free and easy to call home.I always manage my family,which is called cage!\n\n&emsp;In fact.this article is a __dissemination of negative energy__.If you are unhappy,I am sorry.My father just came back,he said that his business is finished.the __rest of the time__ can enjoy.I hope the next summer life will be __enriched__!\n","slug":"Boring-Article","published":1,"updated":"2020-01-19T03:49:51.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozob2000bomoo7pr08vrr","content":"<p>Since I returned to Xinjiang,I have to eat and sleep everyday.I was so <strong>bored</strong>,then I had this article.</p>\n<a id=\"more\"></a>\n<p>&emsp;Befor I came to Xinjiang,I hope I can take many beatuiful pictures,eat my favorite food and do what I want to do.But now the only way to take pictures just can with mobile phone,Cameras can not be used.Every day.I eat with my parents.butI can not eat what I want.Finally,I care too much about me .I thought that home is to be free and easy to call home.I always manage my family,which is called cage!</p>\n<p>&emsp;In fact.this article is a <strong>dissemination of negative energy</strong>.If you are unhappy,I am sorry.My father just came back,he said that his business is finished.the <strong>rest of the time</strong> can enjoy.I hope the next summer life will be <strong>enriched</strong>!</p>\n","site":{"data":{}},"excerpt":"<p>Since I returned to Xinjiang,I have to eat and sleep everyday.I was so <strong>bored</strong>,then I had this article.</p>","more":"<p>&emsp;Befor I came to Xinjiang,I hope I can take many beatuiful pictures,eat my favorite food and do what I want to do.But now the only way to take pictures just can with mobile phone,Cameras can not be used.Every day.I eat with my parents.butI can not eat what I want.Finally,I care too much about me .I thought that home is to be free and easy to call home.I always manage my family,which is called cage!</p>\n<p>&emsp;In fact.this article is a <strong>dissemination of negative energy</strong>.If you are unhappy,I am sorry.My father just came back,he said that his business is finished.the <strong>rest of the time</strong> can enjoy.I hope the next summer life will be <strong>enriched</strong>!</p>"},{"title":"C++内存四区之栈区","copyright":true,"date":"2019-05-10T02:51:17.000Z","_content":"\n# 什么是栈区\n\n栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..\n\n# 操作栈区的注意事项\n\n在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．\n\n因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\nint *func(){\n    //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．\n    int a = 10;\n\n    //尝试返回局部变量的地址\n    return &a;\n}\nint main(){\n    //接受func的返回值\n    int *p = func();\n    //输出p\n    cout<<*p<<endl;\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~\nProcess finished with exit code 139 (interrupted by signal 11: SIGSEGV)\n~~~\n\n上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．\n\n# 其他问题\n\n可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．\n\n---\n","source":"_posts/C-内存四区之栈区.md","raw":"---\ntitle: C++内存四区之栈区\ncopyright: true\ndate: 2019-05-10 10:51:17\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n# 什么是栈区\n\n栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..\n\n# 操作栈区的注意事项\n\n在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．\n\n因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\nint *func(){\n    //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．\n    int a = 10;\n\n    //尝试返回局部变量的地址\n    return &a;\n}\nint main(){\n    //接受func的返回值\n    int *p = func();\n    //输出p\n    cout<<*p<<endl;\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~\nProcess finished with exit code 139 (interrupted by signal 11: SIGSEGV)\n~~~\n\n上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．\n\n# 其他问题\n\n可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．\n\n---\n","slug":"C-内存四区之栈区","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozob4000gomooddmicnpl","content":"<h1 id=\"什么是栈区\"><a href=\"#什么是栈区\" class=\"headerlink\" title=\"什么是栈区\"></a>什么是栈区</h1><p>栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..</p>\n<h1 id=\"操作栈区的注意事项\"><a href=\"#操作栈区的注意事项\" class=\"headerlink\" title=\"操作栈区的注意事项\"></a>操作栈区的注意事项</h1><p>在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．</p>\n<p>因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//尝试返回局部变量的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//接受func的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\">    <span class=\"comment\">//输出p</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure>\n<p>上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．</p>\n<h1 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h1><p>可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是栈区\"><a href=\"#什么是栈区\" class=\"headerlink\" title=\"什么是栈区\"></a>什么是栈区</h1><p>栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..</p>\n<h1 id=\"操作栈区的注意事项\"><a href=\"#操作栈区的注意事项\" class=\"headerlink\" title=\"操作栈区的注意事项\"></a>操作栈区的注意事项</h1><p>在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．</p>\n<p>因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//尝试返回局部变量的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//接受func的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\">    <span class=\"comment\">//输出p</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure>\n<p>上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．</p>\n<h1 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h1><p>可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．</p>\n<hr>\n"},{"title":"C++函数探幽","date":"2019-04-23T22:38:43.000Z","copyright":true,"_content":"<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->\n<!--more-->\n\n**本章内容**\n- 内联函数\n- 引用变量\n- 如何按引用传递函数参数\n- 默认参数\n- 函数重载\n- 函数模板\n- 函数模板具体化\n\n本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．\n\n---\n\n## C++内联函数\n\n> ### **说明**\n\n内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．\n\n那么，我们现在就深入到程序内部．\n\n首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．\n\n当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．\n\n执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．\n\n那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．\n\n\n**所以**\n\nC++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．\n\n相当于编译器将使用相应的函数代码替换函数调用．\n\n对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．\n\n**但是**\n\n虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．\n\n**结论**\n\n我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．\n\n另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．\n\n_除非_　:该函数被经常调用\n\n> ### **使用**\n\n使用内联函数只需要做到以下两点即可：\n\n- 在函数声明前加上关键字**inline**;\n\n- 在函数定义前加上关键字**inline**;\n\n通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．\n\n**可能遇到的问题**\n\n在我们编写函数为内联函数时，编译器不一定满足这种要求．\n\n- 编译器认为该函数过大或识别到函数调用了自己 ***(内联函数不能递归)*** .\n\n- 有些编译器没有启动或实现这种特性．\n\n> ### **案例**\n\n~~~C++\n\n#include <iostream>\n\nusing namespace std;\n\ninline double square(double x) { return x * x; }\n\nint main() {\n    double a(2.0), b(5.0), c(0);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \" \\tc=\" << c << endl;\n    square(a);\n    b = square(b);\n    c = square(7 + 1);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \"\\tc=\" << c << endl;\n    return 0;\n}\n\n~~~\n\n该程序的输出为:\n\n~~~\n此时a=2\tb=5\tc=0\n此时a=4\tb=25\tc=64\n~~~\n\n看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．\n\n也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.\n\n**这使得C++的内联功能远远胜过C语言的宏定义**\n\n__尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.__\n\n__这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参__\n\n### 内联与宏\n\ninline是C++新增的特性.\n\nC语言使用预处理语句#define来提供宏－－内联代码的原始实现．\n\n例如下面这个例子.\n\n~~~C\n#define SQUARE(X) X*X\n\na = SQUARE(2.0);\nb = SQUARE(3.2++);\nc = SQUARE(1+2.3);\n~~~\n\n上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．\n\n---\n\n## 引用变量\n\n引用变量是C++新增的一种复合类型.\n\n引用是为已定义的变量创建了一个别名．\n\n例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.\n\n引用变量通常的使用场景是作为函数的形参．\n\n通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．\n\n---\n\n### 创建引用变量\n\nC++使用 **&** 用于声明引用，但是它还有另外一个作用：地址运算符。\n\n当&为声明引用时可有这样的一个例子:\n\n~~~C++\nint a;\nint & b = a;\n~~~\n\n是否感觉跟指针有点相像呢？\n\n是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&是指指向int的引用。\n\n上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。\n\n下面再看一个例子，你将懂得C++中使用&时引用和地址运算符的区别。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a=1;\n\tint & b = a;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n\tb = 2;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n        cout<<\"a-address:\"<<&a<<endl;\n        cout<<\"b-address:\"<<&b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:1\nb:1\na:2\nb:2\na-address:0x7ffdd4c4ae74\nb-address:0x7ffdd4c4ae74\n~~~\n\n首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。\n\n然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。\n\n再然后，我们输出的不是a和b的值了而是输出它们的地址:\n\n~~~C++\ncout<<\"a-address:\"<<&a<<endl;\n~~~\n\n此时的&代表的就是地址运算符。\n\n经过上面的一些小例子，读者们可能认为C++中&为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a,*p;\n\tint b,*p2(&b);\n\t*p = a;\n\treturn 0;\n}\n~~~\n\n上述代码是可以编译通过的。\n\n**指针在声明时编译器允许不为其进行初始化值**\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int a,&b;\n    b = a;\n    return 0;\n}\n~~~\n\n如果代码是这样，那么则编译不通过。\n\n**我们可以把引用看成cosnt指针**，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。\n\n也就是说：\n\n~~~C++\nint a,&b(a);\n~~~\n\n**仅在表示上等同于**\n\n~~~C++\nint a;\nconst int *p(&a);\n~~~\n\n上面提到“仅在表示上等同于“为什么呢，请看下面的例子。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a(10),&b(a);\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\tint c(20);\n\tb = c;\n\tcout<<\"c:\"<<c<<endl;\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:10\nb:10\nc:20\na:20\nb:20\n~~~\n\n可以看到最初b引用的是a，但随后b作为c的引用：\n\n~~~C++\nb = c;\n~~~\n\n**这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.**\n\n我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:\n\n~~~C++\na = c;\n~~~\n\n也就是说，这意味着”将c变量的值赋给a变量“。\n\n简而言之，**可以通过初始化声明来设置引用，但不能通过赋值来设置。**\n\n下面有一段有趣的代码，你们可以看看。\n\n~~~C++\nint a(10);\nint *p =&a;\nint &b = *p;\nint c(20);\n*p = &c;\n~~~\n\n上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。\n\n### 将\n","source":"_posts/C-函数探幽.md","raw":"---\ntitle: C++函数探幽\ndate: 2019-04-24 06:38:43\ncategories: 学习笔记\ntags:\n  - C++\n  - 编程\ncopyright: true\n---\n<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->\n<!--more-->\n\n**本章内容**\n- 内联函数\n- 引用变量\n- 如何按引用传递函数参数\n- 默认参数\n- 函数重载\n- 函数模板\n- 函数模板具体化\n\n本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．\n\n---\n\n## C++内联函数\n\n> ### **说明**\n\n内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．\n\n那么，我们现在就深入到程序内部．\n\n首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．\n\n当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．\n\n执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．\n\n那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．\n\n\n**所以**\n\nC++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．\n\n相当于编译器将使用相应的函数代码替换函数调用．\n\n对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．\n\n**但是**\n\n虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．\n\n**结论**\n\n我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．\n\n另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．\n\n_除非_　:该函数被经常调用\n\n> ### **使用**\n\n使用内联函数只需要做到以下两点即可：\n\n- 在函数声明前加上关键字**inline**;\n\n- 在函数定义前加上关键字**inline**;\n\n通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．\n\n**可能遇到的问题**\n\n在我们编写函数为内联函数时，编译器不一定满足这种要求．\n\n- 编译器认为该函数过大或识别到函数调用了自己 ***(内联函数不能递归)*** .\n\n- 有些编译器没有启动或实现这种特性．\n\n> ### **案例**\n\n~~~C++\n\n#include <iostream>\n\nusing namespace std;\n\ninline double square(double x) { return x * x; }\n\nint main() {\n    double a(2.0), b(5.0), c(0);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \" \\tc=\" << c << endl;\n    square(a);\n    b = square(b);\n    c = square(7 + 1);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \"\\tc=\" << c << endl;\n    return 0;\n}\n\n~~~\n\n该程序的输出为:\n\n~~~\n此时a=2\tb=5\tc=0\n此时a=4\tb=25\tc=64\n~~~\n\n看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．\n\n也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.\n\n**这使得C++的内联功能远远胜过C语言的宏定义**\n\n__尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.__\n\n__这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参__\n\n### 内联与宏\n\ninline是C++新增的特性.\n\nC语言使用预处理语句#define来提供宏－－内联代码的原始实现．\n\n例如下面这个例子.\n\n~~~C\n#define SQUARE(X) X*X\n\na = SQUARE(2.0);\nb = SQUARE(3.2++);\nc = SQUARE(1+2.3);\n~~~\n\n上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．\n\n---\n\n## 引用变量\n\n引用变量是C++新增的一种复合类型.\n\n引用是为已定义的变量创建了一个别名．\n\n例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.\n\n引用变量通常的使用场景是作为函数的形参．\n\n通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．\n\n---\n\n### 创建引用变量\n\nC++使用 **&** 用于声明引用，但是它还有另外一个作用：地址运算符。\n\n当&为声明引用时可有这样的一个例子:\n\n~~~C++\nint a;\nint & b = a;\n~~~\n\n是否感觉跟指针有点相像呢？\n\n是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&是指指向int的引用。\n\n上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。\n\n下面再看一个例子，你将懂得C++中使用&时引用和地址运算符的区别。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a=1;\n\tint & b = a;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n\tb = 2;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n        cout<<\"a-address:\"<<&a<<endl;\n        cout<<\"b-address:\"<<&b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:1\nb:1\na:2\nb:2\na-address:0x7ffdd4c4ae74\nb-address:0x7ffdd4c4ae74\n~~~\n\n首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。\n\n然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。\n\n再然后，我们输出的不是a和b的值了而是输出它们的地址:\n\n~~~C++\ncout<<\"a-address:\"<<&a<<endl;\n~~~\n\n此时的&代表的就是地址运算符。\n\n经过上面的一些小例子，读者们可能认为C++中&为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a,*p;\n\tint b,*p2(&b);\n\t*p = a;\n\treturn 0;\n}\n~~~\n\n上述代码是可以编译通过的。\n\n**指针在声明时编译器允许不为其进行初始化值**\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int a,&b;\n    b = a;\n    return 0;\n}\n~~~\n\n如果代码是这样，那么则编译不通过。\n\n**我们可以把引用看成cosnt指针**，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。\n\n也就是说：\n\n~~~C++\nint a,&b(a);\n~~~\n\n**仅在表示上等同于**\n\n~~~C++\nint a;\nconst int *p(&a);\n~~~\n\n上面提到“仅在表示上等同于“为什么呢，请看下面的例子。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a(10),&b(a);\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\tint c(20);\n\tb = c;\n\tcout<<\"c:\"<<c<<endl;\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:10\nb:10\nc:20\na:20\nb:20\n~~~\n\n可以看到最初b引用的是a，但随后b作为c的引用：\n\n~~~C++\nb = c;\n~~~\n\n**这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.**\n\n我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:\n\n~~~C++\na = c;\n~~~\n\n也就是说，这意味着”将c变量的值赋给a变量“。\n\n简而言之，**可以通过初始化声明来设置引用，但不能通过赋值来设置。**\n\n下面有一段有趣的代码，你们可以看看。\n\n~~~C++\nint a(10);\nint *p =&a;\nint &b = *p;\nint c(20);\n*p = &c;\n~~~\n\n上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。\n\n### 将\n","slug":"C-函数探幽","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozob6000iomoovwuhu17o","content":"<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->\n<a id=\"more\"></a>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>内联函数</li>\n<li>引用变量</li>\n<li>如何按引用传递函数参数</li>\n<li>默认参数</li>\n<li>函数重载</li>\n<li>函数模板</li>\n<li>函数模板具体化</li>\n</ul>\n<p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p>\n<hr>\n<h2 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h2><blockquote>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3></blockquote>\n<p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p>\n<p>那么，我们现在就深入到程序内部．</p>\n<p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p>\n<p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p>\n<p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p>\n<p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p>\n<p><strong>所以</strong></p>\n<p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p>\n<p>相当于编译器将使用相应的函数代码替换函数调用．</p>\n<p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p>\n<p><strong>但是</strong></p>\n<p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p>\n<p><strong>结论</strong></p>\n<p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p>\n<p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p>\n<p>_除非_　:该函数被经常调用</p>\n<blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h3></blockquote>\n<p>使用内联函数只需要做到以下两点即可：</p>\n<ul>\n<li><p>在函数声明前加上关键字<strong>inline</strong>;</p>\n</li>\n<li><p>在函数定义前加上关键字<strong>inline</strong>;</p>\n</li>\n</ul>\n<p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p>\n<p><strong>可能遇到的问题</strong></p>\n<p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p>\n<ul>\n<li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p>\n</li>\n<li><p>有些编译器没有启动或实现这种特性．</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a><strong>案例</strong></h3></blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    double a(2.0), b(5.0), c(0);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\" \\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    square(a);</span><br><span class=\"line\">    b = square(b);</span><br><span class=\"line\">    c = square(<span class=\"number\">7</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\"\\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该程序的输出为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">此时a=2\tb=5\tc=0</span><br><span class=\"line\">此时a=4\tb=25\tc=64</span><br></pre></td></tr></table></figure>\n<p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p>\n<p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p>\n<p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p>\n<p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p>\n<p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p>\n<h3 id=\"内联与宏\"><a href=\"#内联与宏\" class=\"headerlink\" title=\"内联与宏\"></a>内联与宏</h3><p>inline是C++新增的特性.</p>\n<p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p>\n<p>例如下面这个例子.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SQUARE(X) X*X</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = SQUARE(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">b = SQUARE(<span class=\"number\">3.2</span>++);</span><br><span class=\"line\">c = SQUARE(<span class=\"number\">1</span>+<span class=\"number\">2.3</span>);</span><br></pre></td></tr></table></figure>\n<p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p>\n<hr>\n<h2 id=\"引用变量\"><a href=\"#引用变量\" class=\"headerlink\" title=\"引用变量\"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p>\n<p>引用是为已定义的变量创建了一个别名．</p>\n<p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p>\n<p>引用变量通常的使用场景是作为函数的形参．</p>\n<p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p>\n<hr>\n<h3 id=\"创建引用变量\"><a href=\"#创建引用变量\" class=\"headerlink\" title=\"创建引用变量\"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p>\n<p>当&amp;为声明引用时可有这样的一个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure>\n<p>是否感觉跟指针有点相像呢？</p>\n<p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p>\n<p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p>\n<p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp; b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b-address:\"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:1</span><br><span class=\"line\">b:1</span><br><span class=\"line\">a:2</span><br><span class=\"line\">b:2</span><br><span class=\"line\">a-address:0x7ffdd4c4ae74</span><br><span class=\"line\">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure>\n<p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p>\n<p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p>\n<p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>此时的&amp;代表的就是地址运算符。</p>\n<p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a,*p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b,*p2(&amp;b);</span><br><span class=\"line\">\t*p = a;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是可以编译通过的。</p>\n<p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,&amp;b;</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果代码是这样，那么则编译不通过。</p>\n<p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p>\n<p>也就是说：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure>\n<p><strong>仅在表示上等同于</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"title\">p</span><span class=\"params\">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tint a(10),&amp;b(a);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">\tb = c;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"c:\"</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:10</span><br><span class=\"line\">b:10</span><br><span class=\"line\">c:20</span><br><span class=\"line\">a:20</span><br><span class=\"line\">b:20</span><br></pre></td></tr></table></figure>\n<p>可以看到最初b引用的是a，但随后b作为c的引用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = c;</span><br></pre></td></tr></table></figure>\n<p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p>\n<p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = c;</span><br></pre></td></tr></table></figure>\n<p>也就是说，这意味着”将c变量的值赋给a变量“。</p>\n<p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p>\n<p>下面有一段有趣的代码，你们可以看看。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p =&amp;a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;b = *p;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">*p = &amp;c;</span><br></pre></td></tr></table></figure>\n<p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p>\n<h3 id=\"将\"><a href=\"#将\" class=\"headerlink\" title=\"将\"></a>将</h3>","site":{"data":{}},"excerpt":"<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->","more":"<p><strong>本章内容</strong></p>\n<ul>\n<li>内联函数</li>\n<li>引用变量</li>\n<li>如何按引用传递函数参数</li>\n<li>默认参数</li>\n<li>函数重载</li>\n<li>函数模板</li>\n<li>函数模板具体化</li>\n</ul>\n<p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p>\n<hr>\n<h2 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h2><blockquote>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3></blockquote>\n<p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p>\n<p>那么，我们现在就深入到程序内部．</p>\n<p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p>\n<p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p>\n<p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p>\n<p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p>\n<p><strong>所以</strong></p>\n<p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p>\n<p>相当于编译器将使用相应的函数代码替换函数调用．</p>\n<p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p>\n<p><strong>但是</strong></p>\n<p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p>\n<p><strong>结论</strong></p>\n<p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p>\n<p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p>\n<p>_除非_　:该函数被经常调用</p>\n<blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h3></blockquote>\n<p>使用内联函数只需要做到以下两点即可：</p>\n<ul>\n<li><p>在函数声明前加上关键字<strong>inline</strong>;</p>\n</li>\n<li><p>在函数定义前加上关键字<strong>inline</strong>;</p>\n</li>\n</ul>\n<p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p>\n<p><strong>可能遇到的问题</strong></p>\n<p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p>\n<ul>\n<li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p>\n</li>\n<li><p>有些编译器没有启动或实现这种特性．</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a><strong>案例</strong></h3></blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    double a(2.0), b(5.0), c(0);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\" \\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    square(a);</span><br><span class=\"line\">    b = square(b);</span><br><span class=\"line\">    c = square(<span class=\"number\">7</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\"\\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该程序的输出为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">此时a=2\tb=5\tc=0</span><br><span class=\"line\">此时a=4\tb=25\tc=64</span><br></pre></td></tr></table></figure>\n<p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p>\n<p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p>\n<p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p>\n<p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p>\n<p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p>\n<h3 id=\"内联与宏\"><a href=\"#内联与宏\" class=\"headerlink\" title=\"内联与宏\"></a>内联与宏</h3><p>inline是C++新增的特性.</p>\n<p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p>\n<p>例如下面这个例子.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SQUARE(X) X*X</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = SQUARE(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">b = SQUARE(<span class=\"number\">3.2</span>++);</span><br><span class=\"line\">c = SQUARE(<span class=\"number\">1</span>+<span class=\"number\">2.3</span>);</span><br></pre></td></tr></table></figure>\n<p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p>\n<hr>\n<h2 id=\"引用变量\"><a href=\"#引用变量\" class=\"headerlink\" title=\"引用变量\"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p>\n<p>引用是为已定义的变量创建了一个别名．</p>\n<p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p>\n<p>引用变量通常的使用场景是作为函数的形参．</p>\n<p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p>\n<hr>\n<h3 id=\"创建引用变量\"><a href=\"#创建引用变量\" class=\"headerlink\" title=\"创建引用变量\"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p>\n<p>当&amp;为声明引用时可有这样的一个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure>\n<p>是否感觉跟指针有点相像呢？</p>\n<p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p>\n<p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p>\n<p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp; b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b-address:\"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:1</span><br><span class=\"line\">b:1</span><br><span class=\"line\">a:2</span><br><span class=\"line\">b:2</span><br><span class=\"line\">a-address:0x7ffdd4c4ae74</span><br><span class=\"line\">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure>\n<p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p>\n<p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p>\n<p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>此时的&amp;代表的就是地址运算符。</p>\n<p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a,*p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b,*p2(&amp;b);</span><br><span class=\"line\">\t*p = a;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是可以编译通过的。</p>\n<p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,&amp;b;</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果代码是这样，那么则编译不通过。</p>\n<p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p>\n<p>也就是说：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure>\n<p><strong>仅在表示上等同于</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"title\">p</span><span class=\"params\">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tint a(10),&amp;b(a);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">\tb = c;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"c:\"</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:10</span><br><span class=\"line\">b:10</span><br><span class=\"line\">c:20</span><br><span class=\"line\">a:20</span><br><span class=\"line\">b:20</span><br></pre></td></tr></table></figure>\n<p>可以看到最初b引用的是a，但随后b作为c的引用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = c;</span><br></pre></td></tr></table></figure>\n<p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p>\n<p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = c;</span><br></pre></td></tr></table></figure>\n<p>也就是说，这意味着”将c变量的值赋给a变量“。</p>\n<p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p>\n<p>下面有一段有趣的代码，你们可以看看。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p =&amp;a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;b = *p;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">*p = &amp;c;</span><br></pre></td></tr></table></figure>\n<p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p>\n<h3 id=\"将\"><a href=\"#将\" class=\"headerlink\" title=\"将\"></a>将</h3>"},{"title":"C++友元","copyright":true,"date":"2019-05-17T09:07:28.000Z","_content":"\n相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。\n\n<!--more-->\n\n# 什么是友元？\n\n友元可以访问类中私有的成员。\n\n它的使用场景又如下几种:\n\n- 全局函数作友元\n\n- 类作友元\n\n- 成员函数做友元\n\n# 实例\n\n下面将通过几个案例，分别演示不同场景下，友元的使用方式。\n\n---\n\n## 全局函数作友元\n\n本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//先声明Person类，防止下面报错\nclass Person;\n//声明showPrivateVar函数，防止报错.\nvoid showPrivateVar();\n\n//定义Person类\nclass Person{\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n\n//类外定义构造函数\nPerson::Person(){\n    this->money = 10;\n}\n/**\n * 访问私有成员\n */\nvoid showPrivateVar(){\n    //实例化Person类对象\n    Person p;\n    //访问Person对象的私有成员\n    cout<<\"尝试访问Person类的私有属性:\"<<p.money<<endl;\n}\n\nint main(){\n    //调用访问私有成员函数\n    showPrivateVar();\n    return 0;\n}\n~~~\n\n显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。\n\n~~~C++\nclass Person{\n    //使showPrivateVar函数作为Person类的友元\n    friend void showPrivateVar();\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n~~~\n\n运行结果:\n\n~~~shell\n尝试访问Person类的私有属性:10\n\nProcess finished with exit code 0\n~~~\n\n我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.\n\n**那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。**\n\n---\n\n## 类作类的友元\n\n这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend FriendForBuild;\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~shell\n我正在访问Build类对象的publicRoom成员:公共客厅\n我正在访问Build类对象的privateRoom成员:私人卧室\n\nProcess finished with exit code 0\n~~~\n\n**可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。**\n\n---\n\n## 成员函数做友元\n\n上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend void FriendForBuild::visit();\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n---\n\n# 总结\n\n友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。\n","source":"_posts/C-友元.md","raw":"---\ntitle: C++友元\ncopyright: true\ndate: 2019-05-17 17:07:28\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。\n\n<!--more-->\n\n# 什么是友元？\n\n友元可以访问类中私有的成员。\n\n它的使用场景又如下几种:\n\n- 全局函数作友元\n\n- 类作友元\n\n- 成员函数做友元\n\n# 实例\n\n下面将通过几个案例，分别演示不同场景下，友元的使用方式。\n\n---\n\n## 全局函数作友元\n\n本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//先声明Person类，防止下面报错\nclass Person;\n//声明showPrivateVar函数，防止报错.\nvoid showPrivateVar();\n\n//定义Person类\nclass Person{\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n\n//类外定义构造函数\nPerson::Person(){\n    this->money = 10;\n}\n/**\n * 访问私有成员\n */\nvoid showPrivateVar(){\n    //实例化Person类对象\n    Person p;\n    //访问Person对象的私有成员\n    cout<<\"尝试访问Person类的私有属性:\"<<p.money<<endl;\n}\n\nint main(){\n    //调用访问私有成员函数\n    showPrivateVar();\n    return 0;\n}\n~~~\n\n显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。\n\n~~~C++\nclass Person{\n    //使showPrivateVar函数作为Person类的友元\n    friend void showPrivateVar();\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n~~~\n\n运行结果:\n\n~~~shell\n尝试访问Person类的私有属性:10\n\nProcess finished with exit code 0\n~~~\n\n我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.\n\n**那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。**\n\n---\n\n## 类作类的友元\n\n这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend FriendForBuild;\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~shell\n我正在访问Build类对象的publicRoom成员:公共客厅\n我正在访问Build类对象的privateRoom成员:私人卧室\n\nProcess finished with exit code 0\n~~~\n\n**可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。**\n\n---\n\n## 成员函数做友元\n\n上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend void FriendForBuild::visit();\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n---\n\n# 总结\n\n友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。\n","slug":"C-友元","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoba000oomooiptb4qh5","content":"<p>相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。</p>\n<a id=\"more\"></a>\n<h1 id=\"什么是友元？\"><a href=\"#什么是友元？\" class=\"headerlink\" title=\"什么是友元？\"></a>什么是友元？</h1><p>友元可以访问类中私有的成员。</p>\n<p>它的使用场景又如下几种:</p>\n<ul>\n<li><p>全局函数作友元</p>\n</li>\n<li><p>类作友元</p>\n</li>\n<li><p>成员函数做友元</p>\n</li>\n</ul>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>下面将通过几个案例，分别演示不同场景下，友元的使用方式。</p>\n<hr>\n<h2 id=\"全局函数作友元\"><a href=\"#全局函数作友元\" class=\"headerlink\" title=\"全局函数作友元\"></a>全局函数作友元</h2><p>本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先声明Person类，防止下面报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//声明showPrivateVar函数，防止报错.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Person类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外定义构造函数</span></span><br><span class=\"line\">Person::Person()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;money = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化Person类对象</span></span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"comment\">//访问Person对象的私有成员</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"尝试访问Person类的私有属性:\"</span>&lt;&lt;p.money&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用访问私有成员函数</span></span><br><span class=\"line\">    showPrivateVar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//使showPrivateVar函数作为Person类的友元</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试访问Person类的私有属性:10</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.</p>\n<p><strong>那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。</strong></p>\n<hr>\n<h2 id=\"类作类的友元\"><a href=\"#类作类的友元\" class=\"headerlink\" title=\"类作类的友元\"></a>类作类的友元</h2><p>这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> FriendForBuild;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我正在访问Build类对象的publicRoom成员:公共客厅</span><br><span class=\"line\">我正在访问Build类对象的privateRoom成员:私人卧室</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p><strong>可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。</strong></p>\n<hr>\n<h2 id=\"成员函数做友元\"><a href=\"#成员函数做友元\" class=\"headerlink\" title=\"成员函数做友元\"></a>成员函数做友元</h2><p>上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> FriendForBuild::visit();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。</p>\n","site":{"data":{}},"excerpt":"<p>相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。</p>","more":"<h1 id=\"什么是友元？\"><a href=\"#什么是友元？\" class=\"headerlink\" title=\"什么是友元？\"></a>什么是友元？</h1><p>友元可以访问类中私有的成员。</p>\n<p>它的使用场景又如下几种:</p>\n<ul>\n<li><p>全局函数作友元</p>\n</li>\n<li><p>类作友元</p>\n</li>\n<li><p>成员函数做友元</p>\n</li>\n</ul>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>下面将通过几个案例，分别演示不同场景下，友元的使用方式。</p>\n<hr>\n<h2 id=\"全局函数作友元\"><a href=\"#全局函数作友元\" class=\"headerlink\" title=\"全局函数作友元\"></a>全局函数作友元</h2><p>本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先声明Person类，防止下面报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//声明showPrivateVar函数，防止报错.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Person类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外定义构造函数</span></span><br><span class=\"line\">Person::Person()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;money = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化Person类对象</span></span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"comment\">//访问Person对象的私有成员</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"尝试访问Person类的私有属性:\"</span>&lt;&lt;p.money&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用访问私有成员函数</span></span><br><span class=\"line\">    showPrivateVar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//使showPrivateVar函数作为Person类的友元</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试访问Person类的私有属性:10</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.</p>\n<p><strong>那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。</strong></p>\n<hr>\n<h2 id=\"类作类的友元\"><a href=\"#类作类的友元\" class=\"headerlink\" title=\"类作类的友元\"></a>类作类的友元</h2><p>这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> FriendForBuild;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我正在访问Build类对象的publicRoom成员:公共客厅</span><br><span class=\"line\">我正在访问Build类对象的privateRoom成员:私人卧室</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p><strong>可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。</strong></p>\n<hr>\n<h2 id=\"成员函数做友元\"><a href=\"#成员函数做友元\" class=\"headerlink\" title=\"成员函数做友元\"></a>成员函数做友元</h2><p>上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> FriendForBuild::visit();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。</p>"},{"title":"C++指针[基础01]","date":"2019-05-06T12:19:25.000Z","copyright":true,"_content":"\n开始写C++中比较难理解的几个知识点的笔记。\n\n<!--more-->\n\n# 0x00 **空指针**\n\n**用途:给指针初始化值。**\n\n**特性:空指针不可访问。**\n\n为什么不可访问?\n\n因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。\n\n**报错例子**\n\n~~~c++\n//定义空指针\nint *p = NULL;\n\n//尝试修改空指针所指向的空间的值,报错!\n*p = 2;\n~~~\n\n**常用情景**\n\n~~~C++\n//定义空指针\nint *p = NULL;\n\nint a = 10;\n\n//使指针重新指向内存空间,可行!\np = &a;\n\n~~~\n\n**小结**\n\n空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。\n\n# 0x01 **野指针**\n\n**说明:指针指向的是非法的内存空间叫做野指针**\n\n**异常:读取访问权限错误**\n\n**报错例子:**\n\n~~~C++\n//使指针指向一个未知空间\nint *p = (int*)0x1010;\n\n//尝试修改指向的空间的值,报错!\n*p = 10;\n~~~\n\n**小结**\n\n我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!\n\n# 0x02 **const修饰指针**\n\nconst修饰指针分为三种场景\n\n- const修饰指针————常量指针\n\n- const修饰常量————指针常量\n\n- const既修饰指针又修饰常量\n\n> 常量指针\n\n~~~C++\nint a=10,b=20;\n\n//定义常量指针\nconst int *p = &a;\n\n//尝试修改指针所指向空间的值,报错!\n*p = 20;\n\n//指针重新指向新的空间,可行!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针是不能修改所指向的空间的值，但可重新指向新的空间**,并且定义时，**const关键字是放在指针的左侧的**。\n\n---\n\n> 指针常量\n\n~~~C++\nint a=10,b=20;\n\n//定义指针常量\nint * const p = &a;\n\n//修改指针所指向空间的值,可行!\n*p=20;\n\n//尝试为指针重新指向新的空间，报错!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针可修改所指向的空间的值，但不可重新指向新的空间**,并且定义时，**const关键字是放在指针的右侧的**。\n\n---\n\n> 既修饰指针又修饰常量\n\n~~~C++\n\nint a=10,b=20;\n\n//定义同时const修饰指针常量的指针\nconst int * cosnt p = &a;\n\n//尝试修改指针所指向的空间的值，报错!\n*p = 20;\n\n//尝试为指针重新指向新的空间，报错!\n\np = &b;\n~~~\n\n看上面的案例，可以得出，**如果指针和常量都被const修饰，那么就和const 引用非常类似了**。\n\n---\n\n**小结**\n\n常量指针\n\n- 不可修改所指向的空间的值\n- 可重新指向新的空间\n\n指针常量\n\n- 可修改所指向的空间的值\n- 不可重新指向新的空间\n\n指针和常量都被const所修饰\n\n- 不可修改所指向的空间的值\n- 不可重新指向新的空间\n\n**小技巧**\n\n> 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符\"*\")的右侧还是做左侧。\n\n---","source":"_posts/C-指针-基础01.md","raw":"---\ntitle: 'C++指针[基础01]'\ndate: 2019-05-06 20:19:25\ncategories: 学习笔记\ntags:\n  - C++\n  - 指针\n  - 学习笔记\n  - 基础\ncopyright: true\n---\n\n开始写C++中比较难理解的几个知识点的笔记。\n\n<!--more-->\n\n# 0x00 **空指针**\n\n**用途:给指针初始化值。**\n\n**特性:空指针不可访问。**\n\n为什么不可访问?\n\n因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。\n\n**报错例子**\n\n~~~c++\n//定义空指针\nint *p = NULL;\n\n//尝试修改空指针所指向的空间的值,报错!\n*p = 2;\n~~~\n\n**常用情景**\n\n~~~C++\n//定义空指针\nint *p = NULL;\n\nint a = 10;\n\n//使指针重新指向内存空间,可行!\np = &a;\n\n~~~\n\n**小结**\n\n空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。\n\n# 0x01 **野指针**\n\n**说明:指针指向的是非法的内存空间叫做野指针**\n\n**异常:读取访问权限错误**\n\n**报错例子:**\n\n~~~C++\n//使指针指向一个未知空间\nint *p = (int*)0x1010;\n\n//尝试修改指向的空间的值,报错!\n*p = 10;\n~~~\n\n**小结**\n\n我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!\n\n# 0x02 **const修饰指针**\n\nconst修饰指针分为三种场景\n\n- const修饰指针————常量指针\n\n- const修饰常量————指针常量\n\n- const既修饰指针又修饰常量\n\n> 常量指针\n\n~~~C++\nint a=10,b=20;\n\n//定义常量指针\nconst int *p = &a;\n\n//尝试修改指针所指向空间的值,报错!\n*p = 20;\n\n//指针重新指向新的空间,可行!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针是不能修改所指向的空间的值，但可重新指向新的空间**,并且定义时，**const关键字是放在指针的左侧的**。\n\n---\n\n> 指针常量\n\n~~~C++\nint a=10,b=20;\n\n//定义指针常量\nint * const p = &a;\n\n//修改指针所指向空间的值,可行!\n*p=20;\n\n//尝试为指针重新指向新的空间，报错!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针可修改所指向的空间的值，但不可重新指向新的空间**,并且定义时，**const关键字是放在指针的右侧的**。\n\n---\n\n> 既修饰指针又修饰常量\n\n~~~C++\n\nint a=10,b=20;\n\n//定义同时const修饰指针常量的指针\nconst int * cosnt p = &a;\n\n//尝试修改指针所指向的空间的值，报错!\n*p = 20;\n\n//尝试为指针重新指向新的空间，报错!\n\np = &b;\n~~~\n\n看上面的案例，可以得出，**如果指针和常量都被const修饰，那么就和const 引用非常类似了**。\n\n---\n\n**小结**\n\n常量指针\n\n- 不可修改所指向的空间的值\n- 可重新指向新的空间\n\n指针常量\n\n- 可修改所指向的空间的值\n- 不可重新指向新的空间\n\n指针和常量都被const所修饰\n\n- 不可修改所指向的空间的值\n- 不可重新指向新的空间\n\n**小技巧**\n\n> 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符\"*\")的右侧还是做左侧。\n\n---","slug":"C-指针-基础01","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobb000qomoo38xk44q9","content":"<p>开始写C++中比较难理解的几个知识点的笔记。</p>\n<a id=\"more\"></a>\n<h1 id=\"0x00-空指针\"><a href=\"#0x00-空指针\" class=\"headerlink\" title=\"0x00 空指针\"></a>0x00 <strong>空指针</strong></h1><p><strong>用途:给指针初始化值。</strong></p>\n<p><strong>特性:空指针不可访问。</strong></p>\n<p>为什么不可访问?</p>\n<p>因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。</p>\n<p><strong>报错例子</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改空指针所指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>常用情景</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使指针重新指向内存空间,可行!</span></span><br><span class=\"line\">p = &amp;a;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。</p>\n<h1 id=\"0x01-野指针\"><a href=\"#0x01-野指针\" class=\"headerlink\" title=\"0x01 野指针\"></a>0x01 <strong>野指针</strong></h1><p><strong>说明:指针指向的是非法的内存空间叫做野指针</strong></p>\n<p><strong>异常:读取访问权限错误</strong></p>\n<p><strong>报错例子:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使指针指向一个未知空间</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span>*)<span class=\"number\">0x1010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!</p>\n<h1 id=\"0x02-const修饰指针\"><a href=\"#0x02-const修饰指针\" class=\"headerlink\" title=\"0x02 const修饰指针\"></a>0x02 <strong>const修饰指针</strong></h1><p>const修饰指针分为三种场景</p>\n<ul>\n<li><p>const修饰指针————常量指针</p>\n</li>\n<li><p>const修饰常量————指针常量</p>\n</li>\n<li><p>const既修饰指针又修饰常量</p>\n</li>\n</ul>\n<blockquote>\n<p>常量指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义常量指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指针重新指向新的空间,可行!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针是不能修改所指向的空间的值，但可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的左侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>指针常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义指针常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改指针所指向空间的值,可行!</span></span><br><span class=\"line\">*p=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针可修改所指向的空间的值，但不可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的右侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>既修饰指针又修饰常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义同时const修饰指针常量的指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * cosnt p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向的空间的值，报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>如果指针和常量都被const修饰，那么就和const 引用非常类似了</strong>。</p>\n<hr>\n<p><strong>小结</strong></p>\n<p>常量指针</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>可重新指向新的空间</li>\n</ul>\n<p>指针常量</p>\n<ul>\n<li>可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p>指针和常量都被const所修饰</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p><strong>小技巧</strong></p>\n<blockquote>\n<p>辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"<p>开始写C++中比较难理解的几个知识点的笔记。</p>","more":"<h1 id=\"0x00-空指针\"><a href=\"#0x00-空指针\" class=\"headerlink\" title=\"0x00 空指针\"></a>0x00 <strong>空指针</strong></h1><p><strong>用途:给指针初始化值。</strong></p>\n<p><strong>特性:空指针不可访问。</strong></p>\n<p>为什么不可访问?</p>\n<p>因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。</p>\n<p><strong>报错例子</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改空指针所指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>常用情景</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使指针重新指向内存空间,可行!</span></span><br><span class=\"line\">p = &amp;a;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。</p>\n<h1 id=\"0x01-野指针\"><a href=\"#0x01-野指针\" class=\"headerlink\" title=\"0x01 野指针\"></a>0x01 <strong>野指针</strong></h1><p><strong>说明:指针指向的是非法的内存空间叫做野指针</strong></p>\n<p><strong>异常:读取访问权限错误</strong></p>\n<p><strong>报错例子:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使指针指向一个未知空间</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span>*)<span class=\"number\">0x1010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!</p>\n<h1 id=\"0x02-const修饰指针\"><a href=\"#0x02-const修饰指针\" class=\"headerlink\" title=\"0x02 const修饰指针\"></a>0x02 <strong>const修饰指针</strong></h1><p>const修饰指针分为三种场景</p>\n<ul>\n<li><p>const修饰指针————常量指针</p>\n</li>\n<li><p>const修饰常量————指针常量</p>\n</li>\n<li><p>const既修饰指针又修饰常量</p>\n</li>\n</ul>\n<blockquote>\n<p>常量指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义常量指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指针重新指向新的空间,可行!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针是不能修改所指向的空间的值，但可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的左侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>指针常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义指针常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改指针所指向空间的值,可行!</span></span><br><span class=\"line\">*p=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针可修改所指向的空间的值，但不可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的右侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>既修饰指针又修饰常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义同时const修饰指针常量的指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * cosnt p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向的空间的值，报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>如果指针和常量都被const修饰，那么就和const 引用非常类似了</strong>。</p>\n<hr>\n<p><strong>小结</strong></p>\n<p>常量指针</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>可重新指向新的空间</li>\n</ul>\n<p>指针常量</p>\n<ul>\n<li>可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p>指针和常量都被const所修饰</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p><strong>小技巧</strong></p>\n<blockquote>\n<p>辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。</p>\n</blockquote>\n<hr>"},{"title":"C++指针[基础02]","date":"2019-05-06T13:58:29.000Z","copyright":true,"_content":"\nC++指针和数组的操作。\n\n<!--more-->\n\nC++中访问数组元素可以使用如下示例进行访问:\n\n~~~C++\nint arr[3]={0,1,2};\n\ncout<<\"第2个元素为:\"<<arr[1]<<endl;\n~~~\n\n想必大家都知道输出的值为:1\n\n---\n\n那么我们现在可以使用指针进行访问数组元素\n\n数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\ncout<<\"p:\"<<*p<<endl;\n~~~\n\n输出结果为:\n\n~~~\np:0\n~~~\n\n**提问:**\n\n为什么指针可以指向数组名，而不需要使用引用符(&)？\n\n**疑惑解答:**\n\n那是因为在C++中，数组其实就是一块内存空间，然而里面的**每个元素也就组成了一块连续的内存空间**，而**数组名就当任了数组的首地址**的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。\n\n---\n\n通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\n//对指针进行位偏移\np++;\n\ncout<<\"p:\";\n~~~\n\n输出结果:\n\n~~~\np: 1\n~~~\n\n上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&arr[1]的位置，我们通过下图更直观的查看它的变化。\n\n![位偏移](C-指针-基础02/指针位偏移.png)\n\n---\n\n最后利用指针遍历输出数组内的元素\n\n~~~C++\nint arr[3] = {0,1,2};\n\nint *p = arr;\n\nfor(int i = 0;i <3;i++,p++){\n  std::cout<<*p<<std::endl;\n}\n~~~\n\n输出结果:\n\n~~~\n0\n1\n2\n~~~\n\n---","source":"_posts/C-指针-基础02.md","raw":"---\ntitle: 'C++指针[基础02]'\ndate: 2019-05-06 21:58:29\ncategories: 学习笔记\ntags:\n  - C++\n  - 指针\n  - 学习笔记\ncopyright: true\n---\n\nC++指针和数组的操作。\n\n<!--more-->\n\nC++中访问数组元素可以使用如下示例进行访问:\n\n~~~C++\nint arr[3]={0,1,2};\n\ncout<<\"第2个元素为:\"<<arr[1]<<endl;\n~~~\n\n想必大家都知道输出的值为:1\n\n---\n\n那么我们现在可以使用指针进行访问数组元素\n\n数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\ncout<<\"p:\"<<*p<<endl;\n~~~\n\n输出结果为:\n\n~~~\np:0\n~~~\n\n**提问:**\n\n为什么指针可以指向数组名，而不需要使用引用符(&)？\n\n**疑惑解答:**\n\n那是因为在C++中，数组其实就是一块内存空间，然而里面的**每个元素也就组成了一块连续的内存空间**，而**数组名就当任了数组的首地址**的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。\n\n---\n\n通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\n//对指针进行位偏移\np++;\n\ncout<<\"p:\";\n~~~\n\n输出结果:\n\n~~~\np: 1\n~~~\n\n上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&arr[1]的位置，我们通过下图更直观的查看它的变化。\n\n![位偏移](C-指针-基础02/指针位偏移.png)\n\n---\n\n最后利用指针遍历输出数组内的元素\n\n~~~C++\nint arr[3] = {0,1,2};\n\nint *p = arr;\n\nfor(int i = 0;i <3;i++,p++){\n  std::cout<<*p<<std::endl;\n}\n~~~\n\n输出结果:\n\n~~~\n0\n1\n2\n~~~\n\n---","slug":"C-指针-基础02","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobc000vomooae2kfbnz","content":"<p>C++指针和数组的操作。</p>\n<a id=\"more\"></a>\n<p>C++中访问数组元素可以使用如下示例进行访问:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"第2个元素为:\"</span>&lt;&lt;arr[<span class=\"number\">1</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>想必大家都知道输出的值为:1</p>\n<hr>\n<p>那么我们现在可以使用指针进行访问数组元素</p>\n<p>数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p:0</span><br></pre></td></tr></table></figure>\n<p><strong>提问:</strong></p>\n<p>为什么指针可以指向数组名，而不需要使用引用符(&amp;)？</p>\n<p><strong>疑惑解答:</strong></p>\n<p>那是因为在C++中，数组其实就是一块内存空间，然而里面的<strong>每个元素也就组成了一块连续的内存空间</strong>，而<strong>数组名就当任了数组的首地址</strong>的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。</p>\n<hr>\n<p>通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对指针进行位偏移</span></span><br><span class=\"line\">p++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p: 1</span><br></pre></td></tr></table></figure>\n<p>上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。</p>\n<p><img src=\"/2019/05/06/C-指针-基础02/指针位偏移.png\" alt=\"位偏移\"></p>\n<hr>\n<p>最后利用指针遍历输出数组内的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;<span class=\"number\">3</span>;i++,p++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<p>C++指针和数组的操作。</p>","more":"<p>C++中访问数组元素可以使用如下示例进行访问:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"第2个元素为:\"</span>&lt;&lt;arr[<span class=\"number\">1</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>想必大家都知道输出的值为:1</p>\n<hr>\n<p>那么我们现在可以使用指针进行访问数组元素</p>\n<p>数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p:0</span><br></pre></td></tr></table></figure>\n<p><strong>提问:</strong></p>\n<p>为什么指针可以指向数组名，而不需要使用引用符(&amp;)？</p>\n<p><strong>疑惑解答:</strong></p>\n<p>那是因为在C++中，数组其实就是一块内存空间，然而里面的<strong>每个元素也就组成了一块连续的内存空间</strong>，而<strong>数组名就当任了数组的首地址</strong>的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。</p>\n<hr>\n<p>通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对指针进行位偏移</span></span><br><span class=\"line\">p++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p: 1</span><br></pre></td></tr></table></figure>\n<p>上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。</p>\n<p><img src=\"/2019/05/06/C-指针-基础02/指针位偏移.png\" alt=\"位偏移\"></p>\n<hr>\n<p>最后利用指针遍历输出数组内的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;<span class=\"number\">3</span>;i++,p++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"Doom Emacs Tramp Sending卡死问题","copyright":true,"date":"2020-01-22T02:13:12.000Z","_content":"\n在使用DoomEmacshttps://github.com/bbatsov/prelude/issues/594的 sudo-thin-file函数时出现不能输入密码的解决方案。\n<!--more-->\n\n# 遇到的问题 \n\n> 使用 sudo-this-file函数出现:\n\n``` emacs-lisp\nTramp: Sending Password\n```\n\n\n# 原因\n\n原因是因为projectile占用了minibuffer，当Tramp试图请求输入密码时就会出现问题。\n\n# 解决方案\n\n我在这个Issue找到的[解决方案](https://github.com/bbatsov/prelude/issues/594 \"外\n部链接->Github\")\n\n我是在`Domm Emacs`的`config.el`里加上下面代码:\n\n``` emacs-lisp\n(projectile-global-mode)\n(set projectile-mode-line \" Projectile\")\n```\n\n> TG群里的Citreu还说可以设置~/.authinfo解决，这样好像更加安全。\n","source":"_posts/Doom-Emacs-Tramp-Sending卡死问题.md","raw":"---\ntitle: Doom Emacs Tramp Sending卡死问题\ncopyright: true\ndate: 2020-01-22 10:13:12\ncategories: 折腾日记\ntags: Emacs\n---\n\n在使用DoomEmacshttps://github.com/bbatsov/prelude/issues/594的 sudo-thin-file函数时出现不能输入密码的解决方案。\n<!--more-->\n\n# 遇到的问题 \n\n> 使用 sudo-this-file函数出现:\n\n``` emacs-lisp\nTramp: Sending Password\n```\n\n\n# 原因\n\n原因是因为projectile占用了minibuffer，当Tramp试图请求输入密码时就会出现问题。\n\n# 解决方案\n\n我在这个Issue找到的[解决方案](https://github.com/bbatsov/prelude/issues/594 \"外\n部链接->Github\")\n\n我是在`Domm Emacs`的`config.el`里加上下面代码:\n\n``` emacs-lisp\n(projectile-global-mode)\n(set projectile-mode-line \" Projectile\")\n```\n\n> TG群里的Citreu还说可以设置~/.authinfo解决，这样好像更加安全。\n","slug":"Doom-Emacs-Tramp-Sending卡死问题","published":1,"updated":"2020-01-22T02:32:31.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobf000xomooc3csvtb9","content":"<p>在使用DoomEmacs<a href=\"https://github.com/bbatsov/prelude/issues/594的\" target=\"_blank\" rel=\"noopener\">https://github.com/bbatsov/prelude/issues/594的</a> sudo-thin-file函数时出现不能输入密码的解决方案。<br><a id=\"more\"></a></p>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><blockquote>\n<p>使用 sudo-this-file函数出现:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tramp: Sending Password</span><br></pre></td></tr></table></figure>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>原因是因为projectile占用了minibuffer，当Tramp试图请求输入密码时就会出现问题。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>我在这个Issue找到的<a href=\"https://github.com/bbatsov/prelude/issues/594\" title=\"外\n部链接-&gt;Github\" target=\"_blank\" rel=\"noopener\">解决方案</a></p>\n<p>我是在<code>Domm Emacs</code>的<code>config.el</code>里加上下面代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(projectile-global-mode)</span><br><span class=\"line\">(set projectile-mode-line &quot; Projectile&quot;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>TG群里的Citreu还说可以设置~/.authinfo解决，这样好像更加安全。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在使用DoomEmacs<a href=\"https://github.com/bbatsov/prelude/issues/594的\" target=\"_blank\" rel=\"noopener\">https://github.com/bbatsov/prelude/issues/594的</a> sudo-thin-file函数时出现不能输入密码的解决方案。<br></p>","more":"<p></p>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><blockquote>\n<p>使用 sudo-this-file函数出现:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tramp: Sending Password</span><br></pre></td></tr></table></figure>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>原因是因为projectile占用了minibuffer，当Tramp试图请求输入密码时就会出现问题。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>我在这个Issue找到的<a href=\"https://github.com/bbatsov/prelude/issues/594\" title=\"外\n部链接-&gt;Github\" target=\"_blank\" rel=\"noopener\">解决方案</a></p>\n<p>我是在<code>Domm Emacs</code>的<code>config.el</code>里加上下面代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(projectile-global-mode)</span><br><span class=\"line\">(set projectile-mode-line &quot; Projectile&quot;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>TG群里的Citreu还说可以设置~/.authinfo解决，这样好像更加安全。</p>\n</blockquote>"},{"title":"C++的命名空间与作用域","copyright":true,"date":"2019-05-30T07:42:43.000Z","_content":"\n本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．\n\n<!--more-->\n\n# **命名空间**\n\n> 也称为名字空间，可以解决多模块同名冲突的问题\n\n## **命名空间的作用**\n\n在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突．\n\n解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间．\n\n## **定义命名空间**\n\n定义命名空间很简单只需要使用`namespace`关键字即可\n\n我们可以定义一个命名空间将自己的类，函数或对象包括起来:\n\n~~~C++\nnamespace myspace{\n    class Test{\n    public:\n      int a;\n      Test(int a):this->a(a){}\n    };\n    Test t(10);\n}\n\nint main(){\n  using namespace myspace;\n\n  Test t(20);\n  cout<<t.a<<endl;\n}\n~~~\n\n与类的成员类似，这些对象，函数，类，被称为名字空间的成员．\n\n## **using声明**\n\n> using namespace `命名空间名`;\n\n在前面的内容中，已经不知不觉地使用上了名字空间，例如:\n\n~~~C++\nusing namespace std;\ncout<<\"hello\"<<endl;\n~~~\n\nusing声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl.\n\n## **using指令**\n\n倘若我们只需要使用`std`命名空间中的`cout`和`endl`成员，那么可以通过using指令指定待使用的命名空间的成员.\n\n~~~C++\nusing std::cout;\nusing std::endl;\ncout<<\"hello\"<<endl;\n~~~\n\nusing指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点.\n\n## **命名空间的别名**\n\n如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分.\n\n~~~C++\nnamespace myStd = std;\n\nmyStd::cout<<\"hello\"<<myStd::endl;\n~~~\n\n其中`myStd`作为`std`命名空间的别名．\n\n# **作用域**\n\n> 可以简称为`域`,是指对象的可见性问题\n\nC++目前支持3种作用域:\n  \n  - 局部作用域(local scope);\n  \n  - 名字作用域(namespace scope);\n\n  - 类域(calss scope);\n\n## **局部作用域**\n\n在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用．\n\n例如，函数体，循环体都是局部作用域:\n\n~~~C++\nvoid foo(){\n  int a(10);\n}\n//error a超过了作用域，访问不到foo()函数内部的a变量\ncout<<a<<endl;\n~~~\n\n~~~C++\nfor(int i=0;i<100;i++){\n  cout<<i<<endl;\n}\n//error i超过了for的作用域，i是for的局部变量\ncout<<i<<endl;\n~~~\n\n**提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错.**\n\n下面再看一个case语句块的作用域\n\n~~~C++\nint choose(-1);\ncin>>choose;\nswitch(choose){\n  case 0:\n    string str;\n    break;\n  case 1:\n    //error:重定义了str\n    string str;\n    break;\n}\n~~~\n\n若不用`{}`将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下:\n\n~~~C++\nint choose(-1);\ncin>>choose;\nswitch(choose){\n  case 0:\n  {\n    string str;\n    break;\n  }\n  case 1:\n  {\n    //error:重定义了str\n    string str;\n    break;\n  }\n}\n~~~\n\n我们通过加上`{}`使得给每个case块加上了不同的作用域，也就解决了重定义的问题．\n\n## **函数的作用域**\n\n函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问．\n\n函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制．\n\n~~~C++\nvoid foo(int i){\n  //正常访问i变量\n  cout<<i<<endl;\n}\n//error 未声明i变量\ncout<<i<<endl;\n~~~\n\n当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的\n\n~~~C++\nvoid foo(int i){\n  cout<<i<<endl;\n  if(i>0){\n    foo(i/2);\n  }\n}\n~~~\n\n\n# **局部变量的存储类型**\n\n你可能听说过:自动存储类型，静态存储类型，但是你听过`寄存器存储类型`么?\n\n不同的存储类型，决定了C++编译器存储这些属性的空间和方式.\n\n## **自动存储类型**\n\n在默认情况下，我们定义的变量就属于自动存储类型\n\n~~~C++\nvoid foo(){\n  int a(10);\n  cout<<a<<endl;\n}\n~~~\n\n在foo()函数体执行完毕后`a`变量将会自动释放，我们也可以换种写法:\n\n~~~C++\nvoid foo(){\n  auto int a(10);\n  cout<<a<<endl;\n}\n~~~\n这样做只不过为了显式的说明这个是个自动存储类型的变量\n\n我们还可以使用类函数观测自动存储类型的销毁时间:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Test {\npublic:\n    int a;\n\n    Test(int a);\n\n    ~Test();\n};\n\nTest::Test(int a) : a(a) {\n    cout << \"创建[\" << this << \"]\" << endl;\n}\n\nTest::~Test() {\n    cout << \"销毁[\" << this << \"]\" << endl;\n}\n\nint main() {\n    Test t(10);\n    Test t1(20);\n    return 0;\n}\n~~~\n\n输出结果\n\n~~~\n创建[0x7fff82f501c0]\n创建[0x7fff82f501c4]\n销毁[0x7fff82f501c4]\n销毁[0x7fff82f501c0]\n\nProcess finished with exit code 0\n~~~\n\n以上代码就可观测到自动存储类型变量的自动销毁过程．\n\n**注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义．**\n\n~~~C++\nvoid *foo(){\n  auto Test t(10);\n  return &t;\n}\n~~~\n\n## **寄存器存储类型**\n\n寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量．\n\n~~~C++\nvoid foo(){\n    for (register int i = 0; i < 10000; ++i) {\n        cout<<i<<endl;\n    }\n}\n~~~\n\n虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上`register`仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效．\n\n## **静态存储类型**\n\n静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁．\n\n请看下面的代码:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Test {\n    int _a;\npublic:\n    Test(int a) : _a(a) {\n        cout << \"创建[\" << this << \"]\" << endl;\n    }\n\n    ~Test() {\n        cout << \"销毁[\" << this << \"]\" << endl;\n    }\n};\n\nvoid foo() {\n    //静态变量\n    static Test t(10);\n    cout << \"t对象已销毁\" << endl;\n}\n\nint main() {\n    //调用第一次\n    foo();\n    //调用第二次\n    foo();\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~\n创建[0x5645e7afa19c]\nt对象已销毁\nt对象已销毁\n销毁[0x5645e7afa19c]\n~~~\n\n可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量`t`依然存在!\n\n**常见用法**\n\n程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据.\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nvoid foo() {\n    static int i(0);\n    i++;\n    cout << \"第\" << i << \"次调用foo()\" << endl;\n}\n\nint main() {\n    for (int i = 0; i < 3; ++i) {\n        foo();\n    }\n    return 0;\n}\n~~~\n\n输出结果\n\n~~~\n第1次调用foo()\n第2次调用foo()\n第3次调用foo()\n\nProcess finished with exit code 0\n~~~\n\n今天就先写到这里，继续学习了.\n\n# **命名空间域**\n\n## **全局域**\n\n~~~C++\n//全局作用域下的varA\nint varA=100;\nvoid foo1(){\n    varA++;\n}\nvoid foo2(){\n    int varA=200;\n    ::varA++;\n    //输出内部作用域的varA\n    cout<<varA<<endl;\n    //输出全局作用域的varA\n    cout<<::varA<<endl;\n}\nint main() {\n    foo1();\n    foo2();\n    return 0;\n}\n~~~\n\n输出结果\n\n~~~\n200\n102\n\nProcess finished with exit code 0\n~~~\n\n最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。\n\n我们使用域操作符\"::\"来显式的指定作用域。\n\n\n\n","source":"_posts/C-的命名空间与作用域.md","raw":"---\ntitle: C++的命名空间与作用域\ncopyright: true\ndate: 2019-05-30 15:42:43\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．\n\n<!--more-->\n\n# **命名空间**\n\n> 也称为名字空间，可以解决多模块同名冲突的问题\n\n## **命名空间的作用**\n\n在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突．\n\n解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间．\n\n## **定义命名空间**\n\n定义命名空间很简单只需要使用`namespace`关键字即可\n\n我们可以定义一个命名空间将自己的类，函数或对象包括起来:\n\n~~~C++\nnamespace myspace{\n    class Test{\n    public:\n      int a;\n      Test(int a):this->a(a){}\n    };\n    Test t(10);\n}\n\nint main(){\n  using namespace myspace;\n\n  Test t(20);\n  cout<<t.a<<endl;\n}\n~~~\n\n与类的成员类似，这些对象，函数，类，被称为名字空间的成员．\n\n## **using声明**\n\n> using namespace `命名空间名`;\n\n在前面的内容中，已经不知不觉地使用上了名字空间，例如:\n\n~~~C++\nusing namespace std;\ncout<<\"hello\"<<endl;\n~~~\n\nusing声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl.\n\n## **using指令**\n\n倘若我们只需要使用`std`命名空间中的`cout`和`endl`成员，那么可以通过using指令指定待使用的命名空间的成员.\n\n~~~C++\nusing std::cout;\nusing std::endl;\ncout<<\"hello\"<<endl;\n~~~\n\nusing指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点.\n\n## **命名空间的别名**\n\n如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分.\n\n~~~C++\nnamespace myStd = std;\n\nmyStd::cout<<\"hello\"<<myStd::endl;\n~~~\n\n其中`myStd`作为`std`命名空间的别名．\n\n# **作用域**\n\n> 可以简称为`域`,是指对象的可见性问题\n\nC++目前支持3种作用域:\n  \n  - 局部作用域(local scope);\n  \n  - 名字作用域(namespace scope);\n\n  - 类域(calss scope);\n\n## **局部作用域**\n\n在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用．\n\n例如，函数体，循环体都是局部作用域:\n\n~~~C++\nvoid foo(){\n  int a(10);\n}\n//error a超过了作用域，访问不到foo()函数内部的a变量\ncout<<a<<endl;\n~~~\n\n~~~C++\nfor(int i=0;i<100;i++){\n  cout<<i<<endl;\n}\n//error i超过了for的作用域，i是for的局部变量\ncout<<i<<endl;\n~~~\n\n**提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错.**\n\n下面再看一个case语句块的作用域\n\n~~~C++\nint choose(-1);\ncin>>choose;\nswitch(choose){\n  case 0:\n    string str;\n    break;\n  case 1:\n    //error:重定义了str\n    string str;\n    break;\n}\n~~~\n\n若不用`{}`将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下:\n\n~~~C++\nint choose(-1);\ncin>>choose;\nswitch(choose){\n  case 0:\n  {\n    string str;\n    break;\n  }\n  case 1:\n  {\n    //error:重定义了str\n    string str;\n    break;\n  }\n}\n~~~\n\n我们通过加上`{}`使得给每个case块加上了不同的作用域，也就解决了重定义的问题．\n\n## **函数的作用域**\n\n函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问．\n\n函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制．\n\n~~~C++\nvoid foo(int i){\n  //正常访问i变量\n  cout<<i<<endl;\n}\n//error 未声明i变量\ncout<<i<<endl;\n~~~\n\n当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的\n\n~~~C++\nvoid foo(int i){\n  cout<<i<<endl;\n  if(i>0){\n    foo(i/2);\n  }\n}\n~~~\n\n\n# **局部变量的存储类型**\n\n你可能听说过:自动存储类型，静态存储类型，但是你听过`寄存器存储类型`么?\n\n不同的存储类型，决定了C++编译器存储这些属性的空间和方式.\n\n## **自动存储类型**\n\n在默认情况下，我们定义的变量就属于自动存储类型\n\n~~~C++\nvoid foo(){\n  int a(10);\n  cout<<a<<endl;\n}\n~~~\n\n在foo()函数体执行完毕后`a`变量将会自动释放，我们也可以换种写法:\n\n~~~C++\nvoid foo(){\n  auto int a(10);\n  cout<<a<<endl;\n}\n~~~\n这样做只不过为了显式的说明这个是个自动存储类型的变量\n\n我们还可以使用类函数观测自动存储类型的销毁时间:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Test {\npublic:\n    int a;\n\n    Test(int a);\n\n    ~Test();\n};\n\nTest::Test(int a) : a(a) {\n    cout << \"创建[\" << this << \"]\" << endl;\n}\n\nTest::~Test() {\n    cout << \"销毁[\" << this << \"]\" << endl;\n}\n\nint main() {\n    Test t(10);\n    Test t1(20);\n    return 0;\n}\n~~~\n\n输出结果\n\n~~~\n创建[0x7fff82f501c0]\n创建[0x7fff82f501c4]\n销毁[0x7fff82f501c4]\n销毁[0x7fff82f501c0]\n\nProcess finished with exit code 0\n~~~\n\n以上代码就可观测到自动存储类型变量的自动销毁过程．\n\n**注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义．**\n\n~~~C++\nvoid *foo(){\n  auto Test t(10);\n  return &t;\n}\n~~~\n\n## **寄存器存储类型**\n\n寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量．\n\n~~~C++\nvoid foo(){\n    for (register int i = 0; i < 10000; ++i) {\n        cout<<i<<endl;\n    }\n}\n~~~\n\n虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上`register`仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效．\n\n## **静态存储类型**\n\n静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁．\n\n请看下面的代码:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Test {\n    int _a;\npublic:\n    Test(int a) : _a(a) {\n        cout << \"创建[\" << this << \"]\" << endl;\n    }\n\n    ~Test() {\n        cout << \"销毁[\" << this << \"]\" << endl;\n    }\n};\n\nvoid foo() {\n    //静态变量\n    static Test t(10);\n    cout << \"t对象已销毁\" << endl;\n}\n\nint main() {\n    //调用第一次\n    foo();\n    //调用第二次\n    foo();\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~\n创建[0x5645e7afa19c]\nt对象已销毁\nt对象已销毁\n销毁[0x5645e7afa19c]\n~~~\n\n可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量`t`依然存在!\n\n**常见用法**\n\n程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据.\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nvoid foo() {\n    static int i(0);\n    i++;\n    cout << \"第\" << i << \"次调用foo()\" << endl;\n}\n\nint main() {\n    for (int i = 0; i < 3; ++i) {\n        foo();\n    }\n    return 0;\n}\n~~~\n\n输出结果\n\n~~~\n第1次调用foo()\n第2次调用foo()\n第3次调用foo()\n\nProcess finished with exit code 0\n~~~\n\n今天就先写到这里，继续学习了.\n\n# **命名空间域**\n\n## **全局域**\n\n~~~C++\n//全局作用域下的varA\nint varA=100;\nvoid foo1(){\n    varA++;\n}\nvoid foo2(){\n    int varA=200;\n    ::varA++;\n    //输出内部作用域的varA\n    cout<<varA<<endl;\n    //输出全局作用域的varA\n    cout<<::varA<<endl;\n}\nint main() {\n    foo1();\n    foo2();\n    return 0;\n}\n~~~\n\n输出结果\n\n~~~\n200\n102\n\nProcess finished with exit code 0\n~~~\n\n最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。\n\n我们使用域操作符\"::\"来显式的指定作用域。\n\n\n\n","slug":"C-的命名空间与作用域","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobi0011omoobujoychz","content":"<p>本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．</p>\n<a id=\"more\"></a>\n<h1 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a><strong>命名空间</strong></h1><blockquote>\n<p>也称为名字空间，可以解决多模块同名冲突的问题</p>\n</blockquote>\n<h2 id=\"命名空间的作用\"><a href=\"#命名空间的作用\" class=\"headerlink\" title=\"命名空间的作用\"></a><strong>命名空间的作用</strong></h2><p>在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突．</p>\n<p>解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间．</p>\n<h2 id=\"定义命名空间\"><a href=\"#定义命名空间\" class=\"headerlink\" title=\"定义命名空间\"></a><strong>定义命名空间</strong></h2><p>定义命名空间很简单只需要使用<code>namespace</code>关键字即可</p>\n<p>我们可以定义一个命名空间将自己的类，函数或对象包括起来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> myspace&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">      Test(<span class=\"keyword\">int</span> a):<span class=\"keyword\">this</span>-&gt;a(a)&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> myspace;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;t.a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与类的成员类似，这些对象，函数，类，被称为名字空间的成员．</p>\n<h2 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a><strong>using声明</strong></h2><blockquote>\n<p>using namespace <code>命名空间名</code>;</p>\n</blockquote>\n<p>在前面的内容中，已经不知不觉地使用上了名字空间，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl.</p>\n<h2 id=\"using指令\"><a href=\"#using指令\" class=\"headerlink\" title=\"using指令\"></a><strong>using指令</strong></h2><p>倘若我们只需要使用<code>std</code>命名空间中的<code>cout</code>和<code>endl</code>成员，那么可以通过using指令指定待使用的命名空间的成员.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点.</p>\n<h2 id=\"命名空间的别名\"><a href=\"#命名空间的别名\" class=\"headerlink\" title=\"命名空间的别名\"></a><strong>命名空间的别名</strong></h2><p>如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> myStd = <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myStd::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello\"</span>&lt;&lt;myStd::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>其中<code>myStd</code>作为<code>std</code>命名空间的别名．</p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h1><blockquote>\n<p>可以简称为<code>域</code>,是指对象的可见性问题</p>\n</blockquote>\n<p>C++目前支持3种作用域:</p>\n<ul>\n<li><p>局部作用域(local scope);</p>\n</li>\n<li><p>名字作用域(namespace scope);</p>\n</li>\n<li><p>类域(calss scope);</p>\n</li>\n</ul>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a><strong>局部作用域</strong></h2><p>在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用．</p>\n<p>例如，函数体，循环体都是局部作用域:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//error a超过了作用域，访问不到foo()函数内部的a变量</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">100</span>;i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//error i超过了for的作用域，i是for的局部变量</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错.</strong></p>\n<p>下面再看一个case语句块的作用域</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">choose</span><span class=\"params\">(<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">cin</span>&gt;&gt;choose;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(choose)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"comment\">//error:重定义了str</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若不用<code>{}</code>将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">choose</span><span class=\"params\">(<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">cin</span>&gt;&gt;choose;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(choose)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//error:重定义了str</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过加上<code>{}</code>使得给每个case块加上了不同的作用域，也就解决了重定义的问题．</p>\n<h2 id=\"函数的作用域\"><a href=\"#函数的作用域\" class=\"headerlink\" title=\"函数的作用域\"></a><strong>函数的作用域</strong></h2><p>函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问．</p>\n<p>函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//正常访问i变量</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//error 未声明i变量</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    foo(i/<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"局部变量的存储类型\"><a href=\"#局部变量的存储类型\" class=\"headerlink\" title=\"局部变量的存储类型\"></a><strong>局部变量的存储类型</strong></h1><p>你可能听说过:自动存储类型，静态存储类型，但是你听过<code>寄存器存储类型</code>么?</p>\n<p>不同的存储类型，决定了C++编译器存储这些属性的空间和方式.</p>\n<h2 id=\"自动存储类型\"><a href=\"#自动存储类型\" class=\"headerlink\" title=\"自动存储类型\"></a><strong>自动存储类型</strong></h2><p>在默认情况下，我们定义的变量就属于自动存储类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在foo()函数体执行完毕后<code>a</code>变量将会自动释放，我们也可以换种写法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做只不过为了显式的说明这个是个自动存储类型的变量</p>\n<p>我们还可以使用类函数观测自动存储类型的销毁时间:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Test();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Test::Test(<span class=\"keyword\">int</span> a) : a(a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"创建[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Test::~Test() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"销毁[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建[0x7fff82f501c0]</span><br><span class=\"line\">创建[0x7fff82f501c4]</span><br><span class=\"line\">销毁[0x7fff82f501c4]</span><br><span class=\"line\">销毁[0x7fff82f501c0]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>以上代码就可观测到自动存储类型变量的自动销毁过程．</p>\n<p><strong>注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义．</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"寄存器存储类型\"><a href=\"#寄存器存储类型\" class=\"headerlink\" title=\"寄存器存储类型\"></a><strong>寄存器存储类型</strong></h2><p>寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上<code>register</code>仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效．</p>\n<h2 id=\"静态存储类型\"><a href=\"#静态存储类型\" class=\"headerlink\" title=\"静态存储类型\"></a><strong>静态存储类型</strong></h2><p>静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁．</p>\n<p>请看下面的代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _a;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a) : _a(a) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"创建[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Test() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"销毁[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//静态变量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"t对象已销毁\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用第一次</span></span><br><span class=\"line\">    foo();</span><br><span class=\"line\">    <span class=\"comment\">//调用第二次</span></span><br><span class=\"line\">    foo();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建[0x5645e7afa19c]</span><br><span class=\"line\">t对象已销毁</span><br><span class=\"line\">t对象已销毁</span><br><span class=\"line\">销毁[0x5645e7afa19c]</span><br></pre></td></tr></table></figure>\n<p>可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量<code>t</code>依然存在!</p>\n<p><strong>常见用法</strong></p>\n<p>程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"第\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\"次调用foo()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">        foo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第1次调用foo()</span><br><span class=\"line\">第2次调用foo()</span><br><span class=\"line\">第3次调用foo()</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>今天就先写到这里，继续学习了.</p>\n<h1 id=\"命名空间域\"><a href=\"#命名空间域\" class=\"headerlink\" title=\"命名空间域\"></a><strong>命名空间域</strong></h1><h2 id=\"全局域\"><a href=\"#全局域\" class=\"headerlink\" title=\"全局域\"></a><strong>全局域</strong></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全局作用域下的varA</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> varA=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    varA++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> varA=<span class=\"number\">200</span>;</span><br><span class=\"line\">    ::varA++;</span><br><span class=\"line\">    <span class=\"comment\">//输出内部作用域的varA</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;varA&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//输出全局作用域的varA</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;::varA&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    foo1();</span><br><span class=\"line\">    foo2();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200</span><br><span class=\"line\">102</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。</p>\n<p>我们使用域操作符”::”来显式的指定作用域。</p>\n","site":{"data":{}},"excerpt":"<p>本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决．</p>","more":"<h1 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a><strong>命名空间</strong></h1><blockquote>\n<p>也称为名字空间，可以解决多模块同名冲突的问题</p>\n</blockquote>\n<h2 id=\"命名空间的作用\"><a href=\"#命名空间的作用\" class=\"headerlink\" title=\"命名空间的作用\"></a><strong>命名空间的作用</strong></h2><p>在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突．</p>\n<p>解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间．</p>\n<h2 id=\"定义命名空间\"><a href=\"#定义命名空间\" class=\"headerlink\" title=\"定义命名空间\"></a><strong>定义命名空间</strong></h2><p>定义命名空间很简单只需要使用<code>namespace</code>关键字即可</p>\n<p>我们可以定义一个命名空间将自己的类，函数或对象包括起来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> myspace&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">      Test(<span class=\"keyword\">int</span> a):<span class=\"keyword\">this</span>-&gt;a(a)&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> myspace;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;t.a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与类的成员类似，这些对象，函数，类，被称为名字空间的成员．</p>\n<h2 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a><strong>using声明</strong></h2><blockquote>\n<p>using namespace <code>命名空间名</code>;</p>\n</blockquote>\n<p>在前面的内容中，已经不知不觉地使用上了名字空间，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl.</p>\n<h2 id=\"using指令\"><a href=\"#using指令\" class=\"headerlink\" title=\"using指令\"></a><strong>using指令</strong></h2><p>倘若我们只需要使用<code>std</code>命名空间中的<code>cout</code>和<code>endl</code>成员，那么可以通过using指令指定待使用的命名空间的成员.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点.</p>\n<h2 id=\"命名空间的别名\"><a href=\"#命名空间的别名\" class=\"headerlink\" title=\"命名空间的别名\"></a><strong>命名空间的别名</strong></h2><p>如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> myStd = <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myStd::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello\"</span>&lt;&lt;myStd::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>其中<code>myStd</code>作为<code>std</code>命名空间的别名．</p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h1><blockquote>\n<p>可以简称为<code>域</code>,是指对象的可见性问题</p>\n</blockquote>\n<p>C++目前支持3种作用域:</p>\n<ul>\n<li><p>局部作用域(local scope);</p>\n</li>\n<li><p>名字作用域(namespace scope);</p>\n</li>\n<li><p>类域(calss scope);</p>\n</li>\n</ul>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a><strong>局部作用域</strong></h2><p>在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用．</p>\n<p>例如，函数体，循环体都是局部作用域:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//error a超过了作用域，访问不到foo()函数内部的a变量</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">100</span>;i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//error i超过了for的作用域，i是for的局部变量</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错.</strong></p>\n<p>下面再看一个case语句块的作用域</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">choose</span><span class=\"params\">(<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">cin</span>&gt;&gt;choose;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(choose)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"comment\">//error:重定义了str</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若不用<code>{}</code>将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">choose</span><span class=\"params\">(<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">cin</span>&gt;&gt;choose;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(choose)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//error:重定义了str</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过加上<code>{}</code>使得给每个case块加上了不同的作用域，也就解决了重定义的问题．</p>\n<h2 id=\"函数的作用域\"><a href=\"#函数的作用域\" class=\"headerlink\" title=\"函数的作用域\"></a><strong>函数的作用域</strong></h2><p>函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问．</p>\n<p>函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//正常访问i变量</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//error 未声明i变量</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    foo(i/<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"局部变量的存储类型\"><a href=\"#局部变量的存储类型\" class=\"headerlink\" title=\"局部变量的存储类型\"></a><strong>局部变量的存储类型</strong></h1><p>你可能听说过:自动存储类型，静态存储类型，但是你听过<code>寄存器存储类型</code>么?</p>\n<p>不同的存储类型，决定了C++编译器存储这些属性的空间和方式.</p>\n<h2 id=\"自动存储类型\"><a href=\"#自动存储类型\" class=\"headerlink\" title=\"自动存储类型\"></a><strong>自动存储类型</strong></h2><p>在默认情况下，我们定义的变量就属于自动存储类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在foo()函数体执行完毕后<code>a</code>变量将会自动释放，我们也可以换种写法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做只不过为了显式的说明这个是个自动存储类型的变量</p>\n<p>我们还可以使用类函数观测自动存储类型的销毁时间:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Test();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Test::Test(<span class=\"keyword\">int</span> a) : a(a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"创建[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Test::~Test() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"销毁[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建[0x7fff82f501c0]</span><br><span class=\"line\">创建[0x7fff82f501c4]</span><br><span class=\"line\">销毁[0x7fff82f501c4]</span><br><span class=\"line\">销毁[0x7fff82f501c0]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>以上代码就可观测到自动存储类型变量的自动销毁过程．</p>\n<p><strong>注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义．</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"寄存器存储类型\"><a href=\"#寄存器存储类型\" class=\"headerlink\" title=\"寄存器存储类型\"></a><strong>寄存器存储类型</strong></h2><p>寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上<code>register</code>仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效．</p>\n<h2 id=\"静态存储类型\"><a href=\"#静态存储类型\" class=\"headerlink\" title=\"静态存储类型\"></a><strong>静态存储类型</strong></h2><p>静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁．</p>\n<p>请看下面的代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _a;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a) : _a(a) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"创建[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Test() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"销毁[\"</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//静态变量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Test <span class=\"title\">t</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"t对象已销毁\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用第一次</span></span><br><span class=\"line\">    foo();</span><br><span class=\"line\">    <span class=\"comment\">//调用第二次</span></span><br><span class=\"line\">    foo();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建[0x5645e7afa19c]</span><br><span class=\"line\">t对象已销毁</span><br><span class=\"line\">t对象已销毁</span><br><span class=\"line\">销毁[0x5645e7afa19c]</span><br></pre></td></tr></table></figure>\n<p>可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量<code>t</code>依然存在!</p>\n<p><strong>常见用法</strong></p>\n<p>程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"第\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\"次调用foo()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">        foo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第1次调用foo()</span><br><span class=\"line\">第2次调用foo()</span><br><span class=\"line\">第3次调用foo()</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>今天就先写到这里，继续学习了.</p>\n<h1 id=\"命名空间域\"><a href=\"#命名空间域\" class=\"headerlink\" title=\"命名空间域\"></a><strong>命名空间域</strong></h1><h2 id=\"全局域\"><a href=\"#全局域\" class=\"headerlink\" title=\"全局域\"></a><strong>全局域</strong></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全局作用域下的varA</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> varA=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    varA++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> varA=<span class=\"number\">200</span>;</span><br><span class=\"line\">    ::varA++;</span><br><span class=\"line\">    <span class=\"comment\">//输出内部作用域的varA</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;varA&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//输出全局作用域的varA</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;::varA&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    foo1();</span><br><span class=\"line\">    foo2();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200</span><br><span class=\"line\">102</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。</p>\n<p>我们使用域操作符”::”来显式的指定作用域。</p>"},{"title":"Fraudster Shop-坑爹商店","copyright":true,"date":"2019-07-05T08:44:41.000Z","_content":"\n  昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。\n<!--more-->\n\n---\n\n# Chinese\n\n&emsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。\n\n&emsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。\n\n&emsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信的，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?\" 我说，老板想都没想说了句,\"有啊!\"，说着便拿出一小沓U盘，我看了看说道:\"老板，这些都不是USB3.0，你拿其他的给我看一下吧!\"，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，\"你一个小时后再来吧，我这里3.0的U盘卖完了。\"，虽然老板说是卖完了，但我大概能知道他根本没有进过USB3.0的货，一直靠着用3.0的价格贩卖2.0的U盘。\n\n&emsp;后来我又找了很多家手机店和电脑店，他们居然都没有USB3.0，并且他们卖的都是USB2.0，更让我吃惊的是，他们全部统一地将USB2.0的U盘卖70-80RMB左右。其中我尝试跟他们讲价，就算是2.0U盘我暂时买个4G的USB2.0还可以装我的i3，我出价30，这是我的最高价了...然后卖家给我说不能卖，最低55，掉价这么快，80直接掉到55，最终没谈成，因为我已经很不想买USB2.0了，更不可能花那么多钱买一个过时的产物。\n\n&emsp;说了这么多，其实就是想让大家以后不要再去实体店买这种电子产品了，当然可能有一些实体店还是正常的价格的，但据我的真实体验，实体店普遍就是要坑小白的，并且就算你指明要USB3.0他还是会拿给你USB2.0看，尝试诱骗你。\n\n&emsp;京东晚上7点下的单，第二天9点就可以取件了，真香。强烈推荐一线城市想买这种小物件直接京东买吧，甚至还有同城送，上午买下午就到，不过要多付点运费。\n\n","source":"_posts/Fraudster-Shop-坑爹商店.md","raw":"---\ntitle: Fraudster Shop-坑爹商店\ncopyright: true\ndate: 2019-07-05 16:44:41\ncategories: 英文文章\ntags:\n  - 日常\n---\n\n  昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。\n<!--more-->\n\n---\n\n# Chinese\n\n&emsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。\n\n&emsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。\n\n&emsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信的，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?\" 我说，老板想都没想说了句,\"有啊!\"，说着便拿出一小沓U盘，我看了看说道:\"老板，这些都不是USB3.0，你拿其他的给我看一下吧!\"，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，\"你一个小时后再来吧，我这里3.0的U盘卖完了。\"，虽然老板说是卖完了，但我大概能知道他根本没有进过USB3.0的货，一直靠着用3.0的价格贩卖2.0的U盘。\n\n&emsp;后来我又找了很多家手机店和电脑店，他们居然都没有USB3.0，并且他们卖的都是USB2.0，更让我吃惊的是，他们全部统一地将USB2.0的U盘卖70-80RMB左右。其中我尝试跟他们讲价，就算是2.0U盘我暂时买个4G的USB2.0还可以装我的i3，我出价30，这是我的最高价了...然后卖家给我说不能卖，最低55，掉价这么快，80直接掉到55，最终没谈成，因为我已经很不想买USB2.0了，更不可能花那么多钱买一个过时的产物。\n\n&emsp;说了这么多，其实就是想让大家以后不要再去实体店买这种电子产品了，当然可能有一些实体店还是正常的价格的，但据我的真实体验，实体店普遍就是要坑小白的，并且就算你指明要USB3.0他还是会拿给你USB2.0看，尝试诱骗你。\n\n&emsp;京东晚上7点下的单，第二天9点就可以取件了，真香。强烈推荐一线城市想买这种小物件直接京东买吧，甚至还有同城送，上午买下午就到，不过要多付点运费。\n\n","slug":"Fraudster-Shop-坑爹商店","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobl0014omooierdv4pm","content":"<p>  昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。<br><a id=\"more\"></a></p>\n<hr>\n<h1 id=\"Chinese\"><a href=\"#Chinese\" class=\"headerlink\" title=\"Chinese\"></a>Chinese</h1><p>&emsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。</p>\n<p>&emsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。</p>\n<p>&emsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信的，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?” 我说，老板想都没想说了句,”有啊!”，说着便拿出一小沓U盘，我看了看说道:”老板，这些都不是USB3.0，你拿其他的给我看一下吧!”，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，”你一个小时后再来吧，我这里3.0的U盘卖完了。”，虽然老板说是卖完了，但我大概能知道他根本没有进过USB3.0的货，一直靠着用3.0的价格贩卖2.0的U盘。</p>\n<p>&emsp;后来我又找了很多家手机店和电脑店，他们居然都没有USB3.0，并且他们卖的都是USB2.0，更让我吃惊的是，他们全部统一地将USB2.0的U盘卖70-80RMB左右。其中我尝试跟他们讲价，就算是2.0U盘我暂时买个4G的USB2.0还可以装我的i3，我出价30，这是我的最高价了…然后卖家给我说不能卖，最低55，掉价这么快，80直接掉到55，最终没谈成，因为我已经很不想买USB2.0了，更不可能花那么多钱买一个过时的产物。</p>\n<p>&emsp;说了这么多，其实就是想让大家以后不要再去实体店买这种电子产品了，当然可能有一些实体店还是正常的价格的，但据我的真实体验，实体店普遍就是要坑小白的，并且就算你指明要USB3.0他还是会拿给你USB2.0看，尝试诱骗你。</p>\n<p>&emsp;京东晚上7点下的单，第二天9点就可以取件了，真香。强烈推荐一线城市想买这种小物件直接京东买吧，甚至还有同城送，上午买下午就到，不过要多付点运费。</p>\n","site":{"data":{}},"excerpt":"<p>  昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。<br></p>","more":"<p></p>\n<hr>\n<h1 id=\"Chinese\"><a href=\"#Chinese\" class=\"headerlink\" title=\"Chinese\"></a>Chinese</h1><p>&emsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。</p>\n<p>&emsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。</p>\n<p>&emsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信的，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?” 我说，老板想都没想说了句,”有啊!”，说着便拿出一小沓U盘，我看了看说道:”老板，这些都不是USB3.0，你拿其他的给我看一下吧!”，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，”你一个小时后再来吧，我这里3.0的U盘卖完了。”，虽然老板说是卖完了，但我大概能知道他根本没有进过USB3.0的货，一直靠着用3.0的价格贩卖2.0的U盘。</p>\n<p>&emsp;后来我又找了很多家手机店和电脑店，他们居然都没有USB3.0，并且他们卖的都是USB2.0，更让我吃惊的是，他们全部统一地将USB2.0的U盘卖70-80RMB左右。其中我尝试跟他们讲价，就算是2.0U盘我暂时买个4G的USB2.0还可以装我的i3，我出价30，这是我的最高价了…然后卖家给我说不能卖，最低55，掉价这么快，80直接掉到55，最终没谈成，因为我已经很不想买USB2.0了，更不可能花那么多钱买一个过时的产物。</p>\n<p>&emsp;说了这么多，其实就是想让大家以后不要再去实体店买这种电子产品了，当然可能有一些实体店还是正常的价格的，但据我的真实体验，实体店普遍就是要坑小白的，并且就算你指明要USB3.0他还是会拿给你USB2.0看，尝试诱骗你。</p>\n<p>&emsp;京东晚上7点下的单，第二天9点就可以取件了，真香。强烈推荐一线城市想买这种小物件直接京东买吧，甚至还有同城送，上午买下午就到，不过要多付点运费。</p>"},{"title":"Emacs is sexy!","copyright":true,"date":"2019-07-26T14:04:20.000Z","_content":"\nEmacs is a highly extensible text editor.It is built on a C core, and provides a fully featured Lisp environment\n\nThere's a reason why Emacs was featured in Tron Legacy - because it's sexy!\n\nYou can use Emacs for all of your text processing needs, internet and social network interations, hacking, coding, maaging to-do's and organizing your daily schedule, playing Tetris, and manay other awesome things. It can even provide you with free psychotherapy and counseling using the built in doctor. A vibrant community of hackers is constantly writing new extensions, thanks to the power of the Emacs Lisp environment.\n\nGNU Emacs is Free Software, both free as in free beer and free as in free speech. The original Emacs was written by St. iGNUcius himself ---- Richard Stallman.\n\nNot only does it give the user the four essential freedoms, its architecture is built in such a way that you have the power to mold it, change it and make it comply to your computering needs.\n\n<!--more-->\n\n# Why use Emacs?\n\nEmacs is a very pwoerful text processor, giving you the power to manipulate documents quickly and efficiently. You can easily move through and edit paragraphs, sentences, words, and logical blocks; blaze through text using powerful search tools; and easily edit thousands of lines at once using regular expressions, keyboard macros and more.\n\n# Colorful text editor\n\nEmacs can be cutomized in every conceivable way, including its looks. You can strip it down, choose between dozens of easy to intall themes with M-x load-theme, or even create your own and share it with your friends. Here are a couple of nice theme galleries: Emacs Themes, Emacs Theme Gallery.\n\n# Et tu, Programmer?\n\nThere are tools for every programming languaage out there. Lisp, Ruby, Python, PHP, Java, Erlang, JavaScript, C, C++, Prolog, Tcl, AWK, PostScript, Clojure, Scala, Perl, Haskell, Elixir all of there languages and more are supported in Emacs. Beacuse of the powerfull Lisp core. Emacs is easy to extend to add support, debugging, code browsing, version control integration and much more.\n\n# Vim user?\n\nLet tell about Spacemacs! Spacemacs is a community-driven Emacs distribution that brings together the world of Vim and Emacs into one text eeditor. It also features ergonomics and mnemonickey binding design, and also works great as a starter pack for newcomers.\n\n# More!\n\nOrg mode helps you to keep notes, maintain TODO lists, plan projects and author documents. You can use your Org documents to create HTML websites like this one or export to LaTeX, Beamer, OpenDocuments and many other formats.\n\nTramp allows you to edit remote files without leaving Emacs. You can seamlessly edit files on remote servers via SSH for FTP.edit local files with su/sudo , and much more.\n\nM-x butterfly unleashes the powers of the butterfly.\n\nUse the built in IRC client ERC along with BitlBee to connect to your favorite chat services, or use the Jabber package to hop on any XMPP service.\n\nOut of the box Emacs includes a mail client, web browser, calendar, and games; you can even edit video and images inside Emacs. There are more than 3,000 packages for Emacs, and more are written all the time. You can easilly extend your Emacs with new packages from GNU ELPA, MELPA and Marmelade repositories.\n","source":"_posts/Emacs-is-sexy.md","raw":"---\ntitle: Emacs is sexy!\ncopyright: true\ndate: 2019-07-26 22:04:20\ncategories: 英文文章\ntags:\n  - 转载\n---\n\nEmacs is a highly extensible text editor.It is built on a C core, and provides a fully featured Lisp environment\n\nThere's a reason why Emacs was featured in Tron Legacy - because it's sexy!\n\nYou can use Emacs for all of your text processing needs, internet and social network interations, hacking, coding, maaging to-do's and organizing your daily schedule, playing Tetris, and manay other awesome things. It can even provide you with free psychotherapy and counseling using the built in doctor. A vibrant community of hackers is constantly writing new extensions, thanks to the power of the Emacs Lisp environment.\n\nGNU Emacs is Free Software, both free as in free beer and free as in free speech. The original Emacs was written by St. iGNUcius himself ---- Richard Stallman.\n\nNot only does it give the user the four essential freedoms, its architecture is built in such a way that you have the power to mold it, change it and make it comply to your computering needs.\n\n<!--more-->\n\n# Why use Emacs?\n\nEmacs is a very pwoerful text processor, giving you the power to manipulate documents quickly and efficiently. You can easily move through and edit paragraphs, sentences, words, and logical blocks; blaze through text using powerful search tools; and easily edit thousands of lines at once using regular expressions, keyboard macros and more.\n\n# Colorful text editor\n\nEmacs can be cutomized in every conceivable way, including its looks. You can strip it down, choose between dozens of easy to intall themes with M-x load-theme, or even create your own and share it with your friends. Here are a couple of nice theme galleries: Emacs Themes, Emacs Theme Gallery.\n\n# Et tu, Programmer?\n\nThere are tools for every programming languaage out there. Lisp, Ruby, Python, PHP, Java, Erlang, JavaScript, C, C++, Prolog, Tcl, AWK, PostScript, Clojure, Scala, Perl, Haskell, Elixir all of there languages and more are supported in Emacs. Beacuse of the powerfull Lisp core. Emacs is easy to extend to add support, debugging, code browsing, version control integration and much more.\n\n# Vim user?\n\nLet tell about Spacemacs! Spacemacs is a community-driven Emacs distribution that brings together the world of Vim and Emacs into one text eeditor. It also features ergonomics and mnemonickey binding design, and also works great as a starter pack for newcomers.\n\n# More!\n\nOrg mode helps you to keep notes, maintain TODO lists, plan projects and author documents. You can use your Org documents to create HTML websites like this one or export to LaTeX, Beamer, OpenDocuments and many other formats.\n\nTramp allows you to edit remote files without leaving Emacs. You can seamlessly edit files on remote servers via SSH for FTP.edit local files with su/sudo , and much more.\n\nM-x butterfly unleashes the powers of the butterfly.\n\nUse the built in IRC client ERC along with BitlBee to connect to your favorite chat services, or use the Jabber package to hop on any XMPP service.\n\nOut of the box Emacs includes a mail client, web browser, calendar, and games; you can even edit video and images inside Emacs. There are more than 3,000 packages for Emacs, and more are written all the time. You can easilly extend your Emacs with new packages from GNU ELPA, MELPA and Marmelade repositories.\n","slug":"Emacs-is-sexy","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobn0019omooyli7pu2s","content":"<p>Emacs is a highly extensible text editor.It is built on a C core, and provides a fully featured Lisp environment</p>\n<p>There’s a reason why Emacs was featured in Tron Legacy - because it’s sexy!</p>\n<p>You can use Emacs for all of your text processing needs, internet and social network interations, hacking, coding, maaging to-do’s and organizing your daily schedule, playing Tetris, and manay other awesome things. It can even provide you with free psychotherapy and counseling using the built in doctor. A vibrant community of hackers is constantly writing new extensions, thanks to the power of the Emacs Lisp environment.</p>\n<p>GNU Emacs is Free Software, both free as in free beer and free as in free speech. The original Emacs was written by St. iGNUcius himself —- Richard Stallman.</p>\n<p>Not only does it give the user the four essential freedoms, its architecture is built in such a way that you have the power to mold it, change it and make it comply to your computering needs.</p>\n<a id=\"more\"></a>\n<h1 id=\"Why-use-Emacs\"><a href=\"#Why-use-Emacs\" class=\"headerlink\" title=\"Why use Emacs?\"></a>Why use Emacs?</h1><p>Emacs is a very pwoerful text processor, giving you the power to manipulate documents quickly and efficiently. You can easily move through and edit paragraphs, sentences, words, and logical blocks; blaze through text using powerful search tools; and easily edit thousands of lines at once using regular expressions, keyboard macros and more.</p>\n<h1 id=\"Colorful-text-editor\"><a href=\"#Colorful-text-editor\" class=\"headerlink\" title=\"Colorful text editor\"></a>Colorful text editor</h1><p>Emacs can be cutomized in every conceivable way, including its looks. You can strip it down, choose between dozens of easy to intall themes with M-x load-theme, or even create your own and share it with your friends. Here are a couple of nice theme galleries: Emacs Themes, Emacs Theme Gallery.</p>\n<h1 id=\"Et-tu-Programmer\"><a href=\"#Et-tu-Programmer\" class=\"headerlink\" title=\"Et tu, Programmer?\"></a>Et tu, Programmer?</h1><p>There are tools for every programming languaage out there. Lisp, Ruby, Python, PHP, Java, Erlang, JavaScript, C, C++, Prolog, Tcl, AWK, PostScript, Clojure, Scala, Perl, Haskell, Elixir all of there languages and more are supported in Emacs. Beacuse of the powerfull Lisp core. Emacs is easy to extend to add support, debugging, code browsing, version control integration and much more.</p>\n<h1 id=\"Vim-user\"><a href=\"#Vim-user\" class=\"headerlink\" title=\"Vim user?\"></a>Vim user?</h1><p>Let tell about Spacemacs! Spacemacs is a community-driven Emacs distribution that brings together the world of Vim and Emacs into one text eeditor. It also features ergonomics and mnemonickey binding design, and also works great as a starter pack for newcomers.</p>\n<h1 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More!\"></a>More!</h1><p>Org mode helps you to keep notes, maintain TODO lists, plan projects and author documents. You can use your Org documents to create HTML websites like this one or export to LaTeX, Beamer, OpenDocuments and many other formats.</p>\n<p>Tramp allows you to edit remote files without leaving Emacs. You can seamlessly edit files on remote servers via SSH for FTP.edit local files with su/sudo , and much more.</p>\n<p>M-x butterfly unleashes the powers of the butterfly.</p>\n<p>Use the built in IRC client ERC along with BitlBee to connect to your favorite chat services, or use the Jabber package to hop on any XMPP service.</p>\n<p>Out of the box Emacs includes a mail client, web browser, calendar, and games; you can even edit video and images inside Emacs. There are more than 3,000 packages for Emacs, and more are written all the time. You can easilly extend your Emacs with new packages from GNU ELPA, MELPA and Marmelade repositories.</p>\n","site":{"data":{}},"excerpt":"<p>Emacs is a highly extensible text editor.It is built on a C core, and provides a fully featured Lisp environment</p>\n<p>There’s a reason why Emacs was featured in Tron Legacy - because it’s sexy!</p>\n<p>You can use Emacs for all of your text processing needs, internet and social network interations, hacking, coding, maaging to-do’s and organizing your daily schedule, playing Tetris, and manay other awesome things. It can even provide you with free psychotherapy and counseling using the built in doctor. A vibrant community of hackers is constantly writing new extensions, thanks to the power of the Emacs Lisp environment.</p>\n<p>GNU Emacs is Free Software, both free as in free beer and free as in free speech. The original Emacs was written by St. iGNUcius himself —- Richard Stallman.</p>\n<p>Not only does it give the user the four essential freedoms, its architecture is built in such a way that you have the power to mold it, change it and make it comply to your computering needs.</p>","more":"<h1 id=\"Why-use-Emacs\"><a href=\"#Why-use-Emacs\" class=\"headerlink\" title=\"Why use Emacs?\"></a>Why use Emacs?</h1><p>Emacs is a very pwoerful text processor, giving you the power to manipulate documents quickly and efficiently. You can easily move through and edit paragraphs, sentences, words, and logical blocks; blaze through text using powerful search tools; and easily edit thousands of lines at once using regular expressions, keyboard macros and more.</p>\n<h1 id=\"Colorful-text-editor\"><a href=\"#Colorful-text-editor\" class=\"headerlink\" title=\"Colorful text editor\"></a>Colorful text editor</h1><p>Emacs can be cutomized in every conceivable way, including its looks. You can strip it down, choose between dozens of easy to intall themes with M-x load-theme, or even create your own and share it with your friends. Here are a couple of nice theme galleries: Emacs Themes, Emacs Theme Gallery.</p>\n<h1 id=\"Et-tu-Programmer\"><a href=\"#Et-tu-Programmer\" class=\"headerlink\" title=\"Et tu, Programmer?\"></a>Et tu, Programmer?</h1><p>There are tools for every programming languaage out there. Lisp, Ruby, Python, PHP, Java, Erlang, JavaScript, C, C++, Prolog, Tcl, AWK, PostScript, Clojure, Scala, Perl, Haskell, Elixir all of there languages and more are supported in Emacs. Beacuse of the powerfull Lisp core. Emacs is easy to extend to add support, debugging, code browsing, version control integration and much more.</p>\n<h1 id=\"Vim-user\"><a href=\"#Vim-user\" class=\"headerlink\" title=\"Vim user?\"></a>Vim user?</h1><p>Let tell about Spacemacs! Spacemacs is a community-driven Emacs distribution that brings together the world of Vim and Emacs into one text eeditor. It also features ergonomics and mnemonickey binding design, and also works great as a starter pack for newcomers.</p>\n<h1 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More!\"></a>More!</h1><p>Org mode helps you to keep notes, maintain TODO lists, plan projects and author documents. You can use your Org documents to create HTML websites like this one or export to LaTeX, Beamer, OpenDocuments and many other formats.</p>\n<p>Tramp allows you to edit remote files without leaving Emacs. You can seamlessly edit files on remote servers via SSH for FTP.edit local files with su/sudo , and much more.</p>\n<p>M-x butterfly unleashes the powers of the butterfly.</p>\n<p>Use the built in IRC client ERC along with BitlBee to connect to your favorite chat services, or use the Jabber package to hop on any XMPP service.</p>\n<p>Out of the box Emacs includes a mail client, web browser, calendar, and games; you can even edit video and images inside Emacs. There are more than 3,000 packages for Emacs, and more are written all the time. You can easilly extend your Emacs with new packages from GNU ELPA, MELPA and Marmelade repositories.</p>"},{"title":"C++读写文件","copyright":true,"date":"2019-05-22T03:20:45.000Z","_content":"\n一些简单的读写文件的操作。\n\n<!--more-->\n\n**本篇文章使用C++```fstream```头文件提供的库函数进行读写操作**\n\n\n> 请引入#include \\<fstream\\>进行下面的操作。\n\n# **写入**\n\n写入文件步骤如下:\n\n1. 实例化ofstream对象，或者fstream对象.\n\n    > ofstream ofs;\n2. 打开文件流\n    \n    > ofs.open(const std::string &__s,ios_base::open__mode=ios_base::out);\n\n3. 写入文件\n\n    > ofs<<;\n\n4. 关闭文件流\n\n    > ofs.close();\n\n**注意打开文件流函数的参数分别为`路径`和`打开方式`.**\n\n常用的打开方式如下:\n\n|模式标识|适用对象|描述|\n|:-:|:-----:|:-:|\n|ios::int|ifstream,fstream|打开输入,默认用于`ifstream`和`fstream`|\n|ios::out|ofstream,fstream|打开输出，默认用于`ofstream`和`fstream`|\n|ios::trunc|ofstream|打开输入，默认用户`ofstream`|\n|ios::ate|ifstream|打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错|\n|ios::app|ostream,fstream|打开输出，并且将数据输出至文件末尾，相当与追加|\n|iso::binary|ifstream,ofstream,fstream|以二进制的方式打开文件，进行输入或输出|\n\n以上所有的打开方式可以通过或`|`运算符进行联合使用，例如:\n\n~~~C++\n//以二进制的方式打开输出\nofstream ofs(path,ios::out|ios::binary);\n~~~\n\n**不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作**\n\n好的，下面可以看例子了，我们将写入一些数据到一个文件内。\n\n## **以文本写入**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n~~~C++\n/**\n * 写入文件\n * @param path 文件路径\n * @param context 内容\n */\nvoid writeFile(string path,string context){\n    //实例化写入对象\n    ofstream ofs;\n    //打开输出\n    ofs.open(path,ios::out);\n    //向文件写入数据\n    ofs<<context<<endl;\n    //关闭输出\n    ofs.close();\n}\n\nint main(){\n    //调用\n    writeFile(\"./test.txt\",\"测试\");\n}\n~~~\n\n这样我们就将`测试`这个段文本信息，写入到当前目录下`test.txt`文件内了.\n\n## **以二进制文件写入**\n\n\n以二进制文件方式写入，C++提供了`write()`库函数,它的函数原型是:\n\n> `write(const _CharT* __s, streamsize __n);`\n\n其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。\n\n~~~C++\nclass Student {\nprivate:\n    char name[64];\n    int age;\npublic:\n    Student(char name[64], int age) {\n        for (int i = 0; i < sizeof(name); ++i)\n            this->name[i] = name[i];\n        this->age = age;\n    }\n};`\n/**\n * 写入二进制文件\n * @param path \n */\nvoid writeFileByBinary(string path) {\n    //创建输出流对象，并且指定路径和文件打开方式\n    ofstream ofs(path, ios::out | ios::binary);\n    Student *student = new Student(\"张三\", 18);\n\n    //写入文件\n    ofs.write((const char *) student, sizeof(Student));\n\n    ofs.close();\n\n    delete (student);\n}\nint main(){\n    writeFileByBinary(\"student.bin\");\n}\n~~~\n\n这里我们将类成员属性的值以二进制的方式写入进一个文件内。\n\n最终文件内的内容人类是看不大懂的。\n\n![二进制写](C-读写文件/二进制文件.png)\n\n**注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.**\n\n# **读取**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n## **以文本文件读取**\n\n读取有很多种方式，下面将会演示三种，分别是:\n\n- 逐行读取\n\n- 逐词读取\n\n- 逐字符读取\n\n---\n\n### **逐字符读取(不推荐)**\n\n**逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。**\n\n~~~C++\n/**\n * 逐字符读取\n * @param path 路径\n */\nvoid readFile04(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储变量\n    char cbuffer;\n    //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.\n    while ((cbuffer = ifs.get()) != EOF) {\n        cout << cbuffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n```EOF```代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。\n\n### **逐行读取(有两种方式，但都是逐行读取)**\n\n第一种：\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile02(string path) {\n    //实例化\n    fstream fs;\n    //打开文件\n    fs.open(path, ios::in);\n    //用字符数组进行缓存\n    char buffer[1024] = {0};\n    //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)\n    while (fs.getline(buffer, sizeof(buffer))) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    fs.close();\n}\n~~~\n\n使用`字符数组`作为数据存储容器，用`fstream`对象的`getline()`函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用`sizeof()`是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。\n\n第二种:\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile03(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储容器\n    string buffer;\n    //使用全局函数getline(输入流，可存储的容器)进行逐行读取\n    while (getline(ifs, buffer)) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数`getline(输入对象,数据存储容器)`,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。\n\n### **逐词读取(以空格区分)**\n\n逐词读取，将会已空格进行区分每个词汇，再读取。\n\n~~~C++\n/**\n * 逐词读取文件\n * @param path 文件路径\n */\nvoid readFile01(string path) {\n    //实例化读取文件对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //判断文件是否能打开\n    if (!ifs.is_open()) {\n        cout << \"文件打开失败!\" << endl;\n        return;\n    }\n    //字符数组缓存\n    char buffer[1024] = {0};\n    //将读取的数据放入缓存区\n    while (ifs >> buffer)\n        cout << buffer << endl;\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。\n\n这种逐词读取的方式是`读取对象`通过`右移运算符`把读取的数据存入容器之中，但是是以空格区分每个词汇。\n\n## **以二进制的方式读取**\n\n前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。\n\n\n~~~C++\n/**\n * 以二进制的方式读取文件\n * @param path 路径\n */\nvoid readFileByBinary(string path) {\n    //创建输入流对象，并且指定路径和文件打开方式\n    ifstream ifs(path, ios::in | ios::binary);\n    char * c = new char[64];\n    ifs.read(c, sizeof(c));\n    cout<<c<<endl;\n}\nint main(){\n    readFileByBinary(\"Student.smi\");\n}\n~~~\n\n输出结果:\n\n~~~\n张三\n\nProcess finished with exit code 0\n~~~\n\n这里我们将`Student.smi`这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。\n\n# **总结**\n\n读取文件创建`ifstream`对象,写入文件创建`ofstream`对象，`fstream`对象既可以读又可以写。\n\n操作文件得先`打开文件`\n\n操作文件完毕得`关闭文件`\n\n二进制文件读取需要读取二进制格式的文件\n","source":"_posts/C-读写文件.md","raw":"---\ntitle: C++读写文件\ncopyright: true\ndate: 2019-05-22 11:20:45\ncategories: 学习笔记\ntags:\n - C++\n---\n\n一些简单的读写文件的操作。\n\n<!--more-->\n\n**本篇文章使用C++```fstream```头文件提供的库函数进行读写操作**\n\n\n> 请引入#include \\<fstream\\>进行下面的操作。\n\n# **写入**\n\n写入文件步骤如下:\n\n1. 实例化ofstream对象，或者fstream对象.\n\n    > ofstream ofs;\n2. 打开文件流\n    \n    > ofs.open(const std::string &__s,ios_base::open__mode=ios_base::out);\n\n3. 写入文件\n\n    > ofs<<;\n\n4. 关闭文件流\n\n    > ofs.close();\n\n**注意打开文件流函数的参数分别为`路径`和`打开方式`.**\n\n常用的打开方式如下:\n\n|模式标识|适用对象|描述|\n|:-:|:-----:|:-:|\n|ios::int|ifstream,fstream|打开输入,默认用于`ifstream`和`fstream`|\n|ios::out|ofstream,fstream|打开输出，默认用于`ofstream`和`fstream`|\n|ios::trunc|ofstream|打开输入，默认用户`ofstream`|\n|ios::ate|ifstream|打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错|\n|ios::app|ostream,fstream|打开输出，并且将数据输出至文件末尾，相当与追加|\n|iso::binary|ifstream,ofstream,fstream|以二进制的方式打开文件，进行输入或输出|\n\n以上所有的打开方式可以通过或`|`运算符进行联合使用，例如:\n\n~~~C++\n//以二进制的方式打开输出\nofstream ofs(path,ios::out|ios::binary);\n~~~\n\n**不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作**\n\n好的，下面可以看例子了，我们将写入一些数据到一个文件内。\n\n## **以文本写入**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n~~~C++\n/**\n * 写入文件\n * @param path 文件路径\n * @param context 内容\n */\nvoid writeFile(string path,string context){\n    //实例化写入对象\n    ofstream ofs;\n    //打开输出\n    ofs.open(path,ios::out);\n    //向文件写入数据\n    ofs<<context<<endl;\n    //关闭输出\n    ofs.close();\n}\n\nint main(){\n    //调用\n    writeFile(\"./test.txt\",\"测试\");\n}\n~~~\n\n这样我们就将`测试`这个段文本信息，写入到当前目录下`test.txt`文件内了.\n\n## **以二进制文件写入**\n\n\n以二进制文件方式写入，C++提供了`write()`库函数,它的函数原型是:\n\n> `write(const _CharT* __s, streamsize __n);`\n\n其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。\n\n~~~C++\nclass Student {\nprivate:\n    char name[64];\n    int age;\npublic:\n    Student(char name[64], int age) {\n        for (int i = 0; i < sizeof(name); ++i)\n            this->name[i] = name[i];\n        this->age = age;\n    }\n};`\n/**\n * 写入二进制文件\n * @param path \n */\nvoid writeFileByBinary(string path) {\n    //创建输出流对象，并且指定路径和文件打开方式\n    ofstream ofs(path, ios::out | ios::binary);\n    Student *student = new Student(\"张三\", 18);\n\n    //写入文件\n    ofs.write((const char *) student, sizeof(Student));\n\n    ofs.close();\n\n    delete (student);\n}\nint main(){\n    writeFileByBinary(\"student.bin\");\n}\n~~~\n\n这里我们将类成员属性的值以二进制的方式写入进一个文件内。\n\n最终文件内的内容人类是看不大懂的。\n\n![二进制写](C-读写文件/二进制文件.png)\n\n**注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.**\n\n# **读取**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n## **以文本文件读取**\n\n读取有很多种方式，下面将会演示三种，分别是:\n\n- 逐行读取\n\n- 逐词读取\n\n- 逐字符读取\n\n---\n\n### **逐字符读取(不推荐)**\n\n**逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。**\n\n~~~C++\n/**\n * 逐字符读取\n * @param path 路径\n */\nvoid readFile04(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储变量\n    char cbuffer;\n    //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.\n    while ((cbuffer = ifs.get()) != EOF) {\n        cout << cbuffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n```EOF```代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。\n\n### **逐行读取(有两种方式，但都是逐行读取)**\n\n第一种：\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile02(string path) {\n    //实例化\n    fstream fs;\n    //打开文件\n    fs.open(path, ios::in);\n    //用字符数组进行缓存\n    char buffer[1024] = {0};\n    //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)\n    while (fs.getline(buffer, sizeof(buffer))) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    fs.close();\n}\n~~~\n\n使用`字符数组`作为数据存储容器，用`fstream`对象的`getline()`函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用`sizeof()`是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。\n\n第二种:\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile03(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储容器\n    string buffer;\n    //使用全局函数getline(输入流，可存储的容器)进行逐行读取\n    while (getline(ifs, buffer)) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数`getline(输入对象,数据存储容器)`,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。\n\n### **逐词读取(以空格区分)**\n\n逐词读取，将会已空格进行区分每个词汇，再读取。\n\n~~~C++\n/**\n * 逐词读取文件\n * @param path 文件路径\n */\nvoid readFile01(string path) {\n    //实例化读取文件对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //判断文件是否能打开\n    if (!ifs.is_open()) {\n        cout << \"文件打开失败!\" << endl;\n        return;\n    }\n    //字符数组缓存\n    char buffer[1024] = {0};\n    //将读取的数据放入缓存区\n    while (ifs >> buffer)\n        cout << buffer << endl;\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。\n\n这种逐词读取的方式是`读取对象`通过`右移运算符`把读取的数据存入容器之中，但是是以空格区分每个词汇。\n\n## **以二进制的方式读取**\n\n前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。\n\n\n~~~C++\n/**\n * 以二进制的方式读取文件\n * @param path 路径\n */\nvoid readFileByBinary(string path) {\n    //创建输入流对象，并且指定路径和文件打开方式\n    ifstream ifs(path, ios::in | ios::binary);\n    char * c = new char[64];\n    ifs.read(c, sizeof(c));\n    cout<<c<<endl;\n}\nint main(){\n    readFileByBinary(\"Student.smi\");\n}\n~~~\n\n输出结果:\n\n~~~\n张三\n\nProcess finished with exit code 0\n~~~\n\n这里我们将`Student.smi`这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。\n\n# **总结**\n\n读取文件创建`ifstream`对象,写入文件创建`ofstream`对象，`fstream`对象既可以读又可以写。\n\n操作文件得先`打开文件`\n\n操作文件完毕得`关闭文件`\n\n二进制文件读取需要读取二进制格式的文件\n","slug":"C-读写文件","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobq001comoorzdisk1v","content":"<p>一些简单的读写文件的操作。</p>\n<a id=\"more\"></a>\n<p><strong>本篇文章使用C++<code>fstream</code>头文件提供的库函数进行读写操作</strong></p>\n<blockquote>\n<p>请引入#include \\&lt;fstream>进行下面的操作。</p>\n</blockquote>\n<h1 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a><strong>写入</strong></h1><p>写入文件步骤如下:</p>\n<ol>\n<li><p>实例化ofstream对象，或者fstream对象.</p>\n<blockquote>\n<p>ofstream ofs;</p>\n</blockquote>\n</li>\n<li><p>打开文件流</p>\n<blockquote>\n<p>ofs.open(const std::string &amp;<strong>s,ios_base::open</strong>mode=ios_base::out);</p>\n</blockquote>\n</li>\n<li><p>写入文件</p>\n<blockquote>\n<p>ofs&lt;&lt;;</p>\n</blockquote>\n</li>\n<li><p>关闭文件流</p>\n<blockquote>\n<p>ofs.close();</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>注意打开文件流函数的参数分别为<code>路径</code>和<code>打开方式</code>.</strong></p>\n<p>常用的打开方式如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模式标识</th>\n<th style=\"text-align:center\">适用对象</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ios::int</td>\n<td style=\"text-align:center\">ifstream,fstream</td>\n<td style=\"text-align:center\">打开输入,默认用于<code>ifstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::out</td>\n<td style=\"text-align:center\">ofstream,fstream</td>\n<td style=\"text-align:center\">打开输出，默认用于<code>ofstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::trunc</td>\n<td style=\"text-align:center\">ofstream</td>\n<td style=\"text-align:center\">打开输入，默认用户<code>ofstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::ate</td>\n<td style=\"text-align:center\">ifstream</td>\n<td style=\"text-align:center\">打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::app</td>\n<td style=\"text-align:center\">ostream,fstream</td>\n<td style=\"text-align:center\">打开输出，并且将数据输出至文件末尾，相当与追加</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iso::binary</td>\n<td style=\"text-align:center\">ifstream,ofstream,fstream</td>\n<td style=\"text-align:center\">以二进制的方式打开文件，进行输入或输出</td>\n</tr>\n</tbody>\n</table>\n<p>以上所有的打开方式可以通过或<code>|</code>运算符进行联合使用，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以二进制的方式打开输出</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作</strong></p>\n<p>好的，下面可以看例子了，我们将写入一些数据到一个文件内。</p>\n<h2 id=\"以文本写入\"><a href=\"#以文本写入\" class=\"headerlink\" title=\"以文本写入\"></a><strong>以文本写入</strong></h2><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> * @param context 内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(<span class=\"built_in\">string</span> path,<span class=\"built_in\">string</span> context)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化写入对象</span></span><br><span class=\"line\">    ofstream ofs;</span><br><span class=\"line\">    <span class=\"comment\">//打开输出</span></span><br><span class=\"line\">    ofs.open(path,ios::out);</span><br><span class=\"line\">    <span class=\"comment\">//向文件写入数据</span></span><br><span class=\"line\">    ofs&lt;&lt;context&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭输出</span></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用</span></span><br><span class=\"line\">    writeFile(<span class=\"string\">\"./test.txt\"</span>,<span class=\"string\">\"测试\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就将<code>测试</code>这个段文本信息，写入到当前目录下<code>test.txt</code>文件内了.</p>\n<h2 id=\"以二进制文件写入\"><a href=\"#以二进制文件写入\" class=\"headerlink\" title=\"以二进制文件写入\"></a><strong>以二进制文件写入</strong></h2><p>以二进制文件方式写入，C++提供了<code>write()</code>库函数,它的函数原型是:</p>\n<blockquote>\n<p><code>write(const _CharT* __s, streamsize __n);</code></p>\n</blockquote>\n<p>其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Student(<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>], <span class=\"keyword\">int</span> age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(name); ++i)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;name[i] = name[i];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;`</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入二进制文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输出流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path, ios::out | ios::binary)</span></span>;</span><br><span class=\"line\">    Student *student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"张三\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//写入文件</span></span><br><span class=\"line\">    ofs.write((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *) student, <span class=\"keyword\">sizeof</span>(Student));</span><br><span class=\"line\"></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> (student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    writeFileByBinary(<span class=\"string\">\"student.bin\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们将类成员属性的值以二进制的方式写入进一个文件内。</p>\n<p>最终文件内的内容人类是看不大懂的。</p>\n<p><img src=\"/2019/05/22/C-读写文件/二进制文件.png\" alt=\"二进制写\"></p>\n<p><strong>注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.</strong></p>\n<h1 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a><strong>读取</strong></h1><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<h2 id=\"以文本文件读取\"><a href=\"#以文本文件读取\" class=\"headerlink\" title=\"以文本文件读取\"></a><strong>以文本文件读取</strong></h2><p>读取有很多种方式，下面将会演示三种，分别是:</p>\n<ul>\n<li><p>逐行读取</p>\n</li>\n<li><p>逐词读取</p>\n</li>\n<li><p>逐字符读取</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"逐字符读取-不推荐\"><a href=\"#逐字符读取-不推荐\" class=\"headerlink\" title=\"逐字符读取(不推荐)\"></a><strong>逐字符读取(不推荐)</strong></h3><p><strong>逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐字符读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile04</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储变量</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> cbuffer;</span><br><span class=\"line\">    <span class=\"comment\">//逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((cbuffer = ifs.get()) != EOF) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; cbuffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>EOF</code>代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。</p>\n<h3 id=\"逐行读取-有两种方式，但都是逐行读取\"><a href=\"#逐行读取-有两种方式，但都是逐行读取\" class=\"headerlink\" title=\"逐行读取(有两种方式，但都是逐行读取)\"></a><strong>逐行读取(有两种方式，但都是逐行读取)</strong></h3><p>第一种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile02</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化</span></span><br><span class=\"line\">    fstream fs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    fs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//用字符数组进行缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fs.getline(buffer, <span class=\"keyword\">sizeof</span>(buffer))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    fs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>字符数组</code>作为数据存储容器，用<code>fstream</code>对象的<code>getline()</code>函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用<code>sizeof()</code>是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。</p>\n<p>第二种:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile03</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储容器</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> buffer;</span><br><span class=\"line\">    <span class=\"comment\">//使用全局函数getline(输入流，可存储的容器)进行逐行读取</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getline(ifs, buffer)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数<code>getline(输入对象,数据存储容器)</code>,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。</p>\n<h3 id=\"逐词读取-以空格区分\"><a href=\"#逐词读取-以空格区分\" class=\"headerlink\" title=\"逐词读取(以空格区分)\"></a><strong>逐词读取(以空格区分)</strong></h3><p>逐词读取，将会已空格进行区分每个词汇，再读取。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐词读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile01</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取文件对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//判断文件是否能打开</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ifs.is_open()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"文件打开失败!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//字符数组缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//将读取的数据放入缓存区</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ifs &gt;&gt; buffer)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。</p>\n<p>这种逐词读取的方式是<code>读取对象</code>通过<code>右移运算符</code>把读取的数据存入容器之中，但是是以空格区分每个词汇。</p>\n<h2 id=\"以二进制的方式读取\"><a href=\"#以二进制的方式读取\" class=\"headerlink\" title=\"以二进制的方式读取\"></a><strong>以二进制的方式读取</strong></h2><p>前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 以二进制的方式读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输入流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(path, ios::in | ios::binary)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>];</span><br><span class=\"line\">    ifs.read(c, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    readFileByBinary(<span class=\"string\">\"Student.smi\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">张三</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>这里我们将<code>Student.smi</code>这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>读取文件创建<code>ifstream</code>对象,写入文件创建<code>ofstream</code>对象，<code>fstream</code>对象既可以读又可以写。</p>\n<p>操作文件得先<code>打开文件</code></p>\n<p>操作文件完毕得<code>关闭文件</code></p>\n<p>二进制文件读取需要读取二进制格式的文件</p>\n","site":{"data":{}},"excerpt":"<p>一些简单的读写文件的操作。</p>","more":"<p><strong>本篇文章使用C++<code>fstream</code>头文件提供的库函数进行读写操作</strong></p>\n<blockquote>\n<p>请引入#include \\&lt;fstream>进行下面的操作。</p>\n</blockquote>\n<h1 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a><strong>写入</strong></h1><p>写入文件步骤如下:</p>\n<ol>\n<li><p>实例化ofstream对象，或者fstream对象.</p>\n<blockquote>\n<p>ofstream ofs;</p>\n</blockquote>\n</li>\n<li><p>打开文件流</p>\n<blockquote>\n<p>ofs.open(const std::string &amp;<strong>s,ios_base::open</strong>mode=ios_base::out);</p>\n</blockquote>\n</li>\n<li><p>写入文件</p>\n<blockquote>\n<p>ofs&lt;&lt;;</p>\n</blockquote>\n</li>\n<li><p>关闭文件流</p>\n<blockquote>\n<p>ofs.close();</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>注意打开文件流函数的参数分别为<code>路径</code>和<code>打开方式</code>.</strong></p>\n<p>常用的打开方式如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模式标识</th>\n<th style=\"text-align:center\">适用对象</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ios::int</td>\n<td style=\"text-align:center\">ifstream,fstream</td>\n<td style=\"text-align:center\">打开输入,默认用于<code>ifstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::out</td>\n<td style=\"text-align:center\">ofstream,fstream</td>\n<td style=\"text-align:center\">打开输出，默认用于<code>ofstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::trunc</td>\n<td style=\"text-align:center\">ofstream</td>\n<td style=\"text-align:center\">打开输入，默认用户<code>ofstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::ate</td>\n<td style=\"text-align:center\">ifstream</td>\n<td style=\"text-align:center\">打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::app</td>\n<td style=\"text-align:center\">ostream,fstream</td>\n<td style=\"text-align:center\">打开输出，并且将数据输出至文件末尾，相当与追加</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iso::binary</td>\n<td style=\"text-align:center\">ifstream,ofstream,fstream</td>\n<td style=\"text-align:center\">以二进制的方式打开文件，进行输入或输出</td>\n</tr>\n</tbody>\n</table>\n<p>以上所有的打开方式可以通过或<code>|</code>运算符进行联合使用，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以二进制的方式打开输出</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作</strong></p>\n<p>好的，下面可以看例子了，我们将写入一些数据到一个文件内。</p>\n<h2 id=\"以文本写入\"><a href=\"#以文本写入\" class=\"headerlink\" title=\"以文本写入\"></a><strong>以文本写入</strong></h2><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> * @param context 内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(<span class=\"built_in\">string</span> path,<span class=\"built_in\">string</span> context)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化写入对象</span></span><br><span class=\"line\">    ofstream ofs;</span><br><span class=\"line\">    <span class=\"comment\">//打开输出</span></span><br><span class=\"line\">    ofs.open(path,ios::out);</span><br><span class=\"line\">    <span class=\"comment\">//向文件写入数据</span></span><br><span class=\"line\">    ofs&lt;&lt;context&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭输出</span></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用</span></span><br><span class=\"line\">    writeFile(<span class=\"string\">\"./test.txt\"</span>,<span class=\"string\">\"测试\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就将<code>测试</code>这个段文本信息，写入到当前目录下<code>test.txt</code>文件内了.</p>\n<h2 id=\"以二进制文件写入\"><a href=\"#以二进制文件写入\" class=\"headerlink\" title=\"以二进制文件写入\"></a><strong>以二进制文件写入</strong></h2><p>以二进制文件方式写入，C++提供了<code>write()</code>库函数,它的函数原型是:</p>\n<blockquote>\n<p><code>write(const _CharT* __s, streamsize __n);</code></p>\n</blockquote>\n<p>其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Student(<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>], <span class=\"keyword\">int</span> age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(name); ++i)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;name[i] = name[i];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;`</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入二进制文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输出流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path, ios::out | ios::binary)</span></span>;</span><br><span class=\"line\">    Student *student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"张三\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//写入文件</span></span><br><span class=\"line\">    ofs.write((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *) student, <span class=\"keyword\">sizeof</span>(Student));</span><br><span class=\"line\"></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> (student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    writeFileByBinary(<span class=\"string\">\"student.bin\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们将类成员属性的值以二进制的方式写入进一个文件内。</p>\n<p>最终文件内的内容人类是看不大懂的。</p>\n<p><img src=\"/2019/05/22/C-读写文件/二进制文件.png\" alt=\"二进制写\"></p>\n<p><strong>注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.</strong></p>\n<h1 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a><strong>读取</strong></h1><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<h2 id=\"以文本文件读取\"><a href=\"#以文本文件读取\" class=\"headerlink\" title=\"以文本文件读取\"></a><strong>以文本文件读取</strong></h2><p>读取有很多种方式，下面将会演示三种，分别是:</p>\n<ul>\n<li><p>逐行读取</p>\n</li>\n<li><p>逐词读取</p>\n</li>\n<li><p>逐字符读取</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"逐字符读取-不推荐\"><a href=\"#逐字符读取-不推荐\" class=\"headerlink\" title=\"逐字符读取(不推荐)\"></a><strong>逐字符读取(不推荐)</strong></h3><p><strong>逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐字符读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile04</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储变量</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> cbuffer;</span><br><span class=\"line\">    <span class=\"comment\">//逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((cbuffer = ifs.get()) != EOF) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; cbuffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>EOF</code>代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。</p>\n<h3 id=\"逐行读取-有两种方式，但都是逐行读取\"><a href=\"#逐行读取-有两种方式，但都是逐行读取\" class=\"headerlink\" title=\"逐行读取(有两种方式，但都是逐行读取)\"></a><strong>逐行读取(有两种方式，但都是逐行读取)</strong></h3><p>第一种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile02</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化</span></span><br><span class=\"line\">    fstream fs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    fs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//用字符数组进行缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fs.getline(buffer, <span class=\"keyword\">sizeof</span>(buffer))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    fs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>字符数组</code>作为数据存储容器，用<code>fstream</code>对象的<code>getline()</code>函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用<code>sizeof()</code>是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。</p>\n<p>第二种:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile03</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储容器</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> buffer;</span><br><span class=\"line\">    <span class=\"comment\">//使用全局函数getline(输入流，可存储的容器)进行逐行读取</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getline(ifs, buffer)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数<code>getline(输入对象,数据存储容器)</code>,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。</p>\n<h3 id=\"逐词读取-以空格区分\"><a href=\"#逐词读取-以空格区分\" class=\"headerlink\" title=\"逐词读取(以空格区分)\"></a><strong>逐词读取(以空格区分)</strong></h3><p>逐词读取，将会已空格进行区分每个词汇，再读取。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐词读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile01</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取文件对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//判断文件是否能打开</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ifs.is_open()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"文件打开失败!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//字符数组缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//将读取的数据放入缓存区</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ifs &gt;&gt; buffer)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。</p>\n<p>这种逐词读取的方式是<code>读取对象</code>通过<code>右移运算符</code>把读取的数据存入容器之中，但是是以空格区分每个词汇。</p>\n<h2 id=\"以二进制的方式读取\"><a href=\"#以二进制的方式读取\" class=\"headerlink\" title=\"以二进制的方式读取\"></a><strong>以二进制的方式读取</strong></h2><p>前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 以二进制的方式读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输入流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(path, ios::in | ios::binary)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>];</span><br><span class=\"line\">    ifs.read(c, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    readFileByBinary(<span class=\"string\">\"Student.smi\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">张三</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>这里我们将<code>Student.smi</code>这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>读取文件创建<code>ifstream</code>对象,写入文件创建<code>ofstream</code>对象，<code>fstream</code>对象既可以读又可以写。</p>\n<p>操作文件得先<code>打开文件</code></p>\n<p>操作文件完毕得<code>关闭文件</code></p>\n<p>二进制文件读取需要读取二进制格式的文件</p>"},{"title":"Do you know Linux?","copyright":true,"date":"2019-07-16T16:22:22.000Z","_content":"\nI have been using Linux for about a year and a half.This article let's talk about Linux.\n\n\n&emsp;Linux is an operating system kernel,In addition to some experts,most Linux users are uing Linux dirtributions.The Linux dirtributions is __preintegrated__ with the Linux operating system and __various__ application software for users.\n\n&emsp;The Linux kernel was first released by Linus Trovars on October 5,1999.Although the Linux kernel is develpoed,it does not have the tools included in an operating system,but there is a GNU tool that can be used as a system tool for Linux,so Linux is also called GNU/Linux.Currently,Linux can be used on large computers,supercomputers,mobile phones,__tables__,routers,__televisions__,__game consoleds__ and computers,Such as,the Android operating system is based on the Linux kernel.\n\n&emsp;You maybe ask,can Linux be used as an operating system for  everyday use? I will answer you with __certainty__,Linux Can do it.This article was broin in Arch Linux,I can do __entertainment__ and work on Linux.\n\n&emsp;I love Linux,forever.\n","source":"_posts/Do-you-know-Linux.md","raw":"---\ntitle: Do you know Linux?\ncopyright: true\ndate: 2019-07-17 00:22:22\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\nI have been using Linux for about a year and a half.This article let's talk about Linux.\n\n\n&emsp;Linux is an operating system kernel,In addition to some experts,most Linux users are uing Linux dirtributions.The Linux dirtributions is __preintegrated__ with the Linux operating system and __various__ application software for users.\n\n&emsp;The Linux kernel was first released by Linus Trovars on October 5,1999.Although the Linux kernel is develpoed,it does not have the tools included in an operating system,but there is a GNU tool that can be used as a system tool for Linux,so Linux is also called GNU/Linux.Currently,Linux can be used on large computers,supercomputers,mobile phones,__tables__,routers,__televisions__,__game consoleds__ and computers,Such as,the Android operating system is based on the Linux kernel.\n\n&emsp;You maybe ask,can Linux be used as an operating system for  everyday use? I will answer you with __certainty__,Linux Can do it.This article was broin in Arch Linux,I can do __entertainment__ and work on Linux.\n\n&emsp;I love Linux,forever.\n","slug":"Do-you-know-Linux","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobu001gomoogxnjrkye","content":"<p>I have been using Linux for about a year and a half.This article let’s talk about Linux.</p>\n<p>&emsp;Linux is an operating system kernel,In addition to some experts,most Linux users are uing Linux dirtributions.The Linux dirtributions is <strong>preintegrated</strong> with the Linux operating system and <strong>various</strong> application software for users.</p>\n<p>&emsp;The Linux kernel was first released by Linus Trovars on October 5,1999.Although the Linux kernel is develpoed,it does not have the tools included in an operating system,but there is a GNU tool that can be used as a system tool for Linux,so Linux is also called GNU/Linux.Currently,Linux can be used on large computers,supercomputers,mobile phones,<strong>tables</strong>,routers,<strong>televisions</strong>,<strong>game consoleds</strong> and computers,Such as,the Android operating system is based on the Linux kernel.</p>\n<p>&emsp;You maybe ask,can Linux be used as an operating system for  everyday use? I will answer you with <strong>certainty</strong>,Linux Can do it.This article was broin in Arch Linux,I can do <strong>entertainment</strong> and work on Linux.</p>\n<p>&emsp;I love Linux,forever.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>I have been using Linux for about a year and a half.This article let’s talk about Linux.</p>\n<p>&emsp;Linux is an operating system kernel,In addition to some experts,most Linux users are uing Linux dirtributions.The Linux dirtributions is <strong>preintegrated</strong> with the Linux operating system and <strong>various</strong> application software for users.</p>\n<p>&emsp;The Linux kernel was first released by Linus Trovars on October 5,1999.Although the Linux kernel is develpoed,it does not have the tools included in an operating system,but there is a GNU tool that can be used as a system tool for Linux,so Linux is also called GNU/Linux.Currently,Linux can be used on large computers,supercomputers,mobile phones,<strong>tables</strong>,routers,<strong>televisions</strong>,<strong>game consoleds</strong> and computers,Such as,the Android operating system is based on the Linux kernel.</p>\n<p>&emsp;You maybe ask,can Linux be used as an operating system for  everyday use? I will answer you with <strong>certainty</strong>,Linux Can do it.This article was broin in Arch Linux,I can do <strong>entertainment</strong> and work on Linux.</p>\n<p>&emsp;I love Linux,forever.</p>\n"},{"title":"Happiness from the heart","copyright":true,"date":"2019-08-11T08:55:35.000Z","_content":"\n15分钟前，我观看了一集TED演讲，我从中了解了什么才是真正的快乐。这篇文章就讲述了我的感悟与亲身体验。\n\nFifteen minutes ago, I watched a TED talk, from which I learned what real happiness is.  This article and related my feeling and experience of happiness from the heart.\n\n<!--more-->\n\n# English\n\nNext, I will ask a few questions, which are very simple, because you must have the answer in your heart.  So the first question is: Are you happy today? I think you already have the answer, then the next question is: why are you happy or unhappy today? The point is why you are happy, or why you are not happy.  For example, you may not be happy today because you are arranged to work with colleagues you don't like.  Of course, I think you should have no colleagues you don't like.  In this example, the reason why you are unhappy > is to work with colleagues you don't like, but what I want to say is: you must stop being unhappy because of colleagues or because of something or some external factors.  This is what I want to say.  You may understand this: don't be unhappy because of external factors.  But in fact, what I want to express is: happiness or happiness is from the heart, not > from external factors. even if you work with your favorite colleagues, it cannot be the reason why you are happy today. real happiness is from the heart.\n\n\n\n# Chinese\n下面，我将会问几个问题，这几个问题十分简单，因为你们心中肯定有答案。那么第一个问题是：你今天开心吗？我想你应该已经有了答案，那么接下来是第二个问题：你今天为什么开心或者为什么不开心？重点在于为什么开心，或者为什么不开心。举个例子，你今天可能会因为被领导安排与不喜欢的同事共事，你不开心。当然，我觉得你应该没有不喜欢的同事。这个例子中，你不开心的原因就是与不喜欢的同事共事，但我想说的是：你必须停止因为同事或者说是因为某个事物又或是某些外部因素让你不开心。这也就是我想说的。你可能会理解成：不要因为外部因素，从而使得不开心。但其实我想表达的是：快乐或开心是由自内心的，而不是由自外部因素的，就算是你跟喜欢的同事共事，那么也不能成为你今天快乐的原由，真正的快乐是发自内心。\n","source":"_posts/Happiness-from-the-heart.md","raw":"---\ntitle: Happiness from the heart\ncopyright: true\ndate: 2019-08-11 16:55:35\ncategories: 英文文章\ntags:\n - 个人感想\n---\n\n15分钟前，我观看了一集TED演讲，我从中了解了什么才是真正的快乐。这篇文章就讲述了我的感悟与亲身体验。\n\nFifteen minutes ago, I watched a TED talk, from which I learned what real happiness is.  This article and related my feeling and experience of happiness from the heart.\n\n<!--more-->\n\n# English\n\nNext, I will ask a few questions, which are very simple, because you must have the answer in your heart.  So the first question is: Are you happy today? I think you already have the answer, then the next question is: why are you happy or unhappy today? The point is why you are happy, or why you are not happy.  For example, you may not be happy today because you are arranged to work with colleagues you don't like.  Of course, I think you should have no colleagues you don't like.  In this example, the reason why you are unhappy > is to work with colleagues you don't like, but what I want to say is: you must stop being unhappy because of colleagues or because of something or some external factors.  This is what I want to say.  You may understand this: don't be unhappy because of external factors.  But in fact, what I want to express is: happiness or happiness is from the heart, not > from external factors. even if you work with your favorite colleagues, it cannot be the reason why you are happy today. real happiness is from the heart.\n\n\n\n# Chinese\n下面，我将会问几个问题，这几个问题十分简单，因为你们心中肯定有答案。那么第一个问题是：你今天开心吗？我想你应该已经有了答案，那么接下来是第二个问题：你今天为什么开心或者为什么不开心？重点在于为什么开心，或者为什么不开心。举个例子，你今天可能会因为被领导安排与不喜欢的同事共事，你不开心。当然，我觉得你应该没有不喜欢的同事。这个例子中，你不开心的原因就是与不喜欢的同事共事，但我想说的是：你必须停止因为同事或者说是因为某个事物又或是某些外部因素让你不开心。这也就是我想说的。你可能会理解成：不要因为外部因素，从而使得不开心。但其实我想表达的是：快乐或开心是由自内心的，而不是由自外部因素的，就算是你跟喜欢的同事共事，那么也不能成为你今天快乐的原由，真正的快乐是发自内心。\n","slug":"Happiness-from-the-heart","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobx001komoojv0qi1iu","content":"<p>15分钟前，我观看了一集TED演讲，我从中了解了什么才是真正的快乐。这篇文章就讲述了我的感悟与亲身体验。</p>\n<p>Fifteen minutes ago, I watched a TED talk, from which I learned what real happiness is.  This article and related my feeling and experience of happiness from the heart.</p>\n<a id=\"more\"></a>\n<h1 id=\"English\"><a href=\"#English\" class=\"headerlink\" title=\"English\"></a>English</h1><p>Next, I will ask a few questions, which are very simple, because you must have the answer in your heart.  So the first question is: Are you happy today? I think you already have the answer, then the next question is: why are you happy or unhappy today? The point is why you are happy, or why you are not happy.  For example, you may not be happy today because you are arranged to work with colleagues you don’t like.  Of course, I think you should have no colleagues you don’t like.  In this example, the reason why you are unhappy &gt; is to work with colleagues you don’t like, but what I want to say is: you must stop being unhappy because of colleagues or because of something or some external factors.  This is what I want to say.  You may understand this: don’t be unhappy because of external factors.  But in fact, what I want to express is: happiness or happiness is from the heart, not &gt; from external factors. even if you work with your favorite colleagues, it cannot be the reason why you are happy today. real happiness is from the heart.</p>\n<h1 id=\"Chinese\"><a href=\"#Chinese\" class=\"headerlink\" title=\"Chinese\"></a>Chinese</h1><p>下面，我将会问几个问题，这几个问题十分简单，因为你们心中肯定有答案。那么第一个问题是：你今天开心吗？我想你应该已经有了答案，那么接下来是第二个问题：你今天为什么开心或者为什么不开心？重点在于为什么开心，或者为什么不开心。举个例子，你今天可能会因为被领导安排与不喜欢的同事共事，你不开心。当然，我觉得你应该没有不喜欢的同事。这个例子中，你不开心的原因就是与不喜欢的同事共事，但我想说的是：你必须停止因为同事或者说是因为某个事物又或是某些外部因素让你不开心。这也就是我想说的。你可能会理解成：不要因为外部因素，从而使得不开心。但其实我想表达的是：快乐或开心是由自内心的，而不是由自外部因素的，就算是你跟喜欢的同事共事，那么也不能成为你今天快乐的原由，真正的快乐是发自内心。</p>\n","site":{"data":{}},"excerpt":"<p>15分钟前，我观看了一集TED演讲，我从中了解了什么才是真正的快乐。这篇文章就讲述了我的感悟与亲身体验。</p>\n<p>Fifteen minutes ago, I watched a TED talk, from which I learned what real happiness is.  This article and related my feeling and experience of happiness from the heart.</p>","more":"<h1 id=\"English\"><a href=\"#English\" class=\"headerlink\" title=\"English\"></a>English</h1><p>Next, I will ask a few questions, which are very simple, because you must have the answer in your heart.  So the first question is: Are you happy today? I think you already have the answer, then the next question is: why are you happy or unhappy today? The point is why you are happy, or why you are not happy.  For example, you may not be happy today because you are arranged to work with colleagues you don’t like.  Of course, I think you should have no colleagues you don’t like.  In this example, the reason why you are unhappy &gt; is to work with colleagues you don’t like, but what I want to say is: you must stop being unhappy because of colleagues or because of something or some external factors.  This is what I want to say.  You may understand this: don’t be unhappy because of external factors.  But in fact, what I want to express is: happiness or happiness is from the heart, not &gt; from external factors. even if you work with your favorite colleagues, it cannot be the reason why you are happy today. real happiness is from the heart.</p>\n<h1 id=\"Chinese\"><a href=\"#Chinese\" class=\"headerlink\" title=\"Chinese\"></a>Chinese</h1><p>下面，我将会问几个问题，这几个问题十分简单，因为你们心中肯定有答案。那么第一个问题是：你今天开心吗？我想你应该已经有了答案，那么接下来是第二个问题：你今天为什么开心或者为什么不开心？重点在于为什么开心，或者为什么不开心。举个例子，你今天可能会因为被领导安排与不喜欢的同事共事，你不开心。当然，我觉得你应该没有不喜欢的同事。这个例子中，你不开心的原因就是与不喜欢的同事共事，但我想说的是：你必须停止因为同事或者说是因为某个事物又或是某些外部因素让你不开心。这也就是我想说的。你可能会理解成：不要因为外部因素，从而使得不开心。但其实我想表达的是：快乐或开心是由自内心的，而不是由自外部因素的，就算是你跟喜欢的同事共事，那么也不能成为你今天快乐的原由，真正的快乐是发自内心。</p>"},{"title":"FuShou-Mountain-Day-Trip","copyright":true,"date":"2019-07-23T14:16:13.000Z","_content":"\nToday I gone to the FuShou mountain,So this article is about it.\n\n<!--more-->\n\n&emsp;It's sunny,But I __arrived__`到达` at my __destination__`目的地` at __noon__`正午`.There were manay people.After a long __queue__`排队`,I finally got the __ticket__`门票`.Then I got on the __interval bus__`区间车` again.\n\n&emsp;It was a __bumpy journey to the foot__`一路颠簸` of Fushou Mountain.The first thing I saw was a __snack area__`小食区` supported by a __pile__`支撑` of read __tents__`帐篷`.Then when  I entered the snack area,the air was filled with __grabbing food__`手抓饭`,__thin-skinned steamed buns__`薄皮包子`,the __aroma__`香气` of __barbecue kebabs__`烤肉串` and the __sweet__`香甜的` __Cavas__`卡瓦斯`,Ice cream __attracted__`吸引` me.I __couldn't resist__`无法抵御` the __temptation__`美食` of delicious food, so I ate a lot of delicious food in Xinjiang.\n\n&emsp;After __full stomach__`饱腹`,I began to climb the mountain. The sun was very sunny. Before I reached the __glass trestle__`玻璃栈道`,my skin was red.\n\n&emsp;Glass planks up to 300M,built of steel and glass.People have a head and look through the glass to see the ground.Although I dare not look down from the highrise, I can't fell scared on the glass path. Maybe I trust safety of these projects.\n\n&emsp;Happy time is always short,and soon,we will go home by car...\n\n\n\n\n","source":"_posts/FuShou-Mountain-Day-Trip.md","raw":"---\ntitle: FuShou-Mountain-Day-Trip\ncopyright: true\ndate: 2019-07-23 22:16:13\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\nToday I gone to the FuShou mountain,So this article is about it.\n\n<!--more-->\n\n&emsp;It's sunny,But I __arrived__`到达` at my __destination__`目的地` at __noon__`正午`.There were manay people.After a long __queue__`排队`,I finally got the __ticket__`门票`.Then I got on the __interval bus__`区间车` again.\n\n&emsp;It was a __bumpy journey to the foot__`一路颠簸` of Fushou Mountain.The first thing I saw was a __snack area__`小食区` supported by a __pile__`支撑` of read __tents__`帐篷`.Then when  I entered the snack area,the air was filled with __grabbing food__`手抓饭`,__thin-skinned steamed buns__`薄皮包子`,the __aroma__`香气` of __barbecue kebabs__`烤肉串` and the __sweet__`香甜的` __Cavas__`卡瓦斯`,Ice cream __attracted__`吸引` me.I __couldn't resist__`无法抵御` the __temptation__`美食` of delicious food, so I ate a lot of delicious food in Xinjiang.\n\n&emsp;After __full stomach__`饱腹`,I began to climb the mountain. The sun was very sunny. Before I reached the __glass trestle__`玻璃栈道`,my skin was red.\n\n&emsp;Glass planks up to 300M,built of steel and glass.People have a head and look through the glass to see the ground.Although I dare not look down from the highrise, I can't fell scared on the glass path. Maybe I trust safety of these projects.\n\n&emsp;Happy time is always short,and soon,we will go home by car...\n\n\n\n\n","slug":"FuShou-Mountain-Day-Trip","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoby001oomoo6nuvqxzc","content":"<p>Today I gone to the FuShou mountain,So this article is about it.</p>\n<a id=\"more\"></a>\n<p>&emsp;It’s sunny,But I <strong>arrived</strong><code>到达</code> at my <strong>destination</strong><code>目的地</code> at <strong>noon</strong><code>正午</code>.There were manay people.After a long <strong>queue</strong><code>排队</code>,I finally got the <strong>ticket</strong><code>门票</code>.Then I got on the <strong>interval bus</strong><code>区间车</code> again.</p>\n<p>&emsp;It was a <strong>bumpy journey to the foot</strong><code>一路颠簸</code> of Fushou Mountain.The first thing I saw was a <strong>snack area</strong><code>小食区</code> supported by a <strong>pile</strong><code>支撑</code> of read <strong>tents</strong><code>帐篷</code>.Then when  I entered the snack area,the air was filled with <strong>grabbing food</strong><code>手抓饭</code>,<strong>thin-skinned steamed buns</strong><code>薄皮包子</code>,the <strong>aroma</strong><code>香气</code> of <strong>barbecue kebabs</strong><code>烤肉串</code> and the <strong>sweet</strong><code>香甜的</code> <strong>Cavas</strong><code>卡瓦斯</code>,Ice cream <strong>attracted</strong><code>吸引</code> me.I <strong>couldn’t resist</strong><code>无法抵御</code> the <strong>temptation</strong><code>美食</code> of delicious food, so I ate a lot of delicious food in Xinjiang.</p>\n<p>&emsp;After <strong>full stomach</strong><code>饱腹</code>,I began to climb the mountain. The sun was very sunny. Before I reached the <strong>glass trestle</strong><code>玻璃栈道</code>,my skin was red.</p>\n<p>&emsp;Glass planks up to 300M,built of steel and glass.People have a head and look through the glass to see the ground.Although I dare not look down from the highrise, I can’t fell scared on the glass path. Maybe I trust safety of these projects.</p>\n<p>&emsp;Happy time is always short,and soon,we will go home by car…</p>\n","site":{"data":{}},"excerpt":"<p>Today I gone to the FuShou mountain,So this article is about it.</p>","more":"<p>&emsp;It’s sunny,But I <strong>arrived</strong><code>到达</code> at my <strong>destination</strong><code>目的地</code> at <strong>noon</strong><code>正午</code>.There were manay people.After a long <strong>queue</strong><code>排队</code>,I finally got the <strong>ticket</strong><code>门票</code>.Then I got on the <strong>interval bus</strong><code>区间车</code> again.</p>\n<p>&emsp;It was a <strong>bumpy journey to the foot</strong><code>一路颠簸</code> of Fushou Mountain.The first thing I saw was a <strong>snack area</strong><code>小食区</code> supported by a <strong>pile</strong><code>支撑</code> of read <strong>tents</strong><code>帐篷</code>.Then when  I entered the snack area,the air was filled with <strong>grabbing food</strong><code>手抓饭</code>,<strong>thin-skinned steamed buns</strong><code>薄皮包子</code>,the <strong>aroma</strong><code>香气</code> of <strong>barbecue kebabs</strong><code>烤肉串</code> and the <strong>sweet</strong><code>香甜的</code> <strong>Cavas</strong><code>卡瓦斯</code>,Ice cream <strong>attracted</strong><code>吸引</code> me.I <strong>couldn’t resist</strong><code>无法抵御</code> the <strong>temptation</strong><code>美食</code> of delicious food, so I ate a lot of delicious food in Xinjiang.</p>\n<p>&emsp;After <strong>full stomach</strong><code>饱腹</code>,I began to climb the mountain. The sun was very sunny. Before I reached the <strong>glass trestle</strong><code>玻璃栈道</code>,my skin was red.</p>\n<p>&emsp;Glass planks up to 300M,built of steel and glass.People have a head and look through the glass to see the ground.Although I dare not look down from the highrise, I can’t fell scared on the glass path. Maybe I trust safety of these projects.</p>\n<p>&emsp;Happy time is always short,and soon,we will go home by car…</p>"},{"title":"Learn-Qt5-Qt模块简介","copyright":true,"date":"2019-06-12T12:30:42.000Z","_content":"\nQt5分为两个大的模块，分别是`Qt Essentials`以及`Qt Add-Ons`以及一些额外的模块和工具．\n\n<!--more-->\n\n# Qt Essentials\n\n`Qt Essentials`是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件．\n\n|模块|简述|\n|:-:|:-:|\n|Qt Core|其他非图形类模块所使用的核心,|\n|Qt GUI|图形界面组件的基类，包括了OpenGL.|\n|Qt Multimedia|音频，视频，广播和摄像头相关功能.|\n|Qt Network|提供跨平台的网络能力．|\n|Qt Qml|提供QML使用的C++API.|\n|Qt Quick|允许在Qt/C++程序中嵌入 Qt Quick|\n|Qt SQL|允许使用SQL访问数据库|\n|Qt Test|提供Qt程序的单元测试能力｜\n|Qt Webkit|基于WebKit2的实现以及一套全新的QML API|\n\n# Qt Add-Ons\n`Qt Add-Ons`是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人．\n\n|模块|简述|\n|:-:|:-:|\n|Qt 3D|提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜\n|Qt Bluetooth|提供用于访问蓝牙无线设备的C++和QML API.|\n|Qt Contacts|用于访问地址薄或联系人数据库的C++和QML API.|\n|Qt D-Bus|Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互|\n|Qt Graphical Effects|提供一系列用于实现图像特效的类|\n|Qt Image Formats|支持图片格式的一系列插件|\n|Qt JS Backend|为V8 JavaScript引擎的移植，仅供QtQML模块内部使用|\n|Qt Location|方便在Qt应用程序中使用OpenGL，保留于Qt4|\n|Qt Organize|使用QML和C++API访问组织事件｜\n|Qt Print Support|提供对打印功能的支持｜\n|Qt Publish and Subscribe|为应用程序提供对项目值的读取，导航，订阅等功能.|\n|Qt Quick 1|从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容|\n|Qt Script|提供脚本化机制，为了与Qt5兼容|\n|Qt Script Tools|为了使用Qt Script模块的应用程序提供的额外的组件|\n|Qt Sensors|提供访问各类传感器的QML和C++接口.|\n|Qt Service Framework|提供客户端发现其他设备的服务.|\n|Qt SVF|提供渲染和创建SVG文件的功能．|\n|Qt System Info|提供一套API，用于发现系统相关的信息.|\n|Qt Tools|提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools.|\n|Qt Versit|提供了对Versit API的支持．|\n|Qt Wayland|仅用于Linux平台，用户替代QWS|\n|Qt WebKit|从Qt4 一直来的基于WebKit1和QWidget的API|\n|Qt Widgets|使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框|\n|Qt XML|SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer|\n|Qt XML Patterns|提供对XPath,XQuery,XSLT和XML Schema验证的支持．|\n\n\n\n","source":"_posts/Learn-Qt5-Qt模块简介.md","raw":"---\ntitle: Learn-Qt5-Qt模块简介\ncopyright: true\ndate: 2019-06-12 20:30:42\ncategories: 学习笔记\ntags:\n  - Qt\n  - C_++\n---\n\nQt5分为两个大的模块，分别是`Qt Essentials`以及`Qt Add-Ons`以及一些额外的模块和工具．\n\n<!--more-->\n\n# Qt Essentials\n\n`Qt Essentials`是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件．\n\n|模块|简述|\n|:-:|:-:|\n|Qt Core|其他非图形类模块所使用的核心,|\n|Qt GUI|图形界面组件的基类，包括了OpenGL.|\n|Qt Multimedia|音频，视频，广播和摄像头相关功能.|\n|Qt Network|提供跨平台的网络能力．|\n|Qt Qml|提供QML使用的C++API.|\n|Qt Quick|允许在Qt/C++程序中嵌入 Qt Quick|\n|Qt SQL|允许使用SQL访问数据库|\n|Qt Test|提供Qt程序的单元测试能力｜\n|Qt Webkit|基于WebKit2的实现以及一套全新的QML API|\n\n# Qt Add-Ons\n`Qt Add-Ons`是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人．\n\n|模块|简述|\n|:-:|:-:|\n|Qt 3D|提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜\n|Qt Bluetooth|提供用于访问蓝牙无线设备的C++和QML API.|\n|Qt Contacts|用于访问地址薄或联系人数据库的C++和QML API.|\n|Qt D-Bus|Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互|\n|Qt Graphical Effects|提供一系列用于实现图像特效的类|\n|Qt Image Formats|支持图片格式的一系列插件|\n|Qt JS Backend|为V8 JavaScript引擎的移植，仅供QtQML模块内部使用|\n|Qt Location|方便在Qt应用程序中使用OpenGL，保留于Qt4|\n|Qt Organize|使用QML和C++API访问组织事件｜\n|Qt Print Support|提供对打印功能的支持｜\n|Qt Publish and Subscribe|为应用程序提供对项目值的读取，导航，订阅等功能.|\n|Qt Quick 1|从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容|\n|Qt Script|提供脚本化机制，为了与Qt5兼容|\n|Qt Script Tools|为了使用Qt Script模块的应用程序提供的额外的组件|\n|Qt Sensors|提供访问各类传感器的QML和C++接口.|\n|Qt Service Framework|提供客户端发现其他设备的服务.|\n|Qt SVF|提供渲染和创建SVG文件的功能．|\n|Qt System Info|提供一套API，用于发现系统相关的信息.|\n|Qt Tools|提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools.|\n|Qt Versit|提供了对Versit API的支持．|\n|Qt Wayland|仅用于Linux平台，用户替代QWS|\n|Qt WebKit|从Qt4 一直来的基于WebKit1和QWidget的API|\n|Qt Widgets|使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框|\n|Qt XML|SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer|\n|Qt XML Patterns|提供对XPath,XQuery,XSLT和XML Schema验证的支持．|\n\n\n\n","slug":"Learn-Qt5-Qt模块简介","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozobz001somooyj5wsdj9","content":"<p>Qt5分为两个大的模块，分别是<code>Qt Essentials</code>以及<code>Qt Add-Ons</code>以及一些额外的模块和工具．</p>\n<a id=\"more\"></a>\n<h1 id=\"Qt-Essentials\"><a href=\"#Qt-Essentials\" class=\"headerlink\" title=\"Qt Essentials\"></a>Qt Essentials</h1><p><code>Qt Essentials</code>是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件．</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模块</th>\n<th style=\"text-align:center\">简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Qt Core</td>\n<td style=\"text-align:center\">其他非图形类模块所使用的核心,</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt GUI</td>\n<td style=\"text-align:center\">图形界面组件的基类，包括了OpenGL.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Multimedia</td>\n<td style=\"text-align:center\">音频，视频，广播和摄像头相关功能.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Network</td>\n<td style=\"text-align:center\">提供跨平台的网络能力．</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Qml</td>\n<td style=\"text-align:center\">提供QML使用的C++API.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Quick</td>\n<td style=\"text-align:center\">允许在Qt/C++程序中嵌入 Qt Quick</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt SQL</td>\n<td style=\"text-align:center\">允许使用SQL访问数据库</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Test</td>\n<td style=\"text-align:center\">提供Qt程序的单元测试能力｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Webkit</td>\n<td style=\"text-align:center\">基于WebKit2的实现以及一套全新的QML API</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Qt-Add-Ons\"><a href=\"#Qt-Add-Ons\" class=\"headerlink\" title=\"Qt Add-Ons\"></a>Qt Add-Ons</h1><p><code>Qt Add-Ons</code>是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人．</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模块</th>\n<th style=\"text-align:center\">简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Qt 3D</td>\n<td style=\"text-align:center\">提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Bluetooth</td>\n<td style=\"text-align:center\">提供用于访问蓝牙无线设备的C++和QML API.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Contacts</td>\n<td style=\"text-align:center\">用于访问地址薄或联系人数据库的C++和QML API.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt D-Bus</td>\n<td style=\"text-align:center\">Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Graphical Effects</td>\n<td style=\"text-align:center\">提供一系列用于实现图像特效的类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Image Formats</td>\n<td style=\"text-align:center\">支持图片格式的一系列插件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt JS Backend</td>\n<td style=\"text-align:center\">为V8 JavaScript引擎的移植，仅供QtQML模块内部使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Location</td>\n<td style=\"text-align:center\">方便在Qt应用程序中使用OpenGL，保留于Qt4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Organize</td>\n<td style=\"text-align:center\">使用QML和C++API访问组织事件｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Print Support</td>\n<td style=\"text-align:center\">提供对打印功能的支持｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Publish and Subscribe</td>\n<td style=\"text-align:center\">为应用程序提供对项目值的读取，导航，订阅等功能.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Quick 1</td>\n<td style=\"text-align:center\">从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Script</td>\n<td style=\"text-align:center\">提供脚本化机制，为了与Qt5兼容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Script Tools</td>\n<td style=\"text-align:center\">为了使用Qt Script模块的应用程序提供的额外的组件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Sensors</td>\n<td style=\"text-align:center\">提供访问各类传感器的QML和C++接口.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Service Framework</td>\n<td style=\"text-align:center\">提供客户端发现其他设备的服务.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt SVF</td>\n<td style=\"text-align:center\">提供渲染和创建SVG文件的功能．</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt System Info</td>\n<td style=\"text-align:center\">提供一套API，用于发现系统相关的信息.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Tools</td>\n<td style=\"text-align:center\">提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Versit</td>\n<td style=\"text-align:center\">提供了对Versit API的支持．</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Wayland</td>\n<td style=\"text-align:center\">仅用于Linux平台，用户替代QWS</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt WebKit</td>\n<td style=\"text-align:center\">从Qt4 一直来的基于WebKit1和QWidget的API</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Widgets</td>\n<td style=\"text-align:center\">使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt XML</td>\n<td style=\"text-align:center\">SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt XML Patterns</td>\n<td style=\"text-align:center\">提供对XPath,XQuery,XSLT和XML Schema验证的支持．</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>Qt5分为两个大的模块，分别是<code>Qt Essentials</code>以及<code>Qt Add-Ons</code>以及一些额外的模块和工具．</p>","more":"<h1 id=\"Qt-Essentials\"><a href=\"#Qt-Essentials\" class=\"headerlink\" title=\"Qt Essentials\"></a>Qt Essentials</h1><p><code>Qt Essentials</code>是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件．</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模块</th>\n<th style=\"text-align:center\">简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Qt Core</td>\n<td style=\"text-align:center\">其他非图形类模块所使用的核心,</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt GUI</td>\n<td style=\"text-align:center\">图形界面组件的基类，包括了OpenGL.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Multimedia</td>\n<td style=\"text-align:center\">音频，视频，广播和摄像头相关功能.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Network</td>\n<td style=\"text-align:center\">提供跨平台的网络能力．</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Qml</td>\n<td style=\"text-align:center\">提供QML使用的C++API.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Quick</td>\n<td style=\"text-align:center\">允许在Qt/C++程序中嵌入 Qt Quick</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt SQL</td>\n<td style=\"text-align:center\">允许使用SQL访问数据库</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Test</td>\n<td style=\"text-align:center\">提供Qt程序的单元测试能力｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Webkit</td>\n<td style=\"text-align:center\">基于WebKit2的实现以及一套全新的QML API</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Qt-Add-Ons\"><a href=\"#Qt-Add-Ons\" class=\"headerlink\" title=\"Qt Add-Ons\"></a>Qt Add-Ons</h1><p><code>Qt Add-Ons</code>是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人．</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模块</th>\n<th style=\"text-align:center\">简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Qt 3D</td>\n<td style=\"text-align:center\">提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Bluetooth</td>\n<td style=\"text-align:center\">提供用于访问蓝牙无线设备的C++和QML API.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Contacts</td>\n<td style=\"text-align:center\">用于访问地址薄或联系人数据库的C++和QML API.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt D-Bus</td>\n<td style=\"text-align:center\">Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Graphical Effects</td>\n<td style=\"text-align:center\">提供一系列用于实现图像特效的类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Image Formats</td>\n<td style=\"text-align:center\">支持图片格式的一系列插件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt JS Backend</td>\n<td style=\"text-align:center\">为V8 JavaScript引擎的移植，仅供QtQML模块内部使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Location</td>\n<td style=\"text-align:center\">方便在Qt应用程序中使用OpenGL，保留于Qt4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Organize</td>\n<td style=\"text-align:center\">使用QML和C++API访问组织事件｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Print Support</td>\n<td style=\"text-align:center\">提供对打印功能的支持｜</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Publish and Subscribe</td>\n<td style=\"text-align:center\">为应用程序提供对项目值的读取，导航，订阅等功能.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Quick 1</td>\n<td style=\"text-align:center\">从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Script</td>\n<td style=\"text-align:center\">提供脚本化机制，为了与Qt5兼容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Script Tools</td>\n<td style=\"text-align:center\">为了使用Qt Script模块的应用程序提供的额外的组件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Sensors</td>\n<td style=\"text-align:center\">提供访问各类传感器的QML和C++接口.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Service Framework</td>\n<td style=\"text-align:center\">提供客户端发现其他设备的服务.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt SVF</td>\n<td style=\"text-align:center\">提供渲染和创建SVG文件的功能．</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt System Info</td>\n<td style=\"text-align:center\">提供一套API，用于发现系统相关的信息.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Tools</td>\n<td style=\"text-align:center\">提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Versit</td>\n<td style=\"text-align:center\">提供了对Versit API的支持．</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Wayland</td>\n<td style=\"text-align:center\">仅用于Linux平台，用户替代QWS</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt WebKit</td>\n<td style=\"text-align:center\">从Qt4 一直来的基于WebKit1和QWidget的API</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt Widgets</td>\n<td style=\"text-align:center\">使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt XML</td>\n<td style=\"text-align:center\">SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt XML Patterns</td>\n<td style=\"text-align:center\">提供对XPath,XQuery,XSLT和XML Schema验证的支持．</td>\n</tr>\n</tbody>\n</table>"},{"title":"Learn-Qt5-HelloWorld","copyright":true,"date":"2019-06-08T07:57:36.000Z","_content":"\n当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．\n\n那么就让我们从Qt5的HelloWorld开始吧!\n\n<!--more-->\n\n第一步先创建一个项目\n\n可以使用快捷键 `Ctrl+N` 即可呼出创建项目的菜单\n\n![新建项目](Learn-Qt5-HelloWorld/newProject.gif)\n\n创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分\n\nHelloWorld.pro: Qt的工程文件，由qmake处理\n\nmain.cpp: 里面就是main函数\n\nmainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。\n\n至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。\n\n---\n\n现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。\n\n修改main.cpp文件\n\n~~~C++\n#include <QApplication>\n#include <QLabel>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    QLabel label(\"HelloWorld\");\n    label.show();\n\n    return a.exec();\n}\n~~~\n\n再编译运行，我们则可看到一个显示\"HelloWorld\"的窗体程序。\n\n\n\n\n\n\n\n\n\n","source":"_posts/Learn-Qt5-HelloWorld.md","raw":"---\ntitle: Learn-Qt5-HelloWorld\ncopyright: true\ndate: 2019-06-08 15:57:36\ncategories: 学习笔记\ntags:\n  - C++\n  - Qt5\n---\n\n当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．\n\n那么就让我们从Qt5的HelloWorld开始吧!\n\n<!--more-->\n\n第一步先创建一个项目\n\n可以使用快捷键 `Ctrl+N` 即可呼出创建项目的菜单\n\n![新建项目](Learn-Qt5-HelloWorld/newProject.gif)\n\n创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分\n\nHelloWorld.pro: Qt的工程文件，由qmake处理\n\nmain.cpp: 里面就是main函数\n\nmainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。\n\n至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。\n\n---\n\n现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。\n\n修改main.cpp文件\n\n~~~C++\n#include <QApplication>\n#include <QLabel>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    QLabel label(\"HelloWorld\");\n    label.show();\n\n    return a.exec();\n}\n~~~\n\n再编译运行，我们则可看到一个显示\"HelloWorld\"的窗体程序。\n\n\n\n\n\n\n\n\n\n","slug":"Learn-Qt5-HelloWorld","published":1,"updated":"2020-01-19T03:49:51.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc0001vomoo9r8bqls3","content":"<p>当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．</p>\n<p>那么就让我们从Qt5的HelloWorld开始吧!</p>\n<a id=\"more\"></a>\n<p>第一步先创建一个项目</p>\n<p>可以使用快捷键 <code>Ctrl+N</code> 即可呼出创建项目的菜单</p>\n<p><img src=\"/2019/06/08/Learn-Qt5-HelloWorld/newProject.gif\" alt=\"新建项目\"></p>\n<p>创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分</p>\n<p>HelloWorld.pro: Qt的工程文件，由qmake处理</p>\n<p>main.cpp: 里面就是main函数</p>\n<p>mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。</p>\n<p>至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。</p>\n<hr>\n<p>现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。</p>\n<p>修改main.cpp文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QApplication&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QLabel&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">QApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">QLabel <span class=\"title\">label</span><span class=\"params\">(<span class=\"string\">\"HelloWorld\"</span>)</span></span>;</span><br><span class=\"line\">    label.show();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。</p>\n","site":{"data":{}},"excerpt":"<p>当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选．</p>\n<p>那么就让我们从Qt5的HelloWorld开始吧!</p>","more":"<p>第一步先创建一个项目</p>\n<p>可以使用快捷键 <code>Ctrl+N</code> 即可呼出创建项目的菜单</p>\n<p><img src=\"/2019/06/08/Learn-Qt5-HelloWorld/newProject.gif\" alt=\"新建项目\"></p>\n<p>创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分</p>\n<p>HelloWorld.pro: Qt的工程文件，由qmake处理</p>\n<p>main.cpp: 里面就是main函数</p>\n<p>mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。</p>\n<p>至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。</p>\n<hr>\n<p>现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。</p>\n<p>修改main.cpp文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QApplication&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QLabel&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">QApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">QLabel <span class=\"title\">label</span><span class=\"params\">(<span class=\"string\">\"HelloWorld\"</span>)</span></span>;</span><br><span class=\"line\">    label.show();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。</p>"},{"title":"Learn-Qt5-信号槽","copyright":true,"date":"2019-06-10T00:49:35.000Z","_content":"\n信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.\n\n\n<!--more-->\n\n\n信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号.\n\n但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号．\n\n简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发．\n\n\n下面看代码:\n\n~~~C++\n\n#include <QApplication>\n#include <QDebug>\n#include <QPushButton>\n\nint main(int argc, char *argv[]) {\n  QApplication a(argc, argv);\n  QPushButton button(\"Quit\");\n  QObject::connect(&button, &QPushButton::clicked, &QApplication::quit);\n  button.show();\n  return a.exec();\n}\n\n~~~\n\n编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序．\n\n下面我们分析一下QObject::connect这个函数.\n\n首先它拥有以下几种重载\n\n~~~C++\n\nQMetaObject::Connection connect(const QObject *, const char *,\n                                const QObject *, const char *,\n                                Qt::ConnectionType);\n\nQMetaObject::Connection connect(const QObject *, const QMetaMethod &,\n                                const QObject *, const QMetaMethod &,\n                                Qt::ConnectionType);\n\nQMetaObject::Connection connect(const QObject *, const char *,\n                                const char *,\n                                Qt::ConnectionType) const;\n\nQMetaObject::Connection connect(const QObject *, PointerToMemberFunction,\n                                const QObject *, PointerToMemberFunction,\n                                Qt::ConnectionType)\n\nQMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor);\n\n~~~\n\n每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法:\n\n~~~C++\nconnect(sender,signal,receiver,slot);\n~~~\n\nconnect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数．\n\n简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数．\n\n根据这个常用的形式，我们可以依次分析connect的重载．\n\n- 第一种\n\n  > sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理．\n\n- 第二种\n\n  > sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较\n\n- 第三种\n\n  > sender仍为const Object*，而signal和slot则是const char*，这里的reveiver被省略了，它由this指针代替.\n\n- 第四种\n\n  > sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针．\n\n- 第五种\n\n  > 注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式.\n\n经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别．\n\n信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．","source":"_posts/Learn-Qt5-信号槽.md","raw":"---\ntitle: Learn-Qt5-信号槽\ncopyright: true\ndate: 2019-06-10 08:49:35\ncategories: 学习笔记\ntags:\n  - C++\n  - Qt5\n---\n\n信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.\n\n\n<!--more-->\n\n\n信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号.\n\n但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号．\n\n简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发．\n\n\n下面看代码:\n\n~~~C++\n\n#include <QApplication>\n#include <QDebug>\n#include <QPushButton>\n\nint main(int argc, char *argv[]) {\n  QApplication a(argc, argv);\n  QPushButton button(\"Quit\");\n  QObject::connect(&button, &QPushButton::clicked, &QApplication::quit);\n  button.show();\n  return a.exec();\n}\n\n~~~\n\n编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序．\n\n下面我们分析一下QObject::connect这个函数.\n\n首先它拥有以下几种重载\n\n~~~C++\n\nQMetaObject::Connection connect(const QObject *, const char *,\n                                const QObject *, const char *,\n                                Qt::ConnectionType);\n\nQMetaObject::Connection connect(const QObject *, const QMetaMethod &,\n                                const QObject *, const QMetaMethod &,\n                                Qt::ConnectionType);\n\nQMetaObject::Connection connect(const QObject *, const char *,\n                                const char *,\n                                Qt::ConnectionType) const;\n\nQMetaObject::Connection connect(const QObject *, PointerToMemberFunction,\n                                const QObject *, PointerToMemberFunction,\n                                Qt::ConnectionType)\n\nQMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor);\n\n~~~\n\n每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法:\n\n~~~C++\nconnect(sender,signal,receiver,slot);\n~~~\n\nconnect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数．\n\n简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数．\n\n根据这个常用的形式，我们可以依次分析connect的重载．\n\n- 第一种\n\n  > sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理．\n\n- 第二种\n\n  > sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较\n\n- 第三种\n\n  > sender仍为const Object*，而signal和slot则是const char*，这里的reveiver被省略了，它由this指针代替.\n\n- 第四种\n\n  > sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针．\n\n- 第五种\n\n  > 注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式.\n\n经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别．\n\n信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．","slug":"Learn-Qt5-信号槽","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc1001yomoo5d1xos3s","content":"<p>信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.</p>\n<a id=\"more\"></a>\n<p>信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号.</p>\n<p>但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号．</p>\n<p>简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发．</p>\n<p>下面看代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QApplication&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QDebug&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QPushButton&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">QApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">QPushButton <span class=\"title\">button</span><span class=\"params\">(<span class=\"string\">\"Quit\"</span>)</span></span>;</span><br><span class=\"line\">  QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit);</span><br><span class=\"line\">  button.show();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序．</p>\n<p>下面我们分析一下QObject::connect这个函数.</p>\n<p>首先它拥有以下几种重载</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> QMetaMethod &amp;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> QMetaMethod &amp;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor);</span><br></pre></td></tr></table></figure>\n<p>每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(sender,signal,receiver,slot);</span><br></pre></td></tr></table></figure>\n<p>connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数．</p>\n<p>简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数．</p>\n<p>根据这个常用的形式，我们可以依次分析connect的重载．</p>\n<ul>\n<li><p>第一种</p>\n<blockquote>\n<p>sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理．</p>\n</blockquote>\n</li>\n<li><p>第二种</p>\n<blockquote>\n<p>sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较</p>\n</blockquote>\n</li>\n<li><p>第三种</p>\n<blockquote>\n<p>sender仍为const Object<em>，而signal和slot则是const char</em>，这里的reveiver被省略了，它由this指针代替.</p>\n</blockquote>\n</li>\n<li><p>第四种</p>\n<blockquote>\n<p>sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针．</p>\n</blockquote>\n</li>\n<li><p>第五种</p>\n<blockquote>\n<p>注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式.</p>\n</blockquote>\n</li>\n</ul>\n<p>经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别．</p>\n<p>信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．</p>\n","site":{"data":{}},"excerpt":"<p>信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一.</p>","more":"<p>信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号.</p>\n<p>但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号．</p>\n<p>简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发．</p>\n<p>下面看代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QApplication&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QDebug&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QPushButton&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">QApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">QPushButton <span class=\"title\">button</span><span class=\"params\">(<span class=\"string\">\"Quit\"</span>)</span></span>;</span><br><span class=\"line\">  QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit);</span><br><span class=\"line\">  button.show();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序．</p>\n<p>下面我们分析一下QObject::connect这个函数.</p>\n<p>首先它拥有以下几种重载</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> QMetaMethod &amp;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> QMetaMethod &amp;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">QMetaObject::<span class=\"function\">Connection <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                Qt::ConnectionType)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor);</span><br></pre></td></tr></table></figure>\n<p>每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(sender,signal,receiver,slot);</span><br></pre></td></tr></table></figure>\n<p>connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数．</p>\n<p>简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数．</p>\n<p>根据这个常用的形式，我们可以依次分析connect的重载．</p>\n<ul>\n<li><p>第一种</p>\n<blockquote>\n<p>sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理．</p>\n</blockquote>\n</li>\n<li><p>第二种</p>\n<blockquote>\n<p>sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较</p>\n</blockquote>\n</li>\n<li><p>第三种</p>\n<blockquote>\n<p>sender仍为const Object<em>，而signal和slot则是const char</em>，这里的reveiver被省略了，它由this指针代替.</p>\n</blockquote>\n</li>\n<li><p>第四种</p>\n<blockquote>\n<p>sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针．</p>\n</blockquote>\n</li>\n<li><p>第五种</p>\n<blockquote>\n<p>注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式.</p>\n</blockquote>\n</li>\n</ul>\n<p>经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别．</p>\n<p>信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．</p>"},{"title":"Learn-Qt5-自定义信号槽","copyright":true,"date":"2019-06-11T03:26:58.000Z","_content":"\n上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．\n\n我们通过一个新闻和订阅者的例子讲解典型的观察者模式．\n\n有一个报纸类`Newspaper`，有一个订阅者类`Subscriber`，`Subscriber`可订阅`Newspaper`，订阅后若`Newspaper`有了新内容，那么`Subscriber`则会立即得到通知．\n\n上面这个案例的观察者是`Subscriber`，被观察者则是`Newspaper`．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者．\n\n下面，我们将用Qt的信号槽实现上面的的案例．\n\n~~~C++\n\n//newspaper.h\n#include <QObject>\n\nclass NewsPaper : public QObject {\n  Q_OBJECT\npublic:\n  NewsPaper(const QString &name) : m_name(name) {}\n  void send() { emit newPaper(m_name); }\nsignals:\n  void newPaper(const QString &name);\n\nprivate:\n  QString m_name;\n};\n\n//reader.h\n#include <QObject>\nclass Reader : public QObject {\n    Q_OBJECT\npublic:\n    void receiverNewsPaper(const QString &name){\n        qDebug()<<\"Newpaper:\"<<name;\n    }\n};\n\n//main.cpp\n#include <QCoreApplication>\n#include <newspaper.h>\n#include <reader.h>\n\nint main(int argc, char *argv[]) {\n  QCoreApplication a(argc, argv);\n  NewsPaper paper(\"xx与xxx结婚了!\");\n  Reader reader;\n\n  QObject::connect(&paper, &NewsPaper::newPaper, &reader,\n                   &Reader::receiverNewsPaper);\n\n  paper.send();\n\n  return a.exec();\n}\n\n~~~\n\n运行结果:\n\n~~~\nNewpaper:xx与xxx结婚了!\n~~~\n\n我们看到`Reader`类和`Newspaper`类都继承了`QObject` 类，在Qt中，只有继承了`QObject`类的类才具有信号槽的能力．凡是`Object`类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上`Q_OBJECT`．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内．\n\n再看`Newspaper`类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据.\n\n`Newspaper`类的`send()`函数比较简单，只有一条语句`emit newPaper(m_name);`. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出`newPaper()`信号．如果有接受者关注这个信号，　那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字`m_name`以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移．\n\n`Reader`类是接受信号的，所以我们也需要继承`QObject`，并且添加`Q_OBJECT`宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义．\n\nmain函数中，我们首先创建了`Newspaper`和`Reader`两个独享，然后使用`QObject::connect()`函数．这个然后我们调用`Newspaper`的`send()`函数．这个函数只有一个语句：发出信号．由于我们将`Newspaper`的信号和`Reader`的槽函数进行了连接，当这个信号发出时，那么将会自动调用`Reader`的槽函数．\n\n总结自定义信号槽需要注意的事项:\n\n- 发送者和接收者都需要的是`QObject`的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外．\n- 使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码；\n- 使用emit发送信号\n- 使用QObject::connect()函数连接信号和槽.","source":"_posts/Learn-Qt5-自定义信号槽.md","raw":"---\ntitle: Learn-Qt5-自定义信号槽\ncopyright: true\ndate: 2019-06-11 11:26:58\ncategories: 学习笔记\ntags:\n  - Qt5\n  - C++\n---\n\n上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．\n\n我们通过一个新闻和订阅者的例子讲解典型的观察者模式．\n\n有一个报纸类`Newspaper`，有一个订阅者类`Subscriber`，`Subscriber`可订阅`Newspaper`，订阅后若`Newspaper`有了新内容，那么`Subscriber`则会立即得到通知．\n\n上面这个案例的观察者是`Subscriber`，被观察者则是`Newspaper`．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者．\n\n下面，我们将用Qt的信号槽实现上面的的案例．\n\n~~~C++\n\n//newspaper.h\n#include <QObject>\n\nclass NewsPaper : public QObject {\n  Q_OBJECT\npublic:\n  NewsPaper(const QString &name) : m_name(name) {}\n  void send() { emit newPaper(m_name); }\nsignals:\n  void newPaper(const QString &name);\n\nprivate:\n  QString m_name;\n};\n\n//reader.h\n#include <QObject>\nclass Reader : public QObject {\n    Q_OBJECT\npublic:\n    void receiverNewsPaper(const QString &name){\n        qDebug()<<\"Newpaper:\"<<name;\n    }\n};\n\n//main.cpp\n#include <QCoreApplication>\n#include <newspaper.h>\n#include <reader.h>\n\nint main(int argc, char *argv[]) {\n  QCoreApplication a(argc, argv);\n  NewsPaper paper(\"xx与xxx结婚了!\");\n  Reader reader;\n\n  QObject::connect(&paper, &NewsPaper::newPaper, &reader,\n                   &Reader::receiverNewsPaper);\n\n  paper.send();\n\n  return a.exec();\n}\n\n~~~\n\n运行结果:\n\n~~~\nNewpaper:xx与xxx结婚了!\n~~~\n\n我们看到`Reader`类和`Newspaper`类都继承了`QObject` 类，在Qt中，只有继承了`QObject`类的类才具有信号槽的能力．凡是`Object`类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上`Q_OBJECT`．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内．\n\n再看`Newspaper`类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据.\n\n`Newspaper`类的`send()`函数比较简单，只有一条语句`emit newPaper(m_name);`. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出`newPaper()`信号．如果有接受者关注这个信号，　那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字`m_name`以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移．\n\n`Reader`类是接受信号的，所以我们也需要继承`QObject`，并且添加`Q_OBJECT`宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义．\n\nmain函数中，我们首先创建了`Newspaper`和`Reader`两个独享，然后使用`QObject::connect()`函数．这个然后我们调用`Newspaper`的`send()`函数．这个函数只有一个语句：发出信号．由于我们将`Newspaper`的信号和`Reader`的槽函数进行了连接，当这个信号发出时，那么将会自动调用`Reader`的槽函数．\n\n总结自定义信号槽需要注意的事项:\n\n- 发送者和接收者都需要的是`QObject`的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外．\n- 使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码；\n- 使用emit发送信号\n- 使用QObject::connect()函数连接信号和槽.","slug":"Learn-Qt5-自定义信号槽","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc20021omoo1knddeyr","content":"<p>上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．</p>\n<p>我们通过一个新闻和订阅者的例子讲解典型的观察者模式．</p>\n<p>有一个报纸类<code>Newspaper</code>，有一个订阅者类<code>Subscriber</code>，<code>Subscriber</code>可订阅<code>Newspaper</code>，订阅后若<code>Newspaper</code>有了新内容，那么<code>Subscriber</code>则会立即得到通知．</p>\n<p>上面这个案例的观察者是<code>Subscriber</code>，被观察者则是<code>Newspaper</code>．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者．</p>\n<p>下面，我们将用Qt的信号槽实现上面的的案例．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//newspaper.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QObject&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsPaper</span> :</span> <span class=\"keyword\">public</span> QObject &#123;</span><br><span class=\"line\">  Q_OBJECT</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  NewsPaper(<span class=\"keyword\">const</span> QString &amp;name) : m_name(name) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123; <span class=\"function\">emit <span class=\"title\">newPaper</span><span class=\"params\">(m_name)</span></span>; &#125;</span><br><span class=\"line\">signals:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newPaper</span><span class=\"params\">(<span class=\"keyword\">const</span> QString &amp;name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  QString m_name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reader.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QObject&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reader</span> :</span> <span class=\"keyword\">public</span> QObject &#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">receiverNewsPaper</span><span class=\"params\">(<span class=\"keyword\">const</span> QString &amp;name)</span></span>&#123;</span><br><span class=\"line\">        qDebug()&lt;&lt;<span class=\"string\">\"Newpaper:\"</span>&lt;&lt;name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QCoreApplication&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;newspaper.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;reader.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">QCoreApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">NewsPaper <span class=\"title\">paper</span><span class=\"params\">(<span class=\"string\">\"xx与xxx结婚了!\"</span>)</span></span>;</span><br><span class=\"line\">  Reader reader;</span><br><span class=\"line\"></span><br><span class=\"line\">  QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader,</span><br><span class=\"line\">                   &amp;Reader::receiverNewsPaper);</span><br><span class=\"line\"></span><br><span class=\"line\">  paper.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Newpaper:xx与xxx结婚了!</span><br></pre></td></tr></table></figure>\n<p>我们看到<code>Reader</code>类和<code>Newspaper</code>类都继承了<code>QObject</code> 类，在Qt中，只有继承了<code>QObject</code>类的类才具有信号槽的能力．凡是<code>Object</code>类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上<code>Q_OBJECT</code>．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内．</p>\n<p>再看<code>Newspaper</code>类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据.</p>\n<p><code>Newspaper</code>类的<code>send()</code>函数比较简单，只有一条语句<code>emit newPaper(m_name);</code>. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出<code>newPaper()</code>信号．如果有接受者关注这个信号，　那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字<code>m_name</code>以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移．</p>\n<p><code>Reader</code>类是接受信号的，所以我们也需要继承<code>QObject</code>，并且添加<code>Q_OBJECT</code>宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义．</p>\n<p>main函数中，我们首先创建了<code>Newspaper</code>和<code>Reader</code>两个独享，然后使用<code>QObject::connect()</code>函数．这个然后我们调用<code>Newspaper</code>的<code>send()</code>函数．这个函数只有一个语句：发出信号．由于我们将<code>Newspaper</code>的信号和<code>Reader</code>的槽函数进行了连接，当这个信号发出时，那么将会自动调用<code>Reader</code>的槽函数．</p>\n<p>总结自定义信号槽需要注意的事项:</p>\n<ul>\n<li>发送者和接收者都需要的是<code>QObject</code>的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外．</li>\n<li>使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码；</li>\n<li>使用emit发送信号</li>\n<li>使用QObject::connect()函数连接信号和槽.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性．</p>\n<p>我们通过一个新闻和订阅者的例子讲解典型的观察者模式．</p>\n<p>有一个报纸类<code>Newspaper</code>，有一个订阅者类<code>Subscriber</code>，<code>Subscriber</code>可订阅<code>Newspaper</code>，订阅后若<code>Newspaper</code>有了新内容，那么<code>Subscriber</code>则会立即得到通知．</p>\n<p>上面这个案例的观察者是<code>Subscriber</code>，被观察者则是<code>Newspaper</code>．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者．</p>\n<p>下面，我们将用Qt的信号槽实现上面的的案例．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//newspaper.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QObject&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsPaper</span> :</span> <span class=\"keyword\">public</span> QObject &#123;</span><br><span class=\"line\">  Q_OBJECT</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  NewsPaper(<span class=\"keyword\">const</span> QString &amp;name) : m_name(name) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123; <span class=\"function\">emit <span class=\"title\">newPaper</span><span class=\"params\">(m_name)</span></span>; &#125;</span><br><span class=\"line\">signals:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newPaper</span><span class=\"params\">(<span class=\"keyword\">const</span> QString &amp;name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  QString m_name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reader.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QObject&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reader</span> :</span> <span class=\"keyword\">public</span> QObject &#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">receiverNewsPaper</span><span class=\"params\">(<span class=\"keyword\">const</span> QString &amp;name)</span></span>&#123;</span><br><span class=\"line\">        qDebug()&lt;&lt;<span class=\"string\">\"Newpaper:\"</span>&lt;&lt;name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QCoreApplication&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;newspaper.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;reader.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">QCoreApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">NewsPaper <span class=\"title\">paper</span><span class=\"params\">(<span class=\"string\">\"xx与xxx结婚了!\"</span>)</span></span>;</span><br><span class=\"line\">  Reader reader;</span><br><span class=\"line\"></span><br><span class=\"line\">  QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader,</span><br><span class=\"line\">                   &amp;Reader::receiverNewsPaper);</span><br><span class=\"line\"></span><br><span class=\"line\">  paper.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Newpaper:xx与xxx结婚了!</span><br></pre></td></tr></table></figure>\n<p>我们看到<code>Reader</code>类和<code>Newspaper</code>类都继承了<code>QObject</code> 类，在Qt中，只有继承了<code>QObject</code>类的类才具有信号槽的能力．凡是<code>Object</code>类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上<code>Q_OBJECT</code>．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内．</p>\n<p>再看<code>Newspaper</code>类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据.</p>\n<p><code>Newspaper</code>类的<code>send()</code>函数比较简单，只有一条语句<code>emit newPaper(m_name);</code>. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出<code>newPaper()</code>信号．如果有接受者关注这个信号，　那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字<code>m_name</code>以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移．</p>\n<p><code>Reader</code>类是接受信号的，所以我们也需要继承<code>QObject</code>，并且添加<code>Q_OBJECT</code>宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义．</p>\n<p>main函数中，我们首先创建了<code>Newspaper</code>和<code>Reader</code>两个独享，然后使用<code>QObject::connect()</code>函数．这个然后我们调用<code>Newspaper</code>的<code>send()</code>函数．这个函数只有一个语句：发出信号．由于我们将<code>Newspaper</code>的信号和<code>Reader</code>的槽函数进行了连接，当这个信号发出时，那么将会自动调用<code>Reader</code>的槽函数．</p>\n<p>总结自定义信号槽需要注意的事项:</p>\n<ul>\n<li>发送者和接收者都需要的是<code>QObject</code>的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外．</li>\n<li>使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码；</li>\n<li>使用emit发送信号</li>\n<li>使用QObject::connect()函数连接信号和槽.</li>\n</ul>\n"},{"title":"Linux-Linux命令行简介-man命令","copyright":true,"date":"2019-06-15T10:31:17.000Z","_content":"\n本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。\n\n<!--more-->\n\n# 1.2.1 使用man获取命令帮助信息\n\nman命令的作用:\n  \n  - 查看命令的使用帮助\n\n  - 查看软件服务配置文件\n\n  - 查看系统调用信息\n\n  - 查看C库函数帮助信息\n\nman命令的使用:\n  \n  ~~~Shell\n  man 参数选项 命令/文件\n  ~~~\n\nman命令可选参数:\n\n  |参数|英文说明|中文说明|\n  |---|--------------------------------|----------------------|\n  | 1 | User Commands                  | 用户命令相关         |\n  | 2 | System Calls                   | 系统调用相关         |\n  | 3 | C Library Functions            | C的库函数相关        |\n  | 4 | Devices and Special Files      | 设备与特殊文件相关   |\n  | 5 | File Formats and Conventions   | 文件格式和规则       |\n  | 6 | Games et. Al.                  | 游戏及其他           |\n  | 7 | Miscellanea                    | 宏，包及其他杂项     |\n  | 8 | System Admin tools and Deamons | 系统管理员命令和进程 |\n\n  例子:\n  \n  ~~~Shell\n  # 查看cp命令的使用帮助\n  man cp\n  # 查看C语言printf函数的使用帮助\n  man 3 printf\n  ~~~\n\nman命令信息的格式\n\n  |标签|说明(`!`表示重点)|\n  |----------------------|----------------------------------------------------------------------------|\n  | NAME                 | 命令说明及介绍`!`                                                          |\n  | SYNOPSIS             | 命令的基本使用语法`!`                                                      |\n  | DESCRIPTION          | 命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS`!` |\n  | OPTIONS              | 命令参数选项说明                                                           |\n  | COMMANDS             | 执行某个软件时可附加的软件的命令                                           |\n  | FILES                | 程序涉及的相关文件                                                         |\n  | EXAMPLES             | 命令的例子`!`                                                              |\n  | SEE ALSO             | 命令相关信息的说明                                                         |\n  | BUGS(REPORTING BUGS) | 命令对应缺陷问题的描述                                                     |\n  | COPYRIGHT            | 版权信息相关声明                                                           |\n  | AUTHOR               | 作者介绍                                                                   |\n\nman命令信息操作键\n\n  |操作键|功能说明|\n  |-----------|------------------------------------------------------------------------|\n  | Page Down | 向下翻页                                                               |\n  | Page Up   | 向上翻页                                                               |\n  | Home      | 跳转到第一页                                                           |\n  | End       | 跳转到最后一页                                                         |\n  | /         | 向下查找某个字符                                                       |\n  | ?         | 向上查找某个字符                                                       |\n  | n,N       | 当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反 |\n  | q         | 结束本次man帮助                                                        |\n\n# 1.2.2 使用--help参数获取命令帮助信息\n\n  例子:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ ls --help\n  ~~~\n\n  输出如下:\n\n  ~~~Shell\n  用法：ls [选项]... [文件]...\n  列出给定文件（默认为当前目录）的信息。\n  如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。\n\n  必选参数对长短选项同时适用。\n  -a, --all                     不隐藏任何以. 开始的项目\n  -A, --almost-all              列出除. 及.. 以外的任何项目\n      --author                  与-l 同时使用时列出每个文件的作者\n  -b, --escape                  以八进制溢出序列表示不可打印的字符\n\n  ~~~\n\n# 1.2.3 使用help命令获取命令帮助信息\n\n  例子:\n  \n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ help cd\n  ~~~\n\n  输出如下:\n\n  ~~~Shell\n  cd: cd [-L|[-P [-e]] [-@]] [目录]\n    改变 shell 工作目录。\n    \n    改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME\n    的值。\n    \n    变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。\n    一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH\n    不会用上变量。\n    \n    如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个\n    变量名。如果该变量有值，则它的值被当作 DIR 目录。\n  ~~~\n\n# 1.2.4 使用info获取帮助信息\n  \n  例子:\n\n  ~~~shell\n  [evanmeek@EvanLinux ~]$ info cd\n  ~~~\n  \n  即可打开cd的文档信息，操作跟man的使用方式相似。\n\n# 1.2.5 从互联网搜索获取命令帮助信息\n\n  [Google](https://www.google.com)\n  [Bing](https://www.bing.com)\n  [Github](https://www.github.com)\n  [StackOverFlow](https://stackoverflow.com)\n","source":"_posts/Linux-Linux命令行简介-man命令.md","raw":"---\ntitle: Linux-Linux命令行简介-man命令\ncopyright: true\ndate: 2019-06-15 18:31:17\ncategories: Linux系列\ntags:\n - Linux\n---\n\n本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。\n\n<!--more-->\n\n# 1.2.1 使用man获取命令帮助信息\n\nman命令的作用:\n  \n  - 查看命令的使用帮助\n\n  - 查看软件服务配置文件\n\n  - 查看系统调用信息\n\n  - 查看C库函数帮助信息\n\nman命令的使用:\n  \n  ~~~Shell\n  man 参数选项 命令/文件\n  ~~~\n\nman命令可选参数:\n\n  |参数|英文说明|中文说明|\n  |---|--------------------------------|----------------------|\n  | 1 | User Commands                  | 用户命令相关         |\n  | 2 | System Calls                   | 系统调用相关         |\n  | 3 | C Library Functions            | C的库函数相关        |\n  | 4 | Devices and Special Files      | 设备与特殊文件相关   |\n  | 5 | File Formats and Conventions   | 文件格式和规则       |\n  | 6 | Games et. Al.                  | 游戏及其他           |\n  | 7 | Miscellanea                    | 宏，包及其他杂项     |\n  | 8 | System Admin tools and Deamons | 系统管理员命令和进程 |\n\n  例子:\n  \n  ~~~Shell\n  # 查看cp命令的使用帮助\n  man cp\n  # 查看C语言printf函数的使用帮助\n  man 3 printf\n  ~~~\n\nman命令信息的格式\n\n  |标签|说明(`!`表示重点)|\n  |----------------------|----------------------------------------------------------------------------|\n  | NAME                 | 命令说明及介绍`!`                                                          |\n  | SYNOPSIS             | 命令的基本使用语法`!`                                                      |\n  | DESCRIPTION          | 命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS`!` |\n  | OPTIONS              | 命令参数选项说明                                                           |\n  | COMMANDS             | 执行某个软件时可附加的软件的命令                                           |\n  | FILES                | 程序涉及的相关文件                                                         |\n  | EXAMPLES             | 命令的例子`!`                                                              |\n  | SEE ALSO             | 命令相关信息的说明                                                         |\n  | BUGS(REPORTING BUGS) | 命令对应缺陷问题的描述                                                     |\n  | COPYRIGHT            | 版权信息相关声明                                                           |\n  | AUTHOR               | 作者介绍                                                                   |\n\nman命令信息操作键\n\n  |操作键|功能说明|\n  |-----------|------------------------------------------------------------------------|\n  | Page Down | 向下翻页                                                               |\n  | Page Up   | 向上翻页                                                               |\n  | Home      | 跳转到第一页                                                           |\n  | End       | 跳转到最后一页                                                         |\n  | /         | 向下查找某个字符                                                       |\n  | ?         | 向上查找某个字符                                                       |\n  | n,N       | 当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反 |\n  | q         | 结束本次man帮助                                                        |\n\n# 1.2.2 使用--help参数获取命令帮助信息\n\n  例子:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ ls --help\n  ~~~\n\n  输出如下:\n\n  ~~~Shell\n  用法：ls [选项]... [文件]...\n  列出给定文件（默认为当前目录）的信息。\n  如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。\n\n  必选参数对长短选项同时适用。\n  -a, --all                     不隐藏任何以. 开始的项目\n  -A, --almost-all              列出除. 及.. 以外的任何项目\n      --author                  与-l 同时使用时列出每个文件的作者\n  -b, --escape                  以八进制溢出序列表示不可打印的字符\n\n  ~~~\n\n# 1.2.3 使用help命令获取命令帮助信息\n\n  例子:\n  \n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ help cd\n  ~~~\n\n  输出如下:\n\n  ~~~Shell\n  cd: cd [-L|[-P [-e]] [-@]] [目录]\n    改变 shell 工作目录。\n    \n    改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME\n    的值。\n    \n    变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。\n    一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH\n    不会用上变量。\n    \n    如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个\n    变量名。如果该变量有值，则它的值被当作 DIR 目录。\n  ~~~\n\n# 1.2.4 使用info获取帮助信息\n  \n  例子:\n\n  ~~~shell\n  [evanmeek@EvanLinux ~]$ info cd\n  ~~~\n  \n  即可打开cd的文档信息，操作跟man的使用方式相似。\n\n# 1.2.5 从互联网搜索获取命令帮助信息\n\n  [Google](https://www.google.com)\n  [Bing](https://www.bing.com)\n  [Github](https://www.github.com)\n  [StackOverFlow](https://stackoverflow.com)\n","slug":"Linux-Linux命令行简介-man命令","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc30025omoocyeti0ij","content":"<p>本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-2-1-使用man获取命令帮助信息\"><a href=\"#1-2-1-使用man获取命令帮助信息\" class=\"headerlink\" title=\"1.2.1 使用man获取命令帮助信息\"></a>1.2.1 使用man获取命令帮助信息</h1><p>man命令的作用:</p>\n<ul>\n<li><p>查看命令的使用帮助</p>\n</li>\n<li><p>查看软件服务配置文件</p>\n</li>\n<li><p>查看系统调用信息</p>\n</li>\n<li><p>查看C库函数帮助信息</p>\n</li>\n</ul>\n<p>man命令的使用:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man 参数选项 命令/文件</span><br></pre></td></tr></table></figure>\n<p>man命令可选参数:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>英文说明</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>User Commands</td>\n<td>用户命令相关</td>\n</tr>\n<tr>\n<td>2</td>\n<td>System Calls</td>\n<td>系统调用相关</td>\n</tr>\n<tr>\n<td>3</td>\n<td>C Library Functions</td>\n<td>C的库函数相关</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Devices and Special Files</td>\n<td>设备与特殊文件相关</td>\n</tr>\n<tr>\n<td>5</td>\n<td>File Formats and Conventions</td>\n<td>文件格式和规则</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Games et. Al.</td>\n<td>游戏及其他</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Miscellanea</td>\n<td>宏，包及其他杂项</td>\n</tr>\n<tr>\n<td>8</td>\n<td>System Admin tools and Deamons</td>\n<td>系统管理员命令和进程</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 查看cp命令的使用帮助</span><br><span class=\"line\">man cp</span><br><span class=\"line\"><span class=\"meta\">#</span> 查看C语言printf函数的使用帮助</span><br><span class=\"line\">man 3 printf</span><br></pre></td></tr></table></figure>\n<p>man命令信息的格式</p>\n<table>\n<thead>\n<tr>\n<th>标签</th>\n<th>说明(<code>!</code>表示重点)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NAME</td>\n<td>命令说明及介绍<code>!</code></td>\n</tr>\n<tr>\n<td>SYNOPSIS</td>\n<td>命令的基本使用语法<code>!</code></td>\n</tr>\n<tr>\n<td>DESCRIPTION</td>\n<td>命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS<code>!</code></td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>命令参数选项说明</td>\n</tr>\n<tr>\n<td>COMMANDS</td>\n<td>执行某个软件时可附加的软件的命令</td>\n</tr>\n<tr>\n<td>FILES</td>\n<td>程序涉及的相关文件</td>\n</tr>\n<tr>\n<td>EXAMPLES</td>\n<td>命令的例子<code>!</code></td>\n</tr>\n<tr>\n<td>SEE ALSO</td>\n<td>命令相关信息的说明</td>\n</tr>\n<tr>\n<td>BUGS(REPORTING BUGS)</td>\n<td>命令对应缺陷问题的描述</td>\n</tr>\n<tr>\n<td>COPYRIGHT</td>\n<td>版权信息相关声明</td>\n</tr>\n<tr>\n<td>AUTHOR</td>\n<td>作者介绍</td>\n</tr>\n</tbody>\n</table>\n<p>man命令信息操作键</p>\n<table>\n<thead>\n<tr>\n<th>操作键</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Page Down</td>\n<td>向下翻页</td>\n</tr>\n<tr>\n<td>Page Up</td>\n<td>向上翻页</td>\n</tr>\n<tr>\n<td>Home</td>\n<td>跳转到第一页</td>\n</tr>\n<tr>\n<td>End</td>\n<td>跳转到最后一页</td>\n</tr>\n<tr>\n<td>/</td>\n<td>向下查找某个字符</td>\n</tr>\n<tr>\n<td>?</td>\n<td>向上查找某个字符</td>\n</tr>\n<tr>\n<td>n,N</td>\n<td>当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反</td>\n</tr>\n<tr>\n<td>q</td>\n<td>结束本次man帮助</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"1-2-2-使用–help参数获取命令帮助信息\"><a href=\"#1-2-2-使用–help参数获取命令帮助信息\" class=\"headerlink\" title=\"1.2.2 使用–help参数获取命令帮助信息\"></a>1.2.2 使用–help参数获取命令帮助信息</h1><p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ls --help</span><br></pre></td></tr></table></figure>\n<p>  输出如下:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法：ls [选项]... [文件]...</span><br><span class=\"line\">列出给定文件（默认为当前目录）的信息。</span><br><span class=\"line\">如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。</span><br><span class=\"line\"></span><br><span class=\"line\">必选参数对长短选项同时适用。</span><br><span class=\"line\">-a, --all                     不隐藏任何以. 开始的项目</span><br><span class=\"line\">-A, --almost-all              列出除. 及.. 以外的任何项目</span><br><span class=\"line\">    --author                  与-l 同时使用时列出每个文件的作者</span><br><span class=\"line\">-b, --escape                  以八进制溢出序列表示不可打印的字符</span><br></pre></td></tr></table></figure>\n<h1 id=\"1-2-3-使用help命令获取命令帮助信息\"><a href=\"#1-2-3-使用help命令获取命令帮助信息\" class=\"headerlink\" title=\"1.2.3 使用help命令获取命令帮助信息\"></a>1.2.3 使用help命令获取命令帮助信息</h1><p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ help cd</span><br></pre></td></tr></table></figure>\n<p>  输出如下:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd: cd [-L|[-P [-e]] [-@]] [目录]</span><br><span class=\"line\">  改变 shell 工作目录。</span><br><span class=\"line\">  </span><br><span class=\"line\">  改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME</span><br><span class=\"line\">  的值。</span><br><span class=\"line\">  </span><br><span class=\"line\">  变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。</span><br><span class=\"line\">  一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH</span><br><span class=\"line\">  不会用上变量。</span><br><span class=\"line\">  </span><br><span class=\"line\">  如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个</span><br><span class=\"line\">  变量名。如果该变量有值，则它的值被当作 DIR 目录。</span><br></pre></td></tr></table></figure>\n<h1 id=\"1-2-4-使用info获取帮助信息\"><a href=\"#1-2-4-使用info获取帮助信息\" class=\"headerlink\" title=\"1.2.4 使用info获取帮助信息\"></a>1.2.4 使用info获取帮助信息</h1><p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ info cd</span><br></pre></td></tr></table></figure>\n<p>  即可打开cd的文档信息，操作跟man的使用方式相似。</p>\n<h1 id=\"1-2-5-从互联网搜索获取命令帮助信息\"><a href=\"#1-2-5-从互联网搜索获取命令帮助信息\" class=\"headerlink\" title=\"1.2.5 从互联网搜索获取命令帮助信息\"></a>1.2.5 从互联网搜索获取命令帮助信息</h1><p>  <a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">Google</a><br>  <a href=\"https://www.bing.com\" target=\"_blank\" rel=\"noopener\">Bing</a><br>  <a href=\"https://www.github.com\" target=\"_blank\" rel=\"noopener\">Github</a><br>  <a href=\"https://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverFlow</a></p>\n","site":{"data":{}},"excerpt":"<p>本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。</p>","more":"<h1 id=\"1-2-1-使用man获取命令帮助信息\"><a href=\"#1-2-1-使用man获取命令帮助信息\" class=\"headerlink\" title=\"1.2.1 使用man获取命令帮助信息\"></a>1.2.1 使用man获取命令帮助信息</h1><p>man命令的作用:</p>\n<ul>\n<li><p>查看命令的使用帮助</p>\n</li>\n<li><p>查看软件服务配置文件</p>\n</li>\n<li><p>查看系统调用信息</p>\n</li>\n<li><p>查看C库函数帮助信息</p>\n</li>\n</ul>\n<p>man命令的使用:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man 参数选项 命令/文件</span><br></pre></td></tr></table></figure>\n<p>man命令可选参数:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>英文说明</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>User Commands</td>\n<td>用户命令相关</td>\n</tr>\n<tr>\n<td>2</td>\n<td>System Calls</td>\n<td>系统调用相关</td>\n</tr>\n<tr>\n<td>3</td>\n<td>C Library Functions</td>\n<td>C的库函数相关</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Devices and Special Files</td>\n<td>设备与特殊文件相关</td>\n</tr>\n<tr>\n<td>5</td>\n<td>File Formats and Conventions</td>\n<td>文件格式和规则</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Games et. Al.</td>\n<td>游戏及其他</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Miscellanea</td>\n<td>宏，包及其他杂项</td>\n</tr>\n<tr>\n<td>8</td>\n<td>System Admin tools and Deamons</td>\n<td>系统管理员命令和进程</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 查看cp命令的使用帮助</span><br><span class=\"line\">man cp</span><br><span class=\"line\"><span class=\"meta\">#</span> 查看C语言printf函数的使用帮助</span><br><span class=\"line\">man 3 printf</span><br></pre></td></tr></table></figure>\n<p>man命令信息的格式</p>\n<table>\n<thead>\n<tr>\n<th>标签</th>\n<th>说明(<code>!</code>表示重点)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NAME</td>\n<td>命令说明及介绍<code>!</code></td>\n</tr>\n<tr>\n<td>SYNOPSIS</td>\n<td>命令的基本使用语法<code>!</code></td>\n</tr>\n<tr>\n<td>DESCRIPTION</td>\n<td>命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS<code>!</code></td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>命令参数选项说明</td>\n</tr>\n<tr>\n<td>COMMANDS</td>\n<td>执行某个软件时可附加的软件的命令</td>\n</tr>\n<tr>\n<td>FILES</td>\n<td>程序涉及的相关文件</td>\n</tr>\n<tr>\n<td>EXAMPLES</td>\n<td>命令的例子<code>!</code></td>\n</tr>\n<tr>\n<td>SEE ALSO</td>\n<td>命令相关信息的说明</td>\n</tr>\n<tr>\n<td>BUGS(REPORTING BUGS)</td>\n<td>命令对应缺陷问题的描述</td>\n</tr>\n<tr>\n<td>COPYRIGHT</td>\n<td>版权信息相关声明</td>\n</tr>\n<tr>\n<td>AUTHOR</td>\n<td>作者介绍</td>\n</tr>\n</tbody>\n</table>\n<p>man命令信息操作键</p>\n<table>\n<thead>\n<tr>\n<th>操作键</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Page Down</td>\n<td>向下翻页</td>\n</tr>\n<tr>\n<td>Page Up</td>\n<td>向上翻页</td>\n</tr>\n<tr>\n<td>Home</td>\n<td>跳转到第一页</td>\n</tr>\n<tr>\n<td>End</td>\n<td>跳转到最后一页</td>\n</tr>\n<tr>\n<td>/</td>\n<td>向下查找某个字符</td>\n</tr>\n<tr>\n<td>?</td>\n<td>向上查找某个字符</td>\n</tr>\n<tr>\n<td>n,N</td>\n<td>当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反</td>\n</tr>\n<tr>\n<td>q</td>\n<td>结束本次man帮助</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"1-2-2-使用–help参数获取命令帮助信息\"><a href=\"#1-2-2-使用–help参数获取命令帮助信息\" class=\"headerlink\" title=\"1.2.2 使用–help参数获取命令帮助信息\"></a>1.2.2 使用–help参数获取命令帮助信息</h1><p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ls --help</span><br></pre></td></tr></table></figure>\n<p>  输出如下:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法：ls [选项]... [文件]...</span><br><span class=\"line\">列出给定文件（默认为当前目录）的信息。</span><br><span class=\"line\">如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。</span><br><span class=\"line\"></span><br><span class=\"line\">必选参数对长短选项同时适用。</span><br><span class=\"line\">-a, --all                     不隐藏任何以. 开始的项目</span><br><span class=\"line\">-A, --almost-all              列出除. 及.. 以外的任何项目</span><br><span class=\"line\">    --author                  与-l 同时使用时列出每个文件的作者</span><br><span class=\"line\">-b, --escape                  以八进制溢出序列表示不可打印的字符</span><br></pre></td></tr></table></figure>\n<h1 id=\"1-2-3-使用help命令获取命令帮助信息\"><a href=\"#1-2-3-使用help命令获取命令帮助信息\" class=\"headerlink\" title=\"1.2.3 使用help命令获取命令帮助信息\"></a>1.2.3 使用help命令获取命令帮助信息</h1><p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ help cd</span><br></pre></td></tr></table></figure>\n<p>  输出如下:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd: cd [-L|[-P [-e]] [-@]] [目录]</span><br><span class=\"line\">  改变 shell 工作目录。</span><br><span class=\"line\">  </span><br><span class=\"line\">  改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME</span><br><span class=\"line\">  的值。</span><br><span class=\"line\">  </span><br><span class=\"line\">  变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。</span><br><span class=\"line\">  一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH</span><br><span class=\"line\">  不会用上变量。</span><br><span class=\"line\">  </span><br><span class=\"line\">  如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个</span><br><span class=\"line\">  变量名。如果该变量有值，则它的值被当作 DIR 目录。</span><br></pre></td></tr></table></figure>\n<h1 id=\"1-2-4-使用info获取帮助信息\"><a href=\"#1-2-4-使用info获取帮助信息\" class=\"headerlink\" title=\"1.2.4 使用info获取帮助信息\"></a>1.2.4 使用info获取帮助信息</h1><p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ info cd</span><br></pre></td></tr></table></figure>\n<p>  即可打开cd的文档信息，操作跟man的使用方式相似。</p>\n<h1 id=\"1-2-5-从互联网搜索获取命令帮助信息\"><a href=\"#1-2-5-从互联网搜索获取命令帮助信息\" class=\"headerlink\" title=\"1.2.5 从互联网搜索获取命令帮助信息\"></a>1.2.5 从互联网搜索获取命令帮助信息</h1><p>  <a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">Google</a><br>  <a href=\"https://www.bing.com\" target=\"_blank\" rel=\"noopener\">Bing</a><br>  <a href=\"https://www.github.com\" target=\"_blank\" rel=\"noopener\">Github</a><br>  <a href=\"https://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverFlow</a></p>"},{"title":"Linux-Linux命令行简介-0","copyright":true,"date":"2019-06-15T08:35:38.000Z","_content":"\n# 1.1 Linux命令行概述\n\n## 1.1.1 Linux命令行的作用与意义\n\n  Linux命令行相比图形界面操作的优点:\n\n  - 快速\n\n  - 批量\n\n  - 自动化\n\n  - 智能化管理\n\n## 1.1.2 Linux命令行介绍\n\n  大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图:\n\n  ![命令行图](Linux-Linux命令行简介-0/1.1.2-0)\n\n## 1.1.3 Linux命令行的开启及退出\n\n  主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。\n\n  ~~~Shell\n  user login:_\n  password:_\n  ~~~\n\n  等待你输入用户名密码，密码输入时是不会显示的。\n\n  使用`exit`,`logout`或者`Ctrl+d`快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。\n\n## 1.1.4 Linux命令行提示符介绍\n  \n  Linux命令提示符分为两种，分别是:\n\n  - `$`普通用户\n  - `#`超级管理员(root)\n\n  例子:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$:_\n  [root@EvanLinux ~]#:_\n  ~~~\n\n  其中@前面的为当前登录的`用户名(username)`,@后面的为`主机名(hostname)`，主机名后面的`~`为路径，代表了`home目录`，而`$`或`#`分别代表了用户的是超级管理员还是普通用户。\n\n  > 超级管理员从此以后本系列都以`root`代表。\n\n  root与普通用户的区别：\n\n  - root\n\n    > 拥有管理整个系统的权限。\n  \n  - 普通用户\n\n    > 权限较少，通常只有查看系统文件的权限，以及管理自身`home`目录下所有文件的权限。\n\n  查看当前登录的用户名:使用`whoami`查询\n  查看主机名:使用`hostname`查询\n\n  额外技巧: Linux命令提示符由`PS1`环境变量控制，通过修改`PS1`环境变量，可以让提示符发生变化，例子如下:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ set|grep PS1\n  PS1='[\\u@\\h \\W]\\$'\n  ~~~\n  \n  `PS1`有特殊的变量可供选择，我们可以设置全局配置文件`/etc/bashrc`或/etc/profile`进行按需配置。\n\n## 1.1.5 Linux命令行常用快捷键\n\n  企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: `SecureCRT`和`XShell`,以下快捷键可在此两款软件中使用。\n\n  记住常用的快捷键有利于提高效率，常用快捷键由`!`标注\n\n  |快捷键|功能说明(`!`为常用)|\n  |------------------------|--------------------------------------------|\n  | 最有用的快捷键         |                                            |\n  | tab                    | 命令或路径的补全键，Linux最有用的快捷键`!` |\n  | 移动光标快捷键         |                                            |\n  | Ctrl+a                 | 移动光标至行首`!`                          |\n  | Ctrl+e                 | 移动光标至行尾`!`                          |\n  | Ctrl+f                 | 光标向右移动一个字符(等价与方向键右键)     |\n  | Ctrl+b                 | 光标向左移动一个字符(同上)                 |\n  | 剪切、粘贴、清楚快捷键 |                                            |\n  | Ctrl+Insert            | 复制命令行内容`!`                          |\n  | Shift+Insert           | 粘贴命令行内容`!`                          |\n  | Ctrl+k                 | 剪切(删除)光标处至行尾的字符`!`            |\n  | Ctrl+u                 | 剪切(删除)光标处至行首的字符`!`            |\n  | Ctrl+w                 | 剪切(删除)光标前一个单词`!`                |\n  | Ctrl+y                 | 粘贴上面三个剪切(删除)的字符               |\n  | Ctrl+c                 | 终止终端正在执行的任务或删除整行字符`!`    |\n  | Ctrl+h                 | 删除光标前一个字符(等同于Backspace)`!`     |\n  | 重复执行命令快捷键     |                                            |\n  | Ctrl+d                 | 退出当前Shell命令行`!`                     |\n  | Ctrl+r                 | 搜索命令历史记录`!`                        |\n  | Ctrl+g                 | 退出搜索命令历史记录                       |\n  | 控制快捷键             |\n  | Ctrl+l                 | 清屏(等同于clear命令)`!`                   |\n  | Ctrl+s                 | 锁定终端，使之无法输入                     |\n  | Ctrl+q                 | 解锁锁定终端                               |\n  | Ctrl+z                 | 暂停执行终端运行中的任务`!`                |\n  | \\!开头的快捷键命令     |\n  | !!                     | 执行上一条命令                             |\n  | !pw                    | 执行最近一次以pw开头的命令`!`              |\n  | !pw:p                  | 打印输出最近以pwd开头的命令，不执行        |\n  | !num                   | 执行历史命令列表的第num(数字)条命令`!`     |\n  | !$                     | 上一条命令的最后一个参数，等同于`Esc+.`    |\n  | ESC相关                |\n  | Esc+.                  | 获取上一条命令的最后部分`!`                |\n  | Esc+b                  | 移动到当前单词的开头                       |\n  | Esc+f                  | 移动到当前单词的结尾                       |\n\n# 1.2 在Linux命令行下查看命令帮助\n\n  man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。\n\n  由于篇幅较大，请点击链接单独查看本章附录man命令。\n\n  [点击访问](/2019/06/15/Linux-Linux命令行简介-man命令/)\n\n# 1.3 Linux关机、重启、注销命令\n\n  关机或重启命令:`shutdown`\n\n  |参数选项|说明|\n  |----|-------------------------------|\n  | -r | 重启机器                      |\n  | -P | 关闭机器电源(默认)            |\n  | -H | 暂停机器，CPU停止工作但不断电 |\n  | -h | 等效-P，除非使用了-H          |\n  | -k | 只发送关机提示,不做任何操作   |\n  | -c | 取消关机                      |\n\n  例子:\n\n  ~~~\n  # 立即关机\n  [evanmeek@EvanLinux ~]$ shutdown -h now\n  # 立即重启 \n  [evanmeek@EvanLinux ~]$ shutdonw -r now\n  # 5分钟后关机\n  [evanmeek@EvanLinux ~]$ shutdown -h +5\n  # 1分钟后重启\n  [evanmeek@EvanLinux ~]$ shutdown -r +1\n  ~~~\n\n  重启或关机命令:`halt`/`poweroff`/`reboot`\n\n  `halt`和`poweroff`都是`reboot`的链接而已。\n\n  `reboot`和`shutdown`都是`systemctl`的链接\n\n__本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!__\n\n\n","source":"_posts/Linux-Linux命令行简介-0.md","raw":"---\ntitle: Linux-Linux命令行简介-0\ncopyright: true\ndate: 2019-06-15 16:35:38\ncategories: Linux系列\ntags:\n - Linux\n---\n\n# 1.1 Linux命令行概述\n\n## 1.1.1 Linux命令行的作用与意义\n\n  Linux命令行相比图形界面操作的优点:\n\n  - 快速\n\n  - 批量\n\n  - 自动化\n\n  - 智能化管理\n\n## 1.1.2 Linux命令行介绍\n\n  大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图:\n\n  ![命令行图](Linux-Linux命令行简介-0/1.1.2-0)\n\n## 1.1.3 Linux命令行的开启及退出\n\n  主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。\n\n  ~~~Shell\n  user login:_\n  password:_\n  ~~~\n\n  等待你输入用户名密码，密码输入时是不会显示的。\n\n  使用`exit`,`logout`或者`Ctrl+d`快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。\n\n## 1.1.4 Linux命令行提示符介绍\n  \n  Linux命令提示符分为两种，分别是:\n\n  - `$`普通用户\n  - `#`超级管理员(root)\n\n  例子:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$:_\n  [root@EvanLinux ~]#:_\n  ~~~\n\n  其中@前面的为当前登录的`用户名(username)`,@后面的为`主机名(hostname)`，主机名后面的`~`为路径，代表了`home目录`，而`$`或`#`分别代表了用户的是超级管理员还是普通用户。\n\n  > 超级管理员从此以后本系列都以`root`代表。\n\n  root与普通用户的区别：\n\n  - root\n\n    > 拥有管理整个系统的权限。\n  \n  - 普通用户\n\n    > 权限较少，通常只有查看系统文件的权限，以及管理自身`home`目录下所有文件的权限。\n\n  查看当前登录的用户名:使用`whoami`查询\n  查看主机名:使用`hostname`查询\n\n  额外技巧: Linux命令提示符由`PS1`环境变量控制，通过修改`PS1`环境变量，可以让提示符发生变化，例子如下:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ set|grep PS1\n  PS1='[\\u@\\h \\W]\\$'\n  ~~~\n  \n  `PS1`有特殊的变量可供选择，我们可以设置全局配置文件`/etc/bashrc`或/etc/profile`进行按需配置。\n\n## 1.1.5 Linux命令行常用快捷键\n\n  企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: `SecureCRT`和`XShell`,以下快捷键可在此两款软件中使用。\n\n  记住常用的快捷键有利于提高效率，常用快捷键由`!`标注\n\n  |快捷键|功能说明(`!`为常用)|\n  |------------------------|--------------------------------------------|\n  | 最有用的快捷键         |                                            |\n  | tab                    | 命令或路径的补全键，Linux最有用的快捷键`!` |\n  | 移动光标快捷键         |                                            |\n  | Ctrl+a                 | 移动光标至行首`!`                          |\n  | Ctrl+e                 | 移动光标至行尾`!`                          |\n  | Ctrl+f                 | 光标向右移动一个字符(等价与方向键右键)     |\n  | Ctrl+b                 | 光标向左移动一个字符(同上)                 |\n  | 剪切、粘贴、清楚快捷键 |                                            |\n  | Ctrl+Insert            | 复制命令行内容`!`                          |\n  | Shift+Insert           | 粘贴命令行内容`!`                          |\n  | Ctrl+k                 | 剪切(删除)光标处至行尾的字符`!`            |\n  | Ctrl+u                 | 剪切(删除)光标处至行首的字符`!`            |\n  | Ctrl+w                 | 剪切(删除)光标前一个单词`!`                |\n  | Ctrl+y                 | 粘贴上面三个剪切(删除)的字符               |\n  | Ctrl+c                 | 终止终端正在执行的任务或删除整行字符`!`    |\n  | Ctrl+h                 | 删除光标前一个字符(等同于Backspace)`!`     |\n  | 重复执行命令快捷键     |                                            |\n  | Ctrl+d                 | 退出当前Shell命令行`!`                     |\n  | Ctrl+r                 | 搜索命令历史记录`!`                        |\n  | Ctrl+g                 | 退出搜索命令历史记录                       |\n  | 控制快捷键             |\n  | Ctrl+l                 | 清屏(等同于clear命令)`!`                   |\n  | Ctrl+s                 | 锁定终端，使之无法输入                     |\n  | Ctrl+q                 | 解锁锁定终端                               |\n  | Ctrl+z                 | 暂停执行终端运行中的任务`!`                |\n  | \\!开头的快捷键命令     |\n  | !!                     | 执行上一条命令                             |\n  | !pw                    | 执行最近一次以pw开头的命令`!`              |\n  | !pw:p                  | 打印输出最近以pwd开头的命令，不执行        |\n  | !num                   | 执行历史命令列表的第num(数字)条命令`!`     |\n  | !$                     | 上一条命令的最后一个参数，等同于`Esc+.`    |\n  | ESC相关                |\n  | Esc+.                  | 获取上一条命令的最后部分`!`                |\n  | Esc+b                  | 移动到当前单词的开头                       |\n  | Esc+f                  | 移动到当前单词的结尾                       |\n\n# 1.2 在Linux命令行下查看命令帮助\n\n  man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。\n\n  由于篇幅较大，请点击链接单独查看本章附录man命令。\n\n  [点击访问](/2019/06/15/Linux-Linux命令行简介-man命令/)\n\n# 1.3 Linux关机、重启、注销命令\n\n  关机或重启命令:`shutdown`\n\n  |参数选项|说明|\n  |----|-------------------------------|\n  | -r | 重启机器                      |\n  | -P | 关闭机器电源(默认)            |\n  | -H | 暂停机器，CPU停止工作但不断电 |\n  | -h | 等效-P，除非使用了-H          |\n  | -k | 只发送关机提示,不做任何操作   |\n  | -c | 取消关机                      |\n\n  例子:\n\n  ~~~\n  # 立即关机\n  [evanmeek@EvanLinux ~]$ shutdown -h now\n  # 立即重启 \n  [evanmeek@EvanLinux ~]$ shutdonw -r now\n  # 5分钟后关机\n  [evanmeek@EvanLinux ~]$ shutdown -h +5\n  # 1分钟后重启\n  [evanmeek@EvanLinux ~]$ shutdown -r +1\n  ~~~\n\n  重启或关机命令:`halt`/`poweroff`/`reboot`\n\n  `halt`和`poweroff`都是`reboot`的链接而已。\n\n  `reboot`和`shutdown`都是`systemctl`的链接\n\n__本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!__\n\n\n","slug":"Linux-Linux命令行简介-0","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc30028omoog9r7lgl2","content":"<h1 id=\"1-1-Linux命令行概述\"><a href=\"#1-1-Linux命令行概述\" class=\"headerlink\" title=\"1.1 Linux命令行概述\"></a>1.1 Linux命令行概述</h1><h2 id=\"1-1-1-Linux命令行的作用与意义\"><a href=\"#1-1-1-Linux命令行的作用与意义\" class=\"headerlink\" title=\"1.1.1 Linux命令行的作用与意义\"></a>1.1.1 Linux命令行的作用与意义</h2><p>  Linux命令行相比图形界面操作的优点:</p>\n<ul>\n<li><p>快速</p>\n</li>\n<li><p>批量</p>\n</li>\n<li><p>自动化</p>\n</li>\n<li><p>智能化管理</p>\n</li>\n</ul>\n<h2 id=\"1-1-2-Linux命令行介绍\"><a href=\"#1-1-2-Linux命令行介绍\" class=\"headerlink\" title=\"1.1.2 Linux命令行介绍\"></a>1.1.2 Linux命令行介绍</h2><p>  大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图:</p>\n<p>  <img src=\"/2019/06/15/Linux-Linux命令行简介-0/1.1.2-0\" alt=\"命令行图\"></p>\n<h2 id=\"1-1-3-Linux命令行的开启及退出\"><a href=\"#1-1-3-Linux命令行的开启及退出\" class=\"headerlink\" title=\"1.1.3 Linux命令行的开启及退出\"></a>1.1.3 Linux命令行的开启及退出</h2><p>  主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user login:_</span><br><span class=\"line\">password:_</span><br></pre></td></tr></table></figure>\n<p>  等待你输入用户名密码，密码输入时是不会显示的。</p>\n<p>  使用<code>exit</code>,<code>logout</code>或者<code>Ctrl+d</code>快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。</p>\n<h2 id=\"1-1-4-Linux命令行提示符介绍\"><a href=\"#1-1-4-Linux命令行提示符介绍\" class=\"headerlink\" title=\"1.1.4 Linux命令行提示符介绍\"></a>1.1.4 Linux命令行提示符介绍</h2><p>  Linux命令提示符分为两种，分别是:</p>\n<ul>\n<li><code>$</code>普通用户</li>\n<li><p><code>#</code>超级管理员(root)</p>\n<p>例子:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$:_</span><br><span class=\"line\">[root@EvanLinux ~]#:_</span><br></pre></td></tr></table></figure>\n<p>其中@前面的为当前登录的<code>用户名(username)</code>,@后面的为<code>主机名(hostname)</code>，主机名后面的<code>~</code>为路径，代表了<code>home目录</code>，而<code>$</code>或<code>#</code>分别代表了用户的是超级管理员还是普通用户。</p>\n<blockquote>\n<p>超级管理员从此以后本系列都以<code>root</code>代表。</p>\n</blockquote>\n<p>root与普通用户的区别：</p>\n</li>\n<li><p>root</p>\n<blockquote>\n<p>拥有管理整个系统的权限。</p>\n</blockquote>\n</li>\n<li><p>普通用户</p>\n<blockquote>\n<p>权限较少，通常只有查看系统文件的权限，以及管理自身<code>home</code>目录下所有文件的权限。</p>\n</blockquote>\n<p>查看当前登录的用户名:使用<code>whoami</code>查询<br>查看主机名:使用<code>hostname</code>查询</p>\n<p>额外技巧: Linux命令提示符由<code>PS1</code>环境变量控制，通过修改<code>PS1</code>环境变量，可以让提示符发生变化，例子如下:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ set|grep PS1</span><br><span class=\"line\">PS1='[\\u@\\h \\W]\\$'</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  <code>PS1</code>有特殊的变量可供选择，我们可以设置全局配置文件<code>/etc/bashrc</code>或/etc/profile`进行按需配置。</p>\n<h2 id=\"1-1-5-Linux命令行常用快捷键\"><a href=\"#1-1-5-Linux命令行常用快捷键\" class=\"headerlink\" title=\"1.1.5 Linux命令行常用快捷键\"></a>1.1.5 Linux命令行常用快捷键</h2><p>  企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: <code>SecureCRT</code>和<code>XShell</code>,以下快捷键可在此两款软件中使用。</p>\n<p>  记住常用的快捷键有利于提高效率，常用快捷键由<code>!</code>标注</p>\n<table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能说明(<code>!</code>为常用)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最有用的快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>tab</td>\n<td>命令或路径的补全键，Linux最有用的快捷键<code>!</code></td>\n</tr>\n<tr>\n<td>移动光标快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+a</td>\n<td>移动光标至行首<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+e</td>\n<td>移动光标至行尾<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+f</td>\n<td>光标向右移动一个字符(等价与方向键右键)</td>\n</tr>\n<tr>\n<td>Ctrl+b</td>\n<td>光标向左移动一个字符(同上)</td>\n</tr>\n<tr>\n<td>剪切、粘贴、清楚快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+Insert</td>\n<td>复制命令行内容<code>!</code></td>\n</tr>\n<tr>\n<td>Shift+Insert</td>\n<td>粘贴命令行内容<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+k</td>\n<td>剪切(删除)光标处至行尾的字符<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+u</td>\n<td>剪切(删除)光标处至行首的字符<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+w</td>\n<td>剪切(删除)光标前一个单词<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+y</td>\n<td>粘贴上面三个剪切(删除)的字符</td>\n</tr>\n<tr>\n<td>Ctrl+c</td>\n<td>终止终端正在执行的任务或删除整行字符<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+h</td>\n<td>删除光标前一个字符(等同于Backspace)<code>!</code></td>\n</tr>\n<tr>\n<td>重复执行命令快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+d</td>\n<td>退出当前Shell命令行<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+r</td>\n<td>搜索命令历史记录<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+g</td>\n<td>退出搜索命令历史记录</td>\n</tr>\n<tr>\n<td>控制快捷键</td>\n</tr>\n<tr>\n<td>Ctrl+l</td>\n<td>清屏(等同于clear命令)<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+s</td>\n<td>锁定终端，使之无法输入</td>\n</tr>\n<tr>\n<td>Ctrl+q</td>\n<td>解锁锁定终端</td>\n</tr>\n<tr>\n<td>Ctrl+z</td>\n<td>暂停执行终端运行中的任务<code>!</code></td>\n</tr>\n<tr>\n<td>!开头的快捷键命令</td>\n</tr>\n<tr>\n<td>!!</td>\n<td>执行上一条命令</td>\n</tr>\n<tr>\n<td>!pw</td>\n<td>执行最近一次以pw开头的命令<code>!</code></td>\n</tr>\n<tr>\n<td>!pw:p</td>\n<td>打印输出最近以pwd开头的命令，不执行</td>\n</tr>\n<tr>\n<td>!num</td>\n<td>执行历史命令列表的第num(数字)条命令<code>!</code></td>\n</tr>\n<tr>\n<td>!$</td>\n<td>上一条命令的最后一个参数，等同于<code>Esc+.</code></td>\n</tr>\n<tr>\n<td>ESC相关</td>\n</tr>\n<tr>\n<td>Esc+.</td>\n<td>获取上一条命令的最后部分<code>!</code></td>\n</tr>\n<tr>\n<td>Esc+b</td>\n<td>移动到当前单词的开头</td>\n</tr>\n<tr>\n<td>Esc+f</td>\n<td>移动到当前单词的结尾</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"1-2-在Linux命令行下查看命令帮助\"><a href=\"#1-2-在Linux命令行下查看命令帮助\" class=\"headerlink\" title=\"1.2 在Linux命令行下查看命令帮助\"></a>1.2 在Linux命令行下查看命令帮助</h1><p>  man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。</p>\n<p>  由于篇幅较大，请点击链接单独查看本章附录man命令。</p>\n<p>  <a href=\"/2019/06/15/Linux-Linux命令行简介-man命令/\">点击访问</a></p>\n<h1 id=\"1-3-Linux关机、重启、注销命令\"><a href=\"#1-3-Linux关机、重启、注销命令\" class=\"headerlink\" title=\"1.3 Linux关机、重启、注销命令\"></a>1.3 Linux关机、重启、注销命令</h1><p>  关机或重启命令:<code>shutdown</code></p>\n<table>\n<thead>\n<tr>\n<th>参数选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>重启机器</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>关闭机器电源(默认)</td>\n</tr>\n<tr>\n<td>-H</td>\n<td>暂停机器，CPU停止工作但不断电</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>等效-P，除非使用了-H</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>只发送关机提示,不做任何操作</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>取消关机</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 立即关机</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdown -h now</span><br><span class=\"line\"># 立即重启 </span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdonw -r now</span><br><span class=\"line\"># 5分钟后关机</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdown -h +5</span><br><span class=\"line\"># 1分钟后重启</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdown -r +1</span><br></pre></td></tr></table></figure>\n<p>  重启或关机命令:<code>halt</code>/<code>poweroff</code>/<code>reboot</code></p>\n<p>  <code>halt</code>和<code>poweroff</code>都是<code>reboot</code>的链接而已。</p>\n<p>  <code>reboot</code>和<code>shutdown</code>都是<code>systemctl</code>的链接</p>\n<p><strong>本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-1-Linux命令行概述\"><a href=\"#1-1-Linux命令行概述\" class=\"headerlink\" title=\"1.1 Linux命令行概述\"></a>1.1 Linux命令行概述</h1><h2 id=\"1-1-1-Linux命令行的作用与意义\"><a href=\"#1-1-1-Linux命令行的作用与意义\" class=\"headerlink\" title=\"1.1.1 Linux命令行的作用与意义\"></a>1.1.1 Linux命令行的作用与意义</h2><p>  Linux命令行相比图形界面操作的优点:</p>\n<ul>\n<li><p>快速</p>\n</li>\n<li><p>批量</p>\n</li>\n<li><p>自动化</p>\n</li>\n<li><p>智能化管理</p>\n</li>\n</ul>\n<h2 id=\"1-1-2-Linux命令行介绍\"><a href=\"#1-1-2-Linux命令行介绍\" class=\"headerlink\" title=\"1.1.2 Linux命令行介绍\"></a>1.1.2 Linux命令行介绍</h2><p>  大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图:</p>\n<p>  <img src=\"/2019/06/15/Linux-Linux命令行简介-0/1.1.2-0\" alt=\"命令行图\"></p>\n<h2 id=\"1-1-3-Linux命令行的开启及退出\"><a href=\"#1-1-3-Linux命令行的开启及退出\" class=\"headerlink\" title=\"1.1.3 Linux命令行的开启及退出\"></a>1.1.3 Linux命令行的开启及退出</h2><p>  主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user login:_</span><br><span class=\"line\">password:_</span><br></pre></td></tr></table></figure>\n<p>  等待你输入用户名密码，密码输入时是不会显示的。</p>\n<p>  使用<code>exit</code>,<code>logout</code>或者<code>Ctrl+d</code>快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。</p>\n<h2 id=\"1-1-4-Linux命令行提示符介绍\"><a href=\"#1-1-4-Linux命令行提示符介绍\" class=\"headerlink\" title=\"1.1.4 Linux命令行提示符介绍\"></a>1.1.4 Linux命令行提示符介绍</h2><p>  Linux命令提示符分为两种，分别是:</p>\n<ul>\n<li><code>$</code>普通用户</li>\n<li><p><code>#</code>超级管理员(root)</p>\n<p>例子:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$:_</span><br><span class=\"line\">[root@EvanLinux ~]#:_</span><br></pre></td></tr></table></figure>\n<p>其中@前面的为当前登录的<code>用户名(username)</code>,@后面的为<code>主机名(hostname)</code>，主机名后面的<code>~</code>为路径，代表了<code>home目录</code>，而<code>$</code>或<code>#</code>分别代表了用户的是超级管理员还是普通用户。</p>\n<blockquote>\n<p>超级管理员从此以后本系列都以<code>root</code>代表。</p>\n</blockquote>\n<p>root与普通用户的区别：</p>\n</li>\n<li><p>root</p>\n<blockquote>\n<p>拥有管理整个系统的权限。</p>\n</blockquote>\n</li>\n<li><p>普通用户</p>\n<blockquote>\n<p>权限较少，通常只有查看系统文件的权限，以及管理自身<code>home</code>目录下所有文件的权限。</p>\n</blockquote>\n<p>查看当前登录的用户名:使用<code>whoami</code>查询<br>查看主机名:使用<code>hostname</code>查询</p>\n<p>额外技巧: Linux命令提示符由<code>PS1</code>环境变量控制，通过修改<code>PS1</code>环境变量，可以让提示符发生变化，例子如下:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ set|grep PS1</span><br><span class=\"line\">PS1='[\\u@\\h \\W]\\$'</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  <code>PS1</code>有特殊的变量可供选择，我们可以设置全局配置文件<code>/etc/bashrc</code>或/etc/profile`进行按需配置。</p>\n<h2 id=\"1-1-5-Linux命令行常用快捷键\"><a href=\"#1-1-5-Linux命令行常用快捷键\" class=\"headerlink\" title=\"1.1.5 Linux命令行常用快捷键\"></a>1.1.5 Linux命令行常用快捷键</h2><p>  企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: <code>SecureCRT</code>和<code>XShell</code>,以下快捷键可在此两款软件中使用。</p>\n<p>  记住常用的快捷键有利于提高效率，常用快捷键由<code>!</code>标注</p>\n<table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能说明(<code>!</code>为常用)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最有用的快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>tab</td>\n<td>命令或路径的补全键，Linux最有用的快捷键<code>!</code></td>\n</tr>\n<tr>\n<td>移动光标快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+a</td>\n<td>移动光标至行首<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+e</td>\n<td>移动光标至行尾<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+f</td>\n<td>光标向右移动一个字符(等价与方向键右键)</td>\n</tr>\n<tr>\n<td>Ctrl+b</td>\n<td>光标向左移动一个字符(同上)</td>\n</tr>\n<tr>\n<td>剪切、粘贴、清楚快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+Insert</td>\n<td>复制命令行内容<code>!</code></td>\n</tr>\n<tr>\n<td>Shift+Insert</td>\n<td>粘贴命令行内容<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+k</td>\n<td>剪切(删除)光标处至行尾的字符<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+u</td>\n<td>剪切(删除)光标处至行首的字符<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+w</td>\n<td>剪切(删除)光标前一个单词<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+y</td>\n<td>粘贴上面三个剪切(删除)的字符</td>\n</tr>\n<tr>\n<td>Ctrl+c</td>\n<td>终止终端正在执行的任务或删除整行字符<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+h</td>\n<td>删除光标前一个字符(等同于Backspace)<code>!</code></td>\n</tr>\n<tr>\n<td>重复执行命令快捷键</td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+d</td>\n<td>退出当前Shell命令行<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+r</td>\n<td>搜索命令历史记录<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+g</td>\n<td>退出搜索命令历史记录</td>\n</tr>\n<tr>\n<td>控制快捷键</td>\n</tr>\n<tr>\n<td>Ctrl+l</td>\n<td>清屏(等同于clear命令)<code>!</code></td>\n</tr>\n<tr>\n<td>Ctrl+s</td>\n<td>锁定终端，使之无法输入</td>\n</tr>\n<tr>\n<td>Ctrl+q</td>\n<td>解锁锁定终端</td>\n</tr>\n<tr>\n<td>Ctrl+z</td>\n<td>暂停执行终端运行中的任务<code>!</code></td>\n</tr>\n<tr>\n<td>!开头的快捷键命令</td>\n</tr>\n<tr>\n<td>!!</td>\n<td>执行上一条命令</td>\n</tr>\n<tr>\n<td>!pw</td>\n<td>执行最近一次以pw开头的命令<code>!</code></td>\n</tr>\n<tr>\n<td>!pw:p</td>\n<td>打印输出最近以pwd开头的命令，不执行</td>\n</tr>\n<tr>\n<td>!num</td>\n<td>执行历史命令列表的第num(数字)条命令<code>!</code></td>\n</tr>\n<tr>\n<td>!$</td>\n<td>上一条命令的最后一个参数，等同于<code>Esc+.</code></td>\n</tr>\n<tr>\n<td>ESC相关</td>\n</tr>\n<tr>\n<td>Esc+.</td>\n<td>获取上一条命令的最后部分<code>!</code></td>\n</tr>\n<tr>\n<td>Esc+b</td>\n<td>移动到当前单词的开头</td>\n</tr>\n<tr>\n<td>Esc+f</td>\n<td>移动到当前单词的结尾</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"1-2-在Linux命令行下查看命令帮助\"><a href=\"#1-2-在Linux命令行下查看命令帮助\" class=\"headerlink\" title=\"1.2 在Linux命令行下查看命令帮助\"></a>1.2 在Linux命令行下查看命令帮助</h1><p>  man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。</p>\n<p>  由于篇幅较大，请点击链接单独查看本章附录man命令。</p>\n<p>  <a href=\"/2019/06/15/Linux-Linux命令行简介-man命令/\">点击访问</a></p>\n<h1 id=\"1-3-Linux关机、重启、注销命令\"><a href=\"#1-3-Linux关机、重启、注销命令\" class=\"headerlink\" title=\"1.3 Linux关机、重启、注销命令\"></a>1.3 Linux关机、重启、注销命令</h1><p>  关机或重启命令:<code>shutdown</code></p>\n<table>\n<thead>\n<tr>\n<th>参数选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>重启机器</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>关闭机器电源(默认)</td>\n</tr>\n<tr>\n<td>-H</td>\n<td>暂停机器，CPU停止工作但不断电</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>等效-P，除非使用了-H</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>只发送关机提示,不做任何操作</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>取消关机</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 立即关机</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdown -h now</span><br><span class=\"line\"># 立即重启 </span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdonw -r now</span><br><span class=\"line\"># 5分钟后关机</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdown -h +5</span><br><span class=\"line\"># 1分钟后重启</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ shutdown -r +1</span><br></pre></td></tr></table></figure>\n<p>  重启或关机命令:<code>halt</code>/<code>poweroff</code>/<code>reboot</code></p>\n<p>  <code>halt</code>和<code>poweroff</code>都是<code>reboot</code>的链接而已。</p>\n<p>  <code>reboot</code>和<code>shutdown</code>都是<code>systemctl</code>的链接</p>\n<p><strong>本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!</strong></p>\n"},{"title":"Linux-文件和目录操作命令-1","copyright":true,"date":"2019-06-16T07:56:11.000Z","_content":"\n# 2.0 老男孩新手成为技术大牛心法\n\n执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。\n\n专注: 只做一件事。两耳不闻其他事，一心只读运维书。\n\n自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。\n\n心态: 保持空杯，重视基础；基础不牢，地动山摇。\n\n# 2.1 pwd命令\n\n  `print working diretory`\n\n  __查看当前路径使用`pwd`命令__\n\n  例子:\n\n  ~~~shell\n  [evanmeek@EvanLinux ~]$ pwd\n  ~~~\n\n  输出信息\n\n  ~~~Shell\n  /home/evanmeek\n  ~~~\n\n  |选项|说明|\n  |----|----------------------------------------------------|\n  | -L | 显示当前目录的逻辑路径(忽略软链接文件)             |\n  | -P | 显示当前目录的物理路径(若有软链接则显示源文件地址) |\n\n  所谓的软链接相当于快捷方式，例如`~/test.txt`是`/test.txt`的软链接，那么我们操作`~/test.txt`等同于操作`/test.txt`，详细的软链接将会在后面的`ln`命令讲解。\n\n# 2.2 cd 切换目录\n\n  `change directory`\n\n  __进入某个目录使用`cd`命令__\n\n  例子:\n\n  ~~~shell\n  [evanmeek@EvanLinux ~]$ pwd\n  [evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/\n  [evanmeek@EvanLinux /etc/sysctl.d/]$ pwd\n  ~~~\n\n  输出信息\n\n  ~~~\n  /home/evanmeek/\n  /etc/sysctl.d/\n  ~~~\n  \n  | 选项 | 说明                                                      |\n  |------|-----------------------------------------------------------|\n  | -P   | 进入目录的物理路径                                        |\n  | -L   | 进入目录的逻辑路径                                        |\n  | -    | 进入上次的目录                                            |\n  | ~    | 进入系统环境变量的`HOME`目录路径，即当前登录用户的家目录` |\n  | \\.\\. | 进入父目录                                                |\n\n  `cd` 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录.\n\n  例子:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ cd Desktop\n  [evanmeek@EvanLinux ~/Desktop]$ pwd\n  [evanmeek@EvanLinux ~]$ cd -\n  [evanmeek@EvanLinux ~]$ pwd\n  [evanmeek@EvanLinux ~]$ cd /etc/systemd/\n  [evanmeek@EvanLinux /etc/systemd/]$ pwd\n  [evanmeek@EvanLinux /etc/systemd/]$ cd ..\n  [evanmeek@EvanLinux /etc/]$ pwd\n  ~~~\n\n  输出信息\n\n  ~~~shell\n  ~/Desktop/\n  ~\n  /etc/systemd/\n  /etc/\n  ~~~\n\n# 2.3 tree以树形结构显示目录下的内容\n\n  __树形结构可以很清晰的显示出目录的父子级关系__\n\n  例子:\n\n  ~~~\n  [evanmeek@EvanLinux ~/test]$ tree -L 1\n  ~~~\n\n  输出信息\n\n  ~~~\n  .\n  ├── dir1\n  │   ├── dir1_1\n  │   └── dir2_2\n  └── dir2\n      ├── dir1_1\n      └── dir2_2\n\n  6 directories, 0 files\n  ~~~\n\n  |选项|说明|\n  |-------------|----------------------------------------------------|\n  | -a          | 显示所有文件包括隐藏文件                           |\n  | -d          | 只显示目录`!`                                      |\n  | -f          | 显示每个文件的绝对路径                             |\n  | -i          | 不显示树枝                                         |\n  | -L levelNum | 显示遍历目录的层级，levelNum为层级(数字)           |\n  | -F          | 显示时根据不同文件类型在文件名结尾处显示不同的符号 |\n\n  例子:\n\n  显示隐藏文件\n  ~~~\n  #假设此目录下有隐藏文件\n  [evanmeek@EvanLinux ~/tmp]$ tree -a\n  ~~~\n\n  输出信息\n\n  ~~~\n  .\n  ├── dir1\n  │   ├── dir1_1\n  │   └── dir2_2\n  ├── dir2\n  │   ├── dir1_1\n  │   └── dir2_2\n  ├── .file1\n  └── .file2\n\n  6 directories, 2 files\n  ~~~\n\n  例子:\n\n  显示1级层文件完整路径，并不显示树枝\n  ~~~\n  [evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi .\n  ~~~\n\n  输出信息\n\n  ~~~\n  .\n  ./dir1\n  ./dir2\n  ~~~\n\n# 2.4 mkdir创建目录\n\n  `make directory`\n\n  __创建目录使用`mkdir`命令__\n\n  |选项|说明|\n  |----|------------------------------------|\n  | -p | 递归创建目录，若目录已存在不会报错 |\n  | -m | 创建时指定目录的权限               |\n  | -v | 创建时显示过程信息                 |\n\n  例子:\n\n  创建目录时显示信息\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -v testDir\n  [evanmeek@EvanLinux ~]$ cd testDir\n  [evanmeek@EvanLinux ~/testDir]$ pwd\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'testDir'\n  ~~~\n\n  递归创建目录并且显示信息\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -pv father/son/test\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'father'\n  mkdir: 已创建目录 'father/son'\n  mkdir: 已创建目录 'father/son/test'\n  ~~~\n\n  创建目录并且指定目录权限\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir\n  [evanmeek@EvanLinux ~]$ ls -ld testDir\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'testDir'\n  d-wx-wx-wx 2 evanmeek evanmeek 4096  6月 17 20:15 testDir\n  ~~~\n\n  利用特殊符号“{}”同时创建多目录及多子目录\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -pv father/{son1/{a1,a2},son2/{b1,b2},son3/{c1,c2}}\n  [evanmeek@EvanLinux ~]$ tree father\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'father'\n  mkdir: 已创建目录 'father/son1'\n  mkdir: 已创建目录 'father/son1/a1'\n  mkdir: 已创建目录 'father/son1/a2'\n  mkdir: 已创建目录 'father/son2'\n  mkdir: 已创建目录 'father/son2/b1'\n  mkdir: 已创建目录 'father/son2/b2'\n  mkdir: 已创建目录 'father/son3'\n  mkdir: 已创建目录 'father/son3/c1'\n  mkdir: 已创建目录 'father/son3/c2'\n\n  father\n  ├── son1\n  │   ├── a1\n  │   └── a2\n  ├── son2\n  │   ├── b1\n  │   └── b2\n  └── son3\n      ├── c1\n      └── c2\n\n  9 directories, 0 files\n  ~~~\n\n# 2.5 touch创建空文件或改变文件的时间戳属性\n\n  __创建新的空文件，改变文件的时间戳属性，需要用到touch__\n\n  |选项|说明|\n  |-----------|--------------------------------------------------|\n  | -a        | 更改指定文件的最新访问时间                       |\n  | -d STRING | 用字符串的方式指定一个模板作为指定文件的时间属性 |\n  | -m        | 更改指定文件的最新修改时间                       |\n  | -r file   | 将指定文件的时间属性设置为file的时间属性         |\n  | -t STAMP  | 使用时间格式设置文件的时间属性                   |\n\n  例子:\n\n  创建文件\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch test.txt\n  ~~~\n\n  同时创建多个文件\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch test1.txt test2.txt\n  ~~~\n\n  利用{}批量创建文件\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch t{01..05}.txt\n  ~~~\n\n  利用`stat`命令查看时间戳\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出信息\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2019-06-17 21:36:42.380004039 +0800\n  Modify: 2019-06-17 21:36:42.380004039 +0800\n  Change: 2019-06-17 21:36:42.380004039 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n  __时间戳属性说明:__\n\n  - Access 访问属性\n\n  - Modify 修改属性\n\n  - Birth 状态改变属性\n\n  利用-a选项修改文件最后访问属性\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch -a t01.txt\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出信息\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2019-06-17 21:44:27.210736590 +0800\n  Modify: 2019-06-17 21:36:42.380004039 +0800\n  Change: 2019-06-17 21:44:27.210736590 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n  修改文件的修改时间\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出信息\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2001-01-01 00:00:00.000000000 +0800\n  Modify: 2001-01-01 00:00:00.000000000 +0800\n  Change: 2019-06-17 21:48:26.700992172 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n  修改指定文件为某文件的时间属性\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ stat t02.txt\n  [evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出结果\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2019-06-17 21:36:42.380004039 +0800\n  Modify: 2019-06-17 21:36:42.380004039 +0800\n  Change: 2019-06-17 21:51:35.907031392 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n# 2.6 ls显示目录下的内容及相关属性信息\n  `list directory contents`\n\n  例子:\n\n  查看当前目录下的文件信息\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ls\n  ~~~\n\n  输出结果\n\n  ~~~\n  Applications  Desktop  Downloads  GameDir  index.html  Music  Pictures  temp  WorkDir\n  ~~~\n\n  每个人的目录里面的内容不同，所以可能不一样。\n\n  | 选项                                        | 说明                                                                           |\n  |---------------------------------------------|--------------------------------------------------------------------------------|\n  | -l                                          | 使用长格式列出目录下的文件和信息                                               |\n  | -a                                          | 显示目录下的所有文件，包括隐藏文件`!`                                          |\n  | -t                                          | 根据最新的修改时间排序，不加此参数默认是根据文件名排序`!`                      |\n  | -r                                          | 反向排序                                                                       |\n  | -F                                          | 在显示的条目后加上特殊符号用以区别文件类型`!`                                  |\n  | -p                                          | 目录后面加上“/”                                                                |\n  | -i                                          | 显示inode节点信息                                                              |\n  | -d                                          | 遇到目录时，只列出目录本身，并且不跟随符号链接`!`                              |\n  | -h                                          | 以人类可读的信息显示文件或目录大小                                             |\n  | -A                                          | 列出所有文件，包括隐藏文件夹，但不包括.和..                                    |\n  | -S                                          | 根据文件大小排序                                                               |\n  | -R                                          | 递归列出所有子目录                                                             |\n  | -x                                          | 逐行列出项目而不是逐栏列出                                                     |\n  | -X                                          | 根据扩展名排序                                                                 |\n  | -c                                          | 根据状态改变时间排序                                                           |\n  | -u                                          | 根据最后访问时间排序                                                           |\n  | --color={never,always,auto}                 | 根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示     |\n  | --full-time                                 | 以完整的时间格式进行显示                                                       |\n  | --time-style={full-iso,long-iso,iso,locale} | 以不同的时间格式输出，long-iso最常用                                           |\n  | --time={atime,ctimeA}                       | 按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间 |\n\n  例子:\n\n  环境准备\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir temp\n  [evanmeek@EvanLinux ~]$ cd temp\n  [evanmeek@EvanLinux ~]$ mkdir -p father/dir{01..02}\n  [evanmeek@EvanLinux ~]$ touch father/dir{01..02}/txt{01..02}\n  [evanmeek@EvanLinux ~]$ touch father/dir{01..02}/.txt{01..02}\n  [evanmeek@EvanLinux ~]$ tree -a\n  ~~~\n\n  输出结果\n\n  ~~~\n  .\n  └── father\n      ├── dir01\n      │   ├── .txt01\n      │   ├── txt01\n      │   ├── .txt02\n      │   └── txt02\n      └── dir02\n          ├── .txt01\n          ├── txt01\n          ├── .txt02\n          └── txt02\n\n3 directories, 8 files\n  ~~~\n\n  递归显示所有文件\n\n  ~~~\n  [evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra\n  ~~~\n\n  输出信息\n  \n  ~~~\n  .:\n  .  ..  father\n\n  ./father:\n  .  ..  dir01  dir02\n\n  ./father/dir01:\n  .  ..  .txt01  txt01  .txt02  txt02\n\n  ./father/dir02:\n  .  ..  .txt01  txt01  .txt02  txt02\n  ~~~\n  \n __ls命令输出属性解释__\n\n  目录内容如下：\n\n  ~~~\n  .\n  ├── dir01\n  ├── dir02\n  ├── file01.txt\n  └── file02.txt\n\n  2 directories, 2 files\n  ~~~\n\n  长格式列出人类可读信息并显示inode信息\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ls -lhi\n  ~~~\n\n  输出信息\n\n  ~~~\n  total 8.0K\n  18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir01\n  18219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir02\n  18219054 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file01.txt\n  18219055 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file02.txt\n  ~~~\n\n  从第一列依次往后排，分别含义为:\n\n  1. inode索引节点编号\n  2. 文件类型以及属性(第一字符标注类型，后9个代表权限)\n  3. 硬链接个数\n  4. 文件或目录所属用户\n  5. 文件或目录所属的组\n  6. 文件或目录的大小\n  7. 修改时间\n  10. 文件名或目录名\n\n# 2.7 cp复制文件或目录\n  \n  `copy`\n\n  | 选项 | 说明                                                                                       |\n  |------|--------------------------------------------------------------------------------------------|\n  | -p   | 复制文件时保存源文件的所有者、权限信息及时间属性                                           |\n  | -d   | 如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录 |\n  | -r   | 递归复制目录，即目录下所有的子目录及文件                                                   |\n  | -a   | 等同于上面的p、d、r这3个选项功能的总和                                                     |\n  | -i   | 覆盖已有文件前提示用户确认                                                                 |\n  | -t   | 调换命令格式，默认格式是\"cp 源文件 目标文件\"，将目标文件和源文件进行位置调换               |\n  \n  例子:\n\n  环境准备\n\n  ~~~\n  .\n  └── fatherDir\n      ├── sonDir1\n      │   └── test.txt\n      ├── sonDir2\n      │   └── test.txt\n      └── sonDir3\n          └── test.txt\n\n  4 directories, 3 files\n  ~~~\n\n  拷贝`fatherDir`为`father2Dir`并保留源文件的所有者，权限信息及时间属性\n  \n  ~~~\n  [evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir\n  ~~~\n  \n  再次拷贝`fatherDir`为`father2Dir`从而覆盖上个例子的`father2Dir`\n  \n  ~~~\n  [evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir\n  ~~~\n  \n  输出信息\n\n  ~~~\n  cp：是否覆盖'father2Dir/fatherDir/sonDir1/test.txt'？ y\n  cp：是否覆盖'father2Dir/fatherDir/sonDir2/test.txt'？ y\n  cp：是否覆盖'father2Dir/fatherDir/sonDir3/test.txt'？ y\n  ~~~\n\n# 2.8 mv移动或重命名文件\n  \n  `move`\n  | 选项 | 说明                                                       |\n  |------|------------------------------------------------------------|\n  | -f   | 若目标文件已存在，不询问直接覆盖                           |\n  | -i   | 若目标文件已存在，询问是否覆盖                             |\n  | -n   | 不覆盖已存在的文件                                         |\n  | -t   | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 |\n  | -u   | 源文件比目标文件新，或目标文件不存在时再移动               |\n\n  例子:\n\n  环境准备\n\n  ~~~\n  总用量 4\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test0.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt\n  drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt\n  ~~~\n  \n  更换文件名\n\n  ~~~\n  [evanmeek@EvanMeek ~]$mv test0.txt test-1.txt\n  [evanmeek@EvanMeek ~]$ls -l --full-time\n  ~~~\n  \n  输出信息\n\n  ~~~\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test-1.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt\n  drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt\n  ~~~\n  \n  __移动文件__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mv test-1.txt testTxt\n  ~~~\n\n  __移动多个文件至一个目录__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt\n  ~~~\n  \n# 2.9 rm删除文件或目录\n\n  __前排提示:使用rm命令时最好知道自己在干什么!__\n\n  `remove`\n\n  | 选项 | 说明                                   |\n  |------|----------------------------------------|\n  | -f | 强制删除并且忽略不存在文件的提示       |\n  | -i | 删除时需要确认                         |\n  | -I | 删除三个以上文件或者递归删除前需要确认 |\n  | -r | 递归删除目录以及其内容`!`                |\n\n  例子:\n\n  __再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现)__\n\n  环境准备\n  ~~~\n  .\n  ├── test2Txt\n  │   ├── test1.txt\n  │   ├── test2.txt\n  │   └── testTxt\n  │       └── test-1.txt\n  └── test3.txt\n  ~~~\n\n  __删除文件__\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ rm test3.txt\n  ~~~\n\n  __强制删除并且删除时需要确认__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt\n  ~~~\n  \n  输出信息\n\n  ~~~\n  rm：是否删除普通空文件 'test2Txt/test2.txt'？\n  ~~~\n\n  __删除目录并且删除时需要确认__\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt\n  ~~~\n  \n  __强制删除+递归删除目录__\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ rm -rf test2Txt\n  ~~~\n\n  __最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入__\n\n  ~~~\n  sudo rm -rf /*\n  ~~~\n  \n  __这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内.__\n\n## 删除时的小技巧\n\n  - 使用`mv`命令代替`rm`命令，可以将要删除的文件暂时保存在`/tmp`目录下，需要清理空间时再去删除\n\n  - 删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原\n\n  - 若非要用删除命令清理空间可以选择用`find`代替`rm`\n\n  - 删除时尽量不要使用系统通配符\n\n# 2.10 rmdir删除空目录\n\n  `remove dirctory`\n\n  此命令只能删除空目录\n\n  | 选项 | 说明                                                                                                                  |\n  |------|-----------------------------------------------------------------------------------------------------------------------|\n  | -p   | 递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息 |\n  | -v   | 删除时显示执行过程                                                                                                    |\n\n# 2.11 ln硬链接与软链接\n\n  `link`\n\n  链接分为两种，分别是硬链接与软链接\n\n  硬链接(hard link):\n  \n  - 不能将硬链接链接到不同文件系统的文件\n\n  - 硬链接不能链接目录\n\n  - 删除硬链接或者源文件之一并不能完全删除实体\n\n  - 删除实体需要删除硬链接以及起对应的源文件\n\n  - 硬链接相当与源文件的另外一个入口\n\n  - 对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除\n\n  - 硬链接的文件类型是普通文件(字符型)\n\n  - 硬链接通过索引节点进行链接\n\n  例子:\n\n  创建硬链接\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt\n  ~~~\n\n  软链接(Symbolic Link):\n\n  - 类似于Windows的快捷方式\n\n  - 文件内存放的是源文件的路径\n\n  - 即使删除源文件，软链接仍然存在，但无法访问源文件\n\n  - 源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示\n\n  - 软链接可以用rm命令删除\n\n  例子:\n\n  __创建软链接__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt\n  ~~~\n\n## 文件链接案例\n\n  通过一个案例演示软链接和硬链接的区别。\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ cat testFile\n  123\n  # 创建硬链接\n  [evanmeek@EvanLinux ~]$ ln testFile testFileHardLink\n  # 创建软链接\n  [evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink\n  [evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink\n  123\n  123\n  123\n  # 删除软链接\n  [evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink\n  [evanmeek@EvanLinux ~]$ cat testFile testHardLink\n  123\n  123\n  # 复原\n  [evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink\n  # 删除硬链接\n  [evanmeek@EvanLinux ~]$ rm -f testFileHardLink\n  [evanmeek@EvanLinux ~]$ cat testFile testFileHardLink\n  123\n  123\n  # 复原\n  [evanmeek@EvanLinux ~]$ ln testFile testFileHardLink\n  # 删除源文件\n  [evanmeek@EvanLinux ~]$ rm -f testFile\n  [evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink\n  123\n  cat: testFileSymbolicLink: 没有那个文件或目录\n  ~~~\n  \n  - 硬链接可以没有源文件\n\n  - 软链接不行\n\n# 2.12 readlink 查看符号链接文件的内容\n\n  此命令可查看链接指向的源文件的地址\n\n  | 选项 | 说明                                                           |\n  |------|----------------------------------------------------------------|\n  | -f   | 一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行 |\n\n  例子：\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink\n  ~~~\n\n# 2.13 find 查找目录下的文件\n\n  由于本篇篇幅较大，请点击下方超链接进行访问。\n\n  [点击访问](/2019/6/21/Linux-文件和目录操作命令-find命令)\n\n# 2.14 xargs将标准输入转换成命令行参数\n\n  | 选项 | 说明                                                           |\n  |------|----------------------------------------------------------------|\n  | -n   | 指定每行命令的最大参数数量，每个参数由空格隔开                 |\n  | -d   | 自定义分割符                                                   |\n  | -i   | 以{}替代xargs命令之前的结果                                    |\n  | -I   | 指定一个符号替代前面的结果，而不是使用默认的{}                 |\n  | -P   | 提示让用户确认是否执行后面的命令，y执行，n不执行               |\n  | -0   | 用null替代空格作为分割符，配合find命令的-printf0选项的输出使用 |\n\n## 2.14.2使用范例\n\n  __多行输入变单行__\n\n  ~~~\n  > cat test.txt\n  1 2 3 4 \n  5 6 7\n  8 9\n  1 \n  > xargs < test.txt\n  1 2 3 4 5 6 7 8 9 1\n  ~~~\n\n  __通过-n指定每行的输出个数__\n\n  ~~~\n  > xargs -n 2 < test.txt\n  1 2\n  3 4\n  5 6\n  7 8\n  9 1\n  ~~~\n\n  __自定义分隔符(使用-d功能)__\n  ~~~\n  > echo 123I321I809I098\n  123I321I809I098\n\n  > echo 123I321I809I098|xargs -d I -n 2\n  123 321\n  890 098\n  ~~~\n\n  __指定一个替换字符串__\n  ~~~\n  # 将查找出来的结果删除\n  # 先将结果传给{}\n  # 再会被删除\n  > find . -name \"*.log\"|xargs -i rm -rf {}\n  # 自定义替换字符串\n  > find . -name \"*.log\"|xargs -I [] rm -rf []\n  ~~~\n\n# 2.15 rename重命名\n\n  rename通过替换字符串的方式批量修改文件名\n\n  语法格式\n\n  ~~~\n  rename from to file\n  ~~~\n\n  例子:\n\n  __批量修改文件名__\n\n  ~~~\n  > ls\n  test_demo_0  test_demo_1  test_demo_2  test_demo_3  test_demo_4  test_demo_5\n  > rename \"_demo\" \"\" *\n  > ls\n  test_0  test_1  test_2  test_3  test_4  test_5\n  ~~~\n\n  __批量修改文件扩展名__\n\n  ~~~\n  > ls\n  test0.txt  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt\n  > rename .txt .demo *\n  > ls\n  test0.demo  test1.demo  test2.demo  test3.demo  test4.demo  test5.demo\n  ~~~\n\n# 2.16 basename显示文件名或目录名\n\n  basename命令用于显示去除路径和文件后缀的文件名或目录名\n\n  语法格式\n\n  ~~~\n  basename [<文件或目录>] [后缀]\n  ~~~\n  \n  其中的后缀为可选\n\n  例子:\n\n  __只显示文件名和后缀，不显示完整路径__\n\n  ~~~\n  > mkdir -p dir1/dir2/\n  > touch dir1/dir2/test.txt\n  > basename dir1/dir2/test.txt\n  test.txt\n  ~~~\n\n  只显示文件名，不显示完整路径制定不显示某个后缀\n\n  ~~~\n  > touch dir1/dir2/test.demo.txt\n  > basename dir1/dir2/test.demo.txt .txt\n  test.demo\n  ~~~\n# 2.17 dirname显示文件或目录的路径\n\n  dirname命令用于只显示文件或目录的路径\n\n  语法格式\n\n  ~~~\n  dirname [<文件或目录>]\n  ~~~\n\n  例子:\n\n  ~~~\n  > dirname dir1/dir2/test.txt\n  dir1/dir2\n  ~~~\n\n# 2.18 chattr改变文件的扩展属性\n  charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的．\n\n  语法格式\n\n  ~~~\n  chattr [选项] [模式] [<文件或目录>]\n  ~~~\n\n  提示:`lsattr`命令可以查看文件的属性\n\n  | 选项 | 说明                                       |\n  |------|--------------------------------------------|\n  | -R   | 递归更改目录属性                           |\n  | -V   | 显示执行过程                               |\n  | mode |                                            |\n  | +    | 增加参数                                   |\n  | -    | 移除参数                                   |\n  | =    | 更新为指定参数                             |\n  | A    | 指定文件的最后访问时间不可修改             |\n  | a    | 指定文件只能添加数据，无法删除数据`!`      |\n  | !    | 指定文件不能被删除，重命名，写入或新增内容 |\n\n  例子：\n\n  __给文件加锁，使其只能为只读__\n\n  ~~~\n  > chattr +i test.txt\n  > lsattr test.txt\n  ----i---------e----- test.txt\n  > echo a1111 > test.txt\n  zsh: 不允许的操作: test.txt\n  > echo b2222 >> test.txt \n  zsh: 不允许的操作: test.txt\n  ~~~\n\n  __给文件解锁__\n\n  ~~~\n  > charttr -i test.txt\n  > lsattr test.txt\n  --------------e----- test.txt\n  > eco 111 > test.txt\n  > cat test.txt\n  111\n  ~~~\n\n# 2.19 lsattr查看文件扩展属性\n\n  lsattr命令用于查看文件扩展属\n\n  语法格式\n\n  ~~~\n  lsattr [选项] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                   |\n  |------|------------------------|\n  | -R   | 递归查看目录的扩展属性 |\n  | -a   | 显示所有文件的扩展属性 |\n  | -d   | 显示目录的扩展属性     |\n\n  例子:\n\n  __查看文件的扩展属性__\n\n  ~~~\n  > lsattr test.txt\n  --------------e----- test.txt\n  > chattr +i test.txt\n  > lsattr test.txt\n  ----i---------e----- test.txt\n  ~~~\n\n  __查看目录的扩展属性__\n\n  ~~~\n  > lsattr -d testDir\n  --------------e----- testDir\n  > chattr +i testDir\n  > lsattr -d testDir\n  ----i---------e----- testDir\n  ~~~\n\n# 2.20 file显示文件的类型\n\n  file命令用于显示文件的类型\n\n  语法格式\n\n  ~~~\n  file [选项] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                 |\n  |------|----------------------|\n  | -b   | 输出信息使用精简格式 |\n\n  例子:\n\n  __查看文件类型__\n\n  ~~~\n  > file test.txt\n  test.txt: empty\n  > file *\n  test.txt:      empty\n  test.txt.link: symbolic link to test.txt\n  ~~~\n\n# 2.21 md5sum计算和校验文件的MD5值\n\n  md5sum命令用于计算和校验文件的MD5值.\n\n  语法格式\n\n  ~~~\n  md5sum [选项] [文件]\n  ~~~\n\n  | 选项     | 说明                                                 |\n  |----------|------------------------------------------------------|\n  | -b       | 二进制模式读取文件                                   |\n  | -c       | 从指定文件中读取MD5校验值，并进行校验                |\n  | -t       | 文本模式读取文件，默认                               |\n  | --quiet  | 校验文件时，若通过不输出OK                           |\n  | --status | 校验文件时，不输出任何信息，但可通过命令的返回值判断 |\n\n  例子:\n\n  __生成一个文件的MD5值__\n\n  ~~~\n  > md5sum test.txt\n  d41d8cd98f00b204e9800998ecf8427e  test.txt\n  ~~~\n\n  __校验文件MD5值是否发生改变__\n\n  ~~~\n  > md5sum test.txt > md5.log\n  > cat md5.log\n  d41d8cd98f00b204e9800998ecf8427e  test.txt\n  > md5sum -c md5.log\n  test.txt: 成功\n  > echo \"update\" >> test.txt\n  > md5sum -c md5.log\n  test.txt: 失败\n  md5sum: 警告：1 个校验和不匹配\n  > md5sum --status -c md5.log\n  > echo $?\n  1\n  ~~~\n\n# 2.22 chown改变文件或目录的用户和用户组\n\n  chown命令用于改变文件或目录的用户和用户组\n\n  语法格式\n\n  ~~~\n  chown [选项] [用户:用户组] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                       |\n  |------|----------------------------|\n  | -R   | 递归更改目录的用户和用户组 |\n\n  例子:\n\n  __更改文件所属的用户属性__\n\n  ~~~\n  > ls -l test.txt\n  -rw-r--r-- 1 root root 5  6月 27 00:31 test.txt\n  # 授予权限的用户必须存在\n  > chown xxx test.txt\n  chown: 无效的用户: “xxx”\n  > chown evanmeek test.txt\n  > ls -l test.txt\n  -rw-r--r-- 1 evanmeek root 5  6月 27 00:31 test.txt\n  ~~~\n\n  __更改文件所属用户组的属性__\n\n  ~~~\n  > ls -l\n  总用量 4.0K\n  -rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt\n  > chown .root test.txt\n  > ls -l\n  总用量 4.0K\n  -rw-r--r-- 1 evanmeek root 5  6月 27 00:34 test.txt\n  ~~~\n\n  __同时更改文件的用户和用户组属性__\n\n  ~~~\n  > chown evanmeek:evanmeek test.txt\n  > ls -l\n  总用量 4.0K\n  -rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt\n  ~~~\n\n  __递归更改目录下所有文件及目录的用户和用户组属性__\n\n  ~~~\n  > tree\n  .\n  ├── dir0\n  │   └── test.txt\n  ├── dir1\n  │   └── test.txt\n  └── dir2\n      └── test.txt\n\n  3 directories, 3 files\n  > chown -R root:root .\n  > ls -l\n  总用量 12K\n  drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir0\n  drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir1\n  drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir2\n  ~~~\n\n# 2.23chmod改变文件或目录权限\n\n  只有文件的属主以及超级用户`root`才能执行此命令\n\n  语法格式\n\n  ~~~\n  chmod [选项] [模式] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                         |\n  |------|------------------------------|\n  | -R   | 递归指定目录以及子目录的权限 |\n\n  权限对应表\n\n  | 权限位   | 全称                          | 含义         | 对应数字 |\n  |----------|-------------------------------|--------------|----------|\n  | r        | read                          | 可读权限     | 4        |\n  | w        | write                         | 可写权限     | 2        |\n  | x        | execute                       | 可执行权限   | 1        |\n  | \\-       |                               | 没有任何权限 | 0        |\n  | 备注     | 一些特殊权限位:t,T,s,S,x,X    |              |          |\n  | 用户类型 | 文件所属用户:u(OwnerUser)     |              |          |\n  | 用户类型 | 文件所属用户组:g(Group)       |              |          |\n  | 用户类型 | 其他用户:o(Other)             |              |          |\n  | 用户类型 | 所有:a(ALL),等效于u,g,o的总和 |              |          |\n  | 操作字符 | +:添加/-:减去/=:设置          |              |          |\n\n  例子:\n\n  __权限字母和操作符表达式__\n\n  ~~~\n  > ls -l\n  总用量 4\n  -rw-r--r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  # 给文件所属用户减去可写权限\n  > chmod u-w test.txt\n  # 给用户所属用户组减去可读权限\n  > chmod g-r test.txt\n  > ls -l\n  总用量 4.0K\n  -r-----r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  # 给所有用户以及用户组都设置为可读可写可执行的权限\n  > chmod a=rwx test.txt\n  > ls -l\n  总用量 4.0K\n  -rwxrwxrwx 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  ~~~\n\n  __使用数字更改文件或目录权限__\n\n  先举个例子，有这么一个文件\n\n  ~~~\n  -rw-rw---- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  ~~~\n\n  权限示意图\n\n  ~~~\n  前三个字符代表文件属主的权限\n  中间三个字符代表文件属组的权限\n  后三个字符代表其他用户的权限\n  -rw-rw---- evanmeek evanmeek test.txt\n  ~~~\n\n  __我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660__\n\n  _因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660_\n\n  ~~~\n  # 将test.txt文件的所有用户权限设置为可读可写可执行\n  > chmod 777 test.txt\n  > ls -l\n  ---------- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  ~~~\n\n  __使用数字递归更改文件或目录的权限__\n\n  ~~~\n  > tree\n  .\n  ├── dir0\n  │   └── file.txt\n  ├── dir1\n  │   └── file.txt\n  └── dir2\n      └── file.txt\n  > ls -l\n  总用量 12K\n  drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0\n  drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1\n  drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2\n  > chmod -R 777 dir{0..2}\n  总用量 12K\n  drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0\n  drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1\n  drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2\n  ~~~\n\n  __Linux普通文件的读，写，执行权限说明__\n  | 权限    | 说明                       |\n  |---------|----------------------------|\n  | 可读r   | 表示具有读取文件内容的权限 |\n  | 可写w   | 表示具有修改文件内容的权限 |\n  | 可执行x | 表示具有执行文件的权限     |\n\n  - 可写w\n    1. 如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo >>　的方式进行追加.\n    2. 删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里\n\n  - 可执行x\n    1. 要求文件本身是可执行的\n    2. 普通用户必须要有r权限才能够执行\n    3. root用户即使没有r权限，只需要有x权限即可执行\n    4. 不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行\n\n  __Linux目录的，写，执行权限说明__\n  | 权限    | 说明                                       |\n  |---------|--------------------------------------------|\n  | 可读r   | 表示具有浏览目录下文件以及子目录的权限     |\n  | 可写w   | 表示具有增加，删除或修改目录内文件名的权限 |\n  | 可执行x | 表示具有进入目录的权限                     |\n\n  - 可读r\n    1. 没有x权限不能进入至目录内\n    2. ls列表可以看到所有文件名，不过会提示无法访问目录下的文件\n    3. 如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名\n\n  - 可写w\n    1. 增加的不是文件内容，而是创建新文件\n    2. 修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名，\n    3. 删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除\n  - 可执行权限x\n    1. 没有可读权限r则不能进入目录\n    2. 没有可写权限w则无法创建新文件\n\n# 2.24 chgrp更改文件用户组\n\n  此命令被`chown`取代，用法和参数都和`chown`命令相同\n\n# 2.25 umask显示或设置权限掩码\n\n  umask是通过八进制的数值来定义用户创建文件或目录的默认权限\n\n  语法格式\n\n  ~~~\n  umask [选项] [模式]\n  ~~~\n\n  | 选项 | 说明                               |\n  |------|------------------------------------|\n  | -p   | 输出的权限掩码可直接作为命令来执行 |\n  | -S   | 以字符的方式输出权限掩码           |\n\n## 2.25.2 通过umask计算文件目录权限\n\n  __文件权限的计算__\n\n  创建文件默认的最大权限为666，也就是说没有可执行权限x.\n\n  umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。\n\n  例子:\n\n  假如umask值为:022，那么:\n  ~~~\n  6 6 6 文件默认的权限\n  0 2 2 umask值\n- =====\n  6 4 4 都为偶数，最终结果为644\n  ~~~\n\n  假如umask值为:045，那么:\n  ~~~\n    6 6 6 文件默认的权限\n    0 4 5 umask值\n- =====\n    6 2 1 其他用户权限位为奇数，所以+1\n    0 0 1\n+ =====\n    6 2 2 都为偶数，最终结果为622\n  ~~~\n  \n  __目录权限的计算__\n\n  _目录权限的计算没有奇偶之分_\n\n  创建目录是默认的最大权限为777(-rwx-rwx-rwx)\n\n  计算方法和文件权限计算方法相同\n\n  例子:\n  \n  假如umask值为:022，那么:\n  ~~~\n    7 7 7 目录默认最大权限\n    0 2 2 umask值\n  - =====\n    7 5 5 得到最终结果\n  ~~~\n\n  __查看系统默认的umask值__\n\n  ~~~\n  # 普通用户的默认umask值\n  evanmeek > umask\n  022\n  # 超级用户的默认umask值\n  root > umask\n  0022\n  ~~~\n\n  __-S参数的使用__\n\n  ~~~\n  > umask -S\n  u=rwx,g=rx,o=rx\n  ~~~\n\n  __-p参数的使用__\n\n  ~~~\n  > umask -p\n  umask 0022\n  ~~~\n\n  __临时修改umask值__\n\n  ~~~\n  # 修改umask之前\n  > umask\n  > ls -l file1\n  -rw-r--r-- 1 evanmeek evanmeek 0  6月 30 19:11 file1\n  # 修改umask之后\n  > umask 044\n  > umask\n  044\n  > touch file2\n  > ls -l file1\n  -rw--w--w- 1 evanmeek evanmeek 0  6月 30 19:12 file2\n  ~~~\n\n  __永久修改umask值__\n\n  _若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。_\n\n  编辑`/etc/profile`或者`/etc/bashrc`\n\n  找到`umask`项修改即可\n","source":"_posts/Linux-文件和目录操作命令-1.md","raw":"---\ntitle: Linux-文件和目录操作命令-1\ncopyright: true\ndate: 2019-06-16 15:56:11\ncategories: Linux系列\ntags:\n  - Linux\n---\n\n# 2.0 老男孩新手成为技术大牛心法\n\n执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。\n\n专注: 只做一件事。两耳不闻其他事，一心只读运维书。\n\n自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。\n\n心态: 保持空杯，重视基础；基础不牢，地动山摇。\n\n# 2.1 pwd命令\n\n  `print working diretory`\n\n  __查看当前路径使用`pwd`命令__\n\n  例子:\n\n  ~~~shell\n  [evanmeek@EvanLinux ~]$ pwd\n  ~~~\n\n  输出信息\n\n  ~~~Shell\n  /home/evanmeek\n  ~~~\n\n  |选项|说明|\n  |----|----------------------------------------------------|\n  | -L | 显示当前目录的逻辑路径(忽略软链接文件)             |\n  | -P | 显示当前目录的物理路径(若有软链接则显示源文件地址) |\n\n  所谓的软链接相当于快捷方式，例如`~/test.txt`是`/test.txt`的软链接，那么我们操作`~/test.txt`等同于操作`/test.txt`，详细的软链接将会在后面的`ln`命令讲解。\n\n# 2.2 cd 切换目录\n\n  `change directory`\n\n  __进入某个目录使用`cd`命令__\n\n  例子:\n\n  ~~~shell\n  [evanmeek@EvanLinux ~]$ pwd\n  [evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/\n  [evanmeek@EvanLinux /etc/sysctl.d/]$ pwd\n  ~~~\n\n  输出信息\n\n  ~~~\n  /home/evanmeek/\n  /etc/sysctl.d/\n  ~~~\n  \n  | 选项 | 说明                                                      |\n  |------|-----------------------------------------------------------|\n  | -P   | 进入目录的物理路径                                        |\n  | -L   | 进入目录的逻辑路径                                        |\n  | -    | 进入上次的目录                                            |\n  | ~    | 进入系统环境变量的`HOME`目录路径，即当前登录用户的家目录` |\n  | \\.\\. | 进入父目录                                                |\n\n  `cd` 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录.\n\n  例子:\n\n  ~~~Shell\n  [evanmeek@EvanLinux ~]$ cd Desktop\n  [evanmeek@EvanLinux ~/Desktop]$ pwd\n  [evanmeek@EvanLinux ~]$ cd -\n  [evanmeek@EvanLinux ~]$ pwd\n  [evanmeek@EvanLinux ~]$ cd /etc/systemd/\n  [evanmeek@EvanLinux /etc/systemd/]$ pwd\n  [evanmeek@EvanLinux /etc/systemd/]$ cd ..\n  [evanmeek@EvanLinux /etc/]$ pwd\n  ~~~\n\n  输出信息\n\n  ~~~shell\n  ~/Desktop/\n  ~\n  /etc/systemd/\n  /etc/\n  ~~~\n\n# 2.3 tree以树形结构显示目录下的内容\n\n  __树形结构可以很清晰的显示出目录的父子级关系__\n\n  例子:\n\n  ~~~\n  [evanmeek@EvanLinux ~/test]$ tree -L 1\n  ~~~\n\n  输出信息\n\n  ~~~\n  .\n  ├── dir1\n  │   ├── dir1_1\n  │   └── dir2_2\n  └── dir2\n      ├── dir1_1\n      └── dir2_2\n\n  6 directories, 0 files\n  ~~~\n\n  |选项|说明|\n  |-------------|----------------------------------------------------|\n  | -a          | 显示所有文件包括隐藏文件                           |\n  | -d          | 只显示目录`!`                                      |\n  | -f          | 显示每个文件的绝对路径                             |\n  | -i          | 不显示树枝                                         |\n  | -L levelNum | 显示遍历目录的层级，levelNum为层级(数字)           |\n  | -F          | 显示时根据不同文件类型在文件名结尾处显示不同的符号 |\n\n  例子:\n\n  显示隐藏文件\n  ~~~\n  #假设此目录下有隐藏文件\n  [evanmeek@EvanLinux ~/tmp]$ tree -a\n  ~~~\n\n  输出信息\n\n  ~~~\n  .\n  ├── dir1\n  │   ├── dir1_1\n  │   └── dir2_2\n  ├── dir2\n  │   ├── dir1_1\n  │   └── dir2_2\n  ├── .file1\n  └── .file2\n\n  6 directories, 2 files\n  ~~~\n\n  例子:\n\n  显示1级层文件完整路径，并不显示树枝\n  ~~~\n  [evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi .\n  ~~~\n\n  输出信息\n\n  ~~~\n  .\n  ./dir1\n  ./dir2\n  ~~~\n\n# 2.4 mkdir创建目录\n\n  `make directory`\n\n  __创建目录使用`mkdir`命令__\n\n  |选项|说明|\n  |----|------------------------------------|\n  | -p | 递归创建目录，若目录已存在不会报错 |\n  | -m | 创建时指定目录的权限               |\n  | -v | 创建时显示过程信息                 |\n\n  例子:\n\n  创建目录时显示信息\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -v testDir\n  [evanmeek@EvanLinux ~]$ cd testDir\n  [evanmeek@EvanLinux ~/testDir]$ pwd\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'testDir'\n  ~~~\n\n  递归创建目录并且显示信息\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -pv father/son/test\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'father'\n  mkdir: 已创建目录 'father/son'\n  mkdir: 已创建目录 'father/son/test'\n  ~~~\n\n  创建目录并且指定目录权限\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir\n  [evanmeek@EvanLinux ~]$ ls -ld testDir\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'testDir'\n  d-wx-wx-wx 2 evanmeek evanmeek 4096  6月 17 20:15 testDir\n  ~~~\n\n  利用特殊符号“{}”同时创建多目录及多子目录\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir -pv father/{son1/{a1,a2},son2/{b1,b2},son3/{c1,c2}}\n  [evanmeek@EvanLinux ~]$ tree father\n  ~~~\n\n  输出信息:\n\n  ~~~\n  mkdir: 已创建目录 'father'\n  mkdir: 已创建目录 'father/son1'\n  mkdir: 已创建目录 'father/son1/a1'\n  mkdir: 已创建目录 'father/son1/a2'\n  mkdir: 已创建目录 'father/son2'\n  mkdir: 已创建目录 'father/son2/b1'\n  mkdir: 已创建目录 'father/son2/b2'\n  mkdir: 已创建目录 'father/son3'\n  mkdir: 已创建目录 'father/son3/c1'\n  mkdir: 已创建目录 'father/son3/c2'\n\n  father\n  ├── son1\n  │   ├── a1\n  │   └── a2\n  ├── son2\n  │   ├── b1\n  │   └── b2\n  └── son3\n      ├── c1\n      └── c2\n\n  9 directories, 0 files\n  ~~~\n\n# 2.5 touch创建空文件或改变文件的时间戳属性\n\n  __创建新的空文件，改变文件的时间戳属性，需要用到touch__\n\n  |选项|说明|\n  |-----------|--------------------------------------------------|\n  | -a        | 更改指定文件的最新访问时间                       |\n  | -d STRING | 用字符串的方式指定一个模板作为指定文件的时间属性 |\n  | -m        | 更改指定文件的最新修改时间                       |\n  | -r file   | 将指定文件的时间属性设置为file的时间属性         |\n  | -t STAMP  | 使用时间格式设置文件的时间属性                   |\n\n  例子:\n\n  创建文件\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch test.txt\n  ~~~\n\n  同时创建多个文件\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch test1.txt test2.txt\n  ~~~\n\n  利用{}批量创建文件\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch t{01..05}.txt\n  ~~~\n\n  利用`stat`命令查看时间戳\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出信息\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2019-06-17 21:36:42.380004039 +0800\n  Modify: 2019-06-17 21:36:42.380004039 +0800\n  Change: 2019-06-17 21:36:42.380004039 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n  __时间戳属性说明:__\n\n  - Access 访问属性\n\n  - Modify 修改属性\n\n  - Birth 状态改变属性\n\n  利用-a选项修改文件最后访问属性\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch -a t01.txt\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出信息\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2019-06-17 21:44:27.210736590 +0800\n  Modify: 2019-06-17 21:36:42.380004039 +0800\n  Change: 2019-06-17 21:44:27.210736590 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n  修改文件的修改时间\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出信息\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2001-01-01 00:00:00.000000000 +0800\n  Modify: 2001-01-01 00:00:00.000000000 +0800\n  Change: 2019-06-17 21:48:26.700992172 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n  修改指定文件为某文件的时间属性\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ stat t02.txt\n  [evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt\n  [evanmeek@EvanLinux ~]$ stat t01.txt\n  ~~~\n\n  输出结果\n\n  ~~~\n  File: t01.txt\n  Size: 0               Blocks: 0          IO Block: 4096   regular empty file\n  Device: 10305h/66309d   Inode: 18352077    Links: 1\n  Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)\n  Access: 2019-06-17 21:36:42.380004039 +0800\n  Modify: 2019-06-17 21:36:42.380004039 +0800\n  Change: 2019-06-17 21:51:35.907031392 +0800\n  Birth: 2019-06-17 21:36:42.380004039 +0800\n  ~~~\n\n# 2.6 ls显示目录下的内容及相关属性信息\n  `list directory contents`\n\n  例子:\n\n  查看当前目录下的文件信息\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ls\n  ~~~\n\n  输出结果\n\n  ~~~\n  Applications  Desktop  Downloads  GameDir  index.html  Music  Pictures  temp  WorkDir\n  ~~~\n\n  每个人的目录里面的内容不同，所以可能不一样。\n\n  | 选项                                        | 说明                                                                           |\n  |---------------------------------------------|--------------------------------------------------------------------------------|\n  | -l                                          | 使用长格式列出目录下的文件和信息                                               |\n  | -a                                          | 显示目录下的所有文件，包括隐藏文件`!`                                          |\n  | -t                                          | 根据最新的修改时间排序，不加此参数默认是根据文件名排序`!`                      |\n  | -r                                          | 反向排序                                                                       |\n  | -F                                          | 在显示的条目后加上特殊符号用以区别文件类型`!`                                  |\n  | -p                                          | 目录后面加上“/”                                                                |\n  | -i                                          | 显示inode节点信息                                                              |\n  | -d                                          | 遇到目录时，只列出目录本身，并且不跟随符号链接`!`                              |\n  | -h                                          | 以人类可读的信息显示文件或目录大小                                             |\n  | -A                                          | 列出所有文件，包括隐藏文件夹，但不包括.和..                                    |\n  | -S                                          | 根据文件大小排序                                                               |\n  | -R                                          | 递归列出所有子目录                                                             |\n  | -x                                          | 逐行列出项目而不是逐栏列出                                                     |\n  | -X                                          | 根据扩展名排序                                                                 |\n  | -c                                          | 根据状态改变时间排序                                                           |\n  | -u                                          | 根据最后访问时间排序                                                           |\n  | --color={never,always,auto}                 | 根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示     |\n  | --full-time                                 | 以完整的时间格式进行显示                                                       |\n  | --time-style={full-iso,long-iso,iso,locale} | 以不同的时间格式输出，long-iso最常用                                           |\n  | --time={atime,ctimeA}                       | 按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间 |\n\n  例子:\n\n  环境准备\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mkdir temp\n  [evanmeek@EvanLinux ~]$ cd temp\n  [evanmeek@EvanLinux ~]$ mkdir -p father/dir{01..02}\n  [evanmeek@EvanLinux ~]$ touch father/dir{01..02}/txt{01..02}\n  [evanmeek@EvanLinux ~]$ touch father/dir{01..02}/.txt{01..02}\n  [evanmeek@EvanLinux ~]$ tree -a\n  ~~~\n\n  输出结果\n\n  ~~~\n  .\n  └── father\n      ├── dir01\n      │   ├── .txt01\n      │   ├── txt01\n      │   ├── .txt02\n      │   └── txt02\n      └── dir02\n          ├── .txt01\n          ├── txt01\n          ├── .txt02\n          └── txt02\n\n3 directories, 8 files\n  ~~~\n\n  递归显示所有文件\n\n  ~~~\n  [evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra\n  ~~~\n\n  输出信息\n  \n  ~~~\n  .:\n  .  ..  father\n\n  ./father:\n  .  ..  dir01  dir02\n\n  ./father/dir01:\n  .  ..  .txt01  txt01  .txt02  txt02\n\n  ./father/dir02:\n  .  ..  .txt01  txt01  .txt02  txt02\n  ~~~\n  \n __ls命令输出属性解释__\n\n  目录内容如下：\n\n  ~~~\n  .\n  ├── dir01\n  ├── dir02\n  ├── file01.txt\n  └── file02.txt\n\n  2 directories, 2 files\n  ~~~\n\n  长格式列出人类可读信息并显示inode信息\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ls -lhi\n  ~~~\n\n  输出信息\n\n  ~~~\n  total 8.0K\n  18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir01\n  18219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir02\n  18219054 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file01.txt\n  18219055 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file02.txt\n  ~~~\n\n  从第一列依次往后排，分别含义为:\n\n  1. inode索引节点编号\n  2. 文件类型以及属性(第一字符标注类型，后9个代表权限)\n  3. 硬链接个数\n  4. 文件或目录所属用户\n  5. 文件或目录所属的组\n  6. 文件或目录的大小\n  7. 修改时间\n  10. 文件名或目录名\n\n# 2.7 cp复制文件或目录\n  \n  `copy`\n\n  | 选项 | 说明                                                                                       |\n  |------|--------------------------------------------------------------------------------------------|\n  | -p   | 复制文件时保存源文件的所有者、权限信息及时间属性                                           |\n  | -d   | 如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录 |\n  | -r   | 递归复制目录，即目录下所有的子目录及文件                                                   |\n  | -a   | 等同于上面的p、d、r这3个选项功能的总和                                                     |\n  | -i   | 覆盖已有文件前提示用户确认                                                                 |\n  | -t   | 调换命令格式，默认格式是\"cp 源文件 目标文件\"，将目标文件和源文件进行位置调换               |\n  \n  例子:\n\n  环境准备\n\n  ~~~\n  .\n  └── fatherDir\n      ├── sonDir1\n      │   └── test.txt\n      ├── sonDir2\n      │   └── test.txt\n      └── sonDir3\n          └── test.txt\n\n  4 directories, 3 files\n  ~~~\n\n  拷贝`fatherDir`为`father2Dir`并保留源文件的所有者，权限信息及时间属性\n  \n  ~~~\n  [evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir\n  ~~~\n  \n  再次拷贝`fatherDir`为`father2Dir`从而覆盖上个例子的`father2Dir`\n  \n  ~~~\n  [evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir\n  ~~~\n  \n  输出信息\n\n  ~~~\n  cp：是否覆盖'father2Dir/fatherDir/sonDir1/test.txt'？ y\n  cp：是否覆盖'father2Dir/fatherDir/sonDir2/test.txt'？ y\n  cp：是否覆盖'father2Dir/fatherDir/sonDir3/test.txt'？ y\n  ~~~\n\n# 2.8 mv移动或重命名文件\n  \n  `move`\n  | 选项 | 说明                                                       |\n  |------|------------------------------------------------------------|\n  | -f   | 若目标文件已存在，不询问直接覆盖                           |\n  | -i   | 若目标文件已存在，询问是否覆盖                             |\n  | -n   | 不覆盖已存在的文件                                         |\n  | -t   | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 |\n  | -u   | 源文件比目标文件新，或目标文件不存在时再移动               |\n\n  例子:\n\n  环境准备\n\n  ~~~\n  总用量 4\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test0.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt\n  drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt\n  ~~~\n  \n  更换文件名\n\n  ~~~\n  [evanmeek@EvanMeek ~]$mv test0.txt test-1.txt\n  [evanmeek@EvanMeek ~]$ls -l --full-time\n  ~~~\n  \n  输出信息\n\n  ~~~\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test-1.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt\n  -rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt\n  drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt\n  ~~~\n  \n  __移动文件__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mv test-1.txt testTxt\n  ~~~\n\n  __移动多个文件至一个目录__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt\n  ~~~\n  \n# 2.9 rm删除文件或目录\n\n  __前排提示:使用rm命令时最好知道自己在干什么!__\n\n  `remove`\n\n  | 选项 | 说明                                   |\n  |------|----------------------------------------|\n  | -f | 强制删除并且忽略不存在文件的提示       |\n  | -i | 删除时需要确认                         |\n  | -I | 删除三个以上文件或者递归删除前需要确认 |\n  | -r | 递归删除目录以及其内容`!`                |\n\n  例子:\n\n  __再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现)__\n\n  环境准备\n  ~~~\n  .\n  ├── test2Txt\n  │   ├── test1.txt\n  │   ├── test2.txt\n  │   └── testTxt\n  │       └── test-1.txt\n  └── test3.txt\n  ~~~\n\n  __删除文件__\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ rm test3.txt\n  ~~~\n\n  __强制删除并且删除时需要确认__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt\n  ~~~\n  \n  输出信息\n\n  ~~~\n  rm：是否删除普通空文件 'test2Txt/test2.txt'？\n  ~~~\n\n  __删除目录并且删除时需要确认__\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt\n  ~~~\n  \n  __强制删除+递归删除目录__\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ rm -rf test2Txt\n  ~~~\n\n  __最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入__\n\n  ~~~\n  sudo rm -rf /*\n  ~~~\n  \n  __这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内.__\n\n## 删除时的小技巧\n\n  - 使用`mv`命令代替`rm`命令，可以将要删除的文件暂时保存在`/tmp`目录下，需要清理空间时再去删除\n\n  - 删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原\n\n  - 若非要用删除命令清理空间可以选择用`find`代替`rm`\n\n  - 删除时尽量不要使用系统通配符\n\n# 2.10 rmdir删除空目录\n\n  `remove dirctory`\n\n  此命令只能删除空目录\n\n  | 选项 | 说明                                                                                                                  |\n  |------|-----------------------------------------------------------------------------------------------------------------------|\n  | -p   | 递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息 |\n  | -v   | 删除时显示执行过程                                                                                                    |\n\n# 2.11 ln硬链接与软链接\n\n  `link`\n\n  链接分为两种，分别是硬链接与软链接\n\n  硬链接(hard link):\n  \n  - 不能将硬链接链接到不同文件系统的文件\n\n  - 硬链接不能链接目录\n\n  - 删除硬链接或者源文件之一并不能完全删除实体\n\n  - 删除实体需要删除硬链接以及起对应的源文件\n\n  - 硬链接相当与源文件的另外一个入口\n\n  - 对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除\n\n  - 硬链接的文件类型是普通文件(字符型)\n\n  - 硬链接通过索引节点进行链接\n\n  例子:\n\n  创建硬链接\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt\n  ~~~\n\n  软链接(Symbolic Link):\n\n  - 类似于Windows的快捷方式\n\n  - 文件内存放的是源文件的路径\n\n  - 即使删除源文件，软链接仍然存在，但无法访问源文件\n\n  - 源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示\n\n  - 软链接可以用rm命令删除\n\n  例子:\n\n  __创建软链接__\n\n  ~~~\n  [evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt\n  ~~~\n\n## 文件链接案例\n\n  通过一个案例演示软链接和硬链接的区别。\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ cat testFile\n  123\n  # 创建硬链接\n  [evanmeek@EvanLinux ~]$ ln testFile testFileHardLink\n  # 创建软链接\n  [evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink\n  [evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink\n  123\n  123\n  123\n  # 删除软链接\n  [evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink\n  [evanmeek@EvanLinux ~]$ cat testFile testHardLink\n  123\n  123\n  # 复原\n  [evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink\n  # 删除硬链接\n  [evanmeek@EvanLinux ~]$ rm -f testFileHardLink\n  [evanmeek@EvanLinux ~]$ cat testFile testFileHardLink\n  123\n  123\n  # 复原\n  [evanmeek@EvanLinux ~]$ ln testFile testFileHardLink\n  # 删除源文件\n  [evanmeek@EvanLinux ~]$ rm -f testFile\n  [evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink\n  123\n  cat: testFileSymbolicLink: 没有那个文件或目录\n  ~~~\n  \n  - 硬链接可以没有源文件\n\n  - 软链接不行\n\n# 2.12 readlink 查看符号链接文件的内容\n\n  此命令可查看链接指向的源文件的地址\n\n  | 选项 | 说明                                                           |\n  |------|----------------------------------------------------------------|\n  | -f   | 一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行 |\n\n  例子：\n  \n  ~~~\n  [evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink\n  ~~~\n\n# 2.13 find 查找目录下的文件\n\n  由于本篇篇幅较大，请点击下方超链接进行访问。\n\n  [点击访问](/2019/6/21/Linux-文件和目录操作命令-find命令)\n\n# 2.14 xargs将标准输入转换成命令行参数\n\n  | 选项 | 说明                                                           |\n  |------|----------------------------------------------------------------|\n  | -n   | 指定每行命令的最大参数数量，每个参数由空格隔开                 |\n  | -d   | 自定义分割符                                                   |\n  | -i   | 以{}替代xargs命令之前的结果                                    |\n  | -I   | 指定一个符号替代前面的结果，而不是使用默认的{}                 |\n  | -P   | 提示让用户确认是否执行后面的命令，y执行，n不执行               |\n  | -0   | 用null替代空格作为分割符，配合find命令的-printf0选项的输出使用 |\n\n## 2.14.2使用范例\n\n  __多行输入变单行__\n\n  ~~~\n  > cat test.txt\n  1 2 3 4 \n  5 6 7\n  8 9\n  1 \n  > xargs < test.txt\n  1 2 3 4 5 6 7 8 9 1\n  ~~~\n\n  __通过-n指定每行的输出个数__\n\n  ~~~\n  > xargs -n 2 < test.txt\n  1 2\n  3 4\n  5 6\n  7 8\n  9 1\n  ~~~\n\n  __自定义分隔符(使用-d功能)__\n  ~~~\n  > echo 123I321I809I098\n  123I321I809I098\n\n  > echo 123I321I809I098|xargs -d I -n 2\n  123 321\n  890 098\n  ~~~\n\n  __指定一个替换字符串__\n  ~~~\n  # 将查找出来的结果删除\n  # 先将结果传给{}\n  # 再会被删除\n  > find . -name \"*.log\"|xargs -i rm -rf {}\n  # 自定义替换字符串\n  > find . -name \"*.log\"|xargs -I [] rm -rf []\n  ~~~\n\n# 2.15 rename重命名\n\n  rename通过替换字符串的方式批量修改文件名\n\n  语法格式\n\n  ~~~\n  rename from to file\n  ~~~\n\n  例子:\n\n  __批量修改文件名__\n\n  ~~~\n  > ls\n  test_demo_0  test_demo_1  test_demo_2  test_demo_3  test_demo_4  test_demo_5\n  > rename \"_demo\" \"\" *\n  > ls\n  test_0  test_1  test_2  test_3  test_4  test_5\n  ~~~\n\n  __批量修改文件扩展名__\n\n  ~~~\n  > ls\n  test0.txt  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt\n  > rename .txt .demo *\n  > ls\n  test0.demo  test1.demo  test2.demo  test3.demo  test4.demo  test5.demo\n  ~~~\n\n# 2.16 basename显示文件名或目录名\n\n  basename命令用于显示去除路径和文件后缀的文件名或目录名\n\n  语法格式\n\n  ~~~\n  basename [<文件或目录>] [后缀]\n  ~~~\n  \n  其中的后缀为可选\n\n  例子:\n\n  __只显示文件名和后缀，不显示完整路径__\n\n  ~~~\n  > mkdir -p dir1/dir2/\n  > touch dir1/dir2/test.txt\n  > basename dir1/dir2/test.txt\n  test.txt\n  ~~~\n\n  只显示文件名，不显示完整路径制定不显示某个后缀\n\n  ~~~\n  > touch dir1/dir2/test.demo.txt\n  > basename dir1/dir2/test.demo.txt .txt\n  test.demo\n  ~~~\n# 2.17 dirname显示文件或目录的路径\n\n  dirname命令用于只显示文件或目录的路径\n\n  语法格式\n\n  ~~~\n  dirname [<文件或目录>]\n  ~~~\n\n  例子:\n\n  ~~~\n  > dirname dir1/dir2/test.txt\n  dir1/dir2\n  ~~~\n\n# 2.18 chattr改变文件的扩展属性\n  charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的．\n\n  语法格式\n\n  ~~~\n  chattr [选项] [模式] [<文件或目录>]\n  ~~~\n\n  提示:`lsattr`命令可以查看文件的属性\n\n  | 选项 | 说明                                       |\n  |------|--------------------------------------------|\n  | -R   | 递归更改目录属性                           |\n  | -V   | 显示执行过程                               |\n  | mode |                                            |\n  | +    | 增加参数                                   |\n  | -    | 移除参数                                   |\n  | =    | 更新为指定参数                             |\n  | A    | 指定文件的最后访问时间不可修改             |\n  | a    | 指定文件只能添加数据，无法删除数据`!`      |\n  | !    | 指定文件不能被删除，重命名，写入或新增内容 |\n\n  例子：\n\n  __给文件加锁，使其只能为只读__\n\n  ~~~\n  > chattr +i test.txt\n  > lsattr test.txt\n  ----i---------e----- test.txt\n  > echo a1111 > test.txt\n  zsh: 不允许的操作: test.txt\n  > echo b2222 >> test.txt \n  zsh: 不允许的操作: test.txt\n  ~~~\n\n  __给文件解锁__\n\n  ~~~\n  > charttr -i test.txt\n  > lsattr test.txt\n  --------------e----- test.txt\n  > eco 111 > test.txt\n  > cat test.txt\n  111\n  ~~~\n\n# 2.19 lsattr查看文件扩展属性\n\n  lsattr命令用于查看文件扩展属\n\n  语法格式\n\n  ~~~\n  lsattr [选项] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                   |\n  |------|------------------------|\n  | -R   | 递归查看目录的扩展属性 |\n  | -a   | 显示所有文件的扩展属性 |\n  | -d   | 显示目录的扩展属性     |\n\n  例子:\n\n  __查看文件的扩展属性__\n\n  ~~~\n  > lsattr test.txt\n  --------------e----- test.txt\n  > chattr +i test.txt\n  > lsattr test.txt\n  ----i---------e----- test.txt\n  ~~~\n\n  __查看目录的扩展属性__\n\n  ~~~\n  > lsattr -d testDir\n  --------------e----- testDir\n  > chattr +i testDir\n  > lsattr -d testDir\n  ----i---------e----- testDir\n  ~~~\n\n# 2.20 file显示文件的类型\n\n  file命令用于显示文件的类型\n\n  语法格式\n\n  ~~~\n  file [选项] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                 |\n  |------|----------------------|\n  | -b   | 输出信息使用精简格式 |\n\n  例子:\n\n  __查看文件类型__\n\n  ~~~\n  > file test.txt\n  test.txt: empty\n  > file *\n  test.txt:      empty\n  test.txt.link: symbolic link to test.txt\n  ~~~\n\n# 2.21 md5sum计算和校验文件的MD5值\n\n  md5sum命令用于计算和校验文件的MD5值.\n\n  语法格式\n\n  ~~~\n  md5sum [选项] [文件]\n  ~~~\n\n  | 选项     | 说明                                                 |\n  |----------|------------------------------------------------------|\n  | -b       | 二进制模式读取文件                                   |\n  | -c       | 从指定文件中读取MD5校验值，并进行校验                |\n  | -t       | 文本模式读取文件，默认                               |\n  | --quiet  | 校验文件时，若通过不输出OK                           |\n  | --status | 校验文件时，不输出任何信息，但可通过命令的返回值判断 |\n\n  例子:\n\n  __生成一个文件的MD5值__\n\n  ~~~\n  > md5sum test.txt\n  d41d8cd98f00b204e9800998ecf8427e  test.txt\n  ~~~\n\n  __校验文件MD5值是否发生改变__\n\n  ~~~\n  > md5sum test.txt > md5.log\n  > cat md5.log\n  d41d8cd98f00b204e9800998ecf8427e  test.txt\n  > md5sum -c md5.log\n  test.txt: 成功\n  > echo \"update\" >> test.txt\n  > md5sum -c md5.log\n  test.txt: 失败\n  md5sum: 警告：1 个校验和不匹配\n  > md5sum --status -c md5.log\n  > echo $?\n  1\n  ~~~\n\n# 2.22 chown改变文件或目录的用户和用户组\n\n  chown命令用于改变文件或目录的用户和用户组\n\n  语法格式\n\n  ~~~\n  chown [选项] [用户:用户组] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                       |\n  |------|----------------------------|\n  | -R   | 递归更改目录的用户和用户组 |\n\n  例子:\n\n  __更改文件所属的用户属性__\n\n  ~~~\n  > ls -l test.txt\n  -rw-r--r-- 1 root root 5  6月 27 00:31 test.txt\n  # 授予权限的用户必须存在\n  > chown xxx test.txt\n  chown: 无效的用户: “xxx”\n  > chown evanmeek test.txt\n  > ls -l test.txt\n  -rw-r--r-- 1 evanmeek root 5  6月 27 00:31 test.txt\n  ~~~\n\n  __更改文件所属用户组的属性__\n\n  ~~~\n  > ls -l\n  总用量 4.0K\n  -rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt\n  > chown .root test.txt\n  > ls -l\n  总用量 4.0K\n  -rw-r--r-- 1 evanmeek root 5  6月 27 00:34 test.txt\n  ~~~\n\n  __同时更改文件的用户和用户组属性__\n\n  ~~~\n  > chown evanmeek:evanmeek test.txt\n  > ls -l\n  总用量 4.0K\n  -rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt\n  ~~~\n\n  __递归更改目录下所有文件及目录的用户和用户组属性__\n\n  ~~~\n  > tree\n  .\n  ├── dir0\n  │   └── test.txt\n  ├── dir1\n  │   └── test.txt\n  └── dir2\n      └── test.txt\n\n  3 directories, 3 files\n  > chown -R root:root .\n  > ls -l\n  总用量 12K\n  drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir0\n  drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir1\n  drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir2\n  ~~~\n\n# 2.23chmod改变文件或目录权限\n\n  只有文件的属主以及超级用户`root`才能执行此命令\n\n  语法格式\n\n  ~~~\n  chmod [选项] [模式] [<文件或目录>]\n  ~~~\n\n  | 选项 | 说明                         |\n  |------|------------------------------|\n  | -R   | 递归指定目录以及子目录的权限 |\n\n  权限对应表\n\n  | 权限位   | 全称                          | 含义         | 对应数字 |\n  |----------|-------------------------------|--------------|----------|\n  | r        | read                          | 可读权限     | 4        |\n  | w        | write                         | 可写权限     | 2        |\n  | x        | execute                       | 可执行权限   | 1        |\n  | \\-       |                               | 没有任何权限 | 0        |\n  | 备注     | 一些特殊权限位:t,T,s,S,x,X    |              |          |\n  | 用户类型 | 文件所属用户:u(OwnerUser)     |              |          |\n  | 用户类型 | 文件所属用户组:g(Group)       |              |          |\n  | 用户类型 | 其他用户:o(Other)             |              |          |\n  | 用户类型 | 所有:a(ALL),等效于u,g,o的总和 |              |          |\n  | 操作字符 | +:添加/-:减去/=:设置          |              |          |\n\n  例子:\n\n  __权限字母和操作符表达式__\n\n  ~~~\n  > ls -l\n  总用量 4\n  -rw-r--r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  # 给文件所属用户减去可写权限\n  > chmod u-w test.txt\n  # 给用户所属用户组减去可读权限\n  > chmod g-r test.txt\n  > ls -l\n  总用量 4.0K\n  -r-----r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  # 给所有用户以及用户组都设置为可读可写可执行的权限\n  > chmod a=rwx test.txt\n  > ls -l\n  总用量 4.0K\n  -rwxrwxrwx 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  ~~~\n\n  __使用数字更改文件或目录权限__\n\n  先举个例子，有这么一个文件\n\n  ~~~\n  -rw-rw---- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  ~~~\n\n  权限示意图\n\n  ~~~\n  前三个字符代表文件属主的权限\n  中间三个字符代表文件属组的权限\n  后三个字符代表其他用户的权限\n  -rw-rw---- evanmeek evanmeek test.txt\n  ~~~\n\n  __我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660__\n\n  _因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660_\n\n  ~~~\n  # 将test.txt文件的所有用户权限设置为可读可写可执行\n  > chmod 777 test.txt\n  > ls -l\n  ---------- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt\n  ~~~\n\n  __使用数字递归更改文件或目录的权限__\n\n  ~~~\n  > tree\n  .\n  ├── dir0\n  │   └── file.txt\n  ├── dir1\n  │   └── file.txt\n  └── dir2\n      └── file.txt\n  > ls -l\n  总用量 12K\n  drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0\n  drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1\n  drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2\n  > chmod -R 777 dir{0..2}\n  总用量 12K\n  drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0\n  drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1\n  drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2\n  ~~~\n\n  __Linux普通文件的读，写，执行权限说明__\n  | 权限    | 说明                       |\n  |---------|----------------------------|\n  | 可读r   | 表示具有读取文件内容的权限 |\n  | 可写w   | 表示具有修改文件内容的权限 |\n  | 可执行x | 表示具有执行文件的权限     |\n\n  - 可写w\n    1. 如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo >>　的方式进行追加.\n    2. 删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里\n\n  - 可执行x\n    1. 要求文件本身是可执行的\n    2. 普通用户必须要有r权限才能够执行\n    3. root用户即使没有r权限，只需要有x权限即可执行\n    4. 不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行\n\n  __Linux目录的，写，执行权限说明__\n  | 权限    | 说明                                       |\n  |---------|--------------------------------------------|\n  | 可读r   | 表示具有浏览目录下文件以及子目录的权限     |\n  | 可写w   | 表示具有增加，删除或修改目录内文件名的权限 |\n  | 可执行x | 表示具有进入目录的权限                     |\n\n  - 可读r\n    1. 没有x权限不能进入至目录内\n    2. ls列表可以看到所有文件名，不过会提示无法访问目录下的文件\n    3. 如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名\n\n  - 可写w\n    1. 增加的不是文件内容，而是创建新文件\n    2. 修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名，\n    3. 删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除\n  - 可执行权限x\n    1. 没有可读权限r则不能进入目录\n    2. 没有可写权限w则无法创建新文件\n\n# 2.24 chgrp更改文件用户组\n\n  此命令被`chown`取代，用法和参数都和`chown`命令相同\n\n# 2.25 umask显示或设置权限掩码\n\n  umask是通过八进制的数值来定义用户创建文件或目录的默认权限\n\n  语法格式\n\n  ~~~\n  umask [选项] [模式]\n  ~~~\n\n  | 选项 | 说明                               |\n  |------|------------------------------------|\n  | -p   | 输出的权限掩码可直接作为命令来执行 |\n  | -S   | 以字符的方式输出权限掩码           |\n\n## 2.25.2 通过umask计算文件目录权限\n\n  __文件权限的计算__\n\n  创建文件默认的最大权限为666，也就是说没有可执行权限x.\n\n  umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。\n\n  例子:\n\n  假如umask值为:022，那么:\n  ~~~\n  6 6 6 文件默认的权限\n  0 2 2 umask值\n- =====\n  6 4 4 都为偶数，最终结果为644\n  ~~~\n\n  假如umask值为:045，那么:\n  ~~~\n    6 6 6 文件默认的权限\n    0 4 5 umask值\n- =====\n    6 2 1 其他用户权限位为奇数，所以+1\n    0 0 1\n+ =====\n    6 2 2 都为偶数，最终结果为622\n  ~~~\n  \n  __目录权限的计算__\n\n  _目录权限的计算没有奇偶之分_\n\n  创建目录是默认的最大权限为777(-rwx-rwx-rwx)\n\n  计算方法和文件权限计算方法相同\n\n  例子:\n  \n  假如umask值为:022，那么:\n  ~~~\n    7 7 7 目录默认最大权限\n    0 2 2 umask值\n  - =====\n    7 5 5 得到最终结果\n  ~~~\n\n  __查看系统默认的umask值__\n\n  ~~~\n  # 普通用户的默认umask值\n  evanmeek > umask\n  022\n  # 超级用户的默认umask值\n  root > umask\n  0022\n  ~~~\n\n  __-S参数的使用__\n\n  ~~~\n  > umask -S\n  u=rwx,g=rx,o=rx\n  ~~~\n\n  __-p参数的使用__\n\n  ~~~\n  > umask -p\n  umask 0022\n  ~~~\n\n  __临时修改umask值__\n\n  ~~~\n  # 修改umask之前\n  > umask\n  > ls -l file1\n  -rw-r--r-- 1 evanmeek evanmeek 0  6月 30 19:11 file1\n  # 修改umask之后\n  > umask 044\n  > umask\n  044\n  > touch file2\n  > ls -l file1\n  -rw--w--w- 1 evanmeek evanmeek 0  6月 30 19:12 file2\n  ~~~\n\n  __永久修改umask值__\n\n  _若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。_\n\n  编辑`/etc/profile`或者`/etc/bashrc`\n\n  找到`umask`项修改即可\n","slug":"Linux-文件和目录操作命令-1","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc5002domoor37oi8c3","content":"<h1 id=\"2-0-老男孩新手成为技术大牛心法\"><a href=\"#2-0-老男孩新手成为技术大牛心法\" class=\"headerlink\" title=\"2.0 老男孩新手成为技术大牛心法\"></a>2.0 老男孩新手成为技术大牛心法</h1><p>执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。</p>\n<p>专注: 只做一件事。两耳不闻其他事，一心只读运维书。</p>\n<p>自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。</p>\n<p>心态: 保持空杯，重视基础；基础不牢，地动山摇。</p>\n<h1 id=\"2-1-pwd命令\"><a href=\"#2-1-pwd命令\" class=\"headerlink\" title=\"2.1 pwd命令\"></a>2.1 pwd命令</h1><p>  <code>print working diretory</code></p>\n<p>  <strong>查看当前路径使用<code>pwd</code>命令</strong></p>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ pwd</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/evanmeek</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-L</td>\n<td>显示当前目录的逻辑路径(忽略软链接文件)</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>显示当前目录的物理路径(若有软链接则显示源文件地址)</td>\n</tr>\n</tbody>\n</table>\n<p>  所谓的软链接相当于快捷方式，例如<code>~/test.txt</code>是<code>/test.txt</code>的软链接，那么我们操作<code>~/test.txt</code>等同于操作<code>/test.txt</code>，详细的软链接将会在后面的<code>ln</code>命令讲解。</p>\n<h1 id=\"2-2-cd-切换目录\"><a href=\"#2-2-cd-切换目录\" class=\"headerlink\" title=\"2.2 cd 切换目录\"></a>2.2 cd 切换目录</h1><p>  <code>change directory</code></p>\n<p>  <strong>进入某个目录使用<code>cd</code>命令</strong></p>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/sysctl.d/]$ pwd</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/evanmeek/</span><br><span class=\"line\">/etc/sysctl.d/</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-P</td>\n<td>进入目录的物理路径</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>进入目录的逻辑路径</td>\n</tr>\n<tr>\n<td>-</td>\n<td>进入上次的目录</td>\n</tr>\n<tr>\n<td>~</td>\n<td>进入系统环境变量的<code>HOME</code>目录路径，即当前登录用户的家目录`</td>\n</tr>\n<tr>\n<td>..</td>\n<td>进入父目录</td>\n</tr>\n</tbody>\n</table>\n<p>  <code>cd</code> 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录.</p>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ cd Desktop</span><br><span class=\"line\">[evanmeek@EvanLinux ~/Desktop]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd -</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd /etc/systemd/</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/systemd/]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/systemd/]$ cd ..</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/]$ pwd</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/</span><br><span class=\"line\">~</span><br><span class=\"line\">/etc/systemd/</span><br><span class=\"line\">/etc/</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-3-tree以树形结构显示目录下的内容\"><a href=\"#2-3-tree以树形结构显示目录下的内容\" class=\"headerlink\" title=\"2.3 tree以树形结构显示目录下的内容\"></a>2.3 tree以树形结构显示目录下的内容</h1><p>  <strong>树形结构可以很清晰的显示出目录的父子级关系</strong></p>\n<p>  例子:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/test]$ tree -L 1</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   ├── dir1_1</span><br><span class=\"line\">│   └── dir2_2</span><br><span class=\"line\">└── dir2</span><br><span class=\"line\">    ├── dir1_1</span><br><span class=\"line\">    └── dir2_2</span><br><span class=\"line\"></span><br><span class=\"line\">6 directories, 0 files</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a</td>\n<td>显示所有文件包括隐藏文件</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>只显示目录<code>!</code></td>\n</tr>\n<tr>\n<td>-f</td>\n<td>显示每个文件的绝对路径</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>不显示树枝</td>\n</tr>\n<tr>\n<td>-L levelNum</td>\n<td>显示遍历目录的层级，levelNum为层级(数字)</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>显示时根据不同文件类型在文件名结尾处显示不同的符号</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  显示隐藏文件<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#假设此目录下有隐藏文件</span><br><span class=\"line\">[evanmeek@EvanLinux ~/tmp]$ tree -a</span><br></pre></td></tr></table></figure></p>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   ├── dir1_1</span><br><span class=\"line\">│   └── dir2_2</span><br><span class=\"line\">├── dir2</span><br><span class=\"line\">│   ├── dir1_1</span><br><span class=\"line\">│   └── dir2_2</span><br><span class=\"line\">├── .file1</span><br><span class=\"line\">└── .file2</span><br><span class=\"line\"></span><br><span class=\"line\">6 directories, 2 files</span><br></pre></td></tr></table></figure>\n<p>  例子:</p>\n<p>  显示1级层文件完整路径，并不显示树枝<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi .</span><br></pre></td></tr></table></figure></p>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">./dir1</span><br><span class=\"line\">./dir2</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-4-mkdir创建目录\"><a href=\"#2-4-mkdir创建目录\" class=\"headerlink\" title=\"2.4 mkdir创建目录\"></a>2.4 mkdir创建目录</h1><p>  <code>make directory</code></p>\n<p>  <strong>创建目录使用<code>mkdir</code>命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>递归创建目录，若目录已存在不会报错</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>创建时指定目录的权限</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>创建时显示过程信息</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  创建目录时显示信息<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -v testDir</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd testDir</span><br><span class=\"line\">[evanmeek@EvanLinux ~/testDir]$ pwd</span><br></pre></td></tr></table></figure></p>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;testDir&apos;</span><br></pre></td></tr></table></figure>\n<p>  递归创建目录并且显示信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -pv father/son/test</span><br></pre></td></tr></table></figure>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;father&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son/test&apos;</span><br></pre></td></tr></table></figure>\n<p>  创建目录并且指定目录权限</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ls -ld testDir</span><br></pre></td></tr></table></figure>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;testDir&apos;</span><br><span class=\"line\">d-wx-wx-wx 2 evanmeek evanmeek 4096  6月 17 20:15 testDir</span><br></pre></td></tr></table></figure>\n<p>  利用特殊符号“{}”同时创建多目录及多子目录</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -pv father/&#123;son1/&#123;a1,a2&#125;,son2/&#123;b1,b2&#125;,son3/&#123;c1,c2&#125;&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ tree father</span><br></pre></td></tr></table></figure>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;father&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son1/a1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son1/a2&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son2&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son2/b1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son2/b2&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son3&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son3/c1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son3/c2&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">father</span><br><span class=\"line\">├── son1</span><br><span class=\"line\">│   ├── a1</span><br><span class=\"line\">│   └── a2</span><br><span class=\"line\">├── son2</span><br><span class=\"line\">│   ├── b1</span><br><span class=\"line\">│   └── b2</span><br><span class=\"line\">└── son3</span><br><span class=\"line\">    ├── c1</span><br><span class=\"line\">    └── c2</span><br><span class=\"line\"></span><br><span class=\"line\">9 directories, 0 files</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-5-touch创建空文件或改变文件的时间戳属性\"><a href=\"#2-5-touch创建空文件或改变文件的时间戳属性\" class=\"headerlink\" title=\"2.5 touch创建空文件或改变文件的时间戳属性\"></a>2.5 touch创建空文件或改变文件的时间戳属性</h1><p>  <strong>创建新的空文件，改变文件的时间戳属性，需要用到touch</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a</td>\n<td>更改指定文件的最新访问时间</td>\n</tr>\n<tr>\n<td>-d STRING</td>\n<td>用字符串的方式指定一个模板作为指定文件的时间属性</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>更改指定文件的最新修改时间</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>将指定文件的时间属性设置为file的时间属性</td>\n</tr>\n<tr>\n<td>-t STAMP</td>\n<td>使用时间格式设置文件的时间属性</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  创建文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch test.txt</span><br></pre></td></tr></table></figure>\n<p>  同时创建多个文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch test1.txt test2.txt</span><br></pre></td></tr></table></figure>\n<p>  利用{}批量创建文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch t&#123;01..05&#125;.txt</span><br></pre></td></tr></table></figure>\n<p>  利用<code>stat</code>命令查看时间戳</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n<p>  <strong>时间戳属性说明:</strong></p>\n<ul>\n<li><p>Access 访问属性</p>\n</li>\n<li><p>Modify 修改属性</p>\n</li>\n<li><p>Birth 状态改变属性</p>\n<p>利用-a选项修改文件最后访问属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch -a t01.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>输出信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2019-06-17 21:44:27.210736590 +0800</span><br><span class=\"line\">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:44:27.210736590 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n<p>修改文件的修改时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>输出信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2001-01-01 00:00:00.000000000 +0800</span><br><span class=\"line\">Modify: 2001-01-01 00:00:00.000000000 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:48:26.700992172 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n<p>修改指定文件为某文件的时间属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t02.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:51:35.907031392 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"2-6-ls显示目录下的内容及相关属性信息\"><a href=\"#2-6-ls显示目录下的内容及相关属性信息\" class=\"headerlink\" title=\"2.6 ls显示目录下的内容及相关属性信息\"></a>2.6 ls显示目录下的内容及相关属性信息</h1><p>  <code>list directory contents</code></p>\n<p>  例子:</p>\n<p>  查看当前目录下的文件信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ls</span><br></pre></td></tr></table></figure>\n<p>  输出结果</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Applications  Desktop  Downloads  GameDir  index.html  Music  Pictures  temp  WorkDir</span><br></pre></td></tr></table></figure>\n<p>  每个人的目录里面的内容不同，所以可能不一样。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-l</td>\n<td>使用长格式列出目录下的文件和信息</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>显示目录下的所有文件，包括隐藏文件<code>!</code></td>\n</tr>\n<tr>\n<td>-t</td>\n<td>根据最新的修改时间排序，不加此参数默认是根据文件名排序<code>!</code></td>\n</tr>\n<tr>\n<td>-r</td>\n<td>反向排序</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>在显示的条目后加上特殊符号用以区别文件类型<code>!</code></td>\n</tr>\n<tr>\n<td>-p</td>\n<td>目录后面加上“/”</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>显示inode节点信息</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>遇到目录时，只列出目录本身，并且不跟随符号链接<code>!</code></td>\n</tr>\n<tr>\n<td>-h</td>\n<td>以人类可读的信息显示文件或目录大小</td>\n</tr>\n<tr>\n<td>-A</td>\n<td>列出所有文件，包括隐藏文件夹，但不包括.和..</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>根据文件大小排序</td>\n</tr>\n<tr>\n<td>-R</td>\n<td>递归列出所有子目录</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>逐行列出项目而不是逐栏列出</td>\n</tr>\n<tr>\n<td>-X</td>\n<td>根据扩展名排序</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>根据状态改变时间排序</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>根据最后访问时间排序</td>\n</tr>\n<tr>\n<td>–color={never,always,auto}</td>\n<td>根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示</td>\n</tr>\n<tr>\n<td>–full-time</td>\n<td>以完整的时间格式进行显示</td>\n</tr>\n<tr>\n<td>–time-style={full-iso,long-iso,iso,locale}</td>\n<td>以不同的时间格式输出，long-iso最常用</td>\n</tr>\n<tr>\n<td>–time={atime,ctimeA}</td>\n<td>按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  环境准备</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir temp</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd temp</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -p father/dir&#123;01..02&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/txt&#123;01..02&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/.txt&#123;01..02&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ tree -a</span><br></pre></td></tr></table></figure>\n<p>  输出结果</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  .</span><br><span class=\"line\">  └── father</span><br><span class=\"line\">      ├── dir01</span><br><span class=\"line\">      │   ├── .txt01</span><br><span class=\"line\">      │   ├── txt01</span><br><span class=\"line\">      │   ├── .txt02</span><br><span class=\"line\">      │   └── txt02</span><br><span class=\"line\">      └── dir02</span><br><span class=\"line\">          ├── .txt01</span><br><span class=\"line\">          ├── txt01</span><br><span class=\"line\">          ├── .txt02</span><br><span class=\"line\">          └── txt02</span><br><span class=\"line\"></span><br><span class=\"line\">3 directories, 8 files</span><br></pre></td></tr></table></figure>\n<p>  递归显示所有文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.:</span><br><span class=\"line\">.  ..  father</span><br><span class=\"line\"></span><br><span class=\"line\">./father:</span><br><span class=\"line\">.  ..  dir01  dir02</span><br><span class=\"line\"></span><br><span class=\"line\">./father/dir01:</span><br><span class=\"line\">.  ..  .txt01  txt01  .txt02  txt02</span><br><span class=\"line\"></span><br><span class=\"line\">./father/dir02:</span><br><span class=\"line\">.  ..  .txt01  txt01  .txt02  txt02</span><br></pre></td></tr></table></figure>\n<p> <strong>ls命令输出属性解释</strong></p>\n<p>  目录内容如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dir01</span><br><span class=\"line\">├── dir02</span><br><span class=\"line\">├── file01.txt</span><br><span class=\"line\">└── file02.txt</span><br><span class=\"line\"></span><br><span class=\"line\">2 directories, 2 files</span><br></pre></td></tr></table></figure>\n<p>  长格式列出人类可读信息并显示inode信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ls -lhi</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total 8.0K</span><br><span class=\"line\">18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir01</span><br><span class=\"line\">18219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir02</span><br><span class=\"line\">18219054 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file01.txt</span><br><span class=\"line\">18219055 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file02.txt</span><br></pre></td></tr></table></figure>\n<p>  从第一列依次往后排，分别含义为:</p>\n<ol>\n<li>inode索引节点编号</li>\n<li>文件类型以及属性(第一字符标注类型，后9个代表权限)</li>\n<li>硬链接个数</li>\n<li>文件或目录所属用户</li>\n<li>文件或目录所属的组</li>\n<li>文件或目录的大小</li>\n<li>修改时间</li>\n<li>文件名或目录名</li>\n</ol>\n<h1 id=\"2-7-cp复制文件或目录\"><a href=\"#2-7-cp复制文件或目录\" class=\"headerlink\" title=\"2.7 cp复制文件或目录\"></a>2.7 cp复制文件或目录</h1><p>  <code>copy</code></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>复制文件时保存源文件的所有者、权限信息及时间属性</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归复制目录，即目录下所有的子目录及文件</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>等同于上面的p、d、r这3个选项功能的总和</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>覆盖已有文件前提示用户确认</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>调换命令格式，默认格式是”cp 源文件 目标文件”，将目标文件和源文件进行位置调换</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  环境准备</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">└── fatherDir</span><br><span class=\"line\">    ├── sonDir1</span><br><span class=\"line\">    │   └── test.txt</span><br><span class=\"line\">    ├── sonDir2</span><br><span class=\"line\">    │   └── test.txt</span><br><span class=\"line\">    └── sonDir3</span><br><span class=\"line\">        └── test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">4 directories, 3 files</span><br></pre></td></tr></table></figure>\n<p>  拷贝<code>fatherDir</code>为<code>father2Dir</code>并保留源文件的所有者，权限信息及时间属性</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir</span><br></pre></td></tr></table></figure>\n<p>  再次拷贝<code>fatherDir</code>为<code>father2Dir</code>从而覆盖上个例子的<code>father2Dir</code></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir1/test.txt&apos;？ y</span><br><span class=\"line\">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir2/test.txt&apos;？ y</span><br><span class=\"line\">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir3/test.txt&apos;？ y</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-8-mv移动或重命名文件\"><a href=\"#2-8-mv移动或重命名文件\" class=\"headerlink\" title=\"2.8 mv移动或重命名文件\"></a>2.8 mv移动或重命名文件</h1><p>  <code>move</code><br>  | 选项 | 说明                                                       |<br>  |——|————————————————————|<br>  | -f   | 若目标文件已存在，不询问直接覆盖                           |<br>  | -i   | 若目标文件已存在，询问是否覆盖                             |<br>  | -n   | 不覆盖已存在的文件                                         |<br>  | -t   | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 |<br>  | -u   | 源文件比目标文件新，或目标文件不存在时再移动               |</p>\n<p>  例子:</p>\n<p>  环境准备</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test0.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt</span><br></pre></td></tr></table></figure>\n<p>  更换文件名</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanMeek ~]$mv test0.txt test-1.txt</span><br><span class=\"line\">[evanmeek@EvanMeek ~]$ls -l --full-time</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test-1.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt</span><br></pre></td></tr></table></figure>\n<p>  <strong>移动文件</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mv test-1.txt testTxt</span><br></pre></td></tr></table></figure>\n<p>  <strong>移动多个文件至一个目录</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-9-rm删除文件或目录\"><a href=\"#2-9-rm删除文件或目录\" class=\"headerlink\" title=\"2.9 rm删除文件或目录\"></a>2.9 rm删除文件或目录</h1><p>  <strong>前排提示:使用rm命令时最好知道自己在干什么!</strong></p>\n<p>  <code>remove</code></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-f</td>\n<td>强制删除并且忽略不存在文件的提示</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>删除时需要确认</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>删除三个以上文件或者递归删除前需要确认</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归删除目录以及其内容<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现)</strong></p>\n<p>  环境准备<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── test2Txt</span><br><span class=\"line\">│   ├── test1.txt</span><br><span class=\"line\">│   ├── test2.txt</span><br><span class=\"line\">│   └── testTxt</span><br><span class=\"line\">│       └── test-1.txt</span><br><span class=\"line\">└── test3.txt</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>删除文件</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm test3.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>强制删除并且删除时需要确认</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm：是否删除普通空文件 &apos;test2Txt/test2.txt&apos;？</span><br></pre></td></tr></table></figure>\n<p>  <strong>删除目录并且删除时需要确认</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt</span><br></pre></td></tr></table></figure>\n<p>  <strong>强制删除+递归删除目录</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -rf test2Txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf /*</span><br></pre></td></tr></table></figure>\n<p>  <strong>这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内.</strong></p>\n<h2 id=\"删除时的小技巧\"><a href=\"#删除时的小技巧\" class=\"headerlink\" title=\"删除时的小技巧\"></a>删除时的小技巧</h2><ul>\n<li><p>使用<code>mv</code>命令代替<code>rm</code>命令，可以将要删除的文件暂时保存在<code>/tmp</code>目录下，需要清理空间时再去删除</p>\n</li>\n<li><p>删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原</p>\n</li>\n<li><p>若非要用删除命令清理空间可以选择用<code>find</code>代替<code>rm</code></p>\n</li>\n<li><p>删除时尽量不要使用系统通配符</p>\n</li>\n</ul>\n<h1 id=\"2-10-rmdir删除空目录\"><a href=\"#2-10-rmdir删除空目录\" class=\"headerlink\" title=\"2.10 rmdir删除空目录\"></a>2.10 rmdir删除空目录</h1><p>  <code>remove dirctory</code></p>\n<p>  此命令只能删除空目录</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>删除时显示执行过程</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"2-11-ln硬链接与软链接\"><a href=\"#2-11-ln硬链接与软链接\" class=\"headerlink\" title=\"2.11 ln硬链接与软链接\"></a>2.11 ln硬链接与软链接</h1><p>  <code>link</code></p>\n<p>  链接分为两种，分别是硬链接与软链接</p>\n<p>  硬链接(hard link):</p>\n<ul>\n<li><p>不能将硬链接链接到不同文件系统的文件</p>\n</li>\n<li><p>硬链接不能链接目录</p>\n</li>\n<li><p>删除硬链接或者源文件之一并不能完全删除实体</p>\n</li>\n<li><p>删除实体需要删除硬链接以及起对应的源文件</p>\n</li>\n<li><p>硬链接相当与源文件的另外一个入口</p>\n</li>\n<li><p>对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除</p>\n</li>\n<li><p>硬链接的文件类型是普通文件(字符型)</p>\n</li>\n<li><p>硬链接通过索引节点进行链接</p>\n<p>例子:</p>\n<p>创建硬链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt</span><br></pre></td></tr></table></figure>\n<p>软链接(Symbolic Link):</p>\n</li>\n<li><p>类似于Windows的快捷方式</p>\n</li>\n<li><p>文件内存放的是源文件的路径</p>\n</li>\n<li><p>即使删除源文件，软链接仍然存在，但无法访问源文件</p>\n</li>\n<li><p>源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示</p>\n</li>\n<li><p>软链接可以用rm命令删除</p>\n<p>例子:</p>\n<p><strong>创建软链接</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"文件链接案例\"><a href=\"#文件链接案例\" class=\"headerlink\" title=\"文件链接案例\"></a>文件链接案例</h2><p>  通过一个案例演示软链接和硬链接的区别。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile</span><br><span class=\"line\">123</span><br><span class=\"line\"># 创建硬链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink</span><br><span class=\"line\"># 创建软链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\"># 删除软链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile testHardLink</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\"># 复原</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink</span><br><span class=\"line\"># 删除硬链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -f testFileHardLink</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile testFileHardLink</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\"># 复原</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink</span><br><span class=\"line\"># 删除源文件</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -f testFile</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink</span><br><span class=\"line\">123</span><br><span class=\"line\">cat: testFileSymbolicLink: 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>硬链接可以没有源文件</p>\n</li>\n<li><p>软链接不行</p>\n</li>\n</ul>\n<h1 id=\"2-12-readlink-查看符号链接文件的内容\"><a href=\"#2-12-readlink-查看符号链接文件的内容\" class=\"headerlink\" title=\"2.12 readlink 查看符号链接文件的内容\"></a>2.12 readlink 查看符号链接文件的内容</h1><p>  此命令可查看链接指向的源文件的地址</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-f</td>\n<td>一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行</td>\n</tr>\n</tbody>\n</table>\n<p>  例子：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-13-find-查找目录下的文件\"><a href=\"#2-13-find-查找目录下的文件\" class=\"headerlink\" title=\"2.13 find 查找目录下的文件\"></a>2.13 find 查找目录下的文件</h1><p>  由于本篇篇幅较大，请点击下方超链接进行访问。</p>\n<p>  <a href=\"/2019/6/21/Linux-文件和目录操作命令-find命令\">点击访问</a></p>\n<h1 id=\"2-14-xargs将标准输入转换成命令行参数\"><a href=\"#2-14-xargs将标准输入转换成命令行参数\" class=\"headerlink\" title=\"2.14 xargs将标准输入转换成命令行参数\"></a>2.14 xargs将标准输入转换成命令行参数</h1><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n</td>\n<td>指定每行命令的最大参数数量，每个参数由空格隔开</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>自定义分割符</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>以{}替代xargs命令之前的结果</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>指定一个符号替代前面的结果，而不是使用默认的{}</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>提示让用户确认是否执行后面的命令，y执行，n不执行</td>\n</tr>\n<tr>\n<td>-0</td>\n<td>用null替代空格作为分割符，配合find命令的-printf0选项的输出使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-14-2使用范例\"><a href=\"#2-14-2使用范例\" class=\"headerlink\" title=\"2.14.2使用范例\"></a>2.14.2使用范例</h2><p>  <strong>多行输入变单行</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">1 2 3 4 </span><br><span class=\"line\">5 6 7</span><br><span class=\"line\">8 9</span><br><span class=\"line\">1 </span><br><span class=\"line\">&gt; xargs &lt; test.txt</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 1</span><br></pre></td></tr></table></figure>\n<p>  <strong>通过-n指定每行的输出个数</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; xargs -n 2 &lt; test.txt</span><br><span class=\"line\">1 2</span><br><span class=\"line\">3 4</span><br><span class=\"line\">5 6</span><br><span class=\"line\">7 8</span><br><span class=\"line\">9 1</span><br></pre></td></tr></table></figure>\n<p>  <strong>自定义分隔符(使用-d功能)</strong><br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; echo 123I321I809I098</span><br><span class=\"line\">123I321I809I098</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; echo 123I321I809I098|xargs -d I -n 2</span><br><span class=\"line\">123 321</span><br><span class=\"line\">890 098</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>指定一个替换字符串</strong><br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将查找出来的结果删除</span><br><span class=\"line\"># 先将结果传给&#123;&#125;</span><br><span class=\"line\"># 再会被删除</span><br><span class=\"line\">&gt; find . -name &quot;*.log&quot;|xargs -i rm -rf &#123;&#125;</span><br><span class=\"line\"># 自定义替换字符串</span><br><span class=\"line\">&gt; find . -name &quot;*.log&quot;|xargs -I [] rm -rf []</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-15-rename重命名\"><a href=\"#2-15-rename重命名\" class=\"headerlink\" title=\"2.15 rename重命名\"></a>2.15 rename重命名</h1><p>  rename通过替换字符串的方式批量修改文件名</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rename from to file</span><br></pre></td></tr></table></figure>\n<p>  例子:</p>\n<p>  <strong>批量修改文件名</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">test_demo_0  test_demo_1  test_demo_2  test_demo_3  test_demo_4  test_demo_5</span><br><span class=\"line\">&gt; rename &quot;_demo&quot; &quot;&quot; *</span><br><span class=\"line\">&gt; ls</span><br><span class=\"line\">test_0  test_1  test_2  test_3  test_4  test_5</span><br></pre></td></tr></table></figure>\n<p>  <strong>批量修改文件扩展名</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">test0.txt  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class=\"line\">&gt; rename .txt .demo *</span><br><span class=\"line\">&gt; ls</span><br><span class=\"line\">test0.demo  test1.demo  test2.demo  test3.demo  test4.demo  test5.demo</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-16-basename显示文件名或目录名\"><a href=\"#2-16-basename显示文件名或目录名\" class=\"headerlink\" title=\"2.16 basename显示文件名或目录名\"></a>2.16 basename显示文件名或目录名</h1><p>  basename命令用于显示去除路径和文件后缀的文件名或目录名</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basename [&lt;文件或目录&gt;] [后缀]</span><br></pre></td></tr></table></figure>\n<p>  其中的后缀为可选</p>\n<p>  例子:</p>\n<p>  <strong>只显示文件名和后缀，不显示完整路径</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mkdir -p dir1/dir2/</span><br><span class=\"line\">&gt; touch dir1/dir2/test.txt</span><br><span class=\"line\">&gt; basename dir1/dir2/test.txt</span><br><span class=\"line\">test.txt</span><br></pre></td></tr></table></figure>\n<p>  只显示文件名，不显示完整路径制定不显示某个后缀</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; touch dir1/dir2/test.demo.txt</span><br><span class=\"line\">&gt; basename dir1/dir2/test.demo.txt .txt</span><br><span class=\"line\">test.demo</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-17-dirname显示文件或目录的路径\"><a href=\"#2-17-dirname显示文件或目录的路径\" class=\"headerlink\" title=\"2.17 dirname显示文件或目录的路径\"></a>2.17 dirname显示文件或目录的路径</h1><p>  dirname命令用于只显示文件或目录的路径</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dirname [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<p>  例子:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dirname dir1/dir2/test.txt</span><br><span class=\"line\">dir1/dir2</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-18-chattr改变文件的扩展属性\"><a href=\"#2-18-chattr改变文件的扩展属性\" class=\"headerlink\" title=\"2.18 chattr改变文件的扩展属性\"></a>2.18 chattr改变文件的扩展属性</h1><p>  charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的．</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr [选项] [模式] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<p>  提示:<code>lsattr</code>命令可以查看文件的属性</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归更改目录属性</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示执行过程</td>\n</tr>\n<tr>\n<td>mode</td>\n<td></td>\n</tr>\n<tr>\n<td>+</td>\n<td>增加参数</td>\n</tr>\n<tr>\n<td>-</td>\n<td>移除参数</td>\n</tr>\n<tr>\n<td>=</td>\n<td>更新为指定参数</td>\n</tr>\n<tr>\n<td>A</td>\n<td>指定文件的最后访问时间不可修改</td>\n</tr>\n<tr>\n<td>a</td>\n<td>指定文件只能添加数据，无法删除数据<code>!</code></td>\n</tr>\n<tr>\n<td>!</td>\n<td>指定文件不能被删除，重命名，写入或新增内容</td>\n</tr>\n</tbody>\n</table>\n<p>  例子：</p>\n<p>  <strong>给文件加锁，使其只能为只读</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; chattr +i test.txt</span><br><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">----i---------e----- test.txt</span><br><span class=\"line\">&gt; echo a1111 &gt; test.txt</span><br><span class=\"line\">zsh: 不允许的操作: test.txt</span><br><span class=\"line\">&gt; echo b2222 &gt;&gt; test.txt </span><br><span class=\"line\">zsh: 不允许的操作: test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>给文件解锁</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; charttr -i test.txt</span><br><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">--------------e----- test.txt</span><br><span class=\"line\">&gt; eco 111 &gt; test.txt</span><br><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">111</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-19-lsattr查看文件扩展属性\"><a href=\"#2-19-lsattr查看文件扩展属性\" class=\"headerlink\" title=\"2.19 lsattr查看文件扩展属性\"></a>2.19 lsattr查看文件扩展属性</h1><p>  lsattr命令用于查看文件扩展属</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsattr [选项] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归查看目录的扩展属性</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>显示所有文件的扩展属性</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>显示目录的扩展属性</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>查看文件的扩展属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">--------------e----- test.txt</span><br><span class=\"line\">&gt; chattr +i test.txt</span><br><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">----i---------e----- test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>查看目录的扩展属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lsattr -d testDir</span><br><span class=\"line\">--------------e----- testDir</span><br><span class=\"line\">&gt; chattr +i testDir</span><br><span class=\"line\">&gt; lsattr -d testDir</span><br><span class=\"line\">----i---------e----- testDir</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-20-file显示文件的类型\"><a href=\"#2-20-file显示文件的类型\" class=\"headerlink\" title=\"2.20 file显示文件的类型\"></a>2.20 file显示文件的类型</h1><p>  file命令用于显示文件的类型</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file [选项] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>输出信息使用精简格式</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>查看文件类型</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; file test.txt</span><br><span class=\"line\">test.txt: empty</span><br><span class=\"line\">&gt; file *</span><br><span class=\"line\">test.txt:      empty</span><br><span class=\"line\">test.txt.link: symbolic link to test.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-21-md5sum计算和校验文件的MD5值\"><a href=\"#2-21-md5sum计算和校验文件的MD5值\" class=\"headerlink\" title=\"2.21 md5sum计算和校验文件的MD5值\"></a>2.21 md5sum计算和校验文件的MD5值</h1><p>  md5sum命令用于计算和校验文件的MD5值.</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md5sum [选项] [文件]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>二进制模式读取文件</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>从指定文件中读取MD5校验值，并进行校验</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>文本模式读取文件，默认</td>\n</tr>\n<tr>\n<td>–quiet</td>\n<td>校验文件时，若通过不输出OK</td>\n</tr>\n<tr>\n<td>–status</td>\n<td>校验文件时，不输出任何信息，但可通过命令的返回值判断</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>生成一个文件的MD5值</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; md5sum test.txt</span><br><span class=\"line\">d41d8cd98f00b204e9800998ecf8427e  test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>校验文件MD5值是否发生改变</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; md5sum test.txt &gt; md5.log</span><br><span class=\"line\">&gt; cat md5.log</span><br><span class=\"line\">d41d8cd98f00b204e9800998ecf8427e  test.txt</span><br><span class=\"line\">&gt; md5sum -c md5.log</span><br><span class=\"line\">test.txt: 成功</span><br><span class=\"line\">&gt; echo &quot;update&quot; &gt;&gt; test.txt</span><br><span class=\"line\">&gt; md5sum -c md5.log</span><br><span class=\"line\">test.txt: 失败</span><br><span class=\"line\">md5sum: 警告：1 个校验和不匹配</span><br><span class=\"line\">&gt; md5sum --status -c md5.log</span><br><span class=\"line\">&gt; echo $?</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-22-chown改变文件或目录的用户和用户组\"><a href=\"#2-22-chown改变文件或目录的用户和用户组\" class=\"headerlink\" title=\"2.22 chown改变文件或目录的用户和用户组\"></a>2.22 chown改变文件或目录的用户和用户组</h1><p>  chown命令用于改变文件或目录的用户和用户组</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown [选项] [用户:用户组] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归更改目录的用户和用户组</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>更改文件所属的用户属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l test.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root 5  6月 27 00:31 test.txt</span><br><span class=\"line\"># 授予权限的用户必须存在</span><br><span class=\"line\">&gt; chown xxx test.txt</span><br><span class=\"line\">chown: 无效的用户: “xxx”</span><br><span class=\"line\">&gt; chown evanmeek test.txt</span><br><span class=\"line\">&gt; ls -l test.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek root 5  6月 27 00:31 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>更改文件所属用户组的属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt</span><br><span class=\"line\">&gt; chown .root test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek root 5  6月 27 00:34 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>同时更改文件的用户和用户组属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; chown evanmeek:evanmeek test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>递归更改目录下所有文件及目录的用户和用户组属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── dir0</span><br><span class=\"line\">│   └── test.txt</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   └── test.txt</span><br><span class=\"line\">└── dir2</span><br><span class=\"line\">    └── test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">3 directories, 3 files</span><br><span class=\"line\">&gt; chown -R root:root .</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 12K</span><br><span class=\"line\">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir0</span><br><span class=\"line\">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir1</span><br><span class=\"line\">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir2</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-23chmod改变文件或目录权限\"><a href=\"#2-23chmod改变文件或目录权限\" class=\"headerlink\" title=\"2.23chmod改变文件或目录权限\"></a>2.23chmod改变文件或目录权限</h1><p>  只有文件的属主以及超级用户<code>root</code>才能执行此命令</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod [选项] [模式] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归指定目录以及子目录的权限</td>\n</tr>\n</tbody>\n</table>\n<p>  权限对应表</p>\n<table>\n<thead>\n<tr>\n<th>权限位</th>\n<th>全称</th>\n<th>含义</th>\n<th>对应数字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>read</td>\n<td>可读权限</td>\n<td>4</td>\n</tr>\n<tr>\n<td>w</td>\n<td>write</td>\n<td>可写权限</td>\n<td>2</td>\n</tr>\n<tr>\n<td>x</td>\n<td>execute</td>\n<td>可执行权限</td>\n<td>1</td>\n</tr>\n<tr>\n<td>-</td>\n<td></td>\n<td>没有任何权限</td>\n<td>0</td>\n</tr>\n<tr>\n<td>备注</td>\n<td>一些特殊权限位:t,T,s,S,x,X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>文件所属用户:u(OwnerUser)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>文件所属用户组:g(Group)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>其他用户:o(Other)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>所有:a(ALL),等效于u,g,o的总和</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>操作字符</td>\n<td>+:添加/-:减去/=:设置</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>权限字母和操作符表达式</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br><span class=\"line\"># 给文件所属用户减去可写权限</span><br><span class=\"line\">&gt; chmod u-w test.txt</span><br><span class=\"line\"># 给用户所属用户组减去可读权限</span><br><span class=\"line\">&gt; chmod g-r test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-r-----r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br><span class=\"line\"># 给所有用户以及用户组都设置为可读可写可执行的权限</span><br><span class=\"line\">&gt; chmod a=rwx test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rwxrwxrwx 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>使用数字更改文件或目录权限</strong></p>\n<p>  先举个例子，有这么一个文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-rw---- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure>\n<p>  权限示意图</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前三个字符代表文件属主的权限</span><br><span class=\"line\">中间三个字符代表文件属组的权限</span><br><span class=\"line\">后三个字符代表其他用户的权限</span><br><span class=\"line\">-rw-rw---- evanmeek evanmeek test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660</strong></p>\n<p>  <em>因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660</em></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将test.txt文件的所有用户权限设置为可读可写可执行</span><br><span class=\"line\">&gt; chmod 777 test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">---------- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>使用数字递归更改文件或目录的权限</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── dir0</span><br><span class=\"line\">│   └── file.txt</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   └── file.txt</span><br><span class=\"line\">└── dir2</span><br><span class=\"line\">    └── file.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 12K</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2</span><br><span class=\"line\">&gt; chmod -R 777 dir&#123;0..2&#125;</span><br><span class=\"line\">总用量 12K</span><br><span class=\"line\">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0</span><br><span class=\"line\">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1</span><br><span class=\"line\">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2</span><br></pre></td></tr></table></figure>\n<p>  <strong>Linux普通文件的读，写，执行权限说明</strong><br>  | 权限    | 说明                       |<br>  |———|—————————-|<br>  | 可读r   | 表示具有读取文件内容的权限 |<br>  | 可写w   | 表示具有修改文件内容的权限 |<br>  | 可执行x | 表示具有执行文件的权限     |</p>\n<ul>\n<li><p>可写w</p>\n<ol>\n<li>如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo &gt;&gt;　的方式进行追加.</li>\n<li>删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里</li>\n</ol>\n</li>\n<li><p>可执行x</p>\n<ol>\n<li>要求文件本身是可执行的</li>\n<li>普通用户必须要有r权限才能够执行</li>\n<li>root用户即使没有r权限，只需要有x权限即可执行</li>\n<li>不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行</li>\n</ol>\n<p><strong>Linux目录的，写，执行权限说明</strong><br>| 权限    | 说明                                       |<br>|———|——————————————–|<br>| 可读r   | 表示具有浏览目录下文件以及子目录的权限     |<br>| 可写w   | 表示具有增加，删除或修改目录内文件名的权限 |<br>| 可执行x | 表示具有进入目录的权限                     |</p>\n</li>\n<li><p>可读r</p>\n<ol>\n<li>没有x权限不能进入至目录内</li>\n<li>ls列表可以看到所有文件名，不过会提示无法访问目录下的文件</li>\n<li>如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名</li>\n</ol>\n</li>\n<li><p>可写w</p>\n<ol>\n<li>增加的不是文件内容，而是创建新文件</li>\n<li>修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名，</li>\n<li>删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除</li>\n</ol>\n</li>\n<li>可执行权限x<ol>\n<li>没有可读权限r则不能进入目录</li>\n<li>没有可写权限w则无法创建新文件</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-24-chgrp更改文件用户组\"><a href=\"#2-24-chgrp更改文件用户组\" class=\"headerlink\" title=\"2.24 chgrp更改文件用户组\"></a>2.24 chgrp更改文件用户组</h1><p>  此命令被<code>chown</code>取代，用法和参数都和<code>chown</code>命令相同</p>\n<h1 id=\"2-25-umask显示或设置权限掩码\"><a href=\"#2-25-umask显示或设置权限掩码\" class=\"headerlink\" title=\"2.25 umask显示或设置权限掩码\"></a>2.25 umask显示或设置权限掩码</h1><p>  umask是通过八进制的数值来定义用户创建文件或目录的默认权限</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">umask [选项] [模式]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>输出的权限掩码可直接作为命令来执行</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>以字符的方式输出权限掩码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-25-2-通过umask计算文件目录权限\"><a href=\"#2-25-2-通过umask计算文件目录权限\" class=\"headerlink\" title=\"2.25.2 通过umask计算文件目录权限\"></a>2.25.2 通过umask计算文件目录权限</h2><p>  <strong>文件权限的计算</strong></p>\n<p>  创建文件默认的最大权限为666，也就是说没有可执行权限x.</p>\n<p>  umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。</p>\n<p>  例子:</p>\n<p>  假如umask值为:022，那么:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  6 6 6 文件默认的权限</span><br><span class=\"line\">  0 2 2 umask值</span><br><span class=\"line\">- =====</span><br><span class=\"line\">  6 4 4 都为偶数，最终结果为644</span><br></pre></td></tr></table></figure></p>\n<p>  假如umask值为:045，那么:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    6 6 6 文件默认的权限</span><br><span class=\"line\">    0 4 5 umask值</span><br><span class=\"line\">- =====</span><br><span class=\"line\">    6 2 1 其他用户权限位为奇数，所以+1</span><br><span class=\"line\">    0 0 1</span><br><span class=\"line\">+ =====</span><br><span class=\"line\">    6 2 2 都为偶数，最终结果为622</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>目录权限的计算</strong></p>\n<p>  <em>目录权限的计算没有奇偶之分</em></p>\n<p>  创建目录是默认的最大权限为777(-rwx-rwx-rwx)</p>\n<p>  计算方法和文件权限计算方法相同</p>\n<p>  例子:</p>\n<p>  假如umask值为:022，那么:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  7 7 7 目录默认最大权限</span><br><span class=\"line\">  0 2 2 umask值</span><br><span class=\"line\">- =====</span><br><span class=\"line\">  7 5 5 得到最终结果</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>查看系统默认的umask值</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 普通用户的默认umask值</span><br><span class=\"line\">evanmeek &gt; umask</span><br><span class=\"line\">022</span><br><span class=\"line\"># 超级用户的默认umask值</span><br><span class=\"line\">root &gt; umask</span><br><span class=\"line\">0022</span><br></pre></td></tr></table></figure>\n<p>  <strong>-S参数的使用</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; umask -S</span><br><span class=\"line\">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure>\n<p>  <strong>-p参数的使用</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; umask -p</span><br><span class=\"line\">umask 0022</span><br></pre></td></tr></table></figure>\n<p>  <strong>临时修改umask值</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 修改umask之前</span><br><span class=\"line\">&gt; umask</span><br><span class=\"line\">&gt; ls -l file1</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 0  6月 30 19:11 file1</span><br><span class=\"line\"># 修改umask之后</span><br><span class=\"line\">&gt; umask 044</span><br><span class=\"line\">&gt; umask</span><br><span class=\"line\">044</span><br><span class=\"line\">&gt; touch file2</span><br><span class=\"line\">&gt; ls -l file1</span><br><span class=\"line\">-rw--w--w- 1 evanmeek evanmeek 0  6月 30 19:12 file2</span><br></pre></td></tr></table></figure>\n<p>  <strong>永久修改umask值</strong></p>\n<p>  <em>若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。</em></p>\n<p>  编辑<code>/etc/profile</code>或者<code>/etc/bashrc</code></p>\n<p>  找到<code>umask</code>项修改即可</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2-0-老男孩新手成为技术大牛心法\"><a href=\"#2-0-老男孩新手成为技术大牛心法\" class=\"headerlink\" title=\"2.0 老男孩新手成为技术大牛心法\"></a>2.0 老男孩新手成为技术大牛心法</h1><p>执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。</p>\n<p>专注: 只做一件事。两耳不闻其他事，一心只读运维书。</p>\n<p>自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。</p>\n<p>心态: 保持空杯，重视基础；基础不牢，地动山摇。</p>\n<h1 id=\"2-1-pwd命令\"><a href=\"#2-1-pwd命令\" class=\"headerlink\" title=\"2.1 pwd命令\"></a>2.1 pwd命令</h1><p>  <code>print working diretory</code></p>\n<p>  <strong>查看当前路径使用<code>pwd</code>命令</strong></p>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ pwd</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/evanmeek</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-L</td>\n<td>显示当前目录的逻辑路径(忽略软链接文件)</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>显示当前目录的物理路径(若有软链接则显示源文件地址)</td>\n</tr>\n</tbody>\n</table>\n<p>  所谓的软链接相当于快捷方式，例如<code>~/test.txt</code>是<code>/test.txt</code>的软链接，那么我们操作<code>~/test.txt</code>等同于操作<code>/test.txt</code>，详细的软链接将会在后面的<code>ln</code>命令讲解。</p>\n<h1 id=\"2-2-cd-切换目录\"><a href=\"#2-2-cd-切换目录\" class=\"headerlink\" title=\"2.2 cd 切换目录\"></a>2.2 cd 切换目录</h1><p>  <code>change directory</code></p>\n<p>  <strong>进入某个目录使用<code>cd</code>命令</strong></p>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/sysctl.d/]$ pwd</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/evanmeek/</span><br><span class=\"line\">/etc/sysctl.d/</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-P</td>\n<td>进入目录的物理路径</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>进入目录的逻辑路径</td>\n</tr>\n<tr>\n<td>-</td>\n<td>进入上次的目录</td>\n</tr>\n<tr>\n<td>~</td>\n<td>进入系统环境变量的<code>HOME</code>目录路径，即当前登录用户的家目录`</td>\n</tr>\n<tr>\n<td>..</td>\n<td>进入父目录</td>\n</tr>\n</tbody>\n</table>\n<p>  <code>cd</code> 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录.</p>\n<p>  例子:</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ cd Desktop</span><br><span class=\"line\">[evanmeek@EvanLinux ~/Desktop]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd -</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd /etc/systemd/</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/systemd/]$ pwd</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/systemd/]$ cd ..</span><br><span class=\"line\">[evanmeek@EvanLinux /etc/]$ pwd</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/</span><br><span class=\"line\">~</span><br><span class=\"line\">/etc/systemd/</span><br><span class=\"line\">/etc/</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-3-tree以树形结构显示目录下的内容\"><a href=\"#2-3-tree以树形结构显示目录下的内容\" class=\"headerlink\" title=\"2.3 tree以树形结构显示目录下的内容\"></a>2.3 tree以树形结构显示目录下的内容</h1><p>  <strong>树形结构可以很清晰的显示出目录的父子级关系</strong></p>\n<p>  例子:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/test]$ tree -L 1</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   ├── dir1_1</span><br><span class=\"line\">│   └── dir2_2</span><br><span class=\"line\">└── dir2</span><br><span class=\"line\">    ├── dir1_1</span><br><span class=\"line\">    └── dir2_2</span><br><span class=\"line\"></span><br><span class=\"line\">6 directories, 0 files</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a</td>\n<td>显示所有文件包括隐藏文件</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>只显示目录<code>!</code></td>\n</tr>\n<tr>\n<td>-f</td>\n<td>显示每个文件的绝对路径</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>不显示树枝</td>\n</tr>\n<tr>\n<td>-L levelNum</td>\n<td>显示遍历目录的层级，levelNum为层级(数字)</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>显示时根据不同文件类型在文件名结尾处显示不同的符号</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  显示隐藏文件<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#假设此目录下有隐藏文件</span><br><span class=\"line\">[evanmeek@EvanLinux ~/tmp]$ tree -a</span><br></pre></td></tr></table></figure></p>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   ├── dir1_1</span><br><span class=\"line\">│   └── dir2_2</span><br><span class=\"line\">├── dir2</span><br><span class=\"line\">│   ├── dir1_1</span><br><span class=\"line\">│   └── dir2_2</span><br><span class=\"line\">├── .file1</span><br><span class=\"line\">└── .file2</span><br><span class=\"line\"></span><br><span class=\"line\">6 directories, 2 files</span><br></pre></td></tr></table></figure>\n<p>  例子:</p>\n<p>  显示1级层文件完整路径，并不显示树枝<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi .</span><br></pre></td></tr></table></figure></p>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">./dir1</span><br><span class=\"line\">./dir2</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-4-mkdir创建目录\"><a href=\"#2-4-mkdir创建目录\" class=\"headerlink\" title=\"2.4 mkdir创建目录\"></a>2.4 mkdir创建目录</h1><p>  <code>make directory</code></p>\n<p>  <strong>创建目录使用<code>mkdir</code>命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>递归创建目录，若目录已存在不会报错</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>创建时指定目录的权限</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>创建时显示过程信息</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  创建目录时显示信息<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -v testDir</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd testDir</span><br><span class=\"line\">[evanmeek@EvanLinux ~/testDir]$ pwd</span><br></pre></td></tr></table></figure></p>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;testDir&apos;</span><br></pre></td></tr></table></figure>\n<p>  递归创建目录并且显示信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -pv father/son/test</span><br></pre></td></tr></table></figure>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;father&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son/test&apos;</span><br></pre></td></tr></table></figure>\n<p>  创建目录并且指定目录权限</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ls -ld testDir</span><br></pre></td></tr></table></figure>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;testDir&apos;</span><br><span class=\"line\">d-wx-wx-wx 2 evanmeek evanmeek 4096  6月 17 20:15 testDir</span><br></pre></td></tr></table></figure>\n<p>  利用特殊符号“{}”同时创建多目录及多子目录</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -pv father/&#123;son1/&#123;a1,a2&#125;,son2/&#123;b1,b2&#125;,son3/&#123;c1,c2&#125;&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ tree father</span><br></pre></td></tr></table></figure>\n<p>  输出信息:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir: 已创建目录 &apos;father&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son1/a1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son1/a2&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son2&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son2/b1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son2/b2&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son3&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son3/c1&apos;</span><br><span class=\"line\">mkdir: 已创建目录 &apos;father/son3/c2&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">father</span><br><span class=\"line\">├── son1</span><br><span class=\"line\">│   ├── a1</span><br><span class=\"line\">│   └── a2</span><br><span class=\"line\">├── son2</span><br><span class=\"line\">│   ├── b1</span><br><span class=\"line\">│   └── b2</span><br><span class=\"line\">└── son3</span><br><span class=\"line\">    ├── c1</span><br><span class=\"line\">    └── c2</span><br><span class=\"line\"></span><br><span class=\"line\">9 directories, 0 files</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-5-touch创建空文件或改变文件的时间戳属性\"><a href=\"#2-5-touch创建空文件或改变文件的时间戳属性\" class=\"headerlink\" title=\"2.5 touch创建空文件或改变文件的时间戳属性\"></a>2.5 touch创建空文件或改变文件的时间戳属性</h1><p>  <strong>创建新的空文件，改变文件的时间戳属性，需要用到touch</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a</td>\n<td>更改指定文件的最新访问时间</td>\n</tr>\n<tr>\n<td>-d STRING</td>\n<td>用字符串的方式指定一个模板作为指定文件的时间属性</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>更改指定文件的最新修改时间</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>将指定文件的时间属性设置为file的时间属性</td>\n</tr>\n<tr>\n<td>-t STAMP</td>\n<td>使用时间格式设置文件的时间属性</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  创建文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch test.txt</span><br></pre></td></tr></table></figure>\n<p>  同时创建多个文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch test1.txt test2.txt</span><br></pre></td></tr></table></figure>\n<p>  利用{}批量创建文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch t&#123;01..05&#125;.txt</span><br></pre></td></tr></table></figure>\n<p>  利用<code>stat</code>命令查看时间戳</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n<p>  <strong>时间戳属性说明:</strong></p>\n<ul>\n<li><p>Access 访问属性</p>\n</li>\n<li><p>Modify 修改属性</p>\n</li>\n<li><p>Birth 状态改变属性</p>\n<p>利用-a选项修改文件最后访问属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch -a t01.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>输出信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2019-06-17 21:44:27.210736590 +0800</span><br><span class=\"line\">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:44:27.210736590 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n<p>修改文件的修改时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>输出信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2001-01-01 00:00:00.000000000 +0800</span><br><span class=\"line\">Modify: 2001-01-01 00:00:00.000000000 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:48:26.700992172 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n<p>修改指定文件为某文件的时间属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t02.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ stat t01.txt</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File: t01.txt</span><br><span class=\"line\">Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class=\"line\">Device: 10305h/66309d   Inode: 18352077    Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/evanmeek)   Gid: ( 1000/evanmeek)</span><br><span class=\"line\">Access: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Modify: 2019-06-17 21:36:42.380004039 +0800</span><br><span class=\"line\">Change: 2019-06-17 21:51:35.907031392 +0800</span><br><span class=\"line\">Birth: 2019-06-17 21:36:42.380004039 +0800</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"2-6-ls显示目录下的内容及相关属性信息\"><a href=\"#2-6-ls显示目录下的内容及相关属性信息\" class=\"headerlink\" title=\"2.6 ls显示目录下的内容及相关属性信息\"></a>2.6 ls显示目录下的内容及相关属性信息</h1><p>  <code>list directory contents</code></p>\n<p>  例子:</p>\n<p>  查看当前目录下的文件信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ls</span><br></pre></td></tr></table></figure>\n<p>  输出结果</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Applications  Desktop  Downloads  GameDir  index.html  Music  Pictures  temp  WorkDir</span><br></pre></td></tr></table></figure>\n<p>  每个人的目录里面的内容不同，所以可能不一样。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-l</td>\n<td>使用长格式列出目录下的文件和信息</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>显示目录下的所有文件，包括隐藏文件<code>!</code></td>\n</tr>\n<tr>\n<td>-t</td>\n<td>根据最新的修改时间排序，不加此参数默认是根据文件名排序<code>!</code></td>\n</tr>\n<tr>\n<td>-r</td>\n<td>反向排序</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>在显示的条目后加上特殊符号用以区别文件类型<code>!</code></td>\n</tr>\n<tr>\n<td>-p</td>\n<td>目录后面加上“/”</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>显示inode节点信息</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>遇到目录时，只列出目录本身，并且不跟随符号链接<code>!</code></td>\n</tr>\n<tr>\n<td>-h</td>\n<td>以人类可读的信息显示文件或目录大小</td>\n</tr>\n<tr>\n<td>-A</td>\n<td>列出所有文件，包括隐藏文件夹，但不包括.和..</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>根据文件大小排序</td>\n</tr>\n<tr>\n<td>-R</td>\n<td>递归列出所有子目录</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>逐行列出项目而不是逐栏列出</td>\n</tr>\n<tr>\n<td>-X</td>\n<td>根据扩展名排序</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>根据状态改变时间排序</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>根据最后访问时间排序</td>\n</tr>\n<tr>\n<td>–color={never,always,auto}</td>\n<td>根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示</td>\n</tr>\n<tr>\n<td>–full-time</td>\n<td>以完整的时间格式进行显示</td>\n</tr>\n<tr>\n<td>–time-style={full-iso,long-iso,iso,locale}</td>\n<td>以不同的时间格式输出，long-iso最常用</td>\n</tr>\n<tr>\n<td>–time={atime,ctimeA}</td>\n<td>按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  环境准备</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir temp</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cd temp</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ mkdir -p father/dir&#123;01..02&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/txt&#123;01..02&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/.txt&#123;01..02&#125;</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ tree -a</span><br></pre></td></tr></table></figure>\n<p>  输出结果</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  .</span><br><span class=\"line\">  └── father</span><br><span class=\"line\">      ├── dir01</span><br><span class=\"line\">      │   ├── .txt01</span><br><span class=\"line\">      │   ├── txt01</span><br><span class=\"line\">      │   ├── .txt02</span><br><span class=\"line\">      │   └── txt02</span><br><span class=\"line\">      └── dir02</span><br><span class=\"line\">          ├── .txt01</span><br><span class=\"line\">          ├── txt01</span><br><span class=\"line\">          ├── .txt02</span><br><span class=\"line\">          └── txt02</span><br><span class=\"line\"></span><br><span class=\"line\">3 directories, 8 files</span><br></pre></td></tr></table></figure>\n<p>  递归显示所有文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.:</span><br><span class=\"line\">.  ..  father</span><br><span class=\"line\"></span><br><span class=\"line\">./father:</span><br><span class=\"line\">.  ..  dir01  dir02</span><br><span class=\"line\"></span><br><span class=\"line\">./father/dir01:</span><br><span class=\"line\">.  ..  .txt01  txt01  .txt02  txt02</span><br><span class=\"line\"></span><br><span class=\"line\">./father/dir02:</span><br><span class=\"line\">.  ..  .txt01  txt01  .txt02  txt02</span><br></pre></td></tr></table></figure>\n<p> <strong>ls命令输出属性解释</strong></p>\n<p>  目录内容如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dir01</span><br><span class=\"line\">├── dir02</span><br><span class=\"line\">├── file01.txt</span><br><span class=\"line\">└── file02.txt</span><br><span class=\"line\"></span><br><span class=\"line\">2 directories, 2 files</span><br></pre></td></tr></table></figure>\n<p>  长格式列出人类可读信息并显示inode信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ls -lhi</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total 8.0K</span><br><span class=\"line\">18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir01</span><br><span class=\"line\">18219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 18 19:27 dir02</span><br><span class=\"line\">18219054 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file01.txt</span><br><span class=\"line\">18219055 -rw-r--r-- 1 evanmeek evanmeek    0  6月 18 19:28 file02.txt</span><br></pre></td></tr></table></figure>\n<p>  从第一列依次往后排，分别含义为:</p>\n<ol>\n<li>inode索引节点编号</li>\n<li>文件类型以及属性(第一字符标注类型，后9个代表权限)</li>\n<li>硬链接个数</li>\n<li>文件或目录所属用户</li>\n<li>文件或目录所属的组</li>\n<li>文件或目录的大小</li>\n<li>修改时间</li>\n<li>文件名或目录名</li>\n</ol>\n<h1 id=\"2-7-cp复制文件或目录\"><a href=\"#2-7-cp复制文件或目录\" class=\"headerlink\" title=\"2.7 cp复制文件或目录\"></a>2.7 cp复制文件或目录</h1><p>  <code>copy</code></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>复制文件时保存源文件的所有者、权限信息及时间属性</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归复制目录，即目录下所有的子目录及文件</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>等同于上面的p、d、r这3个选项功能的总和</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>覆盖已有文件前提示用户确认</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>调换命令格式，默认格式是”cp 源文件 目标文件”，将目标文件和源文件进行位置调换</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  环境准备</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">└── fatherDir</span><br><span class=\"line\">    ├── sonDir1</span><br><span class=\"line\">    │   └── test.txt</span><br><span class=\"line\">    ├── sonDir2</span><br><span class=\"line\">    │   └── test.txt</span><br><span class=\"line\">    └── sonDir3</span><br><span class=\"line\">        └── test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">4 directories, 3 files</span><br></pre></td></tr></table></figure>\n<p>  拷贝<code>fatherDir</code>为<code>father2Dir</code>并保留源文件的所有者，权限信息及时间属性</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir</span><br></pre></td></tr></table></figure>\n<p>  再次拷贝<code>fatherDir</code>为<code>father2Dir</code>从而覆盖上个例子的<code>father2Dir</code></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir1/test.txt&apos;？ y</span><br><span class=\"line\">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir2/test.txt&apos;？ y</span><br><span class=\"line\">cp：是否覆盖&apos;father2Dir/fatherDir/sonDir3/test.txt&apos;？ y</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-8-mv移动或重命名文件\"><a href=\"#2-8-mv移动或重命名文件\" class=\"headerlink\" title=\"2.8 mv移动或重命名文件\"></a>2.8 mv移动或重命名文件</h1><p>  <code>move</code><br>  | 选项 | 说明                                                       |<br>  |——|————————————————————|<br>  | -f   | 若目标文件已存在，不询问直接覆盖                           |<br>  | -i   | 若目标文件已存在，询问是否覆盖                             |<br>  | -n   | 不覆盖已存在的文件                                         |<br>  | -t   | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 |<br>  | -u   | 源文件比目标文件新，或目标文件不存在时再移动               |</p>\n<p>  例子:</p>\n<p>  环境准备</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test0.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt</span><br></pre></td></tr></table></figure>\n<p>  更换文件名</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanMeek ~]$mv test0.txt test-1.txt</span><br><span class=\"line\">[evanmeek@EvanMeek ~]$ls -l --full-time</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test-1.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test1.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test2.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek    0 2019-06-20 19:11:36.807398116 +0800 test3.txt</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt</span><br></pre></td></tr></table></figure>\n<p>  <strong>移动文件</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mv test-1.txt testTxt</span><br></pre></td></tr></table></figure>\n<p>  <strong>移动多个文件至一个目录</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-9-rm删除文件或目录\"><a href=\"#2-9-rm删除文件或目录\" class=\"headerlink\" title=\"2.9 rm删除文件或目录\"></a>2.9 rm删除文件或目录</h1><p>  <strong>前排提示:使用rm命令时最好知道自己在干什么!</strong></p>\n<p>  <code>remove</code></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-f</td>\n<td>强制删除并且忽略不存在文件的提示</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>删除时需要确认</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>删除三个以上文件或者递归删除前需要确认</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归删除目录以及其内容<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现)</strong></p>\n<p>  环境准备<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── test2Txt</span><br><span class=\"line\">│   ├── test1.txt</span><br><span class=\"line\">│   ├── test2.txt</span><br><span class=\"line\">│   └── testTxt</span><br><span class=\"line\">│       └── test-1.txt</span><br><span class=\"line\">└── test3.txt</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>删除文件</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm test3.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>强制删除并且删除时需要确认</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt</span><br></pre></td></tr></table></figure>\n<p>  输出信息</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm：是否删除普通空文件 &apos;test2Txt/test2.txt&apos;？</span><br></pre></td></tr></table></figure>\n<p>  <strong>删除目录并且删除时需要确认</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt</span><br></pre></td></tr></table></figure>\n<p>  <strong>强制删除+递归删除目录</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -rf test2Txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf /*</span><br></pre></td></tr></table></figure>\n<p>  <strong>这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内.</strong></p>\n<h2 id=\"删除时的小技巧\"><a href=\"#删除时的小技巧\" class=\"headerlink\" title=\"删除时的小技巧\"></a>删除时的小技巧</h2><ul>\n<li><p>使用<code>mv</code>命令代替<code>rm</code>命令，可以将要删除的文件暂时保存在<code>/tmp</code>目录下，需要清理空间时再去删除</p>\n</li>\n<li><p>删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原</p>\n</li>\n<li><p>若非要用删除命令清理空间可以选择用<code>find</code>代替<code>rm</code></p>\n</li>\n<li><p>删除时尽量不要使用系统通配符</p>\n</li>\n</ul>\n<h1 id=\"2-10-rmdir删除空目录\"><a href=\"#2-10-rmdir删除空目录\" class=\"headerlink\" title=\"2.10 rmdir删除空目录\"></a>2.10 rmdir删除空目录</h1><p>  <code>remove dirctory</code></p>\n<p>  此命令只能删除空目录</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>删除时显示执行过程</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"2-11-ln硬链接与软链接\"><a href=\"#2-11-ln硬链接与软链接\" class=\"headerlink\" title=\"2.11 ln硬链接与软链接\"></a>2.11 ln硬链接与软链接</h1><p>  <code>link</code></p>\n<p>  链接分为两种，分别是硬链接与软链接</p>\n<p>  硬链接(hard link):</p>\n<ul>\n<li><p>不能将硬链接链接到不同文件系统的文件</p>\n</li>\n<li><p>硬链接不能链接目录</p>\n</li>\n<li><p>删除硬链接或者源文件之一并不能完全删除实体</p>\n</li>\n<li><p>删除实体需要删除硬链接以及起对应的源文件</p>\n</li>\n<li><p>硬链接相当与源文件的另外一个入口</p>\n</li>\n<li><p>对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除</p>\n</li>\n<li><p>硬链接的文件类型是普通文件(字符型)</p>\n</li>\n<li><p>硬链接通过索引节点进行链接</p>\n<p>例子:</p>\n<p>创建硬链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt</span><br></pre></td></tr></table></figure>\n<p>软链接(Symbolic Link):</p>\n</li>\n<li><p>类似于Windows的快捷方式</p>\n</li>\n<li><p>文件内存放的是源文件的路径</p>\n</li>\n<li><p>即使删除源文件，软链接仍然存在，但无法访问源文件</p>\n</li>\n<li><p>源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示</p>\n</li>\n<li><p>软链接可以用rm命令删除</p>\n<p>例子:</p>\n<p><strong>创建软链接</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"文件链接案例\"><a href=\"#文件链接案例\" class=\"headerlink\" title=\"文件链接案例\"></a>文件链接案例</h2><p>  通过一个案例演示软链接和硬链接的区别。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile</span><br><span class=\"line\">123</span><br><span class=\"line\"># 创建硬链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink</span><br><span class=\"line\"># 创建软链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\"># 删除软链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile testHardLink</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\"># 复原</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink</span><br><span class=\"line\"># 删除硬链接</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -f testFileHardLink</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFile testFileHardLink</span><br><span class=\"line\">123</span><br><span class=\"line\">123</span><br><span class=\"line\"># 复原</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink</span><br><span class=\"line\"># 删除源文件</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ rm -f testFile</span><br><span class=\"line\">[evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink</span><br><span class=\"line\">123</span><br><span class=\"line\">cat: testFileSymbolicLink: 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>硬链接可以没有源文件</p>\n</li>\n<li><p>软链接不行</p>\n</li>\n</ul>\n<h1 id=\"2-12-readlink-查看符号链接文件的内容\"><a href=\"#2-12-readlink-查看符号链接文件的内容\" class=\"headerlink\" title=\"2.12 readlink 查看符号链接文件的内容\"></a>2.12 readlink 查看符号链接文件的内容</h1><p>  此命令可查看链接指向的源文件的地址</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-f</td>\n<td>一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行</td>\n</tr>\n</tbody>\n</table>\n<p>  例子：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-13-find-查找目录下的文件\"><a href=\"#2-13-find-查找目录下的文件\" class=\"headerlink\" title=\"2.13 find 查找目录下的文件\"></a>2.13 find 查找目录下的文件</h1><p>  由于本篇篇幅较大，请点击下方超链接进行访问。</p>\n<p>  <a href=\"/2019/6/21/Linux-文件和目录操作命令-find命令\">点击访问</a></p>\n<h1 id=\"2-14-xargs将标准输入转换成命令行参数\"><a href=\"#2-14-xargs将标准输入转换成命令行参数\" class=\"headerlink\" title=\"2.14 xargs将标准输入转换成命令行参数\"></a>2.14 xargs将标准输入转换成命令行参数</h1><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n</td>\n<td>指定每行命令的最大参数数量，每个参数由空格隔开</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>自定义分割符</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>以{}替代xargs命令之前的结果</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>指定一个符号替代前面的结果，而不是使用默认的{}</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>提示让用户确认是否执行后面的命令，y执行，n不执行</td>\n</tr>\n<tr>\n<td>-0</td>\n<td>用null替代空格作为分割符，配合find命令的-printf0选项的输出使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-14-2使用范例\"><a href=\"#2-14-2使用范例\" class=\"headerlink\" title=\"2.14.2使用范例\"></a>2.14.2使用范例</h2><p>  <strong>多行输入变单行</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">1 2 3 4 </span><br><span class=\"line\">5 6 7</span><br><span class=\"line\">8 9</span><br><span class=\"line\">1 </span><br><span class=\"line\">&gt; xargs &lt; test.txt</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 1</span><br></pre></td></tr></table></figure>\n<p>  <strong>通过-n指定每行的输出个数</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; xargs -n 2 &lt; test.txt</span><br><span class=\"line\">1 2</span><br><span class=\"line\">3 4</span><br><span class=\"line\">5 6</span><br><span class=\"line\">7 8</span><br><span class=\"line\">9 1</span><br></pre></td></tr></table></figure>\n<p>  <strong>自定义分隔符(使用-d功能)</strong><br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; echo 123I321I809I098</span><br><span class=\"line\">123I321I809I098</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; echo 123I321I809I098|xargs -d I -n 2</span><br><span class=\"line\">123 321</span><br><span class=\"line\">890 098</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>指定一个替换字符串</strong><br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将查找出来的结果删除</span><br><span class=\"line\"># 先将结果传给&#123;&#125;</span><br><span class=\"line\"># 再会被删除</span><br><span class=\"line\">&gt; find . -name &quot;*.log&quot;|xargs -i rm -rf &#123;&#125;</span><br><span class=\"line\"># 自定义替换字符串</span><br><span class=\"line\">&gt; find . -name &quot;*.log&quot;|xargs -I [] rm -rf []</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-15-rename重命名\"><a href=\"#2-15-rename重命名\" class=\"headerlink\" title=\"2.15 rename重命名\"></a>2.15 rename重命名</h1><p>  rename通过替换字符串的方式批量修改文件名</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rename from to file</span><br></pre></td></tr></table></figure>\n<p>  例子:</p>\n<p>  <strong>批量修改文件名</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">test_demo_0  test_demo_1  test_demo_2  test_demo_3  test_demo_4  test_demo_5</span><br><span class=\"line\">&gt; rename &quot;_demo&quot; &quot;&quot; *</span><br><span class=\"line\">&gt; ls</span><br><span class=\"line\">test_0  test_1  test_2  test_3  test_4  test_5</span><br></pre></td></tr></table></figure>\n<p>  <strong>批量修改文件扩展名</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">test0.txt  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class=\"line\">&gt; rename .txt .demo *</span><br><span class=\"line\">&gt; ls</span><br><span class=\"line\">test0.demo  test1.demo  test2.demo  test3.demo  test4.demo  test5.demo</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-16-basename显示文件名或目录名\"><a href=\"#2-16-basename显示文件名或目录名\" class=\"headerlink\" title=\"2.16 basename显示文件名或目录名\"></a>2.16 basename显示文件名或目录名</h1><p>  basename命令用于显示去除路径和文件后缀的文件名或目录名</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basename [&lt;文件或目录&gt;] [后缀]</span><br></pre></td></tr></table></figure>\n<p>  其中的后缀为可选</p>\n<p>  例子:</p>\n<p>  <strong>只显示文件名和后缀，不显示完整路径</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mkdir -p dir1/dir2/</span><br><span class=\"line\">&gt; touch dir1/dir2/test.txt</span><br><span class=\"line\">&gt; basename dir1/dir2/test.txt</span><br><span class=\"line\">test.txt</span><br></pre></td></tr></table></figure>\n<p>  只显示文件名，不显示完整路径制定不显示某个后缀</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; touch dir1/dir2/test.demo.txt</span><br><span class=\"line\">&gt; basename dir1/dir2/test.demo.txt .txt</span><br><span class=\"line\">test.demo</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-17-dirname显示文件或目录的路径\"><a href=\"#2-17-dirname显示文件或目录的路径\" class=\"headerlink\" title=\"2.17 dirname显示文件或目录的路径\"></a>2.17 dirname显示文件或目录的路径</h1><p>  dirname命令用于只显示文件或目录的路径</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dirname [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<p>  例子:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dirname dir1/dir2/test.txt</span><br><span class=\"line\">dir1/dir2</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-18-chattr改变文件的扩展属性\"><a href=\"#2-18-chattr改变文件的扩展属性\" class=\"headerlink\" title=\"2.18 chattr改变文件的扩展属性\"></a>2.18 chattr改变文件的扩展属性</h1><p>  charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的．</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr [选项] [模式] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<p>  提示:<code>lsattr</code>命令可以查看文件的属性</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归更改目录属性</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示执行过程</td>\n</tr>\n<tr>\n<td>mode</td>\n<td></td>\n</tr>\n<tr>\n<td>+</td>\n<td>增加参数</td>\n</tr>\n<tr>\n<td>-</td>\n<td>移除参数</td>\n</tr>\n<tr>\n<td>=</td>\n<td>更新为指定参数</td>\n</tr>\n<tr>\n<td>A</td>\n<td>指定文件的最后访问时间不可修改</td>\n</tr>\n<tr>\n<td>a</td>\n<td>指定文件只能添加数据，无法删除数据<code>!</code></td>\n</tr>\n<tr>\n<td>!</td>\n<td>指定文件不能被删除，重命名，写入或新增内容</td>\n</tr>\n</tbody>\n</table>\n<p>  例子：</p>\n<p>  <strong>给文件加锁，使其只能为只读</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; chattr +i test.txt</span><br><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">----i---------e----- test.txt</span><br><span class=\"line\">&gt; echo a1111 &gt; test.txt</span><br><span class=\"line\">zsh: 不允许的操作: test.txt</span><br><span class=\"line\">&gt; echo b2222 &gt;&gt; test.txt </span><br><span class=\"line\">zsh: 不允许的操作: test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>给文件解锁</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; charttr -i test.txt</span><br><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">--------------e----- test.txt</span><br><span class=\"line\">&gt; eco 111 &gt; test.txt</span><br><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">111</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-19-lsattr查看文件扩展属性\"><a href=\"#2-19-lsattr查看文件扩展属性\" class=\"headerlink\" title=\"2.19 lsattr查看文件扩展属性\"></a>2.19 lsattr查看文件扩展属性</h1><p>  lsattr命令用于查看文件扩展属</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsattr [选项] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归查看目录的扩展属性</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>显示所有文件的扩展属性</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>显示目录的扩展属性</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>查看文件的扩展属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">--------------e----- test.txt</span><br><span class=\"line\">&gt; chattr +i test.txt</span><br><span class=\"line\">&gt; lsattr test.txt</span><br><span class=\"line\">----i---------e----- test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>查看目录的扩展属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lsattr -d testDir</span><br><span class=\"line\">--------------e----- testDir</span><br><span class=\"line\">&gt; chattr +i testDir</span><br><span class=\"line\">&gt; lsattr -d testDir</span><br><span class=\"line\">----i---------e----- testDir</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-20-file显示文件的类型\"><a href=\"#2-20-file显示文件的类型\" class=\"headerlink\" title=\"2.20 file显示文件的类型\"></a>2.20 file显示文件的类型</h1><p>  file命令用于显示文件的类型</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file [选项] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>输出信息使用精简格式</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>查看文件类型</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; file test.txt</span><br><span class=\"line\">test.txt: empty</span><br><span class=\"line\">&gt; file *</span><br><span class=\"line\">test.txt:      empty</span><br><span class=\"line\">test.txt.link: symbolic link to test.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-21-md5sum计算和校验文件的MD5值\"><a href=\"#2-21-md5sum计算和校验文件的MD5值\" class=\"headerlink\" title=\"2.21 md5sum计算和校验文件的MD5值\"></a>2.21 md5sum计算和校验文件的MD5值</h1><p>  md5sum命令用于计算和校验文件的MD5值.</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md5sum [选项] [文件]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>二进制模式读取文件</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>从指定文件中读取MD5校验值，并进行校验</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>文本模式读取文件，默认</td>\n</tr>\n<tr>\n<td>–quiet</td>\n<td>校验文件时，若通过不输出OK</td>\n</tr>\n<tr>\n<td>–status</td>\n<td>校验文件时，不输出任何信息，但可通过命令的返回值判断</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>生成一个文件的MD5值</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; md5sum test.txt</span><br><span class=\"line\">d41d8cd98f00b204e9800998ecf8427e  test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>校验文件MD5值是否发生改变</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; md5sum test.txt &gt; md5.log</span><br><span class=\"line\">&gt; cat md5.log</span><br><span class=\"line\">d41d8cd98f00b204e9800998ecf8427e  test.txt</span><br><span class=\"line\">&gt; md5sum -c md5.log</span><br><span class=\"line\">test.txt: 成功</span><br><span class=\"line\">&gt; echo &quot;update&quot; &gt;&gt; test.txt</span><br><span class=\"line\">&gt; md5sum -c md5.log</span><br><span class=\"line\">test.txt: 失败</span><br><span class=\"line\">md5sum: 警告：1 个校验和不匹配</span><br><span class=\"line\">&gt; md5sum --status -c md5.log</span><br><span class=\"line\">&gt; echo $?</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-22-chown改变文件或目录的用户和用户组\"><a href=\"#2-22-chown改变文件或目录的用户和用户组\" class=\"headerlink\" title=\"2.22 chown改变文件或目录的用户和用户组\"></a>2.22 chown改变文件或目录的用户和用户组</h1><p>  chown命令用于改变文件或目录的用户和用户组</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown [选项] [用户:用户组] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归更改目录的用户和用户组</td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>更改文件所属的用户属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l test.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root 5  6月 27 00:31 test.txt</span><br><span class=\"line\"># 授予权限的用户必须存在</span><br><span class=\"line\">&gt; chown xxx test.txt</span><br><span class=\"line\">chown: 无效的用户: “xxx”</span><br><span class=\"line\">&gt; chown evanmeek test.txt</span><br><span class=\"line\">&gt; ls -l test.txt</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek root 5  6月 27 00:31 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>更改文件所属用户组的属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt</span><br><span class=\"line\">&gt; chown .root test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek root 5  6月 27 00:34 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>同时更改文件的用户和用户组属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; chown evanmeek:evanmeek test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 5  6月 27 00:34 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>递归更改目录下所有文件及目录的用户和用户组属性</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── dir0</span><br><span class=\"line\">│   └── test.txt</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   └── test.txt</span><br><span class=\"line\">└── dir2</span><br><span class=\"line\">    └── test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">3 directories, 3 files</span><br><span class=\"line\">&gt; chown -R root:root .</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 12K</span><br><span class=\"line\">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir0</span><br><span class=\"line\">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir1</span><br><span class=\"line\">drwxr-xr-x 2 root root 4.0K  6月 27 01:14 dir2</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-23chmod改变文件或目录权限\"><a href=\"#2-23chmod改变文件或目录权限\" class=\"headerlink\" title=\"2.23chmod改变文件或目录权限\"></a>2.23chmod改变文件或目录权限</h1><p>  只有文件的属主以及超级用户<code>root</code>才能执行此命令</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod [选项] [模式] [&lt;文件或目录&gt;]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归指定目录以及子目录的权限</td>\n</tr>\n</tbody>\n</table>\n<p>  权限对应表</p>\n<table>\n<thead>\n<tr>\n<th>权限位</th>\n<th>全称</th>\n<th>含义</th>\n<th>对应数字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>read</td>\n<td>可读权限</td>\n<td>4</td>\n</tr>\n<tr>\n<td>w</td>\n<td>write</td>\n<td>可写权限</td>\n<td>2</td>\n</tr>\n<tr>\n<td>x</td>\n<td>execute</td>\n<td>可执行权限</td>\n<td>1</td>\n</tr>\n<tr>\n<td>-</td>\n<td></td>\n<td>没有任何权限</td>\n<td>0</td>\n</tr>\n<tr>\n<td>备注</td>\n<td>一些特殊权限位:t,T,s,S,x,X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>文件所属用户:u(OwnerUser)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>文件所属用户组:g(Group)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>其他用户:o(Other)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>用户类型</td>\n<td>所有:a(ALL),等效于u,g,o的总和</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>操作字符</td>\n<td>+:添加/-:减去/=:设置</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>  例子:</p>\n<p>  <strong>权限字母和操作符表达式</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br><span class=\"line\"># 给文件所属用户减去可写权限</span><br><span class=\"line\">&gt; chmod u-w test.txt</span><br><span class=\"line\"># 给用户所属用户组减去可读权限</span><br><span class=\"line\">&gt; chmod g-r test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-r-----r-- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br><span class=\"line\"># 给所有用户以及用户组都设置为可读可写可执行的权限</span><br><span class=\"line\">&gt; chmod a=rwx test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.0K</span><br><span class=\"line\">-rwxrwxrwx 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>使用数字更改文件或目录权限</strong></p>\n<p>  先举个例子，有这么一个文件</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-rw---- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure>\n<p>  权限示意图</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前三个字符代表文件属主的权限</span><br><span class=\"line\">中间三个字符代表文件属组的权限</span><br><span class=\"line\">后三个字符代表其他用户的权限</span><br><span class=\"line\">-rw-rw---- evanmeek evanmeek test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660</strong></p>\n<p>  <em>因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660</em></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将test.txt文件的所有用户权限设置为可读可写可执行</span><br><span class=\"line\">&gt; chmod 777 test.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">---------- 1 evanmeek evanmeek 4  6月 25 17:43 test.txt</span><br></pre></td></tr></table></figure>\n<p>  <strong>使用数字递归更改文件或目录的权限</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── dir0</span><br><span class=\"line\">│   └── file.txt</span><br><span class=\"line\">├── dir1</span><br><span class=\"line\">│   └── file.txt</span><br><span class=\"line\">└── dir2</span><br><span class=\"line\">    └── file.txt</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 12K</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1</span><br><span class=\"line\">drwxr-xr-x 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2</span><br><span class=\"line\">&gt; chmod -R 777 dir&#123;0..2&#125;</span><br><span class=\"line\">总用量 12K</span><br><span class=\"line\">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir0</span><br><span class=\"line\">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir1</span><br><span class=\"line\">drwxrwxrwx 2 evanmeek evanmeek 4.0K  6月 28 20:59 dir2</span><br></pre></td></tr></table></figure>\n<p>  <strong>Linux普通文件的读，写，执行权限说明</strong><br>  | 权限    | 说明                       |<br>  |———|—————————-|<br>  | 可读r   | 表示具有读取文件内容的权限 |<br>  | 可写w   | 表示具有修改文件内容的权限 |<br>  | 可执行x | 表示具有执行文件的权限     |</p>\n<ul>\n<li><p>可写w</p>\n<ol>\n<li>如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo &gt;&gt;　的方式进行追加.</li>\n<li>删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里</li>\n</ol>\n</li>\n<li><p>可执行x</p>\n<ol>\n<li>要求文件本身是可执行的</li>\n<li>普通用户必须要有r权限才能够执行</li>\n<li>root用户即使没有r权限，只需要有x权限即可执行</li>\n<li>不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行</li>\n</ol>\n<p><strong>Linux目录的，写，执行权限说明</strong><br>| 权限    | 说明                                       |<br>|———|——————————————–|<br>| 可读r   | 表示具有浏览目录下文件以及子目录的权限     |<br>| 可写w   | 表示具有增加，删除或修改目录内文件名的权限 |<br>| 可执行x | 表示具有进入目录的权限                     |</p>\n</li>\n<li><p>可读r</p>\n<ol>\n<li>没有x权限不能进入至目录内</li>\n<li>ls列表可以看到所有文件名，不过会提示无法访问目录下的文件</li>\n<li>如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名</li>\n</ol>\n</li>\n<li><p>可写w</p>\n<ol>\n<li>增加的不是文件内容，而是创建新文件</li>\n<li>修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名，</li>\n<li>删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除</li>\n</ol>\n</li>\n<li>可执行权限x<ol>\n<li>没有可读权限r则不能进入目录</li>\n<li>没有可写权限w则无法创建新文件</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-24-chgrp更改文件用户组\"><a href=\"#2-24-chgrp更改文件用户组\" class=\"headerlink\" title=\"2.24 chgrp更改文件用户组\"></a>2.24 chgrp更改文件用户组</h1><p>  此命令被<code>chown</code>取代，用法和参数都和<code>chown</code>命令相同</p>\n<h1 id=\"2-25-umask显示或设置权限掩码\"><a href=\"#2-25-umask显示或设置权限掩码\" class=\"headerlink\" title=\"2.25 umask显示或设置权限掩码\"></a>2.25 umask显示或设置权限掩码</h1><p>  umask是通过八进制的数值来定义用户创建文件或目录的默认权限</p>\n<p>  语法格式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">umask [选项] [模式]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>输出的权限掩码可直接作为命令来执行</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>以字符的方式输出权限掩码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-25-2-通过umask计算文件目录权限\"><a href=\"#2-25-2-通过umask计算文件目录权限\" class=\"headerlink\" title=\"2.25.2 通过umask计算文件目录权限\"></a>2.25.2 通过umask计算文件目录权限</h2><p>  <strong>文件权限的计算</strong></p>\n<p>  创建文件默认的最大权限为666，也就是说没有可执行权限x.</p>\n<p>  umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。</p>\n<p>  例子:</p>\n<p>  假如umask值为:022，那么:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  6 6 6 文件默认的权限</span><br><span class=\"line\">  0 2 2 umask值</span><br><span class=\"line\">- =====</span><br><span class=\"line\">  6 4 4 都为偶数，最终结果为644</span><br></pre></td></tr></table></figure></p>\n<p>  假如umask值为:045，那么:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    6 6 6 文件默认的权限</span><br><span class=\"line\">    0 4 5 umask值</span><br><span class=\"line\">- =====</span><br><span class=\"line\">    6 2 1 其他用户权限位为奇数，所以+1</span><br><span class=\"line\">    0 0 1</span><br><span class=\"line\">+ =====</span><br><span class=\"line\">    6 2 2 都为偶数，最终结果为622</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>目录权限的计算</strong></p>\n<p>  <em>目录权限的计算没有奇偶之分</em></p>\n<p>  创建目录是默认的最大权限为777(-rwx-rwx-rwx)</p>\n<p>  计算方法和文件权限计算方法相同</p>\n<p>  例子:</p>\n<p>  假如umask值为:022，那么:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  7 7 7 目录默认最大权限</span><br><span class=\"line\">  0 2 2 umask值</span><br><span class=\"line\">- =====</span><br><span class=\"line\">  7 5 5 得到最终结果</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>查看系统默认的umask值</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 普通用户的默认umask值</span><br><span class=\"line\">evanmeek &gt; umask</span><br><span class=\"line\">022</span><br><span class=\"line\"># 超级用户的默认umask值</span><br><span class=\"line\">root &gt; umask</span><br><span class=\"line\">0022</span><br></pre></td></tr></table></figure>\n<p>  <strong>-S参数的使用</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; umask -S</span><br><span class=\"line\">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure>\n<p>  <strong>-p参数的使用</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; umask -p</span><br><span class=\"line\">umask 0022</span><br></pre></td></tr></table></figure>\n<p>  <strong>临时修改umask值</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 修改umask之前</span><br><span class=\"line\">&gt; umask</span><br><span class=\"line\">&gt; ls -l file1</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 0  6月 30 19:11 file1</span><br><span class=\"line\"># 修改umask之后</span><br><span class=\"line\">&gt; umask 044</span><br><span class=\"line\">&gt; umask</span><br><span class=\"line\">044</span><br><span class=\"line\">&gt; touch file2</span><br><span class=\"line\">&gt; ls -l file1</span><br><span class=\"line\">-rw--w--w- 1 evanmeek evanmeek 0  6月 30 19:12 file2</span><br></pre></td></tr></table></figure>\n<p>  <strong>永久修改umask值</strong></p>\n<p>  <em>若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。</em></p>\n<p>  编辑<code>/etc/profile</code>或者<code>/etc/bashrc</code></p>\n<p>  找到<code>umask</code>项修改即可</p>\n"},{"title":"Linux-文件和目录操作命令-find命令","copyright":true,"date":"2019-06-20T17:04:56.000Z","_content":"\n本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示\n\n<!--more-->\n\n# 2.13.1 命令详解\n\nfind命令参数较多，并且不同的参数所在的子模块不同.\n\n~~~\n    如何处理符号链接\n        |\n        |  需要查找的路径\n        |     |\n        |     |\nfind -H-L-P path expression\n                /    |     \\\n              /      |       \\\n            |        |         |\n            options tests actions\n            参数      |       |\n                限定的条件     |\n                          执行的动作\n~~~\n\n| 选项               | 说明                                                                  |\n|--------------------|-----------------------------------------------------------------------|\n| pathname           | 需要查找的路径                                                        |\n| Options模块        |                                                                       |\n| -depth             | 从指定目录下最深层的子目录开始查找                                    |\n| -maxdepth levels   | 查找的最大目录层级数，levels为自然数`!`                               |\n| -regextype type    | 改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended |\n| Tests模块          |                                                                       |\n| -mtime [-n\\|n\\|+n] | 按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天`!`   |\n| -atime[-n\\|n\\|+n]  | 同上，只不过是按照访问时间进行查找，单位为天                          |\n| -ctime             | 按照文件的状态改变时间来查找文件，单位为天                            |\n| -amin              | 按照文件的访问时间查找，单位为分钟                                    |\n| -cmin              | 按照文件的状态改变时间查找，单位为分钟                                |\n| -mmin              | 按照文件的修改时间来查找文件，单位为分钟                              |\n| -group             | 按照文件所属的组来查找文件                                            |\n| -name              | 按照文件名查找文件，只支持\\*,?,[]等特殊通配符`!`                      |\n| -newer             | 查找更改时间比指定文件新的文件                                        |\n| -nogroup           | 查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在           |\n| -nouser            | 查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在           |\n| -path pattern      | 指定路径样式，配合-prune参数排除指定目录                              |\n| -perm              | 按照文件权限来查找文件                                                |\n| -regex             | 接正则表达式                                                          |\n| -iregex            | 不区分大小写接正则表达式                                              |\n| -size n[cwbkMG]    | 查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计             |\n| -user              | 按照文件属主来查找文件                                                |\n| -type              | 查找某一类型的文件:`!`，后面会讲                                      |\n| -Actions模块       |                                                                       |\n| -delete            | 将查找出的文件删除                                                    |\n| -exec              | 对匹配文件执行该参数给出的Shell命令`!`                                |\n| -ok                | 和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行       |\n| -prune             | 使fint命令不再指定的目录中查找                                        |\n| -print             | 将匹配的文件输出到标准输出(默认可用                                   |\n| OPERATORS          | find支持逻辑运算符                                                    |\n| !                  | 取反`!                                                                |\n| -a                 | 取交集，全拼为and`！`                                                 |\n| -o                 | 取并集，全拼为or`!`                                                   |\n\n-type 查找某一类型的文件:\n\n  - b(块设备文件)\n\n  - c(字符设备文件)\n\n  - d(目录)\n\n  - p(管道文件)\n\n  - l(符号链接文件)\n\n  - f(普通文件)\n\n  - s(socket文件)\n\n  - D(door)\n\n\n# 2.13.2 使用范例\n\n__查找指定时间内访问过的文件__\n\n~~~\n> find . -atime -2\n\n./Linux-文件和目录操作命令-1.md\n./Linux-文件和目录操作命令-find命令.md\n./我的VIM配置详解.md\n./我的VIM配置详解\n~~~\n\n__查找指定时间内修改过的文件__\n\n~~~\n> find . -mtime -5\n.\n./Linux-Linux命令行简介-0.md\n./Linux-文件和目录操作命令-1.md\n./C-内存四区之栈区.md\n./Linux-文件和目录操作命令-find命令.md\n./我的VIM配置详解.md\n./Linux-Linux命令行简介-man命令.md\n./我的VIM配置详解\n~~~\n\n时间关系字符图如下:\n\n~~~\n------------+4  4 -4---------------\n8   7   6   5   4   3   2   1   now\n~~~\n\n`-n`代表从第四天到现在之内\n\n`n`代表具体某一天\n\n`+n`代表某一天之前\n\n__根据文件名查找指定时间的文件__\n\n~~~\n> find . -mtime -1 -name '*.md'\n./Linux-文件和目录操作命令-find命令.md\n~~~\n\n__根据文件类型查找目录__\n\n~~~\n> find . -type d\n.\n./Linux-Linux命令行简介-0\n./终端多窗口神器——Screen\n./Qt5\n./2008年5月12日14时28分04秒\n./如何自学编程\n./Learn-Qt5-自定义信号槽\n./C-内存四区之代码区与全局区\n./Linux\n./C-友元\n./Learn-Qt5-Qt模块简介\n./ManjaroLinux的安装过程\n./C-的命名空间与作用域\n./Learn-Qt5-信号槽\n./我儿子的博客\n./C-内存四区之堆区\n./fcitx5安装与配置\n./hexo-next插入网易云音乐\n./Linux-文件和目录操作命令-1\n./C-读写文件\n./Linux-Linux命令行简介-man命令\n./C-指针-基础02\n./Learn-Qt5-HelloWorld\n./常用算法-1\n./C-内存四区之栈区\n./我的VIM配置详解\n./解决KDE下部分应用不能使用fctix中文输入法的问题\n./如何用hexo-github-pages搭建博客\n~~~\n\n__根据文件类型查找非目录的文件__\n\n~~~\n> find . ! -type d\n./Linux-Linux命令行简介-0/1.1.2-0\n./fcitx5安装与配置.md\n./终端多窗口神器——Screen/DefalutCommandKey.png\n./终端多窗口神器——Screen/detachedInfo.png\n./Linux中的解压与压缩.md\n./Linux-Linux命令行简介-0.md\n./终端多窗口神器——Screen.md\n./C-内存四区之代码区与全局区.md\n./C-内存四区之堆区.md\n./2008年5月12日14时28分04秒/空降.webp\n./2008年5月12日14时28分04秒/操场.webp\n./2008年5月12日14时28分04秒/流量图.webp\n./hexo-next插入网易云音乐.md\n./如何自学编程/群组.png\n./Linux-文件和目录操作命令-1.md\n./我儿子的博客.md\n./解决KDE下部分应用不能使用fctix中文输入法的问题.md\n./C-内存四区之代码区与全局区/代码区示意图.png\n./C-内存四区之栈区.md\n./Learn-Qt5-信号槽.md\n./Linux-文件和目录操作命令-find命令.md\n./Learn-Qt5-Qt模块简介.md\n./C-读写文件.md\n./ManjaroLinux的安装过程/编辑文章时截图.png\n./ManjaroLinux的安装过程/分区.png\n./ManjaroLinux的安装过程/开始安装.png\n./ManjaroLinux的安装过程/安装选择界面.png\n./ManjaroLinux的安装过程/摘要.png\n./ManjaroLinux的安装过程/分区标识.png\n./ManjaroLinux的安装过程/桌面.png\n./Learn-Qt5-自定义信号槽.md\n./我儿子的博客/预览.png\n./hexo博客文章插入图片.md\n./C-函数探幽.md\n./C-内存四区之堆区/test.png\n./如何自学编程.md\n./深拷贝和浅拷贝的区别.md\n./ManjaroLinux的安装过程.md\n./fcitx5安装与配置/kcm.png\n./fcitx5安装与配置/输入.gif\n./hexo-next插入网易云音乐/01.png\n./hexo-next插入网易云音乐/插哪.png\n./2008年5月12日14时28分04秒.md\n./C-读写文件/二进制文件.png\n./C-指针-基础02/指针位偏移.png\n./Learn-Qt5-HelloWorld.md\n./ManjaroLinuxTG讨论群组.md\n./Learn-Qt5-HelloWorld/newProject.gif\n./我的VIM配置详解.md\n./C-友元.md\n./如何用hexo-github-pages搭建博客.md\n./Linux-Linux命令行简介-man命令.md\n./常用算法-1.md\n./C-的命名空间与作用域.md\n./我的Linux之路.md\n./2019年的规划.md\n./C-指针-基础01.md\n./C-指针-基础02.md\n./如何用hexo-github-pages搭建博客/创建仓库.png\n./如何用hexo-github-pages搭建博客/deploy.png\n./如何用hexo-github-pages搭建博客/逆光.jpg\n./如何用hexo-github-pages搭建博客/本地部署.png\n./如何用hexo-github-pages搭建博客/hexoinit.png\n./如何用hexo-github-pages搭建博客/导入密钥.png\n./如何用hexo-github-pages搭建博客/打开设置.png\n./如何用hexo-github-pages搭建博客/ssh目录.png\n./如何用hexo-github-pages搭建博客/设置SSH.png\n~~~\n\n__根据文件或目录的权限查找文件__\n\n~~~\n> find . -perm 755\n.\n./Linux-Linux命令行简介-0\n./终端多窗口神器——Screen\n./Qt5\n./2008年5月12日14时28分04秒\n./如何自学编程\n./Learn-Qt5-自定义信号槽\n./C-内存四区之代码区与全局区\n./Linux\n./C-友元\n./Learn-Qt5-Qt模块简介\n./ManjaroLinux的安装过程\n./C-的命名空间与作用域\n./Learn-Qt5-信号槽\n./我儿子的博客\n./C-内存四区之堆区\n./fcitx5安装与配置\n./hexo-next插入网易云音乐\n./Linux-文件和目录操作命令-1\n./C-读写文件\n./Linux-Linux命令行简介-man命令\n./C-指针-基础02\n./Learn-Qt5-HelloWorld\n./常用算法-1\n./C-内存四区之栈区\n./我的VIM配置详解\n./解决KDE下部分应用不能使用fctix中文输入法的问题\n./如何用hexo-github-pages搭建博客\n~~~\n\n__根据文件大小查找文件__\n\n~~~\n> find . -size +1M\n./ManjaroLinux的安装过程/桌面.png\n~~~\n\n__查找时忽略某个目录__\n\n~~~\n> find . -path \"*Linux*\" -prune -o -type d -print\n.\n./终端多窗口神器——Screen\n./Qt5\n./2008年5月12日14时28分04秒\n./如何自学编程\n./Learn-Qt5-自定义信号槽\n./C-内存四区之代码区与全局区\n./C-友元\n./Learn-Qt5-Qt模块简介\n./C-的命名空间与作用域\n./Learn-Qt5-信号槽\n./我儿子的博客\n./C-内存四区之堆区\n./fcitx5安装与配置\n./hexo-next插入网易云音乐\n./C-读写文件\n./C-指针-基础02\n./Learn-Qt5-HelloWorld\n./常用算法-1\n./C-内存四区之栈区\n./我的VIM配置详解\n./解决KDE下部分应用不能使用fctix中文输入法的问题\n./如何用hexo-github-pages搭建博客\n~~~\n\n__查找比某个文件新，但比某个文件旧__\n\n~~~\n# 其中的!不代表取反，代表逻辑运算符非\n> find . -newer new.txt ! -newer old.txt\n./verynew.txt\n~~~\n\n__查找文件时使用正则表达式__\n\n~~~\n> ls\ntxt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt\n> find . -regex \".*xt\"\n./txt0.txt\n./txt4.txt\n./txt1.txt\n./txt2.txt\n./txt3.txt\n~~~\n\n__对查找到的文件执行Shell命令操作__\n\n~~~\n> ls\ntxt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt\n\n# 其中的{}代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\\，因为需要转义\n> find . -regext \".*txt\" -exec mv {} {}.demo \\;\ntxt0.txt.demo  txt1.txt.demo  txt2.txt.demo  txt3.txt.demo  txt4.txt.demo\n~~~\n\n__对查找到的文件使用Shell命令并且使用安全模式-ok\n\n~~~\n> find . -type f -ok rm {} \\;\n< rm ... ./txt1.txt.demo > ? n\n< rm ... ./txt2.txt.demo > ? n\n< rm ... ./txt4.txt.demo > ? n\n< rm ... ./txt0.txt.demo > ? y\n< rm ... ./txt3.txt.demo > ? n\n~~~\n","source":"_posts/Linux-文件和目录操作命令-find命令.md","raw":"---\ntitle: Linux-文件和目录操作命令-find命令\ncopyright: true\ndate: 2019-06-21 01:04:56\ncategories: Linux系列\ntags:\n - Linux\n---\n\n本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示\n\n<!--more-->\n\n# 2.13.1 命令详解\n\nfind命令参数较多，并且不同的参数所在的子模块不同.\n\n~~~\n    如何处理符号链接\n        |\n        |  需要查找的路径\n        |     |\n        |     |\nfind -H-L-P path expression\n                /    |     \\\n              /      |       \\\n            |        |         |\n            options tests actions\n            参数      |       |\n                限定的条件     |\n                          执行的动作\n~~~\n\n| 选项               | 说明                                                                  |\n|--------------------|-----------------------------------------------------------------------|\n| pathname           | 需要查找的路径                                                        |\n| Options模块        |                                                                       |\n| -depth             | 从指定目录下最深层的子目录开始查找                                    |\n| -maxdepth levels   | 查找的最大目录层级数，levels为自然数`!`                               |\n| -regextype type    | 改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended |\n| Tests模块          |                                                                       |\n| -mtime [-n\\|n\\|+n] | 按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天`!`   |\n| -atime[-n\\|n\\|+n]  | 同上，只不过是按照访问时间进行查找，单位为天                          |\n| -ctime             | 按照文件的状态改变时间来查找文件，单位为天                            |\n| -amin              | 按照文件的访问时间查找，单位为分钟                                    |\n| -cmin              | 按照文件的状态改变时间查找，单位为分钟                                |\n| -mmin              | 按照文件的修改时间来查找文件，单位为分钟                              |\n| -group             | 按照文件所属的组来查找文件                                            |\n| -name              | 按照文件名查找文件，只支持\\*,?,[]等特殊通配符`!`                      |\n| -newer             | 查找更改时间比指定文件新的文件                                        |\n| -nogroup           | 查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在           |\n| -nouser            | 查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在           |\n| -path pattern      | 指定路径样式，配合-prune参数排除指定目录                              |\n| -perm              | 按照文件权限来查找文件                                                |\n| -regex             | 接正则表达式                                                          |\n| -iregex            | 不区分大小写接正则表达式                                              |\n| -size n[cwbkMG]    | 查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计             |\n| -user              | 按照文件属主来查找文件                                                |\n| -type              | 查找某一类型的文件:`!`，后面会讲                                      |\n| -Actions模块       |                                                                       |\n| -delete            | 将查找出的文件删除                                                    |\n| -exec              | 对匹配文件执行该参数给出的Shell命令`!`                                |\n| -ok                | 和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行       |\n| -prune             | 使fint命令不再指定的目录中查找                                        |\n| -print             | 将匹配的文件输出到标准输出(默认可用                                   |\n| OPERATORS          | find支持逻辑运算符                                                    |\n| !                  | 取反`!                                                                |\n| -a                 | 取交集，全拼为and`！`                                                 |\n| -o                 | 取并集，全拼为or`!`                                                   |\n\n-type 查找某一类型的文件:\n\n  - b(块设备文件)\n\n  - c(字符设备文件)\n\n  - d(目录)\n\n  - p(管道文件)\n\n  - l(符号链接文件)\n\n  - f(普通文件)\n\n  - s(socket文件)\n\n  - D(door)\n\n\n# 2.13.2 使用范例\n\n__查找指定时间内访问过的文件__\n\n~~~\n> find . -atime -2\n\n./Linux-文件和目录操作命令-1.md\n./Linux-文件和目录操作命令-find命令.md\n./我的VIM配置详解.md\n./我的VIM配置详解\n~~~\n\n__查找指定时间内修改过的文件__\n\n~~~\n> find . -mtime -5\n.\n./Linux-Linux命令行简介-0.md\n./Linux-文件和目录操作命令-1.md\n./C-内存四区之栈区.md\n./Linux-文件和目录操作命令-find命令.md\n./我的VIM配置详解.md\n./Linux-Linux命令行简介-man命令.md\n./我的VIM配置详解\n~~~\n\n时间关系字符图如下:\n\n~~~\n------------+4  4 -4---------------\n8   7   6   5   4   3   2   1   now\n~~~\n\n`-n`代表从第四天到现在之内\n\n`n`代表具体某一天\n\n`+n`代表某一天之前\n\n__根据文件名查找指定时间的文件__\n\n~~~\n> find . -mtime -1 -name '*.md'\n./Linux-文件和目录操作命令-find命令.md\n~~~\n\n__根据文件类型查找目录__\n\n~~~\n> find . -type d\n.\n./Linux-Linux命令行简介-0\n./终端多窗口神器——Screen\n./Qt5\n./2008年5月12日14时28分04秒\n./如何自学编程\n./Learn-Qt5-自定义信号槽\n./C-内存四区之代码区与全局区\n./Linux\n./C-友元\n./Learn-Qt5-Qt模块简介\n./ManjaroLinux的安装过程\n./C-的命名空间与作用域\n./Learn-Qt5-信号槽\n./我儿子的博客\n./C-内存四区之堆区\n./fcitx5安装与配置\n./hexo-next插入网易云音乐\n./Linux-文件和目录操作命令-1\n./C-读写文件\n./Linux-Linux命令行简介-man命令\n./C-指针-基础02\n./Learn-Qt5-HelloWorld\n./常用算法-1\n./C-内存四区之栈区\n./我的VIM配置详解\n./解决KDE下部分应用不能使用fctix中文输入法的问题\n./如何用hexo-github-pages搭建博客\n~~~\n\n__根据文件类型查找非目录的文件__\n\n~~~\n> find . ! -type d\n./Linux-Linux命令行简介-0/1.1.2-0\n./fcitx5安装与配置.md\n./终端多窗口神器——Screen/DefalutCommandKey.png\n./终端多窗口神器——Screen/detachedInfo.png\n./Linux中的解压与压缩.md\n./Linux-Linux命令行简介-0.md\n./终端多窗口神器——Screen.md\n./C-内存四区之代码区与全局区.md\n./C-内存四区之堆区.md\n./2008年5月12日14时28分04秒/空降.webp\n./2008年5月12日14时28分04秒/操场.webp\n./2008年5月12日14时28分04秒/流量图.webp\n./hexo-next插入网易云音乐.md\n./如何自学编程/群组.png\n./Linux-文件和目录操作命令-1.md\n./我儿子的博客.md\n./解决KDE下部分应用不能使用fctix中文输入法的问题.md\n./C-内存四区之代码区与全局区/代码区示意图.png\n./C-内存四区之栈区.md\n./Learn-Qt5-信号槽.md\n./Linux-文件和目录操作命令-find命令.md\n./Learn-Qt5-Qt模块简介.md\n./C-读写文件.md\n./ManjaroLinux的安装过程/编辑文章时截图.png\n./ManjaroLinux的安装过程/分区.png\n./ManjaroLinux的安装过程/开始安装.png\n./ManjaroLinux的安装过程/安装选择界面.png\n./ManjaroLinux的安装过程/摘要.png\n./ManjaroLinux的安装过程/分区标识.png\n./ManjaroLinux的安装过程/桌面.png\n./Learn-Qt5-自定义信号槽.md\n./我儿子的博客/预览.png\n./hexo博客文章插入图片.md\n./C-函数探幽.md\n./C-内存四区之堆区/test.png\n./如何自学编程.md\n./深拷贝和浅拷贝的区别.md\n./ManjaroLinux的安装过程.md\n./fcitx5安装与配置/kcm.png\n./fcitx5安装与配置/输入.gif\n./hexo-next插入网易云音乐/01.png\n./hexo-next插入网易云音乐/插哪.png\n./2008年5月12日14时28分04秒.md\n./C-读写文件/二进制文件.png\n./C-指针-基础02/指针位偏移.png\n./Learn-Qt5-HelloWorld.md\n./ManjaroLinuxTG讨论群组.md\n./Learn-Qt5-HelloWorld/newProject.gif\n./我的VIM配置详解.md\n./C-友元.md\n./如何用hexo-github-pages搭建博客.md\n./Linux-Linux命令行简介-man命令.md\n./常用算法-1.md\n./C-的命名空间与作用域.md\n./我的Linux之路.md\n./2019年的规划.md\n./C-指针-基础01.md\n./C-指针-基础02.md\n./如何用hexo-github-pages搭建博客/创建仓库.png\n./如何用hexo-github-pages搭建博客/deploy.png\n./如何用hexo-github-pages搭建博客/逆光.jpg\n./如何用hexo-github-pages搭建博客/本地部署.png\n./如何用hexo-github-pages搭建博客/hexoinit.png\n./如何用hexo-github-pages搭建博客/导入密钥.png\n./如何用hexo-github-pages搭建博客/打开设置.png\n./如何用hexo-github-pages搭建博客/ssh目录.png\n./如何用hexo-github-pages搭建博客/设置SSH.png\n~~~\n\n__根据文件或目录的权限查找文件__\n\n~~~\n> find . -perm 755\n.\n./Linux-Linux命令行简介-0\n./终端多窗口神器——Screen\n./Qt5\n./2008年5月12日14时28分04秒\n./如何自学编程\n./Learn-Qt5-自定义信号槽\n./C-内存四区之代码区与全局区\n./Linux\n./C-友元\n./Learn-Qt5-Qt模块简介\n./ManjaroLinux的安装过程\n./C-的命名空间与作用域\n./Learn-Qt5-信号槽\n./我儿子的博客\n./C-内存四区之堆区\n./fcitx5安装与配置\n./hexo-next插入网易云音乐\n./Linux-文件和目录操作命令-1\n./C-读写文件\n./Linux-Linux命令行简介-man命令\n./C-指针-基础02\n./Learn-Qt5-HelloWorld\n./常用算法-1\n./C-内存四区之栈区\n./我的VIM配置详解\n./解决KDE下部分应用不能使用fctix中文输入法的问题\n./如何用hexo-github-pages搭建博客\n~~~\n\n__根据文件大小查找文件__\n\n~~~\n> find . -size +1M\n./ManjaroLinux的安装过程/桌面.png\n~~~\n\n__查找时忽略某个目录__\n\n~~~\n> find . -path \"*Linux*\" -prune -o -type d -print\n.\n./终端多窗口神器——Screen\n./Qt5\n./2008年5月12日14时28分04秒\n./如何自学编程\n./Learn-Qt5-自定义信号槽\n./C-内存四区之代码区与全局区\n./C-友元\n./Learn-Qt5-Qt模块简介\n./C-的命名空间与作用域\n./Learn-Qt5-信号槽\n./我儿子的博客\n./C-内存四区之堆区\n./fcitx5安装与配置\n./hexo-next插入网易云音乐\n./C-读写文件\n./C-指针-基础02\n./Learn-Qt5-HelloWorld\n./常用算法-1\n./C-内存四区之栈区\n./我的VIM配置详解\n./解决KDE下部分应用不能使用fctix中文输入法的问题\n./如何用hexo-github-pages搭建博客\n~~~\n\n__查找比某个文件新，但比某个文件旧__\n\n~~~\n# 其中的!不代表取反，代表逻辑运算符非\n> find . -newer new.txt ! -newer old.txt\n./verynew.txt\n~~~\n\n__查找文件时使用正则表达式__\n\n~~~\n> ls\ntxt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt\n> find . -regex \".*xt\"\n./txt0.txt\n./txt4.txt\n./txt1.txt\n./txt2.txt\n./txt3.txt\n~~~\n\n__对查找到的文件执行Shell命令操作__\n\n~~~\n> ls\ntxt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt\n\n# 其中的{}代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\\，因为需要转义\n> find . -regext \".*txt\" -exec mv {} {}.demo \\;\ntxt0.txt.demo  txt1.txt.demo  txt2.txt.demo  txt3.txt.demo  txt4.txt.demo\n~~~\n\n__对查找到的文件使用Shell命令并且使用安全模式-ok\n\n~~~\n> find . -type f -ok rm {} \\;\n< rm ... ./txt1.txt.demo > ? n\n< rm ... ./txt2.txt.demo > ? n\n< rm ... ./txt4.txt.demo > ? n\n< rm ... ./txt0.txt.demo > ? y\n< rm ... ./txt3.txt.demo > ? n\n~~~\n","slug":"Linux-文件和目录操作命令-find命令","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc5002gomoo4bqs8u60","content":"<p>本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示</p>\n<a id=\"more\"></a>\n<h1 id=\"2-13-1-命令详解\"><a href=\"#2-13-1-命令详解\" class=\"headerlink\" title=\"2.13.1 命令详解\"></a>2.13.1 命令详解</h1><p>find命令参数较多，并且不同的参数所在的子模块不同.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    如何处理符号链接</span><br><span class=\"line\">        |</span><br><span class=\"line\">        |  需要查找的路径</span><br><span class=\"line\">        |     |</span><br><span class=\"line\">        |     |</span><br><span class=\"line\">find -H-L-P path expression</span><br><span class=\"line\">                /    |     \\</span><br><span class=\"line\">              /      |       \\</span><br><span class=\"line\">            |        |         |</span><br><span class=\"line\">            options tests actions</span><br><span class=\"line\">            参数      |       |</span><br><span class=\"line\">                限定的条件     |</span><br><span class=\"line\">                          执行的动作</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pathname</td>\n<td>需要查找的路径</td>\n</tr>\n<tr>\n<td>Options模块</td>\n<td></td>\n</tr>\n<tr>\n<td>-depth</td>\n<td>从指定目录下最深层的子目录开始查找</td>\n</tr>\n<tr>\n<td>-maxdepth levels</td>\n<td>查找的最大目录层级数，levels为自然数<code>!</code></td>\n</tr>\n<tr>\n<td>-regextype type</td>\n<td>改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended</td>\n</tr>\n<tr>\n<td>Tests模块</td>\n<td></td>\n</tr>\n<tr>\n<td>-mtime [-n\\</td>\n<td>n\\</td>\n<td>+n]</td>\n<td>按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天<code>!</code></td>\n</tr>\n<tr>\n<td>-atime[-n\\</td>\n<td>n\\</td>\n<td>+n]</td>\n<td>同上，只不过是按照访问时间进行查找，单位为天</td>\n</tr>\n<tr>\n<td>-ctime</td>\n<td>按照文件的状态改变时间来查找文件，单位为天</td>\n</tr>\n<tr>\n<td>-amin</td>\n<td>按照文件的访问时间查找，单位为分钟</td>\n</tr>\n<tr>\n<td>-cmin</td>\n<td>按照文件的状态改变时间查找，单位为分钟</td>\n</tr>\n<tr>\n<td>-mmin</td>\n<td>按照文件的修改时间来查找文件，单位为分钟</td>\n</tr>\n<tr>\n<td>-group</td>\n<td>按照文件所属的组来查找文件</td>\n</tr>\n<tr>\n<td>-name</td>\n<td>按照文件名查找文件，只支持*,?,[]等特殊通配符<code>!</code></td>\n</tr>\n<tr>\n<td>-newer</td>\n<td>查找更改时间比指定文件新的文件</td>\n</tr>\n<tr>\n<td>-nogroup</td>\n<td>查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在</td>\n</tr>\n<tr>\n<td>-nouser</td>\n<td>查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在</td>\n</tr>\n<tr>\n<td>-path pattern</td>\n<td>指定路径样式，配合-prune参数排除指定目录</td>\n</tr>\n<tr>\n<td>-perm</td>\n<td>按照文件权限来查找文件</td>\n</tr>\n<tr>\n<td>-regex</td>\n<td>接正则表达式</td>\n</tr>\n<tr>\n<td>-iregex</td>\n<td>不区分大小写接正则表达式</td>\n</tr>\n<tr>\n<td>-size n[cwbkMG]</td>\n<td>查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计</td>\n</tr>\n<tr>\n<td>-user</td>\n<td>按照文件属主来查找文件</td>\n</tr>\n<tr>\n<td>-type</td>\n<td>查找某一类型的文件:<code>!</code>，后面会讲</td>\n</tr>\n<tr>\n<td>-Actions模块</td>\n<td></td>\n</tr>\n<tr>\n<td>-delete</td>\n<td>将查找出的文件删除</td>\n</tr>\n<tr>\n<td>-exec</td>\n<td>对匹配文件执行该参数给出的Shell命令<code>!</code></td>\n</tr>\n<tr>\n<td>-ok</td>\n<td>和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行</td>\n</tr>\n<tr>\n<td>-prune</td>\n<td>使fint命令不再指定的目录中查找</td>\n</tr>\n<tr>\n<td>-print</td>\n<td>将匹配的文件输出到标准输出(默认可用</td>\n</tr>\n<tr>\n<td>OPERATORS</td>\n<td>find支持逻辑运算符</td>\n</tr>\n<tr>\n<td>!</td>\n<td>取反`!</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>取交集，全拼为and<code>！</code></td>\n</tr>\n<tr>\n<td>-o</td>\n<td>取并集，全拼为or<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>-type 查找某一类型的文件:</p>\n<ul>\n<li><p>b(块设备文件)</p>\n</li>\n<li><p>c(字符设备文件)</p>\n</li>\n<li><p>d(目录)</p>\n</li>\n<li><p>p(管道文件)</p>\n</li>\n<li><p>l(符号链接文件)</p>\n</li>\n<li><p>f(普通文件)</p>\n</li>\n<li><p>s(socket文件)</p>\n</li>\n<li><p>D(door)</p>\n</li>\n</ul>\n<h1 id=\"2-13-2-使用范例\"><a href=\"#2-13-2-使用范例\" class=\"headerlink\" title=\"2.13.2 使用范例\"></a>2.13.2 使用范例</h1><p><strong>查找指定时间内访问过的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -atime -2</span><br><span class=\"line\"></span><br><span class=\"line\">./Linux-文件和目录操作命令-1.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br><span class=\"line\">./我的VIM配置详解.md</span><br><span class=\"line\">./我的VIM配置详解</span><br></pre></td></tr></table></figure>\n<p><strong>查找指定时间内修改过的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -mtime -5</span><br><span class=\"line\">.</span><br><span class=\"line\">./Linux-Linux命令行简介-0.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-1.md</span><br><span class=\"line\">./C-内存四区之栈区.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br><span class=\"line\">./我的VIM配置详解.md</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令.md</span><br><span class=\"line\">./我的VIM配置详解</span><br></pre></td></tr></table></figure>\n<p>时间关系字符图如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------+4  4 -4---------------</span><br><span class=\"line\">8   7   6   5   4   3   2   1   now</span><br></pre></td></tr></table></figure>\n<p><code>-n</code>代表从第四天到现在之内</p>\n<p><code>n</code>代表具体某一天</p>\n<p><code>+n</code>代表某一天之前</p>\n<p><strong>根据文件名查找指定时间的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -mtime -1 -name &apos;*.md&apos;</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件类型查找目录</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -type d</span><br><span class=\"line\">.</span><br><span class=\"line\">./Linux-Linux命令行简介-0</span><br><span class=\"line\">./终端多窗口神器——Screen</span><br><span class=\"line\">./Qt5</span><br><span class=\"line\">./2008年5月12日14时28分04秒</span><br><span class=\"line\">./如何自学编程</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽</span><br><span class=\"line\">./C-内存四区之代码区与全局区</span><br><span class=\"line\">./Linux</span><br><span class=\"line\">./C-友元</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介</span><br><span class=\"line\">./ManjaroLinux的安装过程</span><br><span class=\"line\">./C-的命名空间与作用域</span><br><span class=\"line\">./Learn-Qt5-信号槽</span><br><span class=\"line\">./我儿子的博客</span><br><span class=\"line\">./C-内存四区之堆区</span><br><span class=\"line\">./fcitx5安装与配置</span><br><span class=\"line\">./hexo-next插入网易云音乐</span><br><span class=\"line\">./Linux-文件和目录操作命令-1</span><br><span class=\"line\">./C-读写文件</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令</span><br><span class=\"line\">./C-指针-基础02</span><br><span class=\"line\">./Learn-Qt5-HelloWorld</span><br><span class=\"line\">./常用算法-1</span><br><span class=\"line\">./C-内存四区之栈区</span><br><span class=\"line\">./我的VIM配置详解</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件类型查找非目录的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . ! -type d</span><br><span class=\"line\">./Linux-Linux命令行简介-0/1.1.2-0</span><br><span class=\"line\">./fcitx5安装与配置.md</span><br><span class=\"line\">./终端多窗口神器——Screen/DefalutCommandKey.png</span><br><span class=\"line\">./终端多窗口神器——Screen/detachedInfo.png</span><br><span class=\"line\">./Linux中的解压与压缩.md</span><br><span class=\"line\">./Linux-Linux命令行简介-0.md</span><br><span class=\"line\">./终端多窗口神器——Screen.md</span><br><span class=\"line\">./C-内存四区之代码区与全局区.md</span><br><span class=\"line\">./C-内存四区之堆区.md</span><br><span class=\"line\">./2008年5月12日14时28分04秒/空降.webp</span><br><span class=\"line\">./2008年5月12日14时28分04秒/操场.webp</span><br><span class=\"line\">./2008年5月12日14时28分04秒/流量图.webp</span><br><span class=\"line\">./hexo-next插入网易云音乐.md</span><br><span class=\"line\">./如何自学编程/群组.png</span><br><span class=\"line\">./Linux-文件和目录操作命令-1.md</span><br><span class=\"line\">./我儿子的博客.md</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题.md</span><br><span class=\"line\">./C-内存四区之代码区与全局区/代码区示意图.png</span><br><span class=\"line\">./C-内存四区之栈区.md</span><br><span class=\"line\">./Learn-Qt5-信号槽.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介.md</span><br><span class=\"line\">./C-读写文件.md</span><br><span class=\"line\">./ManjaroLinux的安装过程/编辑文章时截图.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/分区.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/开始安装.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/安装选择界面.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/摘要.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/分区标识.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/桌面.png</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽.md</span><br><span class=\"line\">./我儿子的博客/预览.png</span><br><span class=\"line\">./hexo博客文章插入图片.md</span><br><span class=\"line\">./C-函数探幽.md</span><br><span class=\"line\">./C-内存四区之堆区/test.png</span><br><span class=\"line\">./如何自学编程.md</span><br><span class=\"line\">./深拷贝和浅拷贝的区别.md</span><br><span class=\"line\">./ManjaroLinux的安装过程.md</span><br><span class=\"line\">./fcitx5安装与配置/kcm.png</span><br><span class=\"line\">./fcitx5安装与配置/输入.gif</span><br><span class=\"line\">./hexo-next插入网易云音乐/01.png</span><br><span class=\"line\">./hexo-next插入网易云音乐/插哪.png</span><br><span class=\"line\">./2008年5月12日14时28分04秒.md</span><br><span class=\"line\">./C-读写文件/二进制文件.png</span><br><span class=\"line\">./C-指针-基础02/指针位偏移.png</span><br><span class=\"line\">./Learn-Qt5-HelloWorld.md</span><br><span class=\"line\">./ManjaroLinuxTG讨论群组.md</span><br><span class=\"line\">./Learn-Qt5-HelloWorld/newProject.gif</span><br><span class=\"line\">./我的VIM配置详解.md</span><br><span class=\"line\">./C-友元.md</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客.md</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令.md</span><br><span class=\"line\">./常用算法-1.md</span><br><span class=\"line\">./C-的命名空间与作用域.md</span><br><span class=\"line\">./我的Linux之路.md</span><br><span class=\"line\">./2019年的规划.md</span><br><span class=\"line\">./C-指针-基础01.md</span><br><span class=\"line\">./C-指针-基础02.md</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/创建仓库.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/deploy.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/逆光.jpg</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/本地部署.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/hexoinit.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/导入密钥.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/打开设置.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/ssh目录.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/设置SSH.png</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件或目录的权限查找文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -perm 755</span><br><span class=\"line\">.</span><br><span class=\"line\">./Linux-Linux命令行简介-0</span><br><span class=\"line\">./终端多窗口神器——Screen</span><br><span class=\"line\">./Qt5</span><br><span class=\"line\">./2008年5月12日14时28分04秒</span><br><span class=\"line\">./如何自学编程</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽</span><br><span class=\"line\">./C-内存四区之代码区与全局区</span><br><span class=\"line\">./Linux</span><br><span class=\"line\">./C-友元</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介</span><br><span class=\"line\">./ManjaroLinux的安装过程</span><br><span class=\"line\">./C-的命名空间与作用域</span><br><span class=\"line\">./Learn-Qt5-信号槽</span><br><span class=\"line\">./我儿子的博客</span><br><span class=\"line\">./C-内存四区之堆区</span><br><span class=\"line\">./fcitx5安装与配置</span><br><span class=\"line\">./hexo-next插入网易云音乐</span><br><span class=\"line\">./Linux-文件和目录操作命令-1</span><br><span class=\"line\">./C-读写文件</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令</span><br><span class=\"line\">./C-指针-基础02</span><br><span class=\"line\">./Learn-Qt5-HelloWorld</span><br><span class=\"line\">./常用算法-1</span><br><span class=\"line\">./C-内存四区之栈区</span><br><span class=\"line\">./我的VIM配置详解</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件大小查找文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -size +1M</span><br><span class=\"line\">./ManjaroLinux的安装过程/桌面.png</span><br></pre></td></tr></table></figure>\n<p><strong>查找时忽略某个目录</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -path &quot;*Linux*&quot; -prune -o -type d -print</span><br><span class=\"line\">.</span><br><span class=\"line\">./终端多窗口神器——Screen</span><br><span class=\"line\">./Qt5</span><br><span class=\"line\">./2008年5月12日14时28分04秒</span><br><span class=\"line\">./如何自学编程</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽</span><br><span class=\"line\">./C-内存四区之代码区与全局区</span><br><span class=\"line\">./C-友元</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介</span><br><span class=\"line\">./C-的命名空间与作用域</span><br><span class=\"line\">./Learn-Qt5-信号槽</span><br><span class=\"line\">./我儿子的博客</span><br><span class=\"line\">./C-内存四区之堆区</span><br><span class=\"line\">./fcitx5安装与配置</span><br><span class=\"line\">./hexo-next插入网易云音乐</span><br><span class=\"line\">./C-读写文件</span><br><span class=\"line\">./C-指针-基础02</span><br><span class=\"line\">./Learn-Qt5-HelloWorld</span><br><span class=\"line\">./常用算法-1</span><br><span class=\"line\">./C-内存四区之栈区</span><br><span class=\"line\">./我的VIM配置详解</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure>\n<p><strong>查找比某个文件新，但比某个文件旧</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 其中的!不代表取反，代表逻辑运算符非</span><br><span class=\"line\">&gt; find . -newer new.txt ! -newer old.txt</span><br><span class=\"line\">./verynew.txt</span><br></pre></td></tr></table></figure>\n<p><strong>查找文件时使用正则表达式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">txt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt</span><br><span class=\"line\">&gt; find . -regex &quot;.*xt&quot;</span><br><span class=\"line\">./txt0.txt</span><br><span class=\"line\">./txt4.txt</span><br><span class=\"line\">./txt1.txt</span><br><span class=\"line\">./txt2.txt</span><br><span class=\"line\">./txt3.txt</span><br></pre></td></tr></table></figure>\n<p><strong>对查找到的文件执行Shell命令操作</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">txt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt</span><br><span class=\"line\"></span><br><span class=\"line\"># 其中的&#123;&#125;代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\\，因为需要转义</span><br><span class=\"line\">&gt; find . -regext &quot;.*txt&quot; -exec mv &#123;&#125; &#123;&#125;.demo \\;</span><br><span class=\"line\">txt0.txt.demo  txt1.txt.demo  txt2.txt.demo  txt3.txt.demo  txt4.txt.demo</span><br></pre></td></tr></table></figure>\n<p>__对查找到的文件使用Shell命令并且使用安全模式-ok</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -type f -ok rm &#123;&#125; \\;</span><br><span class=\"line\">&lt; rm ... ./txt1.txt.demo &gt; ? n</span><br><span class=\"line\">&lt; rm ... ./txt2.txt.demo &gt; ? n</span><br><span class=\"line\">&lt; rm ... ./txt4.txt.demo &gt; ? n</span><br><span class=\"line\">&lt; rm ... ./txt0.txt.demo &gt; ? y</span><br><span class=\"line\">&lt; rm ... ./txt3.txt.demo &gt; ? n</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示</p>","more":"<h1 id=\"2-13-1-命令详解\"><a href=\"#2-13-1-命令详解\" class=\"headerlink\" title=\"2.13.1 命令详解\"></a>2.13.1 命令详解</h1><p>find命令参数较多，并且不同的参数所在的子模块不同.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    如何处理符号链接</span><br><span class=\"line\">        |</span><br><span class=\"line\">        |  需要查找的路径</span><br><span class=\"line\">        |     |</span><br><span class=\"line\">        |     |</span><br><span class=\"line\">find -H-L-P path expression</span><br><span class=\"line\">                /    |     \\</span><br><span class=\"line\">              /      |       \\</span><br><span class=\"line\">            |        |         |</span><br><span class=\"line\">            options tests actions</span><br><span class=\"line\">            参数      |       |</span><br><span class=\"line\">                限定的条件     |</span><br><span class=\"line\">                          执行的动作</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pathname</td>\n<td>需要查找的路径</td>\n</tr>\n<tr>\n<td>Options模块</td>\n<td></td>\n</tr>\n<tr>\n<td>-depth</td>\n<td>从指定目录下最深层的子目录开始查找</td>\n</tr>\n<tr>\n<td>-maxdepth levels</td>\n<td>查找的最大目录层级数，levels为自然数<code>!</code></td>\n</tr>\n<tr>\n<td>-regextype type</td>\n<td>改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended</td>\n</tr>\n<tr>\n<td>Tests模块</td>\n<td></td>\n</tr>\n<tr>\n<td>-mtime [-n\\</td>\n<td>n\\</td>\n<td>+n]</td>\n<td>按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天<code>!</code></td>\n</tr>\n<tr>\n<td>-atime[-n\\</td>\n<td>n\\</td>\n<td>+n]</td>\n<td>同上，只不过是按照访问时间进行查找，单位为天</td>\n</tr>\n<tr>\n<td>-ctime</td>\n<td>按照文件的状态改变时间来查找文件，单位为天</td>\n</tr>\n<tr>\n<td>-amin</td>\n<td>按照文件的访问时间查找，单位为分钟</td>\n</tr>\n<tr>\n<td>-cmin</td>\n<td>按照文件的状态改变时间查找，单位为分钟</td>\n</tr>\n<tr>\n<td>-mmin</td>\n<td>按照文件的修改时间来查找文件，单位为分钟</td>\n</tr>\n<tr>\n<td>-group</td>\n<td>按照文件所属的组来查找文件</td>\n</tr>\n<tr>\n<td>-name</td>\n<td>按照文件名查找文件，只支持*,?,[]等特殊通配符<code>!</code></td>\n</tr>\n<tr>\n<td>-newer</td>\n<td>查找更改时间比指定文件新的文件</td>\n</tr>\n<tr>\n<td>-nogroup</td>\n<td>查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在</td>\n</tr>\n<tr>\n<td>-nouser</td>\n<td>查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在</td>\n</tr>\n<tr>\n<td>-path pattern</td>\n<td>指定路径样式，配合-prune参数排除指定目录</td>\n</tr>\n<tr>\n<td>-perm</td>\n<td>按照文件权限来查找文件</td>\n</tr>\n<tr>\n<td>-regex</td>\n<td>接正则表达式</td>\n</tr>\n<tr>\n<td>-iregex</td>\n<td>不区分大小写接正则表达式</td>\n</tr>\n<tr>\n<td>-size n[cwbkMG]</td>\n<td>查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计</td>\n</tr>\n<tr>\n<td>-user</td>\n<td>按照文件属主来查找文件</td>\n</tr>\n<tr>\n<td>-type</td>\n<td>查找某一类型的文件:<code>!</code>，后面会讲</td>\n</tr>\n<tr>\n<td>-Actions模块</td>\n<td></td>\n</tr>\n<tr>\n<td>-delete</td>\n<td>将查找出的文件删除</td>\n</tr>\n<tr>\n<td>-exec</td>\n<td>对匹配文件执行该参数给出的Shell命令<code>!</code></td>\n</tr>\n<tr>\n<td>-ok</td>\n<td>和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行</td>\n</tr>\n<tr>\n<td>-prune</td>\n<td>使fint命令不再指定的目录中查找</td>\n</tr>\n<tr>\n<td>-print</td>\n<td>将匹配的文件输出到标准输出(默认可用</td>\n</tr>\n<tr>\n<td>OPERATORS</td>\n<td>find支持逻辑运算符</td>\n</tr>\n<tr>\n<td>!</td>\n<td>取反`!</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>取交集，全拼为and<code>！</code></td>\n</tr>\n<tr>\n<td>-o</td>\n<td>取并集，全拼为or<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>-type 查找某一类型的文件:</p>\n<ul>\n<li><p>b(块设备文件)</p>\n</li>\n<li><p>c(字符设备文件)</p>\n</li>\n<li><p>d(目录)</p>\n</li>\n<li><p>p(管道文件)</p>\n</li>\n<li><p>l(符号链接文件)</p>\n</li>\n<li><p>f(普通文件)</p>\n</li>\n<li><p>s(socket文件)</p>\n</li>\n<li><p>D(door)</p>\n</li>\n</ul>\n<h1 id=\"2-13-2-使用范例\"><a href=\"#2-13-2-使用范例\" class=\"headerlink\" title=\"2.13.2 使用范例\"></a>2.13.2 使用范例</h1><p><strong>查找指定时间内访问过的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -atime -2</span><br><span class=\"line\"></span><br><span class=\"line\">./Linux-文件和目录操作命令-1.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br><span class=\"line\">./我的VIM配置详解.md</span><br><span class=\"line\">./我的VIM配置详解</span><br></pre></td></tr></table></figure>\n<p><strong>查找指定时间内修改过的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -mtime -5</span><br><span class=\"line\">.</span><br><span class=\"line\">./Linux-Linux命令行简介-0.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-1.md</span><br><span class=\"line\">./C-内存四区之栈区.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br><span class=\"line\">./我的VIM配置详解.md</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令.md</span><br><span class=\"line\">./我的VIM配置详解</span><br></pre></td></tr></table></figure>\n<p>时间关系字符图如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------+4  4 -4---------------</span><br><span class=\"line\">8   7   6   5   4   3   2   1   now</span><br></pre></td></tr></table></figure>\n<p><code>-n</code>代表从第四天到现在之内</p>\n<p><code>n</code>代表具体某一天</p>\n<p><code>+n</code>代表某一天之前</p>\n<p><strong>根据文件名查找指定时间的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -mtime -1 -name &apos;*.md&apos;</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件类型查找目录</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -type d</span><br><span class=\"line\">.</span><br><span class=\"line\">./Linux-Linux命令行简介-0</span><br><span class=\"line\">./终端多窗口神器——Screen</span><br><span class=\"line\">./Qt5</span><br><span class=\"line\">./2008年5月12日14时28分04秒</span><br><span class=\"line\">./如何自学编程</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽</span><br><span class=\"line\">./C-内存四区之代码区与全局区</span><br><span class=\"line\">./Linux</span><br><span class=\"line\">./C-友元</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介</span><br><span class=\"line\">./ManjaroLinux的安装过程</span><br><span class=\"line\">./C-的命名空间与作用域</span><br><span class=\"line\">./Learn-Qt5-信号槽</span><br><span class=\"line\">./我儿子的博客</span><br><span class=\"line\">./C-内存四区之堆区</span><br><span class=\"line\">./fcitx5安装与配置</span><br><span class=\"line\">./hexo-next插入网易云音乐</span><br><span class=\"line\">./Linux-文件和目录操作命令-1</span><br><span class=\"line\">./C-读写文件</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令</span><br><span class=\"line\">./C-指针-基础02</span><br><span class=\"line\">./Learn-Qt5-HelloWorld</span><br><span class=\"line\">./常用算法-1</span><br><span class=\"line\">./C-内存四区之栈区</span><br><span class=\"line\">./我的VIM配置详解</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件类型查找非目录的文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . ! -type d</span><br><span class=\"line\">./Linux-Linux命令行简介-0/1.1.2-0</span><br><span class=\"line\">./fcitx5安装与配置.md</span><br><span class=\"line\">./终端多窗口神器——Screen/DefalutCommandKey.png</span><br><span class=\"line\">./终端多窗口神器——Screen/detachedInfo.png</span><br><span class=\"line\">./Linux中的解压与压缩.md</span><br><span class=\"line\">./Linux-Linux命令行简介-0.md</span><br><span class=\"line\">./终端多窗口神器——Screen.md</span><br><span class=\"line\">./C-内存四区之代码区与全局区.md</span><br><span class=\"line\">./C-内存四区之堆区.md</span><br><span class=\"line\">./2008年5月12日14时28分04秒/空降.webp</span><br><span class=\"line\">./2008年5月12日14时28分04秒/操场.webp</span><br><span class=\"line\">./2008年5月12日14时28分04秒/流量图.webp</span><br><span class=\"line\">./hexo-next插入网易云音乐.md</span><br><span class=\"line\">./如何自学编程/群组.png</span><br><span class=\"line\">./Linux-文件和目录操作命令-1.md</span><br><span class=\"line\">./我儿子的博客.md</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题.md</span><br><span class=\"line\">./C-内存四区之代码区与全局区/代码区示意图.png</span><br><span class=\"line\">./C-内存四区之栈区.md</span><br><span class=\"line\">./Learn-Qt5-信号槽.md</span><br><span class=\"line\">./Linux-文件和目录操作命令-find命令.md</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介.md</span><br><span class=\"line\">./C-读写文件.md</span><br><span class=\"line\">./ManjaroLinux的安装过程/编辑文章时截图.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/分区.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/开始安装.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/安装选择界面.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/摘要.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/分区标识.png</span><br><span class=\"line\">./ManjaroLinux的安装过程/桌面.png</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽.md</span><br><span class=\"line\">./我儿子的博客/预览.png</span><br><span class=\"line\">./hexo博客文章插入图片.md</span><br><span class=\"line\">./C-函数探幽.md</span><br><span class=\"line\">./C-内存四区之堆区/test.png</span><br><span class=\"line\">./如何自学编程.md</span><br><span class=\"line\">./深拷贝和浅拷贝的区别.md</span><br><span class=\"line\">./ManjaroLinux的安装过程.md</span><br><span class=\"line\">./fcitx5安装与配置/kcm.png</span><br><span class=\"line\">./fcitx5安装与配置/输入.gif</span><br><span class=\"line\">./hexo-next插入网易云音乐/01.png</span><br><span class=\"line\">./hexo-next插入网易云音乐/插哪.png</span><br><span class=\"line\">./2008年5月12日14时28分04秒.md</span><br><span class=\"line\">./C-读写文件/二进制文件.png</span><br><span class=\"line\">./C-指针-基础02/指针位偏移.png</span><br><span class=\"line\">./Learn-Qt5-HelloWorld.md</span><br><span class=\"line\">./ManjaroLinuxTG讨论群组.md</span><br><span class=\"line\">./Learn-Qt5-HelloWorld/newProject.gif</span><br><span class=\"line\">./我的VIM配置详解.md</span><br><span class=\"line\">./C-友元.md</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客.md</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令.md</span><br><span class=\"line\">./常用算法-1.md</span><br><span class=\"line\">./C-的命名空间与作用域.md</span><br><span class=\"line\">./我的Linux之路.md</span><br><span class=\"line\">./2019年的规划.md</span><br><span class=\"line\">./C-指针-基础01.md</span><br><span class=\"line\">./C-指针-基础02.md</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/创建仓库.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/deploy.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/逆光.jpg</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/本地部署.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/hexoinit.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/导入密钥.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/打开设置.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/ssh目录.png</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客/设置SSH.png</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件或目录的权限查找文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -perm 755</span><br><span class=\"line\">.</span><br><span class=\"line\">./Linux-Linux命令行简介-0</span><br><span class=\"line\">./终端多窗口神器——Screen</span><br><span class=\"line\">./Qt5</span><br><span class=\"line\">./2008年5月12日14时28分04秒</span><br><span class=\"line\">./如何自学编程</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽</span><br><span class=\"line\">./C-内存四区之代码区与全局区</span><br><span class=\"line\">./Linux</span><br><span class=\"line\">./C-友元</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介</span><br><span class=\"line\">./ManjaroLinux的安装过程</span><br><span class=\"line\">./C-的命名空间与作用域</span><br><span class=\"line\">./Learn-Qt5-信号槽</span><br><span class=\"line\">./我儿子的博客</span><br><span class=\"line\">./C-内存四区之堆区</span><br><span class=\"line\">./fcitx5安装与配置</span><br><span class=\"line\">./hexo-next插入网易云音乐</span><br><span class=\"line\">./Linux-文件和目录操作命令-1</span><br><span class=\"line\">./C-读写文件</span><br><span class=\"line\">./Linux-Linux命令行简介-man命令</span><br><span class=\"line\">./C-指针-基础02</span><br><span class=\"line\">./Learn-Qt5-HelloWorld</span><br><span class=\"line\">./常用算法-1</span><br><span class=\"line\">./C-内存四区之栈区</span><br><span class=\"line\">./我的VIM配置详解</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure>\n<p><strong>根据文件大小查找文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -size +1M</span><br><span class=\"line\">./ManjaroLinux的安装过程/桌面.png</span><br></pre></td></tr></table></figure>\n<p><strong>查找时忽略某个目录</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -path &quot;*Linux*&quot; -prune -o -type d -print</span><br><span class=\"line\">.</span><br><span class=\"line\">./终端多窗口神器——Screen</span><br><span class=\"line\">./Qt5</span><br><span class=\"line\">./2008年5月12日14时28分04秒</span><br><span class=\"line\">./如何自学编程</span><br><span class=\"line\">./Learn-Qt5-自定义信号槽</span><br><span class=\"line\">./C-内存四区之代码区与全局区</span><br><span class=\"line\">./C-友元</span><br><span class=\"line\">./Learn-Qt5-Qt模块简介</span><br><span class=\"line\">./C-的命名空间与作用域</span><br><span class=\"line\">./Learn-Qt5-信号槽</span><br><span class=\"line\">./我儿子的博客</span><br><span class=\"line\">./C-内存四区之堆区</span><br><span class=\"line\">./fcitx5安装与配置</span><br><span class=\"line\">./hexo-next插入网易云音乐</span><br><span class=\"line\">./C-读写文件</span><br><span class=\"line\">./C-指针-基础02</span><br><span class=\"line\">./Learn-Qt5-HelloWorld</span><br><span class=\"line\">./常用算法-1</span><br><span class=\"line\">./C-内存四区之栈区</span><br><span class=\"line\">./我的VIM配置详解</span><br><span class=\"line\">./解决KDE下部分应用不能使用fctix中文输入法的问题</span><br><span class=\"line\">./如何用hexo-github-pages搭建博客</span><br></pre></td></tr></table></figure>\n<p><strong>查找比某个文件新，但比某个文件旧</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 其中的!不代表取反，代表逻辑运算符非</span><br><span class=\"line\">&gt; find . -newer new.txt ! -newer old.txt</span><br><span class=\"line\">./verynew.txt</span><br></pre></td></tr></table></figure>\n<p><strong>查找文件时使用正则表达式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">txt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt</span><br><span class=\"line\">&gt; find . -regex &quot;.*xt&quot;</span><br><span class=\"line\">./txt0.txt</span><br><span class=\"line\">./txt4.txt</span><br><span class=\"line\">./txt1.txt</span><br><span class=\"line\">./txt2.txt</span><br><span class=\"line\">./txt3.txt</span><br></pre></td></tr></table></figure>\n<p><strong>对查找到的文件执行Shell命令操作</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls</span><br><span class=\"line\">txt0.txt  txt1.txt  txt2.txt  txt3.txt  txt4.txt</span><br><span class=\"line\"></span><br><span class=\"line\"># 其中的&#123;&#125;代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\\，因为需要转义</span><br><span class=\"line\">&gt; find . -regext &quot;.*txt&quot; -exec mv &#123;&#125; &#123;&#125;.demo \\;</span><br><span class=\"line\">txt0.txt.demo  txt1.txt.demo  txt2.txt.demo  txt3.txt.demo  txt4.txt.demo</span><br></pre></td></tr></table></figure>\n<p>__对查找到的文件使用Shell命令并且使用安全模式-ok</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; find . -type f -ok rm &#123;&#125; \\;</span><br><span class=\"line\">&lt; rm ... ./txt1.txt.demo &gt; ? n</span><br><span class=\"line\">&lt; rm ... ./txt2.txt.demo &gt; ? n</span><br><span class=\"line\">&lt; rm ... ./txt4.txt.demo &gt; ? n</span><br><span class=\"line\">&lt; rm ... ./txt0.txt.demo &gt; ? y</span><br><span class=\"line\">&lt; rm ... ./txt3.txt.demo &gt; ? n</span><br></pre></td></tr></table></figure>"},{"title":"Linux-文件过滤及内容编辑处理命令-2","copyright":true,"date":"2019-06-30T11:26:29.000Z","_content":"\n# 3.0 做Linux运维的多个好处\n\n1. 做运维可以认识更多人，同时也被更多人认识。\n\n2. 做运维可以让自己沟通，交际能力变得比开发人员更强。\n\n3. 相比开发岗位，运维的岗位更重要一些。\n\n# 3.1 cat 合并文件或查看文件内容\n\n`concatenate`\n\n__cat命令5大常用功能__\n\n| 序号 | 常用功能                 | 例子以及说明                                              |\n|------|--------------------------|-----------------------------------------------------------|\n| 1    | 查看文件内容             | cat file.txt 查看文件内容，最基本的使用                   |\n| 2    | 多个文件合并为一个文件   | cat f1 f2 > newf 将f1和f2的内容合并到newf                 |\n| 3    | 创建编辑新文件           | cat > file 输入后会请求输入，快捷键Ctrl+d/c可退出         |\n| 4    | 非交互式编辑或追加新内容 | cat >>file<<EOF 输入后会请求输入，在结束时输入EOF即可退出 |\n| 5    | 清空文件内容             | cat /dev/null > file 清空文件内容                         |\n\n语法格式\n\n~~~\ncat [选项] [文件]\n~~~\n\n| 选项 | 说明                                   |\n|------|----------------------------------------|\n| -n   | 为输出的内容加编号，从1开始            |\n| -b   | 与-n类似，但它忽略空白行               |\n| -s   | 当遇到有多行空白行，则合并为单行空白行 |\n| -v   | 除了LFD和TAB之外，使用^和M-引用        |\n| -T   | 将Tab字符显示为^I                      |\n| -E   | 在行尾显示$符号                        |\n| -t   | 等价与-vT                              |\n| -A   | 等价于-vE                              |\n\n例子\n\n__使用cat命令以非交互式的方式编辑文件__\n\n方式1:\n\n~~~\n> cat >file<<EOF\n\n\nJust a test.\nEOF\n> cat file\n\n\nJust a test\n~~~\n\n解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现\n\n易错点: 结束EOF必须置前，前面不能有任意字符\n\n方式2:\n\n~~~\n> cat >file<<-EOF\n\n\nJust a test.\n  EOF\n> cat file\n\n\nJust a test.\n~~~\n\n解释: 在字符标签前加上`-`可以使得结束标签前可放置制表符，但仅仅只可放制表符\n\n__合并多个文件为单个文件__\n\n~~~\n> cat > f1\nf1\nCtrl+d\n> cat > f2\nf2\nCtrl+c\n> cat f1 f2\nf1\nf2\n> cat f1 f2 > newfile\n> cat newfile\nf1\nf2\n~~~\n\n# 3.2 tac 反向显示文件内容\n\n跟`cat`命令类似，反向输出文件内容\n\n| 选项 | 说明                             |\n|------|----------------------------------|\n| -b   | 在行前添加分隔标志               |\n| -r   | 将分隔标志视作正则表达式进行解析 |\n| -s   | 使用指定字符作为换行的标志       |\n\n例子\n\n~~~\n> cat file1\nhello\nworld\n> tac file2\nworld\nhello\n~~~\n\n# 3.3 more 分页显示文件内容\n\n`more`类似于`cat`命令，区别在于`cat`命令是将文件内容一次性全部显示在屏幕上，而`more`则会分页进行显示。\n\n语法格式\n\n~~~\nmore [选项] [文件]\n~~~\n\n`more`参数选项说明\n\n| 选项 | 说明                                                                         |\n|------|------------------------------------------------------------------------------|\n| -num | 指定屏幕显示大小为num行                                                      |\n| +num | 从行号num开始显示                                                            |\n| -s   | 把连续的多个空行显示在一行                                                   |\n| -p   | 不滚屏，而是清除整个自己屏幕，然后显示文件                                   |\n| -c   | 不滚屏，而是从每一屏的顶部开始显示文本，每显示完一行，就清除这一行的剩余部分 |\n\n`more`交互式说明\n\n| 子命令    | 说明                     |\n|-----------|--------------------------|\n| h/?       | 查看帮助                 |\n| 空格键    | 向下滚动一屏             |\n| z         | 向下滚动一屏             |\n| Enter     | 向下显示一行             |\n| f         | 向下滚动一屏             |\n| b         | 返回上一屏               |\n| =         | 输出当前行的行号         |\n| /查找文本 | 查找指定的文本           |\n| :f        | 输出文件名和当前行的行号 |\n| v         | 调用vi编辑器             |\n| !命令     | 调用Shell，并执行命令    |\n| q         | 退出more                 |\n\n# 3.4 less 分页显示文件内容\n\n`less`类似`more`命令，`less`的功能比`more`要强大\n\n语法格式\n\n~~~\nless [选项] [文件]\n~~~\n\n`less`命令的参数选项及说明\n\n| 选项 | 说明                                                        |\n|------|-------------------------------------------------------------|\n| -i   | 搜索时忽略大小写                                            |\n| -m   | 显示进度百分比                                              |\n| -N   | 显示行号                                                    |\n| -s   | 多行空行显示为单行                                          |\n| -e   | 当显示到文件结尾时自动退出，若没有此选项则需要用交互式q退出 |\n\n`less`命令的交互式子命令及说明\n\n| 子命令    | 说明         |\n|-----------|--------------|\n| b         | 向前翻一页   |\n| 空格键    | 向后翻一页   |\n| u         | 向前翻半页   |\n| d         | 向后翻半页   |\n| y         | 向上滚动一行 |\n| 回车键    | 向下滚动一行 |\n| 方向键-上 | 向上滚动一行 |\n| 方向键-下 | 向下滚动一行 |\n| Page UP   | 向上滚动一屏 |\n| Page Down | 向下滚动一屏 |\n\n例子:\n\n__显示文件内容时并且显示行号__\n\n~~~\n> less -N 文件名\n~~~\n\n__分页显示命令的结果__\n\n\n~~~\n> ls -l | less\n~~~\n\n# 3.5 head 显示文件内容头部\n\n`head`命令用于显示文件内容头部，默认输出行数为10行。\n\n语法格式\n\n~~~\nhead [选项] [文件]\n~~~\n\n`head`命令的参数选项及说明\n\n| 选项     | 说明                                     |\n|----------|------------------------------------------|\n| -n<行数> | 指定显示的行数                           |\n| -c<字节> | 指定显示的字节数                         |\n| -q       | 显示时不包含指定的文件名作为文件头部     |\n| -v       | 显示时包含指定的文件的文件名作为文件头部 |\n\n例子:\n\n__默认显示文件的前10行__\n\n~~~\n> head /etc/passwd\nroot:x:0:0::/root:/bin/bash\nnobody:x:65534:65534:Nobody:/:/sbin/nologin\ndbus:x:81:81:System Message Bus:/:/sbin/nologin\nbin:x:1:1::/:/sbin/nologin\ndaemon:x:2:2::/:/sbin/nologin\nmail:x:8:12::/var/spool/mail:/sbin/nologin\nftp:x:14:11::/srv/ftp:/sbin/nologin\nhttp:x:33:33::/srv/http:/sbin/nologin\nsystemd-journal-remote:x:982:982:systemd Journal Remote:/:/sbin/nologin\nsystemd-network:x:981:981:systemd Network Management:/:/sbin/nologin\n~~~\n__显示文件的前n行__\n\n~~~\n> head -n 2 /etc/passwd\nroot:x:0:0::/root:/bin/bash\nnobody:x:65534:65534:Nobody:/:/sbin/nologin\n~~~\n\n__显示文件的前n个字节__\n\n~~~\n> head -c 4 /etc/passwd\nroot\n~~~\n\n__显示多个文件__\n\n\n~~~\n> head -1 /etc/passwd /etc/profile\n==> /etc/passwd <==\nroot:x:0:0::/root:/bin/bash\n\n==> /etc/profile <==\n# /etc/profile\n~~~\n\n# 3.6 tail显示文件内容尾部\n\n`tail`命令用于显示文件内容尾部，默认输出行数为10行。\n\n语法格式\n\n~~~\ntail [选项] [文件]\n~~~\n\n`tail`命令的参数选项及说明\n\n| 选项         | 说明                                       |\n|--------------|--------------------------------------------|\n| -c<字节>     | 指定显示的字节数                           |\n| -n<行数>     | 指定显示的行数                             |\n| -f           | 实时输出文件内容追加的数据                 |\n| --retry      | 不停的尝试打开文件，直到打开为止           |\n| -F           | 等同于-f--retry                            |\n| --pid=进程号 | 若进程关闭则tail的-f选项则不会继续输出内容 |\n| -s 秒数 N    | 监视文件的间隔秒数                         |\n| -q           | 显示时不包含指定的文件名作为文件头部       |\n| -v           | 显示时包含指定的文件的文件名作为文件头部   |\n\n例子:\n\n__显示文件最后10行__\n\n~~~\n> tail /etc/passwd\ngit:x:973:973:git daemon user:/:/usr/bin/git-shell\nlightdm:x:620:620:Light Display Manager:/var/lib/lightdm:/sbin/nologin\nnm-openconnect:x:972:972:NetworkManager OpenConnect:/:/sbin/nologin\nnm-openvpn:x:971:971:NetworkManager OpenVPN:/:/sbin/nologin\nntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/false\npolkitd:x:102:102:PolicyKit daemon:/:/sbin/nologin\nusbmux:x:140:140:usbmux user:/:/sbin/nologin\nevanmeek:x:1000:1000:EvanMeek:/home/evanmeek:/usr/bin/zsh\nnvidia-persistenced:x:143:143:NVIDIA Persistence Daemon:/:/sbin/nologin\nprivoxy:x:42:42:Privoxy:/:/sbin/nologin\n~~~\n\n__显示文件最后5行__\n\n_第一种写法_\n\n~~~\n> tail -n 5 /etc/passwd\n~~~\n\n_第二种写法_\n\n~~~\n> tail -5 /etc/passwd\n~~~\n\n__指定从第几行开始显示文件__\n\n~~~\n> tail -n +10 /etc/passwd\n~~~\n\n__实时监控文件的变化__\n\n监测\n~~~\n> tail -f --retry test.txt\ntestwords\n~~~\n追加内容\n\n~~~\n> echo testwords >> test.txt\n~~~\n\n# 3.7 tailf 跟踪日志文件\n\n`tailf`命令日常工作中用于跟踪日志文件，它与`tail -f `命令基本相同，但唯一的区别是若文件内容无增加，则不会重复访问磁盘文件，也不会修改文件访问时间。\n\n语法格式\n\n~~~\ntailf [选项] [文件]\n~~~\n\n`tailf`命令的参数选项及说明\n\n| 选项     | 说明                               |\n|----------|------------------------------------|\n| -n<行数> | 指定显示的行数，默认为文件最后10行 |\n\n例子：\n\n__跟踪日志文件__\n\n~~~\n> tailf \n~~~\n\n# 3.8 cut 从文本中提取一段文字并输出\n\n`cut`命令从文件的每一行剪切字节，字符或字段，并将其输出至标准输出。\n\n语法格式\n\n~~~\ncut [选项] [文件]\n~~~\n\n`cut`命令的参数选项及说明\n\n| 选项 | 说明                                |\n|------|-------------------------------------|\n| -b   | 以字节为单位进行分割                |\n| -n   | 取消分割多字节字符                  |\n| -c   | 以字符为单位进行分割`!`             |\n| -d   | 自定义分隔符，默认以tab为分隔符`!`  |\n| -f   | 与选项-d一起使用，指定显示哪个区域  |\n| N    | 第N个字节、字符或字段`!`            |\n| N-   | 从第N个字节、字符或字段开始直至行尾 |\n| N-M  | 从第N到第M个字节、字符或字段        |\n| -M   | 从第一到第M个字节、字符或字段       |\n\n例子:\n\n__以字节为分隔符__\n\n~~~\n> cat test.txt\nHello World\n# 截取第5个字节，并输出\n> cut -b 5 test.txt\no\n# 截取第5个字节之前的所有字符(包括第5个)，并输出\n> cut -b -5 test.txt\nHello\n# 截取第5个字节之后的所有字符，并输出\n> cut -b 5- test.txt\no World\n# 截取第5个字节和第10个字节，并输出\n> cut -b 5,10 test.txt\nol\n# 截取第1个字节到第5个字节，并输出\n> cut -b 1-5 test.txt\nHello\n~~~\n\n__以字符为分隔符__\n\n~~~\n> cat test.txt\nHello World\n你好世界\n# 截取第1到第6个字符，并输出\n> cut -b 1-6 test.txt\nHello\n你好\n~~~\n\n__自定义分隔符__\n\n~~~\n> cat /etc/passwd | head -n 5\nroot:x:0:0::/root:/bin/bash\nnobody:x:65534:65534:Nobody:/:/sbin/nologin\ndbus:x:81:81:System Message Bus:/:/sbin/nologin\nbin:x:1:1::/:/sbin/nologin\ndaemon:x:2:2::/:/sbin/nologin\n# 自定义分隔符为`:`，并且之输出文件前5行(:为分隔符，-f 1为指定显示第1个区域\n> cut -d : -f 1 /etc/passwd | head -n 5\nroot\nnobody\ndbus\nbin\ndaemon\n# 指定显示区域为1,6-8\n> cut -d : -f 1,6-8 /etc/passwd | head -n +5\n~~~\n\n# 3.9 split 分割文件\n\n`split`命令可以将文件进行分割，支持根据行数或文件大小进行分割。\n\n语法格式\n\n~~~\nsplit [选项] [输入文件] [输出文件名[前缀]]\n~~~\n\n_输出文件的格式会加上前缀，例如`PREFIXaa,PREFIXab`_\n\n`split`命令的参数选项及说明\n\n| 选项 | 说明                        |\n|------|-----------------------------|\n| -b   | 指定分割后文件的最大字节数  |\n| -l   | 指定分割后文件的最大行数`!` |\n| -a   | 指定后缀长度，默认为2位字母 |\n| -d   | 使用数字后缀                |\n\n例子:\n\n__按行分割文件，以及指定后缀形式__\n\n~~~\n# wc 命令可以查看文件的行数\n> wc -l /etc/passwd\n31 /etc/passwd\n# 按行进行分割，每10行分割为一个新文件，文件前缀为split_\n> split -l 10 /etc/passwd split_\n> wc -l split_*\n10 split_aa\n10 split_ab\n10 split_ac\n 1 split_ad\n31 总用量\n# 参数-a指定分割文件的前缀长度，这里设置的是1\n> split -l 10 -a 1 /etc/passwd split2_\n> wc -l split2_*\n10 split2_a\n10 split2_b\n10 split2_c\n 1 split2_d\n31 总用量\n# 参数-d指定文件使用数字后缀\n> split -l 10 -d -a 1 /etc/passwd split_\n> wc -l split_*\n10 split_0\n10 split_1\n10 split_2\n 1 split_3\n31 总用量<Paste>\n~~~\n\n__按文件大小分割文件__\n\n~~~\n# 准备测试文件\n> cp /sbin/lvm .\n> ls -l\n总用量 2.3M\n-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm\n# 按文件字节进行分割，每500K字节分割为一个文件，以数字作为文件后缀\n> split -b 500K -d lvm lvm_split_\n> ls -l\n总用量 4.5M\n-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_00\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_01\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_02\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_03\n-rw-r--r-- 1 evanmeek evanmeek 254K  7月 22 21:25 lvm_split_04\n~~~\n\n# 3.10 paste 合并文件\n\n`paste`命令能将文件按照行与行进行合并，中间使用tab隔开\n\n语法格式\n~~~\npaste [选项] [文件]\n~~~\n\n`paste`命令的参数选项及说明\n\n| 选项 | 说明                           |\n|------|--------------------------------|\n| -d   | 指定合并的分隔符，默认是Tab`!` |\n| -s   | 每个文件占用一行               |\n\n例子:\n\n__合并文件__\n\n~~~\n> more t1 t2\n::::::::::::::\nt1\n::::::::::::::\ntest1\ntest1\ntest1\n::::::::::::::\nt2\n::::::::::::::\ntest2\ntest2\ntest2\n# t1与t2合并，将内容写入t3\n> paste t1 t2 > t3\n> cat t3\ntest1\ttest2\ntest1\ttest2\ntest1\ttest2\n# 合并时，自定义分隔符\n> paste -d - t1 t2 > t3\n> cat t3\ntest1-test2\ntest1-test2\ntest1-test2\n~~~\n\n__文件内容合并成一行__\n\n~~~\n> paste -s t1 t2 > t3\n> cat t3\ntest1\ttest1\ttest1\ntest2\ttest2\ttest2\n~~~\n\n# 3.11 sort 文本排序\n\n`sort`命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出\n\n语法格式\n\n~~~\nsort [选项] [文件]\n~~~\n\n`sort`命令的参数选项及说明\n\n| 选项 | 说明                       |\n|------|----------------------------|\n| -b   | 忽略每行开头存在的空格字符 |\n| -n   | 按照数值的大小进行排序`!`  |\n| -r   | 倒序排序`!`                |\n| -u   | 去除重复行                 |\n| -t   | 指定分隔符`!`              |\n| -k   | 按照指定区间排序`!`        |\n\n例子:\n\n__默认以行为单位进行排序__\n\n~~~\n$ cat test.txt\nt1\nt2\nt3\nt4\n# sort默认是以ASCII码进行升序排序。\n$ sort test.txt\nt1\nt2\nt3\nt4\n# 按照数值的大小进行排序\n$ sort -n test.txt\nt1\nt2\nt3\nt4\n# 按照数值的大小降序排序\n$ sort -nr test.txt\nt4\nt3\nt2\nt1\n~~~\n\n__去除重复行__\n\n~~~\n$ cat test.txt\nt1 D\nt1 D\nt1 D\nt2 C\nt3 B\nt4 A\n# 去除重复行，并且逆序排序\n$ sort -u test.txt | sort -nr\nt4 A\nt3 B\nt2 C\nt1 D\n~~~\n\n__自定义区间排序__\n\n~~~\n# 指定以空格作为分隔符，并且以第二列进行逆序排序\n$ sort -t \" \" -k2 test.txt\nt4 A\nt3 B\nt2 C\nt1 D\nt1 D\nt1 D\n~~~\n\n__-t -k的进阶用法__\n\n~~~\n$ cat ip.txt\n192.197.113.0\t192.197.113.255\t256\n193.112.0.0\t193.112.255.255\t65536\n195.78.82.0\t195.78.83.255\t512\n198.175.100.0\t198.175.103.255\t1024\n199.212.57.0\t199.212.57.255\t256\n202.0.100.0\t202.0.101.255\t512\n202.0.122.0\t202.0.123.255\t512\n202.0.176.0\t202.0.179.255\t1024\n202.3.128.0\t202.3.129.255\t512\n202.3.134.0\t202.3.134.255\t256\n202.4.128.0\t202.4.159.255\t8192\n202.4.252.0\t202.4.255.255\t1024\n# 以第3个字段的第1个字符到第3个字段的第3个字段进行数字排序\n$ sort -n -t. -k3.1,3.3 ip.txt\n193.112.0.0\t193.112.255.255\t65536\n199.212.57.0\t199.212.57.255\t256\n195.78.82.0\t195.78.83.255\t512\n198.175.100.0\t198.175.103.255\t1024\n202.0.100.0\t202.0.101.255\t512\n192.197.113.0\t192.197.113.255\t256\n202.0.122.0\t202.0.123.255\t512\n202.3.128.0\t202.3.129.255\t512\n202.4.128.0\t202.4.159.255\t8192\n202.3.134.0\t202.3.134.255\t256\n202.0.176.0\t202.0.179.255\t1024\n202.4.252.0\t202.4.255.255\t1024\n~~~\n\n# 3.12 join 按两个文件的相同字段合并\n\n`join`命令针对每一对具有相同内容的输入行，整合为一行输出到标准输出，默认情况下是把输入的第一个字段作为连接字段，字段之间用空格隔开。\n\n语法格式\n\n~~~\njoin [选项] [文件1] [文件2]\n~~~\n\n`join`命令的参数选项及说明\n\n| 选项     | 说明                                                    |\n|----------|---------------------------------------------------------|\n| -a文件号 | 输出文件中不匹配的行，文件号可选值1或2,代表文件1和文件2 |\n| -i       | 比较字段时忽略大小写                                    |\n| -1 字段  | 以第1个文件的指定字段为基础进行合并                     |\n| -2 字段  | 以第2个文件的指定字段为基础进行合并                     |\n\n例子:\n\n__合并文本__\n\n~~~\n$ more t1.txt t2.txt\n::::::::::::::\nt1.txt\n::::::::::::::\n张三 21岁\n李四 23岁\n王五 17岁\n赵六 15岁\n\n::::::::::::::\nt2.txt\n::::::::::::::\n张三 男\n李四 女\n王五 男\n赵六 女\n# 将t1和t2进行合并\n$ join t1.txt t2.txt > t3.txt\n$ cat t3.txt\n张三 21岁 男\n李四 23岁 女\n王五 17岁 男\n赵六 15岁 女\n~~~\n\n# 3.13 uniq 去除重复行\n\n`uniq`命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用`uniq`命令去重并计数。\n\n语法格式\n\n~~~\nuniq [选项] [文件或标准输入]\n~~~\n\n选项说明\n\n| 选项 | 说明                               |\n|------|------------------------------------|\n| -c   | 去除重复行，并且计算每行出现的次数 |\n| -d   | 只显示重复的行                     |\n| -u   | 只显示唯一的行                     |\n\n例子:\n\n__去重测试案例__\n\n~~~\n> cat test.txt\n重复重复重复\n重复重复重复\n重复重复重复\n重复重复重复\n重复重复重复\n> uniq -c test.txt\n5 重复重复重复\n~~~\n\n__结合sort排序后去重__\n\n~~~\n> cat test.txt\n10000\n10000\n2\n10000\n10000\n2\n10000\n> uniq -c test.txt\n2 10000\n1 2\n2 10000\n1 2\n1 10000\n# 在这里我们发现，uniq只能去除相邻重复的行，所以我们就使用sort排序后再进行去重复\n> sort -n test.txt | uniq -c\n2 2\n5 10000\n~~~\n\n# 3.14 wc 统计文件的行数、单词数或字节数\n\n`wc`命令用于统计文件的行数、单词数和字节数。\n\n语法格式\n\n~~~\nwc [选项] [文件]\n~~~\n\n选项说明\n\n| 选项 | 说明                |\n|------|---------------------|\n| -c   | 统计字节数          |\n| -l   | 统计行数`!`         |\n| -m   | 统计字符数          |\n| -w   | 统计单词数          |\n| -L   | 输出最长行的长度`!` |\n\n例子:\n\n__查看文件的字节数、字数、行数__\n~~~\n> wc /etc/profile\n9      30     189 /etc/profile\n\n# 依次排列过去是 行数 - 单词数 - 字节数\n~~~\n\n# 3.15 iconv 转换文件的编码格式\n\n`iconv`命令用于转换文件的编码格式.\n\n语法格式\n\n~~~\niconv [选项] [原编码] [新编码] [输入文件]\n~~~\n\n选项说明\n\n| 选项         | 说明                    |\n|--------------|-------------------------|\n| -f encodingA | 从编码A转换`!`          |\n| -t encodingB | 转换程编码B `!`         |\n| -l           | 显示系统支持的编码`!`   |\n| -o           | 将输出输入到指定文件`!` |\n\n例子:\n\n~~~\n> cat utf-8.txt\n你好世界\n# 指定utf-8.txt的编码格式为utf-8，将要转换成GB2312\n> iconv -f UTF-8 -t GB2312 utf-8.txt > gbk.txt\n> cat gbk.txt\n无回显\n~~~\n\n# 3.16 dos2unix 将DOS格式文件转换成UNIX格式\n\n由于dos格式的文件的换行符与unix格式的文件的换行符不同，所以需要转换。\n\n语法格式\n\n~~~\ndos2unix [文件]\n~~~\n\n例子:\n\n~~~\n> dos2unix dosfile.txt\n~~~\n\n# 3.17 diff 比较两个文件的不同\n\n`diff`命令可以逐行比较纯文本文件的内容，并输出文件的差异。\n\n语法格式\n\n~~~\ndiff [选项] [文件1] [文件2]\n~~~\n\n选项说明\n\n| 选项 | 说明                           |\n|------|--------------------------------|\n| -y   | 以并列的方式显示文件的异同之处 |\n| -W   | 在使用-y参数时，指定显示宽度   |\n| -c   | 使用上下文的输出格式           |\n| -u   | 使用统一格式输出               |\n\n例子:\n\n__比较两个文本文件__\n\n~~~\nevanmeek@EvanMeekdeMBP  ~/TestDir  cat test1.txt\n1\n2\n3\n4\n5\n6\nevanmeek@EvanMeekdeMBP  ~/TestDir  cat test2.txt\n4\n5\n6\n7\n8\n9\nevanmeek@EvanMeekdeMBP  ~/TestDir  diff test1.txt test2.txt\n# 代表文件2对比文件1删除了第一行到第三行\n1,3d0\n< 1\n< 2\n< 3\n# 代表文件1的第6行下增加了文件2的第4行和第5行\n6a4,6\n> 7\n> 8\n> 9\n~~~\n\n__并排格式输出__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y test1.txt test2.txt\n1                                                             <\n2                                                             <\n3                                                             <\n4                                                               4\n5                                                               5\n6                                                               6\n                                                            > 7\n                                                            > 8\n                                                            > 9\n~~~\n\n__并排格式输出时指定宽度__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y -W 30 test1.txt test2.txt\n1             <\n2             <\n3             <\n4               4\n5               5\n6               6\n              > 7\n              > 8\n              > 9\n~~~\n\n__上下文输出格式__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -c test1.txt test2.txt\n*** test1.txt   2019-08-25 16:39:32.000000000 +0800\n--- test2.txt   2019-08-25 16:40:32.000000000 +0800\n***************\n*** 1,6 ****\n- 1\n- 2\n- 3\n  4\n  5\n  6\n--- 1,6 ----\n  4\n  5\n  6\n+ 7\n+ 8\n+ 9\n~~~\n\n__统一标准输出格式__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -u test1.txt test2.txt\n--- test1.txt   2019-08-25 16:39:32.000000000 +0800\n+++ test2.txt   2019-08-25 16:40:32.000000000 +0800\n@@ -1,6 +1,6 @@\n-1\n-2\n-3\n 4\n 5\n 6\n+7\n+8\n+9\n~~~\n\n# 3.19 rev 反向输出文件内容\n\n`rev`命令可以按行反向输出文件内容\n\n语法格式\n\n~~~\nrev [文件]\n~~~\n\n例子:\n\n__字符串反转__\n\n~~~\n> echo {1..10}\n1 2 3 4 5 6 7 8 9 10\n> echo {1..10}|rev\n01 9 8 7 6 5 4 3 2 1\n~~~\n\n__文本反转__\n\n~~~\n> cat testfile\n你好世界\n> rev testfile\n界世好你\n~~~\n\n# 3.20 tr 替换或删除字符\n\n`tr`命令从标准输入中替换、缩减或删除字符，并将结果写入到标准输出\n\n语法格式\n\n~~~\ntr [选项] [字符1] [字符2]\n~~~\n\n选项说明\n\n| 选项 | 说明                                   |\n|------|----------------------------------------|\n| -d   | 删除字符`!`                            |\n| -s   | 保留连续字符的第一个字符，删除其他字符 |\n| -c   | 使用第一个字符串(set1)的补集，取反     |\n\n例子:\n\n__替换文本中出现的字符为某字符__\n\n~~~\n> cat testfile\ntest word\naa bb cc\nabc\n# 这里是将文件中出现'a'的字符替换成'x',依次对应\n> tr 'abc' 'xyz' < testfile\ntest word\nxx yy zz\nxyz\n~~~\n\n__使用tr统一字母大小写__\n\n~~~\n> cat testfile\ntest word\naa bb cc\nabc\n# [a-z]代表小写字母a b c d..z\n> tr '[a-z]' '[A-Z]' < testfile\nTEST WORD\nAA BB CC\nABC\n~~~\n\n__将数字0-9替换为a-j__\n\n~~~\n> cat testfile\n0 1 2 3 4 5 6 7 8 9\n> tr '[0-9]' '[a-j]' < testfile\na b c d e f g h i j\n~~~\n\n__删除文件中出现的Evan这个单词中的每个字符__\n\n~~~\n> cat testfile\nEeEvVvaAanNn\n> tr -d 'Evan' < testfile\neVAN\n~~~\n\n__删除文件中出现的换行符和制表符__\n\n~~~\n> cat tesfile\n\na aaa aaa   aaa\nb   b     b \n> tr -d '\\n\\t' < testfile\na aaa aaa   aaab   b     b%\n~~~\n\n# 3.21 od 按不同进制显示文件\n\n`od`命令用于输出文件的八进制，十六进制等其他编码格式的字节，通常用于显示或查看文件中不能直接显示在终端的字符\n\n语法格式\n\n~~~\nod [选项] [文件]\n~~~\n\n选项说明\n\n| 选项        | 说明                     |\n|-------------|--------------------------|\n| -A 地址进制 | 按指定的进制显示地址信息 |\n| -t 显示格式 | 指定数据的显示格式       |\n\n\n| 地址信息 | 解释         |\n|----------|--------------|\n| o        | 八进制(默认) |\n| d        | 十进制       |\n| x        | 十六进制     |\n| n        | 不打印位移值 |\n\n| 格式 | 解释                  |\n|------|-----------------------|\n| a    | 命名字符，忽略高阶位  |\n| c    | ASCII字符或反斜杠序列 |\n| d    | 有符号的十进制数      |\n| f    | 浮点数                |\n| o    | 八进制(系统默认)      |\n| u    | 无符号十进制          |\n| x    | 十六进制              |\n","source":"_posts/Linux-文件过滤及内容编辑处理命令-2.md","raw":"---\ntitle: Linux-文件过滤及内容编辑处理命令-2\ncopyright: true\ndate: 2019-06-30 19:26:29\ncategories: Linux系列\ntags:\n  - Linux\n---\n\n# 3.0 做Linux运维的多个好处\n\n1. 做运维可以认识更多人，同时也被更多人认识。\n\n2. 做运维可以让自己沟通，交际能力变得比开发人员更强。\n\n3. 相比开发岗位，运维的岗位更重要一些。\n\n# 3.1 cat 合并文件或查看文件内容\n\n`concatenate`\n\n__cat命令5大常用功能__\n\n| 序号 | 常用功能                 | 例子以及说明                                              |\n|------|--------------------------|-----------------------------------------------------------|\n| 1    | 查看文件内容             | cat file.txt 查看文件内容，最基本的使用                   |\n| 2    | 多个文件合并为一个文件   | cat f1 f2 > newf 将f1和f2的内容合并到newf                 |\n| 3    | 创建编辑新文件           | cat > file 输入后会请求输入，快捷键Ctrl+d/c可退出         |\n| 4    | 非交互式编辑或追加新内容 | cat >>file<<EOF 输入后会请求输入，在结束时输入EOF即可退出 |\n| 5    | 清空文件内容             | cat /dev/null > file 清空文件内容                         |\n\n语法格式\n\n~~~\ncat [选项] [文件]\n~~~\n\n| 选项 | 说明                                   |\n|------|----------------------------------------|\n| -n   | 为输出的内容加编号，从1开始            |\n| -b   | 与-n类似，但它忽略空白行               |\n| -s   | 当遇到有多行空白行，则合并为单行空白行 |\n| -v   | 除了LFD和TAB之外，使用^和M-引用        |\n| -T   | 将Tab字符显示为^I                      |\n| -E   | 在行尾显示$符号                        |\n| -t   | 等价与-vT                              |\n| -A   | 等价于-vE                              |\n\n例子\n\n__使用cat命令以非交互式的方式编辑文件__\n\n方式1:\n\n~~~\n> cat >file<<EOF\n\n\nJust a test.\nEOF\n> cat file\n\n\nJust a test\n~~~\n\n解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现\n\n易错点: 结束EOF必须置前，前面不能有任意字符\n\n方式2:\n\n~~~\n> cat >file<<-EOF\n\n\nJust a test.\n  EOF\n> cat file\n\n\nJust a test.\n~~~\n\n解释: 在字符标签前加上`-`可以使得结束标签前可放置制表符，但仅仅只可放制表符\n\n__合并多个文件为单个文件__\n\n~~~\n> cat > f1\nf1\nCtrl+d\n> cat > f2\nf2\nCtrl+c\n> cat f1 f2\nf1\nf2\n> cat f1 f2 > newfile\n> cat newfile\nf1\nf2\n~~~\n\n# 3.2 tac 反向显示文件内容\n\n跟`cat`命令类似，反向输出文件内容\n\n| 选项 | 说明                             |\n|------|----------------------------------|\n| -b   | 在行前添加分隔标志               |\n| -r   | 将分隔标志视作正则表达式进行解析 |\n| -s   | 使用指定字符作为换行的标志       |\n\n例子\n\n~~~\n> cat file1\nhello\nworld\n> tac file2\nworld\nhello\n~~~\n\n# 3.3 more 分页显示文件内容\n\n`more`类似于`cat`命令，区别在于`cat`命令是将文件内容一次性全部显示在屏幕上，而`more`则会分页进行显示。\n\n语法格式\n\n~~~\nmore [选项] [文件]\n~~~\n\n`more`参数选项说明\n\n| 选项 | 说明                                                                         |\n|------|------------------------------------------------------------------------------|\n| -num | 指定屏幕显示大小为num行                                                      |\n| +num | 从行号num开始显示                                                            |\n| -s   | 把连续的多个空行显示在一行                                                   |\n| -p   | 不滚屏，而是清除整个自己屏幕，然后显示文件                                   |\n| -c   | 不滚屏，而是从每一屏的顶部开始显示文本，每显示完一行，就清除这一行的剩余部分 |\n\n`more`交互式说明\n\n| 子命令    | 说明                     |\n|-----------|--------------------------|\n| h/?       | 查看帮助                 |\n| 空格键    | 向下滚动一屏             |\n| z         | 向下滚动一屏             |\n| Enter     | 向下显示一行             |\n| f         | 向下滚动一屏             |\n| b         | 返回上一屏               |\n| =         | 输出当前行的行号         |\n| /查找文本 | 查找指定的文本           |\n| :f        | 输出文件名和当前行的行号 |\n| v         | 调用vi编辑器             |\n| !命令     | 调用Shell，并执行命令    |\n| q         | 退出more                 |\n\n# 3.4 less 分页显示文件内容\n\n`less`类似`more`命令，`less`的功能比`more`要强大\n\n语法格式\n\n~~~\nless [选项] [文件]\n~~~\n\n`less`命令的参数选项及说明\n\n| 选项 | 说明                                                        |\n|------|-------------------------------------------------------------|\n| -i   | 搜索时忽略大小写                                            |\n| -m   | 显示进度百分比                                              |\n| -N   | 显示行号                                                    |\n| -s   | 多行空行显示为单行                                          |\n| -e   | 当显示到文件结尾时自动退出，若没有此选项则需要用交互式q退出 |\n\n`less`命令的交互式子命令及说明\n\n| 子命令    | 说明         |\n|-----------|--------------|\n| b         | 向前翻一页   |\n| 空格键    | 向后翻一页   |\n| u         | 向前翻半页   |\n| d         | 向后翻半页   |\n| y         | 向上滚动一行 |\n| 回车键    | 向下滚动一行 |\n| 方向键-上 | 向上滚动一行 |\n| 方向键-下 | 向下滚动一行 |\n| Page UP   | 向上滚动一屏 |\n| Page Down | 向下滚动一屏 |\n\n例子:\n\n__显示文件内容时并且显示行号__\n\n~~~\n> less -N 文件名\n~~~\n\n__分页显示命令的结果__\n\n\n~~~\n> ls -l | less\n~~~\n\n# 3.5 head 显示文件内容头部\n\n`head`命令用于显示文件内容头部，默认输出行数为10行。\n\n语法格式\n\n~~~\nhead [选项] [文件]\n~~~\n\n`head`命令的参数选项及说明\n\n| 选项     | 说明                                     |\n|----------|------------------------------------------|\n| -n<行数> | 指定显示的行数                           |\n| -c<字节> | 指定显示的字节数                         |\n| -q       | 显示时不包含指定的文件名作为文件头部     |\n| -v       | 显示时包含指定的文件的文件名作为文件头部 |\n\n例子:\n\n__默认显示文件的前10行__\n\n~~~\n> head /etc/passwd\nroot:x:0:0::/root:/bin/bash\nnobody:x:65534:65534:Nobody:/:/sbin/nologin\ndbus:x:81:81:System Message Bus:/:/sbin/nologin\nbin:x:1:1::/:/sbin/nologin\ndaemon:x:2:2::/:/sbin/nologin\nmail:x:8:12::/var/spool/mail:/sbin/nologin\nftp:x:14:11::/srv/ftp:/sbin/nologin\nhttp:x:33:33::/srv/http:/sbin/nologin\nsystemd-journal-remote:x:982:982:systemd Journal Remote:/:/sbin/nologin\nsystemd-network:x:981:981:systemd Network Management:/:/sbin/nologin\n~~~\n__显示文件的前n行__\n\n~~~\n> head -n 2 /etc/passwd\nroot:x:0:0::/root:/bin/bash\nnobody:x:65534:65534:Nobody:/:/sbin/nologin\n~~~\n\n__显示文件的前n个字节__\n\n~~~\n> head -c 4 /etc/passwd\nroot\n~~~\n\n__显示多个文件__\n\n\n~~~\n> head -1 /etc/passwd /etc/profile\n==> /etc/passwd <==\nroot:x:0:0::/root:/bin/bash\n\n==> /etc/profile <==\n# /etc/profile\n~~~\n\n# 3.6 tail显示文件内容尾部\n\n`tail`命令用于显示文件内容尾部，默认输出行数为10行。\n\n语法格式\n\n~~~\ntail [选项] [文件]\n~~~\n\n`tail`命令的参数选项及说明\n\n| 选项         | 说明                                       |\n|--------------|--------------------------------------------|\n| -c<字节>     | 指定显示的字节数                           |\n| -n<行数>     | 指定显示的行数                             |\n| -f           | 实时输出文件内容追加的数据                 |\n| --retry      | 不停的尝试打开文件，直到打开为止           |\n| -F           | 等同于-f--retry                            |\n| --pid=进程号 | 若进程关闭则tail的-f选项则不会继续输出内容 |\n| -s 秒数 N    | 监视文件的间隔秒数                         |\n| -q           | 显示时不包含指定的文件名作为文件头部       |\n| -v           | 显示时包含指定的文件的文件名作为文件头部   |\n\n例子:\n\n__显示文件最后10行__\n\n~~~\n> tail /etc/passwd\ngit:x:973:973:git daemon user:/:/usr/bin/git-shell\nlightdm:x:620:620:Light Display Manager:/var/lib/lightdm:/sbin/nologin\nnm-openconnect:x:972:972:NetworkManager OpenConnect:/:/sbin/nologin\nnm-openvpn:x:971:971:NetworkManager OpenVPN:/:/sbin/nologin\nntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/false\npolkitd:x:102:102:PolicyKit daemon:/:/sbin/nologin\nusbmux:x:140:140:usbmux user:/:/sbin/nologin\nevanmeek:x:1000:1000:EvanMeek:/home/evanmeek:/usr/bin/zsh\nnvidia-persistenced:x:143:143:NVIDIA Persistence Daemon:/:/sbin/nologin\nprivoxy:x:42:42:Privoxy:/:/sbin/nologin\n~~~\n\n__显示文件最后5行__\n\n_第一种写法_\n\n~~~\n> tail -n 5 /etc/passwd\n~~~\n\n_第二种写法_\n\n~~~\n> tail -5 /etc/passwd\n~~~\n\n__指定从第几行开始显示文件__\n\n~~~\n> tail -n +10 /etc/passwd\n~~~\n\n__实时监控文件的变化__\n\n监测\n~~~\n> tail -f --retry test.txt\ntestwords\n~~~\n追加内容\n\n~~~\n> echo testwords >> test.txt\n~~~\n\n# 3.7 tailf 跟踪日志文件\n\n`tailf`命令日常工作中用于跟踪日志文件，它与`tail -f `命令基本相同，但唯一的区别是若文件内容无增加，则不会重复访问磁盘文件，也不会修改文件访问时间。\n\n语法格式\n\n~~~\ntailf [选项] [文件]\n~~~\n\n`tailf`命令的参数选项及说明\n\n| 选项     | 说明                               |\n|----------|------------------------------------|\n| -n<行数> | 指定显示的行数，默认为文件最后10行 |\n\n例子：\n\n__跟踪日志文件__\n\n~~~\n> tailf \n~~~\n\n# 3.8 cut 从文本中提取一段文字并输出\n\n`cut`命令从文件的每一行剪切字节，字符或字段，并将其输出至标准输出。\n\n语法格式\n\n~~~\ncut [选项] [文件]\n~~~\n\n`cut`命令的参数选项及说明\n\n| 选项 | 说明                                |\n|------|-------------------------------------|\n| -b   | 以字节为单位进行分割                |\n| -n   | 取消分割多字节字符                  |\n| -c   | 以字符为单位进行分割`!`             |\n| -d   | 自定义分隔符，默认以tab为分隔符`!`  |\n| -f   | 与选项-d一起使用，指定显示哪个区域  |\n| N    | 第N个字节、字符或字段`!`            |\n| N-   | 从第N个字节、字符或字段开始直至行尾 |\n| N-M  | 从第N到第M个字节、字符或字段        |\n| -M   | 从第一到第M个字节、字符或字段       |\n\n例子:\n\n__以字节为分隔符__\n\n~~~\n> cat test.txt\nHello World\n# 截取第5个字节，并输出\n> cut -b 5 test.txt\no\n# 截取第5个字节之前的所有字符(包括第5个)，并输出\n> cut -b -5 test.txt\nHello\n# 截取第5个字节之后的所有字符，并输出\n> cut -b 5- test.txt\no World\n# 截取第5个字节和第10个字节，并输出\n> cut -b 5,10 test.txt\nol\n# 截取第1个字节到第5个字节，并输出\n> cut -b 1-5 test.txt\nHello\n~~~\n\n__以字符为分隔符__\n\n~~~\n> cat test.txt\nHello World\n你好世界\n# 截取第1到第6个字符，并输出\n> cut -b 1-6 test.txt\nHello\n你好\n~~~\n\n__自定义分隔符__\n\n~~~\n> cat /etc/passwd | head -n 5\nroot:x:0:0::/root:/bin/bash\nnobody:x:65534:65534:Nobody:/:/sbin/nologin\ndbus:x:81:81:System Message Bus:/:/sbin/nologin\nbin:x:1:1::/:/sbin/nologin\ndaemon:x:2:2::/:/sbin/nologin\n# 自定义分隔符为`:`，并且之输出文件前5行(:为分隔符，-f 1为指定显示第1个区域\n> cut -d : -f 1 /etc/passwd | head -n 5\nroot\nnobody\ndbus\nbin\ndaemon\n# 指定显示区域为1,6-8\n> cut -d : -f 1,6-8 /etc/passwd | head -n +5\n~~~\n\n# 3.9 split 分割文件\n\n`split`命令可以将文件进行分割，支持根据行数或文件大小进行分割。\n\n语法格式\n\n~~~\nsplit [选项] [输入文件] [输出文件名[前缀]]\n~~~\n\n_输出文件的格式会加上前缀，例如`PREFIXaa,PREFIXab`_\n\n`split`命令的参数选项及说明\n\n| 选项 | 说明                        |\n|------|-----------------------------|\n| -b   | 指定分割后文件的最大字节数  |\n| -l   | 指定分割后文件的最大行数`!` |\n| -a   | 指定后缀长度，默认为2位字母 |\n| -d   | 使用数字后缀                |\n\n例子:\n\n__按行分割文件，以及指定后缀形式__\n\n~~~\n# wc 命令可以查看文件的行数\n> wc -l /etc/passwd\n31 /etc/passwd\n# 按行进行分割，每10行分割为一个新文件，文件前缀为split_\n> split -l 10 /etc/passwd split_\n> wc -l split_*\n10 split_aa\n10 split_ab\n10 split_ac\n 1 split_ad\n31 总用量\n# 参数-a指定分割文件的前缀长度，这里设置的是1\n> split -l 10 -a 1 /etc/passwd split2_\n> wc -l split2_*\n10 split2_a\n10 split2_b\n10 split2_c\n 1 split2_d\n31 总用量\n# 参数-d指定文件使用数字后缀\n> split -l 10 -d -a 1 /etc/passwd split_\n> wc -l split_*\n10 split_0\n10 split_1\n10 split_2\n 1 split_3\n31 总用量<Paste>\n~~~\n\n__按文件大小分割文件__\n\n~~~\n# 准备测试文件\n> cp /sbin/lvm .\n> ls -l\n总用量 2.3M\n-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm\n# 按文件字节进行分割，每500K字节分割为一个文件，以数字作为文件后缀\n> split -b 500K -d lvm lvm_split_\n> ls -l\n总用量 4.5M\n-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_00\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_01\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_02\n-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_03\n-rw-r--r-- 1 evanmeek evanmeek 254K  7月 22 21:25 lvm_split_04\n~~~\n\n# 3.10 paste 合并文件\n\n`paste`命令能将文件按照行与行进行合并，中间使用tab隔开\n\n语法格式\n~~~\npaste [选项] [文件]\n~~~\n\n`paste`命令的参数选项及说明\n\n| 选项 | 说明                           |\n|------|--------------------------------|\n| -d   | 指定合并的分隔符，默认是Tab`!` |\n| -s   | 每个文件占用一行               |\n\n例子:\n\n__合并文件__\n\n~~~\n> more t1 t2\n::::::::::::::\nt1\n::::::::::::::\ntest1\ntest1\ntest1\n::::::::::::::\nt2\n::::::::::::::\ntest2\ntest2\ntest2\n# t1与t2合并，将内容写入t3\n> paste t1 t2 > t3\n> cat t3\ntest1\ttest2\ntest1\ttest2\ntest1\ttest2\n# 合并时，自定义分隔符\n> paste -d - t1 t2 > t3\n> cat t3\ntest1-test2\ntest1-test2\ntest1-test2\n~~~\n\n__文件内容合并成一行__\n\n~~~\n> paste -s t1 t2 > t3\n> cat t3\ntest1\ttest1\ttest1\ntest2\ttest2\ttest2\n~~~\n\n# 3.11 sort 文本排序\n\n`sort`命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出\n\n语法格式\n\n~~~\nsort [选项] [文件]\n~~~\n\n`sort`命令的参数选项及说明\n\n| 选项 | 说明                       |\n|------|----------------------------|\n| -b   | 忽略每行开头存在的空格字符 |\n| -n   | 按照数值的大小进行排序`!`  |\n| -r   | 倒序排序`!`                |\n| -u   | 去除重复行                 |\n| -t   | 指定分隔符`!`              |\n| -k   | 按照指定区间排序`!`        |\n\n例子:\n\n__默认以行为单位进行排序__\n\n~~~\n$ cat test.txt\nt1\nt2\nt3\nt4\n# sort默认是以ASCII码进行升序排序。\n$ sort test.txt\nt1\nt2\nt3\nt4\n# 按照数值的大小进行排序\n$ sort -n test.txt\nt1\nt2\nt3\nt4\n# 按照数值的大小降序排序\n$ sort -nr test.txt\nt4\nt3\nt2\nt1\n~~~\n\n__去除重复行__\n\n~~~\n$ cat test.txt\nt1 D\nt1 D\nt1 D\nt2 C\nt3 B\nt4 A\n# 去除重复行，并且逆序排序\n$ sort -u test.txt | sort -nr\nt4 A\nt3 B\nt2 C\nt1 D\n~~~\n\n__自定义区间排序__\n\n~~~\n# 指定以空格作为分隔符，并且以第二列进行逆序排序\n$ sort -t \" \" -k2 test.txt\nt4 A\nt3 B\nt2 C\nt1 D\nt1 D\nt1 D\n~~~\n\n__-t -k的进阶用法__\n\n~~~\n$ cat ip.txt\n192.197.113.0\t192.197.113.255\t256\n193.112.0.0\t193.112.255.255\t65536\n195.78.82.0\t195.78.83.255\t512\n198.175.100.0\t198.175.103.255\t1024\n199.212.57.0\t199.212.57.255\t256\n202.0.100.0\t202.0.101.255\t512\n202.0.122.0\t202.0.123.255\t512\n202.0.176.0\t202.0.179.255\t1024\n202.3.128.0\t202.3.129.255\t512\n202.3.134.0\t202.3.134.255\t256\n202.4.128.0\t202.4.159.255\t8192\n202.4.252.0\t202.4.255.255\t1024\n# 以第3个字段的第1个字符到第3个字段的第3个字段进行数字排序\n$ sort -n -t. -k3.1,3.3 ip.txt\n193.112.0.0\t193.112.255.255\t65536\n199.212.57.0\t199.212.57.255\t256\n195.78.82.0\t195.78.83.255\t512\n198.175.100.0\t198.175.103.255\t1024\n202.0.100.0\t202.0.101.255\t512\n192.197.113.0\t192.197.113.255\t256\n202.0.122.0\t202.0.123.255\t512\n202.3.128.0\t202.3.129.255\t512\n202.4.128.0\t202.4.159.255\t8192\n202.3.134.0\t202.3.134.255\t256\n202.0.176.0\t202.0.179.255\t1024\n202.4.252.0\t202.4.255.255\t1024\n~~~\n\n# 3.12 join 按两个文件的相同字段合并\n\n`join`命令针对每一对具有相同内容的输入行，整合为一行输出到标准输出，默认情况下是把输入的第一个字段作为连接字段，字段之间用空格隔开。\n\n语法格式\n\n~~~\njoin [选项] [文件1] [文件2]\n~~~\n\n`join`命令的参数选项及说明\n\n| 选项     | 说明                                                    |\n|----------|---------------------------------------------------------|\n| -a文件号 | 输出文件中不匹配的行，文件号可选值1或2,代表文件1和文件2 |\n| -i       | 比较字段时忽略大小写                                    |\n| -1 字段  | 以第1个文件的指定字段为基础进行合并                     |\n| -2 字段  | 以第2个文件的指定字段为基础进行合并                     |\n\n例子:\n\n__合并文本__\n\n~~~\n$ more t1.txt t2.txt\n::::::::::::::\nt1.txt\n::::::::::::::\n张三 21岁\n李四 23岁\n王五 17岁\n赵六 15岁\n\n::::::::::::::\nt2.txt\n::::::::::::::\n张三 男\n李四 女\n王五 男\n赵六 女\n# 将t1和t2进行合并\n$ join t1.txt t2.txt > t3.txt\n$ cat t3.txt\n张三 21岁 男\n李四 23岁 女\n王五 17岁 男\n赵六 15岁 女\n~~~\n\n# 3.13 uniq 去除重复行\n\n`uniq`命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用`uniq`命令去重并计数。\n\n语法格式\n\n~~~\nuniq [选项] [文件或标准输入]\n~~~\n\n选项说明\n\n| 选项 | 说明                               |\n|------|------------------------------------|\n| -c   | 去除重复行，并且计算每行出现的次数 |\n| -d   | 只显示重复的行                     |\n| -u   | 只显示唯一的行                     |\n\n例子:\n\n__去重测试案例__\n\n~~~\n> cat test.txt\n重复重复重复\n重复重复重复\n重复重复重复\n重复重复重复\n重复重复重复\n> uniq -c test.txt\n5 重复重复重复\n~~~\n\n__结合sort排序后去重__\n\n~~~\n> cat test.txt\n10000\n10000\n2\n10000\n10000\n2\n10000\n> uniq -c test.txt\n2 10000\n1 2\n2 10000\n1 2\n1 10000\n# 在这里我们发现，uniq只能去除相邻重复的行，所以我们就使用sort排序后再进行去重复\n> sort -n test.txt | uniq -c\n2 2\n5 10000\n~~~\n\n# 3.14 wc 统计文件的行数、单词数或字节数\n\n`wc`命令用于统计文件的行数、单词数和字节数。\n\n语法格式\n\n~~~\nwc [选项] [文件]\n~~~\n\n选项说明\n\n| 选项 | 说明                |\n|------|---------------------|\n| -c   | 统计字节数          |\n| -l   | 统计行数`!`         |\n| -m   | 统计字符数          |\n| -w   | 统计单词数          |\n| -L   | 输出最长行的长度`!` |\n\n例子:\n\n__查看文件的字节数、字数、行数__\n~~~\n> wc /etc/profile\n9      30     189 /etc/profile\n\n# 依次排列过去是 行数 - 单词数 - 字节数\n~~~\n\n# 3.15 iconv 转换文件的编码格式\n\n`iconv`命令用于转换文件的编码格式.\n\n语法格式\n\n~~~\niconv [选项] [原编码] [新编码] [输入文件]\n~~~\n\n选项说明\n\n| 选项         | 说明                    |\n|--------------|-------------------------|\n| -f encodingA | 从编码A转换`!`          |\n| -t encodingB | 转换程编码B `!`         |\n| -l           | 显示系统支持的编码`!`   |\n| -o           | 将输出输入到指定文件`!` |\n\n例子:\n\n~~~\n> cat utf-8.txt\n你好世界\n# 指定utf-8.txt的编码格式为utf-8，将要转换成GB2312\n> iconv -f UTF-8 -t GB2312 utf-8.txt > gbk.txt\n> cat gbk.txt\n无回显\n~~~\n\n# 3.16 dos2unix 将DOS格式文件转换成UNIX格式\n\n由于dos格式的文件的换行符与unix格式的文件的换行符不同，所以需要转换。\n\n语法格式\n\n~~~\ndos2unix [文件]\n~~~\n\n例子:\n\n~~~\n> dos2unix dosfile.txt\n~~~\n\n# 3.17 diff 比较两个文件的不同\n\n`diff`命令可以逐行比较纯文本文件的内容，并输出文件的差异。\n\n语法格式\n\n~~~\ndiff [选项] [文件1] [文件2]\n~~~\n\n选项说明\n\n| 选项 | 说明                           |\n|------|--------------------------------|\n| -y   | 以并列的方式显示文件的异同之处 |\n| -W   | 在使用-y参数时，指定显示宽度   |\n| -c   | 使用上下文的输出格式           |\n| -u   | 使用统一格式输出               |\n\n例子:\n\n__比较两个文本文件__\n\n~~~\nevanmeek@EvanMeekdeMBP  ~/TestDir  cat test1.txt\n1\n2\n3\n4\n5\n6\nevanmeek@EvanMeekdeMBP  ~/TestDir  cat test2.txt\n4\n5\n6\n7\n8\n9\nevanmeek@EvanMeekdeMBP  ~/TestDir  diff test1.txt test2.txt\n# 代表文件2对比文件1删除了第一行到第三行\n1,3d0\n< 1\n< 2\n< 3\n# 代表文件1的第6行下增加了文件2的第4行和第5行\n6a4,6\n> 7\n> 8\n> 9\n~~~\n\n__并排格式输出__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y test1.txt test2.txt\n1                                                             <\n2                                                             <\n3                                                             <\n4                                                               4\n5                                                               5\n6                                                               6\n                                                            > 7\n                                                            > 8\n                                                            > 9\n~~~\n\n__并排格式输出时指定宽度__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y -W 30 test1.txt test2.txt\n1             <\n2             <\n3             <\n4               4\n5               5\n6               6\n              > 7\n              > 8\n              > 9\n~~~\n\n__上下文输出格式__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -c test1.txt test2.txt\n*** test1.txt   2019-08-25 16:39:32.000000000 +0800\n--- test2.txt   2019-08-25 16:40:32.000000000 +0800\n***************\n*** 1,6 ****\n- 1\n- 2\n- 3\n  4\n  5\n  6\n--- 1,6 ----\n  4\n  5\n  6\n+ 7\n+ 8\n+ 9\n~~~\n\n__统一标准输出格式__\n\n~~~\n✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -u test1.txt test2.txt\n--- test1.txt   2019-08-25 16:39:32.000000000 +0800\n+++ test2.txt   2019-08-25 16:40:32.000000000 +0800\n@@ -1,6 +1,6 @@\n-1\n-2\n-3\n 4\n 5\n 6\n+7\n+8\n+9\n~~~\n\n# 3.19 rev 反向输出文件内容\n\n`rev`命令可以按行反向输出文件内容\n\n语法格式\n\n~~~\nrev [文件]\n~~~\n\n例子:\n\n__字符串反转__\n\n~~~\n> echo {1..10}\n1 2 3 4 5 6 7 8 9 10\n> echo {1..10}|rev\n01 9 8 7 6 5 4 3 2 1\n~~~\n\n__文本反转__\n\n~~~\n> cat testfile\n你好世界\n> rev testfile\n界世好你\n~~~\n\n# 3.20 tr 替换或删除字符\n\n`tr`命令从标准输入中替换、缩减或删除字符，并将结果写入到标准输出\n\n语法格式\n\n~~~\ntr [选项] [字符1] [字符2]\n~~~\n\n选项说明\n\n| 选项 | 说明                                   |\n|------|----------------------------------------|\n| -d   | 删除字符`!`                            |\n| -s   | 保留连续字符的第一个字符，删除其他字符 |\n| -c   | 使用第一个字符串(set1)的补集，取反     |\n\n例子:\n\n__替换文本中出现的字符为某字符__\n\n~~~\n> cat testfile\ntest word\naa bb cc\nabc\n# 这里是将文件中出现'a'的字符替换成'x',依次对应\n> tr 'abc' 'xyz' < testfile\ntest word\nxx yy zz\nxyz\n~~~\n\n__使用tr统一字母大小写__\n\n~~~\n> cat testfile\ntest word\naa bb cc\nabc\n# [a-z]代表小写字母a b c d..z\n> tr '[a-z]' '[A-Z]' < testfile\nTEST WORD\nAA BB CC\nABC\n~~~\n\n__将数字0-9替换为a-j__\n\n~~~\n> cat testfile\n0 1 2 3 4 5 6 7 8 9\n> tr '[0-9]' '[a-j]' < testfile\na b c d e f g h i j\n~~~\n\n__删除文件中出现的Evan这个单词中的每个字符__\n\n~~~\n> cat testfile\nEeEvVvaAanNn\n> tr -d 'Evan' < testfile\neVAN\n~~~\n\n__删除文件中出现的换行符和制表符__\n\n~~~\n> cat tesfile\n\na aaa aaa   aaa\nb   b     b \n> tr -d '\\n\\t' < testfile\na aaa aaa   aaab   b     b%\n~~~\n\n# 3.21 od 按不同进制显示文件\n\n`od`命令用于输出文件的八进制，十六进制等其他编码格式的字节，通常用于显示或查看文件中不能直接显示在终端的字符\n\n语法格式\n\n~~~\nod [选项] [文件]\n~~~\n\n选项说明\n\n| 选项        | 说明                     |\n|-------------|--------------------------|\n| -A 地址进制 | 按指定的进制显示地址信息 |\n| -t 显示格式 | 指定数据的显示格式       |\n\n\n| 地址信息 | 解释         |\n|----------|--------------|\n| o        | 八进制(默认) |\n| d        | 十进制       |\n| x        | 十六进制     |\n| n        | 不打印位移值 |\n\n| 格式 | 解释                  |\n|------|-----------------------|\n| a    | 命名字符，忽略高阶位  |\n| c    | ASCII字符或反斜杠序列 |\n| d    | 有符号的十进制数      |\n| f    | 浮点数                |\n| o    | 八进制(系统默认)      |\n| u    | 无符号十进制          |\n| x    | 十六进制              |\n","slug":"Linux-文件过滤及内容编辑处理命令-2","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc6002komooz6zrjq3h","content":"<h1 id=\"3-0-做Linux运维的多个好处\"><a href=\"#3-0-做Linux运维的多个好处\" class=\"headerlink\" title=\"3.0 做Linux运维的多个好处\"></a>3.0 做Linux运维的多个好处</h1><ol>\n<li><p>做运维可以认识更多人，同时也被更多人认识。</p>\n</li>\n<li><p>做运维可以让自己沟通，交际能力变得比开发人员更强。</p>\n</li>\n<li><p>相比开发岗位，运维的岗位更重要一些。</p>\n</li>\n</ol>\n<h1 id=\"3-1-cat-合并文件或查看文件内容\"><a href=\"#3-1-cat-合并文件或查看文件内容\" class=\"headerlink\" title=\"3.1 cat 合并文件或查看文件内容\"></a>3.1 cat 合并文件或查看文件内容</h1><p><code>concatenate</code></p>\n<p><strong>cat命令5大常用功能</strong></p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>常用功能</th>\n<th>例子以及说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>查看文件内容</td>\n<td>cat file.txt 查看文件内容，最基本的使用</td>\n</tr>\n<tr>\n<td>2</td>\n<td>多个文件合并为一个文件</td>\n<td>cat f1 f2 &gt; newf 将f1和f2的内容合并到newf</td>\n</tr>\n<tr>\n<td>3</td>\n<td>创建编辑新文件</td>\n<td>cat &gt; file 输入后会请求输入，快捷键Ctrl+d/c可退出</td>\n</tr>\n<tr>\n<td>4</td>\n<td>非交互式编辑或追加新内容</td>\n<td>cat &gt;&gt;file&lt;&lt;EOF 输入后会请求输入，在结束时输入EOF即可退出</td>\n</tr>\n<tr>\n<td>5</td>\n<td>清空文件内容</td>\n<td>cat /dev/null &gt; file 清空文件内容</td>\n</tr>\n</tbody>\n</table>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat [选项] [文件]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n</td>\n<td>为输出的内容加编号，从1开始</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>与-n类似，但它忽略空白行</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>当遇到有多行空白行，则合并为单行空白行</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>除了LFD和TAB之外，使用^和M-引用</td>\n</tr>\n<tr>\n<td>-T</td>\n<td>将Tab字符显示为^I</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>在行尾显示$符号</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>等价与-vT</td>\n</tr>\n<tr>\n<td>-A</td>\n<td>等价于-vE</td>\n</tr>\n</tbody>\n</table>\n<p>例子</p>\n<p><strong>使用cat命令以非交互式的方式编辑文件</strong></p>\n<p>方式1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat &gt;file&lt;&lt;EOF</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test.</span><br><span class=\"line\">EOF</span><br><span class=\"line\">&gt; cat file</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test</span><br></pre></td></tr></table></figure>\n<p>解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现</p>\n<p>易错点: 结束EOF必须置前，前面不能有任意字符</p>\n<p>方式2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat &gt;file&lt;&lt;-EOF</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test.</span><br><span class=\"line\">  EOF</span><br><span class=\"line\">&gt; cat file</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test.</span><br></pre></td></tr></table></figure>\n<p>解释: 在字符标签前加上<code>-</code>可以使得结束标签前可放置制表符，但仅仅只可放制表符</p>\n<p><strong>合并多个文件为单个文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat &gt; f1</span><br><span class=\"line\">f1</span><br><span class=\"line\">Ctrl+d</span><br><span class=\"line\">&gt; cat &gt; f2</span><br><span class=\"line\">f2</span><br><span class=\"line\">Ctrl+c</span><br><span class=\"line\">&gt; cat f1 f2</span><br><span class=\"line\">f1</span><br><span class=\"line\">f2</span><br><span class=\"line\">&gt; cat f1 f2 &gt; newfile</span><br><span class=\"line\">&gt; cat newfile</span><br><span class=\"line\">f1</span><br><span class=\"line\">f2</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-2-tac-反向显示文件内容\"><a href=\"#3-2-tac-反向显示文件内容\" class=\"headerlink\" title=\"3.2 tac 反向显示文件内容\"></a>3.2 tac 反向显示文件内容</h1><p>跟<code>cat</code>命令类似，反向输出文件内容</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>在行前添加分隔标志</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>将分隔标志视作正则表达式进行解析</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>使用指定字符作为换行的标志</td>\n</tr>\n</tbody>\n</table>\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat file1</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">&gt; tac file2</span><br><span class=\"line\">world</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-3-more-分页显示文件内容\"><a href=\"#3-3-more-分页显示文件内容\" class=\"headerlink\" title=\"3.3 more 分页显示文件内容\"></a>3.3 more 分页显示文件内容</h1><p><code>more</code>类似于<code>cat</code>命令，区别在于<code>cat</code>命令是将文件内容一次性全部显示在屏幕上，而<code>more</code>则会分页进行显示。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>more</code>参数选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-num</td>\n<td>指定屏幕显示大小为num行</td>\n</tr>\n<tr>\n<td>+num</td>\n<td>从行号num开始显示</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>把连续的多个空行显示在一行</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>不滚屏，而是清除整个自己屏幕，然后显示文件</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>不滚屏，而是从每一屏的顶部开始显示文本，每显示完一行，就清除这一行的剩余部分</td>\n</tr>\n</tbody>\n</table>\n<p><code>more</code>交互式说明</p>\n<table>\n<thead>\n<tr>\n<th>子命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>h/?</td>\n<td>查看帮助</td>\n</tr>\n<tr>\n<td>空格键</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>z</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>Enter</td>\n<td>向下显示一行</td>\n</tr>\n<tr>\n<td>f</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>b</td>\n<td>返回上一屏</td>\n</tr>\n<tr>\n<td>=</td>\n<td>输出当前行的行号</td>\n</tr>\n<tr>\n<td>/查找文本</td>\n<td>查找指定的文本</td>\n</tr>\n<tr>\n<td>:f</td>\n<td>输出文件名和当前行的行号</td>\n</tr>\n<tr>\n<td>v</td>\n<td>调用vi编辑器</td>\n</tr>\n<tr>\n<td>!命令</td>\n<td>调用Shell，并执行命令</td>\n</tr>\n<tr>\n<td>q</td>\n<td>退出more</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"3-4-less-分页显示文件内容\"><a href=\"#3-4-less-分页显示文件内容\" class=\"headerlink\" title=\"3.4 less 分页显示文件内容\"></a>3.4 less 分页显示文件内容</h1><p><code>less</code>类似<code>more</code>命令，<code>less</code>的功能比<code>more</code>要强大</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>less</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-i</td>\n<td>搜索时忽略大小写</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>显示进度百分比</td>\n</tr>\n<tr>\n<td>-N</td>\n<td>显示行号</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>多行空行显示为单行</td>\n</tr>\n<tr>\n<td>-e</td>\n<td>当显示到文件结尾时自动退出，若没有此选项则需要用交互式q退出</td>\n</tr>\n</tbody>\n</table>\n<p><code>less</code>命令的交互式子命令及说明</p>\n<table>\n<thead>\n<tr>\n<th>子命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n<td>向前翻一页</td>\n</tr>\n<tr>\n<td>空格键</td>\n<td>向后翻一页</td>\n</tr>\n<tr>\n<td>u</td>\n<td>向前翻半页</td>\n</tr>\n<tr>\n<td>d</td>\n<td>向后翻半页</td>\n</tr>\n<tr>\n<td>y</td>\n<td>向上滚动一行</td>\n</tr>\n<tr>\n<td>回车键</td>\n<td>向下滚动一行</td>\n</tr>\n<tr>\n<td>方向键-上</td>\n<td>向上滚动一行</td>\n</tr>\n<tr>\n<td>方向键-下</td>\n<td>向下滚动一行</td>\n</tr>\n<tr>\n<td>Page UP</td>\n<td>向上滚动一屏</td>\n</tr>\n<tr>\n<td>Page Down</td>\n<td>向下滚动一屏</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>显示文件内容时并且显示行号</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; less -N 文件名</span><br></pre></td></tr></table></figure>\n<p><strong>分页显示命令的结果</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l | less</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-5-head-显示文件内容头部\"><a href=\"#3-5-head-显示文件内容头部\" class=\"headerlink\" title=\"3.5 head 显示文件内容头部\"></a>3.5 head 显示文件内容头部</h1><p><code>head</code>命令用于显示文件内容头部，默认输出行数为10行。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>head</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n&lt;行数&gt;</td>\n<td>指定显示的行数</td>\n</tr>\n<tr>\n<td>-c&lt;字节&gt;</td>\n<td>指定显示的字节数</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>显示时不包含指定的文件名作为文件头部</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示时包含指定的文件的文件名作为文件头部</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>默认显示文件的前10行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head /etc/passwd</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\">nobody:x:65534:65534:Nobody:/:/sbin/nologin</span><br><span class=\"line\">dbus:x:81:81:System Message Bus:/:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1::/:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2::/:/sbin/nologin</span><br><span class=\"line\">mail:x:8:12::/var/spool/mail:/sbin/nologin</span><br><span class=\"line\">ftp:x:14:11::/srv/ftp:/sbin/nologin</span><br><span class=\"line\">http:x:33:33::/srv/http:/sbin/nologin</span><br><span class=\"line\">systemd-journal-remote:x:982:982:systemd Journal Remote:/:/sbin/nologin</span><br><span class=\"line\">systemd-network:x:981:981:systemd Network Management:/:/sbin/nologin</span><br></pre></td></tr></table></figure>\n<p><strong>显示文件的前n行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head -n 2 /etc/passwd</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\">nobody:x:65534:65534:Nobody:/:/sbin/nologin</span><br></pre></td></tr></table></figure>\n<p><strong>显示文件的前n个字节</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head -c 4 /etc/passwd</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n<p><strong>显示多个文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head -1 /etc/passwd /etc/profile</span><br><span class=\"line\">==&gt; /etc/passwd &lt;==</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; /etc/profile &lt;==</span><br><span class=\"line\"># /etc/profile</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-6-tail显示文件内容尾部\"><a href=\"#3-6-tail显示文件内容尾部\" class=\"headerlink\" title=\"3.6 tail显示文件内容尾部\"></a>3.6 tail显示文件内容尾部</h1><p><code>tail</code>命令用于显示文件内容尾部，默认输出行数为10行。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>tail</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c&lt;字节&gt;</td>\n<td>指定显示的字节数</td>\n</tr>\n<tr>\n<td>-n&lt;行数&gt;</td>\n<td>指定显示的行数</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>实时输出文件内容追加的数据</td>\n</tr>\n<tr>\n<td>–retry</td>\n<td>不停的尝试打开文件，直到打开为止</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>等同于-f–retry</td>\n</tr>\n<tr>\n<td>–pid=进程号</td>\n<td>若进程关闭则tail的-f选项则不会继续输出内容</td>\n</tr>\n<tr>\n<td>-s 秒数 N</td>\n<td>监视文件的间隔秒数</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>显示时不包含指定的文件名作为文件头部</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示时包含指定的文件的文件名作为文件头部</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>显示文件最后10行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail /etc/passwd</span><br><span class=\"line\">git:x:973:973:git daemon user:/:/usr/bin/git-shell</span><br><span class=\"line\">lightdm:x:620:620:Light Display Manager:/var/lib/lightdm:/sbin/nologin</span><br><span class=\"line\">nm-openconnect:x:972:972:NetworkManager OpenConnect:/:/sbin/nologin</span><br><span class=\"line\">nm-openvpn:x:971:971:NetworkManager OpenVPN:/:/sbin/nologin</span><br><span class=\"line\">ntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/false</span><br><span class=\"line\">polkitd:x:102:102:PolicyKit daemon:/:/sbin/nologin</span><br><span class=\"line\">usbmux:x:140:140:usbmux user:/:/sbin/nologin</span><br><span class=\"line\">evanmeek:x:1000:1000:EvanMeek:/home/evanmeek:/usr/bin/zsh</span><br><span class=\"line\">nvidia-persistenced:x:143:143:NVIDIA Persistence Daemon:/:/sbin/nologin</span><br><span class=\"line\">privoxy:x:42:42:Privoxy:/:/sbin/nologin</span><br></pre></td></tr></table></figure>\n<p><strong>显示文件最后5行</strong></p>\n<p><em>第一种写法</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -n 5 /etc/passwd</span><br></pre></td></tr></table></figure>\n<p><em>第二种写法</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -5 /etc/passwd</span><br></pre></td></tr></table></figure>\n<p><strong>指定从第几行开始显示文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -n +10 /etc/passwd</span><br></pre></td></tr></table></figure>\n<p><strong>实时监控文件的变化</strong></p>\n<p>监测<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -f --retry test.txt</span><br><span class=\"line\">testwords</span><br></pre></td></tr></table></figure></p>\n<p>追加内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; echo testwords &gt;&gt; test.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-7-tailf-跟踪日志文件\"><a href=\"#3-7-tailf-跟踪日志文件\" class=\"headerlink\" title=\"3.7 tailf 跟踪日志文件\"></a>3.7 tailf 跟踪日志文件</h1><p><code>tailf</code>命令日常工作中用于跟踪日志文件，它与<code>tail -f</code>命令基本相同，但唯一的区别是若文件内容无增加，则不会重复访问磁盘文件，也不会修改文件访问时间。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tailf [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>tailf</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n&lt;行数&gt;</td>\n<td>指定显示的行数，默认为文件最后10行</td>\n</tr>\n</tbody>\n</table>\n<p>例子：</p>\n<p><strong>跟踪日志文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tailf</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-8-cut-从文本中提取一段文字并输出\"><a href=\"#3-8-cut-从文本中提取一段文字并输出\" class=\"headerlink\" title=\"3.8 cut 从文本中提取一段文字并输出\"></a>3.8 cut 从文本中提取一段文字并输出</h1><p><code>cut</code>命令从文件的每一行剪切字节，字符或字段，并将其输出至标准输出。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cut [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>cut</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>以字节为单位进行分割</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>取消分割多字节字符</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>以字符为单位进行分割<code>!</code></td>\n</tr>\n<tr>\n<td>-d</td>\n<td>自定义分隔符，默认以tab为分隔符<code>!</code></td>\n</tr>\n<tr>\n<td>-f</td>\n<td>与选项-d一起使用，指定显示哪个区域</td>\n</tr>\n<tr>\n<td>N</td>\n<td>第N个字节、字符或字段<code>!</code></td>\n</tr>\n<tr>\n<td>N-</td>\n<td>从第N个字节、字符或字段开始直至行尾</td>\n</tr>\n<tr>\n<td>N-M</td>\n<td>从第N到第M个字节、字符或字段</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>从第一到第M个字节、字符或字段</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>以字节为分隔符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">Hello World</span><br><span class=\"line\"># 截取第5个字节，并输出</span><br><span class=\"line\">&gt; cut -b 5 test.txt</span><br><span class=\"line\">o</span><br><span class=\"line\"># 截取第5个字节之前的所有字符(包括第5个)，并输出</span><br><span class=\"line\">&gt; cut -b -5 test.txt</span><br><span class=\"line\">Hello</span><br><span class=\"line\"># 截取第5个字节之后的所有字符，并输出</span><br><span class=\"line\">&gt; cut -b 5- test.txt</span><br><span class=\"line\">o World</span><br><span class=\"line\"># 截取第5个字节和第10个字节，并输出</span><br><span class=\"line\">&gt; cut -b 5,10 test.txt</span><br><span class=\"line\">ol</span><br><span class=\"line\"># 截取第1个字节到第5个字节，并输出</span><br><span class=\"line\">&gt; cut -b 1-5 test.txt</span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n<p><strong>以字符为分隔符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">Hello World</span><br><span class=\"line\">你好世界</span><br><span class=\"line\"># 截取第1到第6个字符，并输出</span><br><span class=\"line\">&gt; cut -b 1-6 test.txt</span><br><span class=\"line\">Hello</span><br><span class=\"line\">你好</span><br></pre></td></tr></table></figure>\n<p><strong>自定义分隔符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat /etc/passwd | head -n 5</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\">nobody:x:65534:65534:Nobody:/:/sbin/nologin</span><br><span class=\"line\">dbus:x:81:81:System Message Bus:/:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1::/:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2::/:/sbin/nologin</span><br><span class=\"line\"># 自定义分隔符为`:`，并且之输出文件前5行(:为分隔符，-f 1为指定显示第1个区域</span><br><span class=\"line\">&gt; cut -d : -f 1 /etc/passwd | head -n 5</span><br><span class=\"line\">root</span><br><span class=\"line\">nobody</span><br><span class=\"line\">dbus</span><br><span class=\"line\">bin</span><br><span class=\"line\">daemon</span><br><span class=\"line\"># 指定显示区域为1,6-8</span><br><span class=\"line\">&gt; cut -d : -f 1,6-8 /etc/passwd | head -n +5</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-9-split-分割文件\"><a href=\"#3-9-split-分割文件\" class=\"headerlink\" title=\"3.9 split 分割文件\"></a>3.9 split 分割文件</h1><p><code>split</code>命令可以将文件进行分割，支持根据行数或文件大小进行分割。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split [选项] [输入文件] [输出文件名[前缀]]</span><br></pre></td></tr></table></figure>\n<p><em>输出文件的格式会加上前缀，例如<code>PREFIXaa,PREFIXab</code></em></p>\n<p><code>split</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>指定分割后文件的最大字节数</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>指定分割后文件的最大行数<code>!</code></td>\n</tr>\n<tr>\n<td>-a</td>\n<td>指定后缀长度，默认为2位字母</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>使用数字后缀</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>按行分割文件，以及指定后缀形式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># wc 命令可以查看文件的行数</span><br><span class=\"line\">&gt; wc -l /etc/passwd</span><br><span class=\"line\">31 /etc/passwd</span><br><span class=\"line\"># 按行进行分割，每10行分割为一个新文件，文件前缀为split_</span><br><span class=\"line\">&gt; split -l 10 /etc/passwd split_</span><br><span class=\"line\">&gt; wc -l split_*</span><br><span class=\"line\">10 split_aa</span><br><span class=\"line\">10 split_ab</span><br><span class=\"line\">10 split_ac</span><br><span class=\"line\"> 1 split_ad</span><br><span class=\"line\">31 总用量</span><br><span class=\"line\"># 参数-a指定分割文件的前缀长度，这里设置的是1</span><br><span class=\"line\">&gt; split -l 10 -a 1 /etc/passwd split2_</span><br><span class=\"line\">&gt; wc -l split2_*</span><br><span class=\"line\">10 split2_a</span><br><span class=\"line\">10 split2_b</span><br><span class=\"line\">10 split2_c</span><br><span class=\"line\"> 1 split2_d</span><br><span class=\"line\">31 总用量</span><br><span class=\"line\"># 参数-d指定文件使用数字后缀</span><br><span class=\"line\">&gt; split -l 10 -d -a 1 /etc/passwd split_</span><br><span class=\"line\">&gt; wc -l split_*</span><br><span class=\"line\">10 split_0</span><br><span class=\"line\">10 split_1</span><br><span class=\"line\">10 split_2</span><br><span class=\"line\"> 1 split_3</span><br><span class=\"line\">31 总用量&lt;Paste&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>按文件大小分割文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 准备测试文件</span><br><span class=\"line\">&gt; cp /sbin/lvm .</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 2.3M</span><br><span class=\"line\">-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm</span><br><span class=\"line\"># 按文件字节进行分割，每500K字节分割为一个文件，以数字作为文件后缀</span><br><span class=\"line\">&gt; split -b 500K -d lvm lvm_split_</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.5M</span><br><span class=\"line\">-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_00</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_01</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_02</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_03</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 254K  7月 22 21:25 lvm_split_04</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-10-paste-合并文件\"><a href=\"#3-10-paste-合并文件\" class=\"headerlink\" title=\"3.10 paste 合并文件\"></a>3.10 paste 合并文件</h1><p><code>paste</code>命令能将文件按照行与行进行合并，中间使用tab隔开</p>\n<p>语法格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paste [选项] [文件]</span><br></pre></td></tr></table></figure></p>\n<p><code>paste</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d</td>\n<td>指定合并的分隔符，默认是Tab<code>!</code></td>\n</tr>\n<tr>\n<td>-s</td>\n<td>每个文件占用一行</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>合并文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; more t1 t2</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t1</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">test1</span><br><span class=\"line\">test1</span><br><span class=\"line\">test1</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t2</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">test2</span><br><span class=\"line\">test2</span><br><span class=\"line\">test2</span><br><span class=\"line\"># t1与t2合并，将内容写入t3</span><br><span class=\"line\">&gt; paste t1 t2 &gt; t3</span><br><span class=\"line\">&gt; cat t3</span><br><span class=\"line\">test1\ttest2</span><br><span class=\"line\">test1\ttest2</span><br><span class=\"line\">test1\ttest2</span><br><span class=\"line\"># 合并时，自定义分隔符</span><br><span class=\"line\">&gt; paste -d - t1 t2 &gt; t3</span><br><span class=\"line\">&gt; cat t3</span><br><span class=\"line\">test1-test2</span><br><span class=\"line\">test1-test2</span><br><span class=\"line\">test1-test2</span><br></pre></td></tr></table></figure>\n<p><strong>文件内容合并成一行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; paste -s t1 t2 &gt; t3</span><br><span class=\"line\">&gt; cat t3</span><br><span class=\"line\">test1\ttest1\ttest1</span><br><span class=\"line\">test2\ttest2\ttest2</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-11-sort-文本排序\"><a href=\"#3-11-sort-文本排序\" class=\"headerlink\" title=\"3.11 sort 文本排序\"></a>3.11 sort 文本排序</h1><p><code>sort</code>命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>sort</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>忽略每行开头存在的空格字符</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>按照数值的大小进行排序<code>!</code></td>\n</tr>\n<tr>\n<td>-r</td>\n<td>倒序排序<code>!</code></td>\n</tr>\n<tr>\n<td>-u</td>\n<td>去除重复行</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>指定分隔符<code>!</code></td>\n</tr>\n<tr>\n<td>-k</td>\n<td>按照指定区间排序<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>默认以行为单位进行排序</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat test.txt</span><br><span class=\"line\">t1</span><br><span class=\"line\">t2</span><br><span class=\"line\">t3</span><br><span class=\"line\">t4</span><br><span class=\"line\"># sort默认是以ASCII码进行升序排序。</span><br><span class=\"line\">$ sort test.txt</span><br><span class=\"line\">t1</span><br><span class=\"line\">t2</span><br><span class=\"line\">t3</span><br><span class=\"line\">t4</span><br><span class=\"line\"># 按照数值的大小进行排序</span><br><span class=\"line\">$ sort -n test.txt</span><br><span class=\"line\">t1</span><br><span class=\"line\">t2</span><br><span class=\"line\">t3</span><br><span class=\"line\">t4</span><br><span class=\"line\"># 按照数值的大小降序排序</span><br><span class=\"line\">$ sort -nr test.txt</span><br><span class=\"line\">t4</span><br><span class=\"line\">t3</span><br><span class=\"line\">t2</span><br><span class=\"line\">t1</span><br></pre></td></tr></table></figure>\n<p><strong>去除重复行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat test.txt</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t2 C</span><br><span class=\"line\">t3 B</span><br><span class=\"line\">t4 A</span><br><span class=\"line\"># 去除重复行，并且逆序排序</span><br><span class=\"line\">$ sort -u test.txt | sort -nr</span><br><span class=\"line\">t4 A</span><br><span class=\"line\">t3 B</span><br><span class=\"line\">t2 C</span><br><span class=\"line\">t1 D</span><br></pre></td></tr></table></figure>\n<p><strong>自定义区间排序</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 指定以空格作为分隔符，并且以第二列进行逆序排序</span><br><span class=\"line\">$ sort -t &quot; &quot; -k2 test.txt</span><br><span class=\"line\">t4 A</span><br><span class=\"line\">t3 B</span><br><span class=\"line\">t2 C</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br></pre></td></tr></table></figure>\n<p><strong>-t -k的进阶用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat ip.txt</span><br><span class=\"line\">192.197.113.0\t192.197.113.255\t256</span><br><span class=\"line\">193.112.0.0\t193.112.255.255\t65536</span><br><span class=\"line\">195.78.82.0\t195.78.83.255\t512</span><br><span class=\"line\">198.175.100.0\t198.175.103.255\t1024</span><br><span class=\"line\">199.212.57.0\t199.212.57.255\t256</span><br><span class=\"line\">202.0.100.0\t202.0.101.255\t512</span><br><span class=\"line\">202.0.122.0\t202.0.123.255\t512</span><br><span class=\"line\">202.0.176.0\t202.0.179.255\t1024</span><br><span class=\"line\">202.3.128.0\t202.3.129.255\t512</span><br><span class=\"line\">202.3.134.0\t202.3.134.255\t256</span><br><span class=\"line\">202.4.128.0\t202.4.159.255\t8192</span><br><span class=\"line\">202.4.252.0\t202.4.255.255\t1024</span><br><span class=\"line\"># 以第3个字段的第1个字符到第3个字段的第3个字段进行数字排序</span><br><span class=\"line\">$ sort -n -t. -k3.1,3.3 ip.txt</span><br><span class=\"line\">193.112.0.0\t193.112.255.255\t65536</span><br><span class=\"line\">199.212.57.0\t199.212.57.255\t256</span><br><span class=\"line\">195.78.82.0\t195.78.83.255\t512</span><br><span class=\"line\">198.175.100.0\t198.175.103.255\t1024</span><br><span class=\"line\">202.0.100.0\t202.0.101.255\t512</span><br><span class=\"line\">192.197.113.0\t192.197.113.255\t256</span><br><span class=\"line\">202.0.122.0\t202.0.123.255\t512</span><br><span class=\"line\">202.3.128.0\t202.3.129.255\t512</span><br><span class=\"line\">202.4.128.0\t202.4.159.255\t8192</span><br><span class=\"line\">202.3.134.0\t202.3.134.255\t256</span><br><span class=\"line\">202.0.176.0\t202.0.179.255\t1024</span><br><span class=\"line\">202.4.252.0\t202.4.255.255\t1024</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-12-join-按两个文件的相同字段合并\"><a href=\"#3-12-join-按两个文件的相同字段合并\" class=\"headerlink\" title=\"3.12 join 按两个文件的相同字段合并\"></a>3.12 join 按两个文件的相同字段合并</h1><p><code>join</code>命令针对每一对具有相同内容的输入行，整合为一行输出到标准输出，默认情况下是把输入的第一个字段作为连接字段，字段之间用空格隔开。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">join [选项] [文件1] [文件2]</span><br></pre></td></tr></table></figure>\n<p><code>join</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a文件号</td>\n<td>输出文件中不匹配的行，文件号可选值1或2,代表文件1和文件2</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>比较字段时忽略大小写</td>\n</tr>\n<tr>\n<td>-1 字段</td>\n<td>以第1个文件的指定字段为基础进行合并</td>\n</tr>\n<tr>\n<td>-2 字段</td>\n<td>以第2个文件的指定字段为基础进行合并</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>合并文本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more t1.txt t2.txt</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t1.txt</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">张三 21岁</span><br><span class=\"line\">李四 23岁</span><br><span class=\"line\">王五 17岁</span><br><span class=\"line\">赵六 15岁</span><br><span class=\"line\"></span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t2.txt</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">张三 男</span><br><span class=\"line\">李四 女</span><br><span class=\"line\">王五 男</span><br><span class=\"line\">赵六 女</span><br><span class=\"line\"># 将t1和t2进行合并</span><br><span class=\"line\">$ join t1.txt t2.txt &gt; t3.txt</span><br><span class=\"line\">$ cat t3.txt</span><br><span class=\"line\">张三 21岁 男</span><br><span class=\"line\">李四 23岁 女</span><br><span class=\"line\">王五 17岁 男</span><br><span class=\"line\">赵六 15岁 女</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-13-uniq-去除重复行\"><a href=\"#3-13-uniq-去除重复行\" class=\"headerlink\" title=\"3.13 uniq 去除重复行\"></a>3.13 uniq 去除重复行</h1><p><code>uniq</code>命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用<code>uniq</code>命令去重并计数。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniq [选项] [文件或标准输入]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>去除重复行，并且计算每行出现的次数</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>只显示重复的行</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>只显示唯一的行</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>去重测试案例</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">&gt; uniq -c test.txt</span><br><span class=\"line\">5 重复重复重复</span><br></pre></td></tr></table></figure>\n<p><strong>结合sort排序后去重</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">10000</span><br><span class=\"line\">10000</span><br><span class=\"line\">2</span><br><span class=\"line\">10000</span><br><span class=\"line\">10000</span><br><span class=\"line\">2</span><br><span class=\"line\">10000</span><br><span class=\"line\">&gt; uniq -c test.txt</span><br><span class=\"line\">2 10000</span><br><span class=\"line\">1 2</span><br><span class=\"line\">2 10000</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 10000</span><br><span class=\"line\"># 在这里我们发现，uniq只能去除相邻重复的行，所以我们就使用sort排序后再进行去重复</span><br><span class=\"line\">&gt; sort -n test.txt | uniq -c</span><br><span class=\"line\">2 2</span><br><span class=\"line\">5 10000</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-14-wc-统计文件的行数、单词数或字节数\"><a href=\"#3-14-wc-统计文件的行数、单词数或字节数\" class=\"headerlink\" title=\"3.14 wc 统计文件的行数、单词数或字节数\"></a>3.14 wc 统计文件的行数、单词数或字节数</h1><p><code>wc</code>命令用于统计文件的行数、单词数和字节数。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>统计字节数</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>统计行数<code>!</code></td>\n</tr>\n<tr>\n<td>-m</td>\n<td>统计字符数</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>统计单词数</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>输出最长行的长度<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>查看文件的字节数、字数、行数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; wc /etc/profile</span><br><span class=\"line\">9      30     189 /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"># 依次排列过去是 行数 - 单词数 - 字节数</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-15-iconv-转换文件的编码格式\"><a href=\"#3-15-iconv-转换文件的编码格式\" class=\"headerlink\" title=\"3.15 iconv 转换文件的编码格式\"></a>3.15 iconv 转换文件的编码格式</h1><p><code>iconv</code>命令用于转换文件的编码格式.</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iconv [选项] [原编码] [新编码] [输入文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-f encodingA</td>\n<td>从编码A转换<code>!</code></td>\n</tr>\n<tr>\n<td>-t encodingB</td>\n<td>转换程编码B <code>!</code></td>\n</tr>\n<tr>\n<td>-l</td>\n<td>显示系统支持的编码<code>!</code></td>\n</tr>\n<tr>\n<td>-o</td>\n<td>将输出输入到指定文件<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat utf-8.txt</span><br><span class=\"line\">你好世界</span><br><span class=\"line\"># 指定utf-8.txt的编码格式为utf-8，将要转换成GB2312</span><br><span class=\"line\">&gt; iconv -f UTF-8 -t GB2312 utf-8.txt &gt; gbk.txt</span><br><span class=\"line\">&gt; cat gbk.txt</span><br><span class=\"line\">无回显</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-16-dos2unix-将DOS格式文件转换成UNIX格式\"><a href=\"#3-16-dos2unix-将DOS格式文件转换成UNIX格式\" class=\"headerlink\" title=\"3.16 dos2unix 将DOS格式文件转换成UNIX格式\"></a>3.16 dos2unix 将DOS格式文件转换成UNIX格式</h1><p>由于dos格式的文件的换行符与unix格式的文件的换行符不同，所以需要转换。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dos2unix [文件]</span><br></pre></td></tr></table></figure>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dos2unix dosfile.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-17-diff-比较两个文件的不同\"><a href=\"#3-17-diff-比较两个文件的不同\" class=\"headerlink\" title=\"3.17 diff 比较两个文件的不同\"></a>3.17 diff 比较两个文件的不同</h1><p><code>diff</code>命令可以逐行比较纯文本文件的内容，并输出文件的差异。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff [选项] [文件1] [文件2]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-y</td>\n<td>以并列的方式显示文件的异同之处</td>\n</tr>\n<tr>\n<td>-W</td>\n<td>在使用-y参数时，指定显示宽度</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>使用上下文的输出格式</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>使用统一格式输出</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>比较两个文本文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evanmeek@EvanMeekdeMBP  ~/TestDir  cat test1.txt</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">evanmeek@EvanMeekdeMBP  ~/TestDir  cat test2.txt</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">evanmeek@EvanMeekdeMBP  ~/TestDir  diff test1.txt test2.txt</span><br><span class=\"line\"># 代表文件2对比文件1删除了第一行到第三行</span><br><span class=\"line\">1,3d0</span><br><span class=\"line\">&lt; 1</span><br><span class=\"line\">&lt; 2</span><br><span class=\"line\">&lt; 3</span><br><span class=\"line\"># 代表文件1的第6行下增加了文件2的第4行和第5行</span><br><span class=\"line\">6a4,6</span><br><span class=\"line\">&gt; 7</span><br><span class=\"line\">&gt; 8</span><br><span class=\"line\">&gt; 9</span><br></pre></td></tr></table></figure>\n<p><strong>并排格式输出</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y test1.txt test2.txt</span><br><span class=\"line\">1                                                             &lt;</span><br><span class=\"line\">2                                                             &lt;</span><br><span class=\"line\">3                                                             &lt;</span><br><span class=\"line\">4                                                               4</span><br><span class=\"line\">5                                                               5</span><br><span class=\"line\">6                                                               6</span><br><span class=\"line\">                                                            &gt; 7</span><br><span class=\"line\">                                                            &gt; 8</span><br><span class=\"line\">                                                            &gt; 9</span><br></pre></td></tr></table></figure>\n<p><strong>并排格式输出时指定宽度</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y -W 30 test1.txt test2.txt</span><br><span class=\"line\">1             &lt;</span><br><span class=\"line\">2             &lt;</span><br><span class=\"line\">3             &lt;</span><br><span class=\"line\">4               4</span><br><span class=\"line\">5               5</span><br><span class=\"line\">6               6</span><br><span class=\"line\">              &gt; 7</span><br><span class=\"line\">              &gt; 8</span><br><span class=\"line\">              &gt; 9</span><br></pre></td></tr></table></figure>\n<p><strong>上下文输出格式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -c test1.txt test2.txt</span><br><span class=\"line\">*** test1.txt   2019-08-25 16:39:32.000000000 +0800</span><br><span class=\"line\">--- test2.txt   2019-08-25 16:40:32.000000000 +0800</span><br><span class=\"line\">***************</span><br><span class=\"line\">*** 1,6 ****</span><br><span class=\"line\">- 1</span><br><span class=\"line\">- 2</span><br><span class=\"line\">- 3</span><br><span class=\"line\">  4</span><br><span class=\"line\">  5</span><br><span class=\"line\">  6</span><br><span class=\"line\">--- 1,6 ----</span><br><span class=\"line\">  4</span><br><span class=\"line\">  5</span><br><span class=\"line\">  6</span><br><span class=\"line\">+ 7</span><br><span class=\"line\">+ 8</span><br><span class=\"line\">+ 9</span><br></pre></td></tr></table></figure>\n<p><strong>统一标准输出格式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -u test1.txt test2.txt</span><br><span class=\"line\">--- test1.txt   2019-08-25 16:39:32.000000000 +0800</span><br><span class=\"line\">+++ test2.txt   2019-08-25 16:40:32.000000000 +0800</span><br><span class=\"line\">@@ -1,6 +1,6 @@</span><br><span class=\"line\">-1</span><br><span class=\"line\">-2</span><br><span class=\"line\">-3</span><br><span class=\"line\"> 4</span><br><span class=\"line\"> 5</span><br><span class=\"line\"> 6</span><br><span class=\"line\">+7</span><br><span class=\"line\">+8</span><br><span class=\"line\">+9</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-19-rev-反向输出文件内容\"><a href=\"#3-19-rev-反向输出文件内容\" class=\"headerlink\" title=\"3.19 rev 反向输出文件内容\"></a>3.19 rev 反向输出文件内容</h1><p><code>rev</code>命令可以按行反向输出文件内容</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rev [文件]</span><br></pre></td></tr></table></figure>\n<p>例子:</p>\n<p><strong>字符串反转</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; echo &#123;1..10&#125;</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 10</span><br><span class=\"line\">&gt; echo &#123;1..10&#125;|rev</span><br><span class=\"line\">01 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>\n<p><strong>文本反转</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">你好世界</span><br><span class=\"line\">&gt; rev testfile</span><br><span class=\"line\">界世好你</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-20-tr-替换或删除字符\"><a href=\"#3-20-tr-替换或删除字符\" class=\"headerlink\" title=\"3.20 tr 替换或删除字符\"></a>3.20 tr 替换或删除字符</h1><p><code>tr</code>命令从标准输入中替换、缩减或删除字符，并将结果写入到标准输出</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tr [选项] [字符1] [字符2]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d</td>\n<td>删除字符<code>!</code></td>\n</tr>\n<tr>\n<td>-s</td>\n<td>保留连续字符的第一个字符，删除其他字符</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>使用第一个字符串(set1)的补集，取反</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>替换文本中出现的字符为某字符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">test word</span><br><span class=\"line\">aa bb cc</span><br><span class=\"line\">abc</span><br><span class=\"line\"># 这里是将文件中出现&apos;a&apos;的字符替换成&apos;x&apos;,依次对应</span><br><span class=\"line\">&gt; tr &apos;abc&apos; &apos;xyz&apos; &lt; testfile</span><br><span class=\"line\">test word</span><br><span class=\"line\">xx yy zz</span><br><span class=\"line\">xyz</span><br></pre></td></tr></table></figure>\n<p><strong>使用tr统一字母大小写</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">test word</span><br><span class=\"line\">aa bb cc</span><br><span class=\"line\">abc</span><br><span class=\"line\"># [a-z]代表小写字母a b c d..z</span><br><span class=\"line\">&gt; tr &apos;[a-z]&apos; &apos;[A-Z]&apos; &lt; testfile</span><br><span class=\"line\">TEST WORD</span><br><span class=\"line\">AA BB CC</span><br><span class=\"line\">ABC</span><br></pre></td></tr></table></figure>\n<p><strong>将数字0-9替换为a-j</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\">&gt; tr &apos;[0-9]&apos; &apos;[a-j]&apos; &lt; testfile</span><br><span class=\"line\">a b c d e f g h i j</span><br></pre></td></tr></table></figure>\n<p><strong>删除文件中出现的Evan这个单词中的每个字符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">EeEvVvaAanNn</span><br><span class=\"line\">&gt; tr -d &apos;Evan&apos; &lt; testfile</span><br><span class=\"line\">eVAN</span><br></pre></td></tr></table></figure>\n<p><strong>删除文件中出现的换行符和制表符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat tesfile</span><br><span class=\"line\"></span><br><span class=\"line\">a aaa aaa   aaa</span><br><span class=\"line\">b   b     b </span><br><span class=\"line\">&gt; tr -d &apos;\\n\\t&apos; &lt; testfile</span><br><span class=\"line\">a aaa aaa   aaab   b     b%</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-21-od-按不同进制显示文件\"><a href=\"#3-21-od-按不同进制显示文件\" class=\"headerlink\" title=\"3.21 od 按不同进制显示文件\"></a>3.21 od 按不同进制显示文件</h1><p><code>od</code>命令用于输出文件的八进制，十六进制等其他编码格式的字节，通常用于显示或查看文件中不能直接显示在终端的字符</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">od [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-A 地址进制</td>\n<td>按指定的进制显示地址信息</td>\n</tr>\n<tr>\n<td>-t 显示格式</td>\n<td>指定数据的显示格式</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>地址信息</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>o</td>\n<td>八进制(默认)</td>\n</tr>\n<tr>\n<td>d</td>\n<td>十进制</td>\n</tr>\n<tr>\n<td>x</td>\n<td>十六进制</td>\n</tr>\n<tr>\n<td>n</td>\n<td>不打印位移值</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>命名字符，忽略高阶位</td>\n</tr>\n<tr>\n<td>c</td>\n<td>ASCII字符或反斜杠序列</td>\n</tr>\n<tr>\n<td>d</td>\n<td>有符号的十进制数</td>\n</tr>\n<tr>\n<td>f</td>\n<td>浮点数</td>\n</tr>\n<tr>\n<td>o</td>\n<td>八进制(系统默认)</td>\n</tr>\n<tr>\n<td>u</td>\n<td>无符号十进制</td>\n</tr>\n<tr>\n<td>x</td>\n<td>十六进制</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"3-0-做Linux运维的多个好处\"><a href=\"#3-0-做Linux运维的多个好处\" class=\"headerlink\" title=\"3.0 做Linux运维的多个好处\"></a>3.0 做Linux运维的多个好处</h1><ol>\n<li><p>做运维可以认识更多人，同时也被更多人认识。</p>\n</li>\n<li><p>做运维可以让自己沟通，交际能力变得比开发人员更强。</p>\n</li>\n<li><p>相比开发岗位，运维的岗位更重要一些。</p>\n</li>\n</ol>\n<h1 id=\"3-1-cat-合并文件或查看文件内容\"><a href=\"#3-1-cat-合并文件或查看文件内容\" class=\"headerlink\" title=\"3.1 cat 合并文件或查看文件内容\"></a>3.1 cat 合并文件或查看文件内容</h1><p><code>concatenate</code></p>\n<p><strong>cat命令5大常用功能</strong></p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>常用功能</th>\n<th>例子以及说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>查看文件内容</td>\n<td>cat file.txt 查看文件内容，最基本的使用</td>\n</tr>\n<tr>\n<td>2</td>\n<td>多个文件合并为一个文件</td>\n<td>cat f1 f2 &gt; newf 将f1和f2的内容合并到newf</td>\n</tr>\n<tr>\n<td>3</td>\n<td>创建编辑新文件</td>\n<td>cat &gt; file 输入后会请求输入，快捷键Ctrl+d/c可退出</td>\n</tr>\n<tr>\n<td>4</td>\n<td>非交互式编辑或追加新内容</td>\n<td>cat &gt;&gt;file&lt;&lt;EOF 输入后会请求输入，在结束时输入EOF即可退出</td>\n</tr>\n<tr>\n<td>5</td>\n<td>清空文件内容</td>\n<td>cat /dev/null &gt; file 清空文件内容</td>\n</tr>\n</tbody>\n</table>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat [选项] [文件]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n</td>\n<td>为输出的内容加编号，从1开始</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>与-n类似，但它忽略空白行</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>当遇到有多行空白行，则合并为单行空白行</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>除了LFD和TAB之外，使用^和M-引用</td>\n</tr>\n<tr>\n<td>-T</td>\n<td>将Tab字符显示为^I</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>在行尾显示$符号</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>等价与-vT</td>\n</tr>\n<tr>\n<td>-A</td>\n<td>等价于-vE</td>\n</tr>\n</tbody>\n</table>\n<p>例子</p>\n<p><strong>使用cat命令以非交互式的方式编辑文件</strong></p>\n<p>方式1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat &gt;file&lt;&lt;EOF</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test.</span><br><span class=\"line\">EOF</span><br><span class=\"line\">&gt; cat file</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test</span><br></pre></td></tr></table></figure>\n<p>解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现</p>\n<p>易错点: 结束EOF必须置前，前面不能有任意字符</p>\n<p>方式2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat &gt;file&lt;&lt;-EOF</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test.</span><br><span class=\"line\">  EOF</span><br><span class=\"line\">&gt; cat file</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Just a test.</span><br></pre></td></tr></table></figure>\n<p>解释: 在字符标签前加上<code>-</code>可以使得结束标签前可放置制表符，但仅仅只可放制表符</p>\n<p><strong>合并多个文件为单个文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat &gt; f1</span><br><span class=\"line\">f1</span><br><span class=\"line\">Ctrl+d</span><br><span class=\"line\">&gt; cat &gt; f2</span><br><span class=\"line\">f2</span><br><span class=\"line\">Ctrl+c</span><br><span class=\"line\">&gt; cat f1 f2</span><br><span class=\"line\">f1</span><br><span class=\"line\">f2</span><br><span class=\"line\">&gt; cat f1 f2 &gt; newfile</span><br><span class=\"line\">&gt; cat newfile</span><br><span class=\"line\">f1</span><br><span class=\"line\">f2</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-2-tac-反向显示文件内容\"><a href=\"#3-2-tac-反向显示文件内容\" class=\"headerlink\" title=\"3.2 tac 反向显示文件内容\"></a>3.2 tac 反向显示文件内容</h1><p>跟<code>cat</code>命令类似，反向输出文件内容</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>在行前添加分隔标志</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>将分隔标志视作正则表达式进行解析</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>使用指定字符作为换行的标志</td>\n</tr>\n</tbody>\n</table>\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat file1</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">&gt; tac file2</span><br><span class=\"line\">world</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-3-more-分页显示文件内容\"><a href=\"#3-3-more-分页显示文件内容\" class=\"headerlink\" title=\"3.3 more 分页显示文件内容\"></a>3.3 more 分页显示文件内容</h1><p><code>more</code>类似于<code>cat</code>命令，区别在于<code>cat</code>命令是将文件内容一次性全部显示在屏幕上，而<code>more</code>则会分页进行显示。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>more</code>参数选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-num</td>\n<td>指定屏幕显示大小为num行</td>\n</tr>\n<tr>\n<td>+num</td>\n<td>从行号num开始显示</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>把连续的多个空行显示在一行</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>不滚屏，而是清除整个自己屏幕，然后显示文件</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>不滚屏，而是从每一屏的顶部开始显示文本，每显示完一行，就清除这一行的剩余部分</td>\n</tr>\n</tbody>\n</table>\n<p><code>more</code>交互式说明</p>\n<table>\n<thead>\n<tr>\n<th>子命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>h/?</td>\n<td>查看帮助</td>\n</tr>\n<tr>\n<td>空格键</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>z</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>Enter</td>\n<td>向下显示一行</td>\n</tr>\n<tr>\n<td>f</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>b</td>\n<td>返回上一屏</td>\n</tr>\n<tr>\n<td>=</td>\n<td>输出当前行的行号</td>\n</tr>\n<tr>\n<td>/查找文本</td>\n<td>查找指定的文本</td>\n</tr>\n<tr>\n<td>:f</td>\n<td>输出文件名和当前行的行号</td>\n</tr>\n<tr>\n<td>v</td>\n<td>调用vi编辑器</td>\n</tr>\n<tr>\n<td>!命令</td>\n<td>调用Shell，并执行命令</td>\n</tr>\n<tr>\n<td>q</td>\n<td>退出more</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"3-4-less-分页显示文件内容\"><a href=\"#3-4-less-分页显示文件内容\" class=\"headerlink\" title=\"3.4 less 分页显示文件内容\"></a>3.4 less 分页显示文件内容</h1><p><code>less</code>类似<code>more</code>命令，<code>less</code>的功能比<code>more</code>要强大</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>less</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-i</td>\n<td>搜索时忽略大小写</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>显示进度百分比</td>\n</tr>\n<tr>\n<td>-N</td>\n<td>显示行号</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>多行空行显示为单行</td>\n</tr>\n<tr>\n<td>-e</td>\n<td>当显示到文件结尾时自动退出，若没有此选项则需要用交互式q退出</td>\n</tr>\n</tbody>\n</table>\n<p><code>less</code>命令的交互式子命令及说明</p>\n<table>\n<thead>\n<tr>\n<th>子命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n<td>向前翻一页</td>\n</tr>\n<tr>\n<td>空格键</td>\n<td>向后翻一页</td>\n</tr>\n<tr>\n<td>u</td>\n<td>向前翻半页</td>\n</tr>\n<tr>\n<td>d</td>\n<td>向后翻半页</td>\n</tr>\n<tr>\n<td>y</td>\n<td>向上滚动一行</td>\n</tr>\n<tr>\n<td>回车键</td>\n<td>向下滚动一行</td>\n</tr>\n<tr>\n<td>方向键-上</td>\n<td>向上滚动一行</td>\n</tr>\n<tr>\n<td>方向键-下</td>\n<td>向下滚动一行</td>\n</tr>\n<tr>\n<td>Page UP</td>\n<td>向上滚动一屏</td>\n</tr>\n<tr>\n<td>Page Down</td>\n<td>向下滚动一屏</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>显示文件内容时并且显示行号</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; less -N 文件名</span><br></pre></td></tr></table></figure>\n<p><strong>分页显示命令的结果</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ls -l | less</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-5-head-显示文件内容头部\"><a href=\"#3-5-head-显示文件内容头部\" class=\"headerlink\" title=\"3.5 head 显示文件内容头部\"></a>3.5 head 显示文件内容头部</h1><p><code>head</code>命令用于显示文件内容头部，默认输出行数为10行。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>head</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n&lt;行数&gt;</td>\n<td>指定显示的行数</td>\n</tr>\n<tr>\n<td>-c&lt;字节&gt;</td>\n<td>指定显示的字节数</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>显示时不包含指定的文件名作为文件头部</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示时包含指定的文件的文件名作为文件头部</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>默认显示文件的前10行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head /etc/passwd</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\">nobody:x:65534:65534:Nobody:/:/sbin/nologin</span><br><span class=\"line\">dbus:x:81:81:System Message Bus:/:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1::/:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2::/:/sbin/nologin</span><br><span class=\"line\">mail:x:8:12::/var/spool/mail:/sbin/nologin</span><br><span class=\"line\">ftp:x:14:11::/srv/ftp:/sbin/nologin</span><br><span class=\"line\">http:x:33:33::/srv/http:/sbin/nologin</span><br><span class=\"line\">systemd-journal-remote:x:982:982:systemd Journal Remote:/:/sbin/nologin</span><br><span class=\"line\">systemd-network:x:981:981:systemd Network Management:/:/sbin/nologin</span><br></pre></td></tr></table></figure>\n<p><strong>显示文件的前n行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head -n 2 /etc/passwd</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\">nobody:x:65534:65534:Nobody:/:/sbin/nologin</span><br></pre></td></tr></table></figure>\n<p><strong>显示文件的前n个字节</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head -c 4 /etc/passwd</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n<p><strong>显示多个文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; head -1 /etc/passwd /etc/profile</span><br><span class=\"line\">==&gt; /etc/passwd &lt;==</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; /etc/profile &lt;==</span><br><span class=\"line\"># /etc/profile</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-6-tail显示文件内容尾部\"><a href=\"#3-6-tail显示文件内容尾部\" class=\"headerlink\" title=\"3.6 tail显示文件内容尾部\"></a>3.6 tail显示文件内容尾部</h1><p><code>tail</code>命令用于显示文件内容尾部，默认输出行数为10行。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>tail</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c&lt;字节&gt;</td>\n<td>指定显示的字节数</td>\n</tr>\n<tr>\n<td>-n&lt;行数&gt;</td>\n<td>指定显示的行数</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>实时输出文件内容追加的数据</td>\n</tr>\n<tr>\n<td>–retry</td>\n<td>不停的尝试打开文件，直到打开为止</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>等同于-f–retry</td>\n</tr>\n<tr>\n<td>–pid=进程号</td>\n<td>若进程关闭则tail的-f选项则不会继续输出内容</td>\n</tr>\n<tr>\n<td>-s 秒数 N</td>\n<td>监视文件的间隔秒数</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>显示时不包含指定的文件名作为文件头部</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示时包含指定的文件的文件名作为文件头部</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>显示文件最后10行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail /etc/passwd</span><br><span class=\"line\">git:x:973:973:git daemon user:/:/usr/bin/git-shell</span><br><span class=\"line\">lightdm:x:620:620:Light Display Manager:/var/lib/lightdm:/sbin/nologin</span><br><span class=\"line\">nm-openconnect:x:972:972:NetworkManager OpenConnect:/:/sbin/nologin</span><br><span class=\"line\">nm-openvpn:x:971:971:NetworkManager OpenVPN:/:/sbin/nologin</span><br><span class=\"line\">ntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/false</span><br><span class=\"line\">polkitd:x:102:102:PolicyKit daemon:/:/sbin/nologin</span><br><span class=\"line\">usbmux:x:140:140:usbmux user:/:/sbin/nologin</span><br><span class=\"line\">evanmeek:x:1000:1000:EvanMeek:/home/evanmeek:/usr/bin/zsh</span><br><span class=\"line\">nvidia-persistenced:x:143:143:NVIDIA Persistence Daemon:/:/sbin/nologin</span><br><span class=\"line\">privoxy:x:42:42:Privoxy:/:/sbin/nologin</span><br></pre></td></tr></table></figure>\n<p><strong>显示文件最后5行</strong></p>\n<p><em>第一种写法</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -n 5 /etc/passwd</span><br></pre></td></tr></table></figure>\n<p><em>第二种写法</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -5 /etc/passwd</span><br></pre></td></tr></table></figure>\n<p><strong>指定从第几行开始显示文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -n +10 /etc/passwd</span><br></pre></td></tr></table></figure>\n<p><strong>实时监控文件的变化</strong></p>\n<p>监测<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tail -f --retry test.txt</span><br><span class=\"line\">testwords</span><br></pre></td></tr></table></figure></p>\n<p>追加内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; echo testwords &gt;&gt; test.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-7-tailf-跟踪日志文件\"><a href=\"#3-7-tailf-跟踪日志文件\" class=\"headerlink\" title=\"3.7 tailf 跟踪日志文件\"></a>3.7 tailf 跟踪日志文件</h1><p><code>tailf</code>命令日常工作中用于跟踪日志文件，它与<code>tail -f</code>命令基本相同，但唯一的区别是若文件内容无增加，则不会重复访问磁盘文件，也不会修改文件访问时间。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tailf [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>tailf</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-n&lt;行数&gt;</td>\n<td>指定显示的行数，默认为文件最后10行</td>\n</tr>\n</tbody>\n</table>\n<p>例子：</p>\n<p><strong>跟踪日志文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tailf</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-8-cut-从文本中提取一段文字并输出\"><a href=\"#3-8-cut-从文本中提取一段文字并输出\" class=\"headerlink\" title=\"3.8 cut 从文本中提取一段文字并输出\"></a>3.8 cut 从文本中提取一段文字并输出</h1><p><code>cut</code>命令从文件的每一行剪切字节，字符或字段，并将其输出至标准输出。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cut [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>cut</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>以字节为单位进行分割</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>取消分割多字节字符</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>以字符为单位进行分割<code>!</code></td>\n</tr>\n<tr>\n<td>-d</td>\n<td>自定义分隔符，默认以tab为分隔符<code>!</code></td>\n</tr>\n<tr>\n<td>-f</td>\n<td>与选项-d一起使用，指定显示哪个区域</td>\n</tr>\n<tr>\n<td>N</td>\n<td>第N个字节、字符或字段<code>!</code></td>\n</tr>\n<tr>\n<td>N-</td>\n<td>从第N个字节、字符或字段开始直至行尾</td>\n</tr>\n<tr>\n<td>N-M</td>\n<td>从第N到第M个字节、字符或字段</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>从第一到第M个字节、字符或字段</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>以字节为分隔符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">Hello World</span><br><span class=\"line\"># 截取第5个字节，并输出</span><br><span class=\"line\">&gt; cut -b 5 test.txt</span><br><span class=\"line\">o</span><br><span class=\"line\"># 截取第5个字节之前的所有字符(包括第5个)，并输出</span><br><span class=\"line\">&gt; cut -b -5 test.txt</span><br><span class=\"line\">Hello</span><br><span class=\"line\"># 截取第5个字节之后的所有字符，并输出</span><br><span class=\"line\">&gt; cut -b 5- test.txt</span><br><span class=\"line\">o World</span><br><span class=\"line\"># 截取第5个字节和第10个字节，并输出</span><br><span class=\"line\">&gt; cut -b 5,10 test.txt</span><br><span class=\"line\">ol</span><br><span class=\"line\"># 截取第1个字节到第5个字节，并输出</span><br><span class=\"line\">&gt; cut -b 1-5 test.txt</span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n<p><strong>以字符为分隔符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">Hello World</span><br><span class=\"line\">你好世界</span><br><span class=\"line\"># 截取第1到第6个字符，并输出</span><br><span class=\"line\">&gt; cut -b 1-6 test.txt</span><br><span class=\"line\">Hello</span><br><span class=\"line\">你好</span><br></pre></td></tr></table></figure>\n<p><strong>自定义分隔符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat /etc/passwd | head -n 5</span><br><span class=\"line\">root:x:0:0::/root:/bin/bash</span><br><span class=\"line\">nobody:x:65534:65534:Nobody:/:/sbin/nologin</span><br><span class=\"line\">dbus:x:81:81:System Message Bus:/:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1::/:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2::/:/sbin/nologin</span><br><span class=\"line\"># 自定义分隔符为`:`，并且之输出文件前5行(:为分隔符，-f 1为指定显示第1个区域</span><br><span class=\"line\">&gt; cut -d : -f 1 /etc/passwd | head -n 5</span><br><span class=\"line\">root</span><br><span class=\"line\">nobody</span><br><span class=\"line\">dbus</span><br><span class=\"line\">bin</span><br><span class=\"line\">daemon</span><br><span class=\"line\"># 指定显示区域为1,6-8</span><br><span class=\"line\">&gt; cut -d : -f 1,6-8 /etc/passwd | head -n +5</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-9-split-分割文件\"><a href=\"#3-9-split-分割文件\" class=\"headerlink\" title=\"3.9 split 分割文件\"></a>3.9 split 分割文件</h1><p><code>split</code>命令可以将文件进行分割，支持根据行数或文件大小进行分割。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split [选项] [输入文件] [输出文件名[前缀]]</span><br></pre></td></tr></table></figure>\n<p><em>输出文件的格式会加上前缀，例如<code>PREFIXaa,PREFIXab</code></em></p>\n<p><code>split</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>指定分割后文件的最大字节数</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>指定分割后文件的最大行数<code>!</code></td>\n</tr>\n<tr>\n<td>-a</td>\n<td>指定后缀长度，默认为2位字母</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>使用数字后缀</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>按行分割文件，以及指定后缀形式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># wc 命令可以查看文件的行数</span><br><span class=\"line\">&gt; wc -l /etc/passwd</span><br><span class=\"line\">31 /etc/passwd</span><br><span class=\"line\"># 按行进行分割，每10行分割为一个新文件，文件前缀为split_</span><br><span class=\"line\">&gt; split -l 10 /etc/passwd split_</span><br><span class=\"line\">&gt; wc -l split_*</span><br><span class=\"line\">10 split_aa</span><br><span class=\"line\">10 split_ab</span><br><span class=\"line\">10 split_ac</span><br><span class=\"line\"> 1 split_ad</span><br><span class=\"line\">31 总用量</span><br><span class=\"line\"># 参数-a指定分割文件的前缀长度，这里设置的是1</span><br><span class=\"line\">&gt; split -l 10 -a 1 /etc/passwd split2_</span><br><span class=\"line\">&gt; wc -l split2_*</span><br><span class=\"line\">10 split2_a</span><br><span class=\"line\">10 split2_b</span><br><span class=\"line\">10 split2_c</span><br><span class=\"line\"> 1 split2_d</span><br><span class=\"line\">31 总用量</span><br><span class=\"line\"># 参数-d指定文件使用数字后缀</span><br><span class=\"line\">&gt; split -l 10 -d -a 1 /etc/passwd split_</span><br><span class=\"line\">&gt; wc -l split_*</span><br><span class=\"line\">10 split_0</span><br><span class=\"line\">10 split_1</span><br><span class=\"line\">10 split_2</span><br><span class=\"line\"> 1 split_3</span><br><span class=\"line\">31 总用量&lt;Paste&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>按文件大小分割文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 准备测试文件</span><br><span class=\"line\">&gt; cp /sbin/lvm .</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 2.3M</span><br><span class=\"line\">-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm</span><br><span class=\"line\"># 按文件字节进行分割，每500K字节分割为一个文件，以数字作为文件后缀</span><br><span class=\"line\">&gt; split -b 500K -d lvm lvm_split_</span><br><span class=\"line\">&gt; ls -l</span><br><span class=\"line\">总用量 4.5M</span><br><span class=\"line\">-r-xr-xr-x 1 evanmeek evanmeek 2.3M  7月 22 21:23 lvm</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_00</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_01</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_02</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 500K  7月 22 21:25 lvm_split_03</span><br><span class=\"line\">-rw-r--r-- 1 evanmeek evanmeek 254K  7月 22 21:25 lvm_split_04</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-10-paste-合并文件\"><a href=\"#3-10-paste-合并文件\" class=\"headerlink\" title=\"3.10 paste 合并文件\"></a>3.10 paste 合并文件</h1><p><code>paste</code>命令能将文件按照行与行进行合并，中间使用tab隔开</p>\n<p>语法格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paste [选项] [文件]</span><br></pre></td></tr></table></figure></p>\n<p><code>paste</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d</td>\n<td>指定合并的分隔符，默认是Tab<code>!</code></td>\n</tr>\n<tr>\n<td>-s</td>\n<td>每个文件占用一行</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>合并文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; more t1 t2</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t1</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">test1</span><br><span class=\"line\">test1</span><br><span class=\"line\">test1</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t2</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">test2</span><br><span class=\"line\">test2</span><br><span class=\"line\">test2</span><br><span class=\"line\"># t1与t2合并，将内容写入t3</span><br><span class=\"line\">&gt; paste t1 t2 &gt; t3</span><br><span class=\"line\">&gt; cat t3</span><br><span class=\"line\">test1\ttest2</span><br><span class=\"line\">test1\ttest2</span><br><span class=\"line\">test1\ttest2</span><br><span class=\"line\"># 合并时，自定义分隔符</span><br><span class=\"line\">&gt; paste -d - t1 t2 &gt; t3</span><br><span class=\"line\">&gt; cat t3</span><br><span class=\"line\">test1-test2</span><br><span class=\"line\">test1-test2</span><br><span class=\"line\">test1-test2</span><br></pre></td></tr></table></figure>\n<p><strong>文件内容合并成一行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; paste -s t1 t2 &gt; t3</span><br><span class=\"line\">&gt; cat t3</span><br><span class=\"line\">test1\ttest1\ttest1</span><br><span class=\"line\">test2\ttest2\ttest2</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-11-sort-文本排序\"><a href=\"#3-11-sort-文本排序\" class=\"headerlink\" title=\"3.11 sort 文本排序\"></a>3.11 sort 文本排序</h1><p><code>sort</code>命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p><code>sort</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b</td>\n<td>忽略每行开头存在的空格字符</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>按照数值的大小进行排序<code>!</code></td>\n</tr>\n<tr>\n<td>-r</td>\n<td>倒序排序<code>!</code></td>\n</tr>\n<tr>\n<td>-u</td>\n<td>去除重复行</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>指定分隔符<code>!</code></td>\n</tr>\n<tr>\n<td>-k</td>\n<td>按照指定区间排序<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>默认以行为单位进行排序</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat test.txt</span><br><span class=\"line\">t1</span><br><span class=\"line\">t2</span><br><span class=\"line\">t3</span><br><span class=\"line\">t4</span><br><span class=\"line\"># sort默认是以ASCII码进行升序排序。</span><br><span class=\"line\">$ sort test.txt</span><br><span class=\"line\">t1</span><br><span class=\"line\">t2</span><br><span class=\"line\">t3</span><br><span class=\"line\">t4</span><br><span class=\"line\"># 按照数值的大小进行排序</span><br><span class=\"line\">$ sort -n test.txt</span><br><span class=\"line\">t1</span><br><span class=\"line\">t2</span><br><span class=\"line\">t3</span><br><span class=\"line\">t4</span><br><span class=\"line\"># 按照数值的大小降序排序</span><br><span class=\"line\">$ sort -nr test.txt</span><br><span class=\"line\">t4</span><br><span class=\"line\">t3</span><br><span class=\"line\">t2</span><br><span class=\"line\">t1</span><br></pre></td></tr></table></figure>\n<p><strong>去除重复行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat test.txt</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t2 C</span><br><span class=\"line\">t3 B</span><br><span class=\"line\">t4 A</span><br><span class=\"line\"># 去除重复行，并且逆序排序</span><br><span class=\"line\">$ sort -u test.txt | sort -nr</span><br><span class=\"line\">t4 A</span><br><span class=\"line\">t3 B</span><br><span class=\"line\">t2 C</span><br><span class=\"line\">t1 D</span><br></pre></td></tr></table></figure>\n<p><strong>自定义区间排序</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 指定以空格作为分隔符，并且以第二列进行逆序排序</span><br><span class=\"line\">$ sort -t &quot; &quot; -k2 test.txt</span><br><span class=\"line\">t4 A</span><br><span class=\"line\">t3 B</span><br><span class=\"line\">t2 C</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br><span class=\"line\">t1 D</span><br></pre></td></tr></table></figure>\n<p><strong>-t -k的进阶用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat ip.txt</span><br><span class=\"line\">192.197.113.0\t192.197.113.255\t256</span><br><span class=\"line\">193.112.0.0\t193.112.255.255\t65536</span><br><span class=\"line\">195.78.82.0\t195.78.83.255\t512</span><br><span class=\"line\">198.175.100.0\t198.175.103.255\t1024</span><br><span class=\"line\">199.212.57.0\t199.212.57.255\t256</span><br><span class=\"line\">202.0.100.0\t202.0.101.255\t512</span><br><span class=\"line\">202.0.122.0\t202.0.123.255\t512</span><br><span class=\"line\">202.0.176.0\t202.0.179.255\t1024</span><br><span class=\"line\">202.3.128.0\t202.3.129.255\t512</span><br><span class=\"line\">202.3.134.0\t202.3.134.255\t256</span><br><span class=\"line\">202.4.128.0\t202.4.159.255\t8192</span><br><span class=\"line\">202.4.252.0\t202.4.255.255\t1024</span><br><span class=\"line\"># 以第3个字段的第1个字符到第3个字段的第3个字段进行数字排序</span><br><span class=\"line\">$ sort -n -t. -k3.1,3.3 ip.txt</span><br><span class=\"line\">193.112.0.0\t193.112.255.255\t65536</span><br><span class=\"line\">199.212.57.0\t199.212.57.255\t256</span><br><span class=\"line\">195.78.82.0\t195.78.83.255\t512</span><br><span class=\"line\">198.175.100.0\t198.175.103.255\t1024</span><br><span class=\"line\">202.0.100.0\t202.0.101.255\t512</span><br><span class=\"line\">192.197.113.0\t192.197.113.255\t256</span><br><span class=\"line\">202.0.122.0\t202.0.123.255\t512</span><br><span class=\"line\">202.3.128.0\t202.3.129.255\t512</span><br><span class=\"line\">202.4.128.0\t202.4.159.255\t8192</span><br><span class=\"line\">202.3.134.0\t202.3.134.255\t256</span><br><span class=\"line\">202.0.176.0\t202.0.179.255\t1024</span><br><span class=\"line\">202.4.252.0\t202.4.255.255\t1024</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-12-join-按两个文件的相同字段合并\"><a href=\"#3-12-join-按两个文件的相同字段合并\" class=\"headerlink\" title=\"3.12 join 按两个文件的相同字段合并\"></a>3.12 join 按两个文件的相同字段合并</h1><p><code>join</code>命令针对每一对具有相同内容的输入行，整合为一行输出到标准输出，默认情况下是把输入的第一个字段作为连接字段，字段之间用空格隔开。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">join [选项] [文件1] [文件2]</span><br></pre></td></tr></table></figure>\n<p><code>join</code>命令的参数选项及说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a文件号</td>\n<td>输出文件中不匹配的行，文件号可选值1或2,代表文件1和文件2</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>比较字段时忽略大小写</td>\n</tr>\n<tr>\n<td>-1 字段</td>\n<td>以第1个文件的指定字段为基础进行合并</td>\n</tr>\n<tr>\n<td>-2 字段</td>\n<td>以第2个文件的指定字段为基础进行合并</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>合并文本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more t1.txt t2.txt</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t1.txt</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">张三 21岁</span><br><span class=\"line\">李四 23岁</span><br><span class=\"line\">王五 17岁</span><br><span class=\"line\">赵六 15岁</span><br><span class=\"line\"></span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">t2.txt</span><br><span class=\"line\">::::::::::::::</span><br><span class=\"line\">张三 男</span><br><span class=\"line\">李四 女</span><br><span class=\"line\">王五 男</span><br><span class=\"line\">赵六 女</span><br><span class=\"line\"># 将t1和t2进行合并</span><br><span class=\"line\">$ join t1.txt t2.txt &gt; t3.txt</span><br><span class=\"line\">$ cat t3.txt</span><br><span class=\"line\">张三 21岁 男</span><br><span class=\"line\">李四 23岁 女</span><br><span class=\"line\">王五 17岁 男</span><br><span class=\"line\">赵六 15岁 女</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-13-uniq-去除重复行\"><a href=\"#3-13-uniq-去除重复行\" class=\"headerlink\" title=\"3.13 uniq 去除重复行\"></a>3.13 uniq 去除重复行</h1><p><code>uniq</code>命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用<code>uniq</code>命令去重并计数。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniq [选项] [文件或标准输入]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>去除重复行，并且计算每行出现的次数</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>只显示重复的行</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>只显示唯一的行</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>去重测试案例</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">重复重复重复</span><br><span class=\"line\">&gt; uniq -c test.txt</span><br><span class=\"line\">5 重复重复重复</span><br></pre></td></tr></table></figure>\n<p><strong>结合sort排序后去重</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat test.txt</span><br><span class=\"line\">10000</span><br><span class=\"line\">10000</span><br><span class=\"line\">2</span><br><span class=\"line\">10000</span><br><span class=\"line\">10000</span><br><span class=\"line\">2</span><br><span class=\"line\">10000</span><br><span class=\"line\">&gt; uniq -c test.txt</span><br><span class=\"line\">2 10000</span><br><span class=\"line\">1 2</span><br><span class=\"line\">2 10000</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 10000</span><br><span class=\"line\"># 在这里我们发现，uniq只能去除相邻重复的行，所以我们就使用sort排序后再进行去重复</span><br><span class=\"line\">&gt; sort -n test.txt | uniq -c</span><br><span class=\"line\">2 2</span><br><span class=\"line\">5 10000</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-14-wc-统计文件的行数、单词数或字节数\"><a href=\"#3-14-wc-统计文件的行数、单词数或字节数\" class=\"headerlink\" title=\"3.14 wc 统计文件的行数、单词数或字节数\"></a>3.14 wc 统计文件的行数、单词数或字节数</h1><p><code>wc</code>命令用于统计文件的行数、单词数和字节数。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>统计字节数</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>统计行数<code>!</code></td>\n</tr>\n<tr>\n<td>-m</td>\n<td>统计字符数</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>统计单词数</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>输出最长行的长度<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>查看文件的字节数、字数、行数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; wc /etc/profile</span><br><span class=\"line\">9      30     189 /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"># 依次排列过去是 行数 - 单词数 - 字节数</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-15-iconv-转换文件的编码格式\"><a href=\"#3-15-iconv-转换文件的编码格式\" class=\"headerlink\" title=\"3.15 iconv 转换文件的编码格式\"></a>3.15 iconv 转换文件的编码格式</h1><p><code>iconv</code>命令用于转换文件的编码格式.</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iconv [选项] [原编码] [新编码] [输入文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-f encodingA</td>\n<td>从编码A转换<code>!</code></td>\n</tr>\n<tr>\n<td>-t encodingB</td>\n<td>转换程编码B <code>!</code></td>\n</tr>\n<tr>\n<td>-l</td>\n<td>显示系统支持的编码<code>!</code></td>\n</tr>\n<tr>\n<td>-o</td>\n<td>将输出输入到指定文件<code>!</code></td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat utf-8.txt</span><br><span class=\"line\">你好世界</span><br><span class=\"line\"># 指定utf-8.txt的编码格式为utf-8，将要转换成GB2312</span><br><span class=\"line\">&gt; iconv -f UTF-8 -t GB2312 utf-8.txt &gt; gbk.txt</span><br><span class=\"line\">&gt; cat gbk.txt</span><br><span class=\"line\">无回显</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-16-dos2unix-将DOS格式文件转换成UNIX格式\"><a href=\"#3-16-dos2unix-将DOS格式文件转换成UNIX格式\" class=\"headerlink\" title=\"3.16 dos2unix 将DOS格式文件转换成UNIX格式\"></a>3.16 dos2unix 将DOS格式文件转换成UNIX格式</h1><p>由于dos格式的文件的换行符与unix格式的文件的换行符不同，所以需要转换。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dos2unix [文件]</span><br></pre></td></tr></table></figure>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dos2unix dosfile.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-17-diff-比较两个文件的不同\"><a href=\"#3-17-diff-比较两个文件的不同\" class=\"headerlink\" title=\"3.17 diff 比较两个文件的不同\"></a>3.17 diff 比较两个文件的不同</h1><p><code>diff</code>命令可以逐行比较纯文本文件的内容，并输出文件的差异。</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff [选项] [文件1] [文件2]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-y</td>\n<td>以并列的方式显示文件的异同之处</td>\n</tr>\n<tr>\n<td>-W</td>\n<td>在使用-y参数时，指定显示宽度</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>使用上下文的输出格式</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>使用统一格式输出</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>比较两个文本文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evanmeek@EvanMeekdeMBP  ~/TestDir  cat test1.txt</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">evanmeek@EvanMeekdeMBP  ~/TestDir  cat test2.txt</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">evanmeek@EvanMeekdeMBP  ~/TestDir  diff test1.txt test2.txt</span><br><span class=\"line\"># 代表文件2对比文件1删除了第一行到第三行</span><br><span class=\"line\">1,3d0</span><br><span class=\"line\">&lt; 1</span><br><span class=\"line\">&lt; 2</span><br><span class=\"line\">&lt; 3</span><br><span class=\"line\"># 代表文件1的第6行下增加了文件2的第4行和第5行</span><br><span class=\"line\">6a4,6</span><br><span class=\"line\">&gt; 7</span><br><span class=\"line\">&gt; 8</span><br><span class=\"line\">&gt; 9</span><br></pre></td></tr></table></figure>\n<p><strong>并排格式输出</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y test1.txt test2.txt</span><br><span class=\"line\">1                                                             &lt;</span><br><span class=\"line\">2                                                             &lt;</span><br><span class=\"line\">3                                                             &lt;</span><br><span class=\"line\">4                                                               4</span><br><span class=\"line\">5                                                               5</span><br><span class=\"line\">6                                                               6</span><br><span class=\"line\">                                                            &gt; 7</span><br><span class=\"line\">                                                            &gt; 8</span><br><span class=\"line\">                                                            &gt; 9</span><br></pre></td></tr></table></figure>\n<p><strong>并排格式输出时指定宽度</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y -W 30 test1.txt test2.txt</span><br><span class=\"line\">1             &lt;</span><br><span class=\"line\">2             &lt;</span><br><span class=\"line\">3             &lt;</span><br><span class=\"line\">4               4</span><br><span class=\"line\">5               5</span><br><span class=\"line\">6               6</span><br><span class=\"line\">              &gt; 7</span><br><span class=\"line\">              &gt; 8</span><br><span class=\"line\">              &gt; 9</span><br></pre></td></tr></table></figure>\n<p><strong>上下文输出格式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -c test1.txt test2.txt</span><br><span class=\"line\">*** test1.txt   2019-08-25 16:39:32.000000000 +0800</span><br><span class=\"line\">--- test2.txt   2019-08-25 16:40:32.000000000 +0800</span><br><span class=\"line\">***************</span><br><span class=\"line\">*** 1,6 ****</span><br><span class=\"line\">- 1</span><br><span class=\"line\">- 2</span><br><span class=\"line\">- 3</span><br><span class=\"line\">  4</span><br><span class=\"line\">  5</span><br><span class=\"line\">  6</span><br><span class=\"line\">--- 1,6 ----</span><br><span class=\"line\">  4</span><br><span class=\"line\">  5</span><br><span class=\"line\">  6</span><br><span class=\"line\">+ 7</span><br><span class=\"line\">+ 8</span><br><span class=\"line\">+ 9</span><br></pre></td></tr></table></figure>\n<p><strong>统一标准输出格式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -u test1.txt test2.txt</span><br><span class=\"line\">--- test1.txt   2019-08-25 16:39:32.000000000 +0800</span><br><span class=\"line\">+++ test2.txt   2019-08-25 16:40:32.000000000 +0800</span><br><span class=\"line\">@@ -1,6 +1,6 @@</span><br><span class=\"line\">-1</span><br><span class=\"line\">-2</span><br><span class=\"line\">-3</span><br><span class=\"line\"> 4</span><br><span class=\"line\"> 5</span><br><span class=\"line\"> 6</span><br><span class=\"line\">+7</span><br><span class=\"line\">+8</span><br><span class=\"line\">+9</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-19-rev-反向输出文件内容\"><a href=\"#3-19-rev-反向输出文件内容\" class=\"headerlink\" title=\"3.19 rev 反向输出文件内容\"></a>3.19 rev 反向输出文件内容</h1><p><code>rev</code>命令可以按行反向输出文件内容</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rev [文件]</span><br></pre></td></tr></table></figure>\n<p>例子:</p>\n<p><strong>字符串反转</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; echo &#123;1..10&#125;</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 10</span><br><span class=\"line\">&gt; echo &#123;1..10&#125;|rev</span><br><span class=\"line\">01 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>\n<p><strong>文本反转</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">你好世界</span><br><span class=\"line\">&gt; rev testfile</span><br><span class=\"line\">界世好你</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-20-tr-替换或删除字符\"><a href=\"#3-20-tr-替换或删除字符\" class=\"headerlink\" title=\"3.20 tr 替换或删除字符\"></a>3.20 tr 替换或删除字符</h1><p><code>tr</code>命令从标准输入中替换、缩减或删除字符，并将结果写入到标准输出</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tr [选项] [字符1] [字符2]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d</td>\n<td>删除字符<code>!</code></td>\n</tr>\n<tr>\n<td>-s</td>\n<td>保留连续字符的第一个字符，删除其他字符</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>使用第一个字符串(set1)的补集，取反</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<p><strong>替换文本中出现的字符为某字符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">test word</span><br><span class=\"line\">aa bb cc</span><br><span class=\"line\">abc</span><br><span class=\"line\"># 这里是将文件中出现&apos;a&apos;的字符替换成&apos;x&apos;,依次对应</span><br><span class=\"line\">&gt; tr &apos;abc&apos; &apos;xyz&apos; &lt; testfile</span><br><span class=\"line\">test word</span><br><span class=\"line\">xx yy zz</span><br><span class=\"line\">xyz</span><br></pre></td></tr></table></figure>\n<p><strong>使用tr统一字母大小写</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">test word</span><br><span class=\"line\">aa bb cc</span><br><span class=\"line\">abc</span><br><span class=\"line\"># [a-z]代表小写字母a b c d..z</span><br><span class=\"line\">&gt; tr &apos;[a-z]&apos; &apos;[A-Z]&apos; &lt; testfile</span><br><span class=\"line\">TEST WORD</span><br><span class=\"line\">AA BB CC</span><br><span class=\"line\">ABC</span><br></pre></td></tr></table></figure>\n<p><strong>将数字0-9替换为a-j</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\">&gt; tr &apos;[0-9]&apos; &apos;[a-j]&apos; &lt; testfile</span><br><span class=\"line\">a b c d e f g h i j</span><br></pre></td></tr></table></figure>\n<p><strong>删除文件中出现的Evan这个单词中的每个字符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat testfile</span><br><span class=\"line\">EeEvVvaAanNn</span><br><span class=\"line\">&gt; tr -d &apos;Evan&apos; &lt; testfile</span><br><span class=\"line\">eVAN</span><br></pre></td></tr></table></figure>\n<p><strong>删除文件中出现的换行符和制表符</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cat tesfile</span><br><span class=\"line\"></span><br><span class=\"line\">a aaa aaa   aaa</span><br><span class=\"line\">b   b     b </span><br><span class=\"line\">&gt; tr -d &apos;\\n\\t&apos; &lt; testfile</span><br><span class=\"line\">a aaa aaa   aaab   b     b%</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-21-od-按不同进制显示文件\"><a href=\"#3-21-od-按不同进制显示文件\" class=\"headerlink\" title=\"3.21 od 按不同进制显示文件\"></a>3.21 od 按不同进制显示文件</h1><p><code>od</code>命令用于输出文件的八进制，十六进制等其他编码格式的字节，通常用于显示或查看文件中不能直接显示在终端的字符</p>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">od [选项] [文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-A 地址进制</td>\n<td>按指定的进制显示地址信息</td>\n</tr>\n<tr>\n<td>-t 显示格式</td>\n<td>指定数据的显示格式</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>地址信息</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>o</td>\n<td>八进制(默认)</td>\n</tr>\n<tr>\n<td>d</td>\n<td>十进制</td>\n</tr>\n<tr>\n<td>x</td>\n<td>十六进制</td>\n</tr>\n<tr>\n<td>n</td>\n<td>不打印位移值</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>命名字符，忽略高阶位</td>\n</tr>\n<tr>\n<td>c</td>\n<td>ASCII字符或反斜杠序列</td>\n</tr>\n<tr>\n<td>d</td>\n<td>有符号的十进制数</td>\n</tr>\n<tr>\n<td>f</td>\n<td>浮点数</td>\n</tr>\n<tr>\n<td>o</td>\n<td>八进制(系统默认)</td>\n</tr>\n<tr>\n<td>u</td>\n<td>无符号十进制</td>\n</tr>\n<tr>\n<td>x</td>\n<td>十六进制</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Linux-文本处理三剑客-3","copyright":true,"date":"2019-12-12T09:07:28.000Z","_content":"\n# 4.1 grep: 文本过滤工具\n\n## 命令详解\n\n功能说明\n\ngrep命令可以从文本文件或管道数据流中筛选匹配的行或数据，还可以配合正则表达式一起\n使用。\n\n语法格式\n\n```shell\ngrep [参数] [匹配模式] [需要查找的文件]\n```\n\n选项说明\n\n| 参数选项     | 解释说明                         |\n|--------------|----------------------------------|\n| -v           | 排除某行                         |\n| -n           | 显示匹配行及行号                 |\n| -i           | 不区分大小写                     |\n| -c           | 统计匹配行数                     |\n| -E           | 使用egrep命令替代grep            |\n| --color=auto | 为grep过滤后匹配的字符串添加颜色 |\n| -w           | 只匹配过滤的单词                 |\n| -o           | 只输出匹配的内容                 |\n\n## 使用范例\n\n1. 基础范例\n\n使用grep过滤不包括evanmeek字符串的行(-v参数实践)\n\n```shell\n➜   cat test.txt \nChina\nJapan\nroot\nEvanMeek\nMyBlog\nevanmeek\n\n➜   grep -v \"evanmeek\" test.txt\nChina\nJapan\nroot\nEvanMeek\nMyBlog\n```\n\n*提示:* grep命令-v参数正如刚刚输出所示，会将过滤参数后的内容。\n\n使用grep过滤包括evanmeek字符串的行，并显示其所在行行号(-n实践)\n\n```shell\n# 文本内容相同，我们使用下面这条命令，看看会发生什么\n➜   grep -n \"evanmeek\" test.txt \n# 我们得到了test.txt中包含evanmeek的行且行号。\n\n# 我们也可以使用.匹配任意内容，相当于看test.txt文件内容加上行号\n➜   grep -n \".\" test.txt \n1:China\n2:Japan\n3:root\n4:EvanMeek\n5:MyBlog\n6:evanmeek\n6:evanmeek\n```\n\n不区分大小写参数实践\n\n```shell\n# grep在过滤时可以选择忽略区分大小写，默认是区分的\n# 文件内容相同,使用-i参数忽略大小写，-n参数选择要筛选的内容并有行号\n➜   grep -i -n \"evanmeek\" test.txt\n4:EvanMeek\n6:evanmeek\n```\n\n计算匹配的字符串的数量(-c参数实践)\n","source":"_posts/Linux-文本处理三剑客-3.md","raw":"---\ntitle: Linux-文本处理三剑客-3\ncopyright: true\ndate: 2019-12-12 17:07:28\ncategories: Linux系列\ntags:\n  - Linux\n---\n\n# 4.1 grep: 文本过滤工具\n\n## 命令详解\n\n功能说明\n\ngrep命令可以从文本文件或管道数据流中筛选匹配的行或数据，还可以配合正则表达式一起\n使用。\n\n语法格式\n\n```shell\ngrep [参数] [匹配模式] [需要查找的文件]\n```\n\n选项说明\n\n| 参数选项     | 解释说明                         |\n|--------------|----------------------------------|\n| -v           | 排除某行                         |\n| -n           | 显示匹配行及行号                 |\n| -i           | 不区分大小写                     |\n| -c           | 统计匹配行数                     |\n| -E           | 使用egrep命令替代grep            |\n| --color=auto | 为grep过滤后匹配的字符串添加颜色 |\n| -w           | 只匹配过滤的单词                 |\n| -o           | 只输出匹配的内容                 |\n\n## 使用范例\n\n1. 基础范例\n\n使用grep过滤不包括evanmeek字符串的行(-v参数实践)\n\n```shell\n➜   cat test.txt \nChina\nJapan\nroot\nEvanMeek\nMyBlog\nevanmeek\n\n➜   grep -v \"evanmeek\" test.txt\nChina\nJapan\nroot\nEvanMeek\nMyBlog\n```\n\n*提示:* grep命令-v参数正如刚刚输出所示，会将过滤参数后的内容。\n\n使用grep过滤包括evanmeek字符串的行，并显示其所在行行号(-n实践)\n\n```shell\n# 文本内容相同，我们使用下面这条命令，看看会发生什么\n➜   grep -n \"evanmeek\" test.txt \n# 我们得到了test.txt中包含evanmeek的行且行号。\n\n# 我们也可以使用.匹配任意内容，相当于看test.txt文件内容加上行号\n➜   grep -n \".\" test.txt \n1:China\n2:Japan\n3:root\n4:EvanMeek\n5:MyBlog\n6:evanmeek\n6:evanmeek\n```\n\n不区分大小写参数实践\n\n```shell\n# grep在过滤时可以选择忽略区分大小写，默认是区分的\n# 文件内容相同,使用-i参数忽略大小写，-n参数选择要筛选的内容并有行号\n➜   grep -i -n \"evanmeek\" test.txt\n4:EvanMeek\n6:evanmeek\n```\n\n计算匹配的字符串的数量(-c参数实践)\n","slug":"Linux-文本处理三剑客-3","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc8002oomooy5l2ikoh","content":"<h1 id=\"4-1-grep-文本过滤工具\"><a href=\"#4-1-grep-文本过滤工具\" class=\"headerlink\" title=\"4.1 grep: 文本过滤工具\"></a>4.1 grep: 文本过滤工具</h1><h2 id=\"命令详解\"><a href=\"#命令详解\" class=\"headerlink\" title=\"命令详解\"></a>命令详解</h2><p>功能说明</p>\n<p>grep命令可以从文本文件或管道数据流中筛选匹配的行或数据，还可以配合正则表达式一起<br>使用。</p>\n<p>语法格式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [参数] [匹配模式] [需要查找的文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>参数选项</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-v</td>\n<td>排除某行</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>显示匹配行及行号</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>不区分大小写</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>统计匹配行数</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>使用egrep命令替代grep</td>\n</tr>\n<tr>\n<td>–color=auto</td>\n<td>为grep过滤后匹配的字符串添加颜色</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>只匹配过滤的单词</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>只输出匹配的内容</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用范例\"><a href=\"#使用范例\" class=\"headerlink\" title=\"使用范例\"></a>使用范例</h2><ol>\n<li>基础范例</li>\n</ol>\n<p>使用grep过滤不包括evanmeek字符串的行(-v参数实践)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜   cat test.txt </span><br><span class=\"line\">China</span><br><span class=\"line\">Japan</span><br><span class=\"line\">root</span><br><span class=\"line\">EvanMeek</span><br><span class=\"line\">MyBlog</span><br><span class=\"line\">evanmeek</span><br><span class=\"line\"></span><br><span class=\"line\">➜   grep -v \"evanmeek\" test.txt</span><br><span class=\"line\">China</span><br><span class=\"line\">Japan</span><br><span class=\"line\">root</span><br><span class=\"line\">EvanMeek</span><br><span class=\"line\">MyBlog</span><br></pre></td></tr></table></figure>\n<p><em>提示:</em> grep命令-v参数正如刚刚输出所示，会将过滤参数后的内容。</p>\n<p>使用grep过滤包括evanmeek字符串的行，并显示其所在行行号(-n实践)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 文本内容相同，我们使用下面这条命令，看看会发生什么</span><br><span class=\"line\">➜   grep -n \"evanmeek\" test.txt </span><br><span class=\"line\"><span class=\"meta\">#</span> 我们得到了test.txt中包含evanmeek的行且行号。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 我们也可以使用.匹配任意内容，相当于看test.txt文件内容加上行号</span><br><span class=\"line\">➜   grep -n \".\" test.txt </span><br><span class=\"line\">1:China</span><br><span class=\"line\">2:Japan</span><br><span class=\"line\">3:root</span><br><span class=\"line\">4:EvanMeek</span><br><span class=\"line\">5:MyBlog</span><br><span class=\"line\">6:evanmeek</span><br><span class=\"line\">6:evanmeek</span><br></pre></td></tr></table></figure>\n<p>不区分大小写参数实践</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> grep在过滤时可以选择忽略区分大小写，默认是区分的</span><br><span class=\"line\"><span class=\"meta\">#</span> 文件内容相同,使用-i参数忽略大小写，-n参数选择要筛选的内容并有行号</span><br><span class=\"line\">➜   grep -i -n \"evanmeek\" test.txt</span><br><span class=\"line\">4:EvanMeek</span><br><span class=\"line\">6:evanmeek</span><br></pre></td></tr></table></figure>\n<p>计算匹配的字符串的数量(-c参数实践)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"4-1-grep-文本过滤工具\"><a href=\"#4-1-grep-文本过滤工具\" class=\"headerlink\" title=\"4.1 grep: 文本过滤工具\"></a>4.1 grep: 文本过滤工具</h1><h2 id=\"命令详解\"><a href=\"#命令详解\" class=\"headerlink\" title=\"命令详解\"></a>命令详解</h2><p>功能说明</p>\n<p>grep命令可以从文本文件或管道数据流中筛选匹配的行或数据，还可以配合正则表达式一起<br>使用。</p>\n<p>语法格式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [参数] [匹配模式] [需要查找的文件]</span><br></pre></td></tr></table></figure>\n<p>选项说明</p>\n<table>\n<thead>\n<tr>\n<th>参数选项</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-v</td>\n<td>排除某行</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>显示匹配行及行号</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>不区分大小写</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>统计匹配行数</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>使用egrep命令替代grep</td>\n</tr>\n<tr>\n<td>–color=auto</td>\n<td>为grep过滤后匹配的字符串添加颜色</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>只匹配过滤的单词</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>只输出匹配的内容</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用范例\"><a href=\"#使用范例\" class=\"headerlink\" title=\"使用范例\"></a>使用范例</h2><ol>\n<li>基础范例</li>\n</ol>\n<p>使用grep过滤不包括evanmeek字符串的行(-v参数实践)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜   cat test.txt </span><br><span class=\"line\">China</span><br><span class=\"line\">Japan</span><br><span class=\"line\">root</span><br><span class=\"line\">EvanMeek</span><br><span class=\"line\">MyBlog</span><br><span class=\"line\">evanmeek</span><br><span class=\"line\"></span><br><span class=\"line\">➜   grep -v \"evanmeek\" test.txt</span><br><span class=\"line\">China</span><br><span class=\"line\">Japan</span><br><span class=\"line\">root</span><br><span class=\"line\">EvanMeek</span><br><span class=\"line\">MyBlog</span><br></pre></td></tr></table></figure>\n<p><em>提示:</em> grep命令-v参数正如刚刚输出所示，会将过滤参数后的内容。</p>\n<p>使用grep过滤包括evanmeek字符串的行，并显示其所在行行号(-n实践)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 文本内容相同，我们使用下面这条命令，看看会发生什么</span><br><span class=\"line\">➜   grep -n \"evanmeek\" test.txt </span><br><span class=\"line\"><span class=\"meta\">#</span> 我们得到了test.txt中包含evanmeek的行且行号。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 我们也可以使用.匹配任意内容，相当于看test.txt文件内容加上行号</span><br><span class=\"line\">➜   grep -n \".\" test.txt </span><br><span class=\"line\">1:China</span><br><span class=\"line\">2:Japan</span><br><span class=\"line\">3:root</span><br><span class=\"line\">4:EvanMeek</span><br><span class=\"line\">5:MyBlog</span><br><span class=\"line\">6:evanmeek</span><br><span class=\"line\">6:evanmeek</span><br></pre></td></tr></table></figure>\n<p>不区分大小写参数实践</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> grep在过滤时可以选择忽略区分大小写，默认是区分的</span><br><span class=\"line\"><span class=\"meta\">#</span> 文件内容相同,使用-i参数忽略大小写，-n参数选择要筛选的内容并有行号</span><br><span class=\"line\">➜   grep -i -n \"evanmeek\" test.txt</span><br><span class=\"line\">4:EvanMeek</span><br><span class=\"line\">6:evanmeek</span><br></pre></td></tr></table></figure>\n<p>计算匹配的字符串的数量(-c参数实践)</p>\n"},{"title":"Linux中的解压与压缩","date":"2019-05-08T12:54:19.000Z","copyright":true,"_content":"\n当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。\n\n<!--more-->\n\n在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。\n\n\nLinux下有三种主流常用的解压压缩软件可选:\n\n- gzip (GNUzip)\n\n- bz2 (bzip2)\n\n- xz (xzutils)\n\n三个软件的参数相同，只是命令不同:\n\n~~~shell\n$ gzip [参数] <文件名>\n~~~\n\n~~~shell\n$ bzip2 [参数] <文件名>\n~~~\n\n~~~shell\n$ xz [参数] <文件名>\n~~~\n\n> 可选参数\n\n|参数名|作用|\n---|:---:|---\n|-d|解压|\n|-k|压缩时不删除源文件|\n|-r|递归查找目录下的文件，并且压缩|\n|-v|显示详细信息|\n|-t|测试压缩包是否完整|\n|-l|显示压缩包信息|\n|-c|写入标准输出，保持原始文件不变|\n|-1~9|压缩等级|\n\n**示例:**\n\n> 压缩test.txt，并删除.\n\n~~~shell\n$ gzip test.txt\n~~~\n\n> 压缩test.txt，不删除原文件，并且显示信息.\n\n~~~shell\n$ gzip -vk test.txt\n~~~\n\n> 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz\n\n~~~shell\n$ gzip -9cvk test.txt test2.txt > test.gz\n~~~\n\n> 解压test.gz\n\n~~~shell\n$ gzip -d test.gz\n~~~\n\n---\n\n介绍完上面的几种压缩软件，下面介绍一个打包软件**tar**\n\n我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。\n\n\n## 压缩\n\n这里注意第一个参数，它们分别代表使用什么压缩软件。\n\n> bz2\n~~~shell\n$ tar -jcvf test.tar.bz test/ \n~~~\n\n>xz\n~~~shell\n$ tar -Jcvf test.tar.xz test/\n~~~\n\n>gzip\n~~~shell\n$ tar -zcvf test.tar.gz test/\n~~~\n\n## 解压\n\n只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.\n\n\n~~~shell\n$ tar -Jxvf test.tar.xz test/\n~~~\n\n---\n","source":"_posts/Linux中的解压与压缩.md","raw":"---\ntitle: Linux中的解压与压缩\ndate: 2019-05-08 20:54:19\ncategories: 学习笔记\ntags:\n  - Linux\ncopyright: true\n---\n\n当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。\n\n<!--more-->\n\n在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。\n\n\nLinux下有三种主流常用的解压压缩软件可选:\n\n- gzip (GNUzip)\n\n- bz2 (bzip2)\n\n- xz (xzutils)\n\n三个软件的参数相同，只是命令不同:\n\n~~~shell\n$ gzip [参数] <文件名>\n~~~\n\n~~~shell\n$ bzip2 [参数] <文件名>\n~~~\n\n~~~shell\n$ xz [参数] <文件名>\n~~~\n\n> 可选参数\n\n|参数名|作用|\n---|:---:|---\n|-d|解压|\n|-k|压缩时不删除源文件|\n|-r|递归查找目录下的文件，并且压缩|\n|-v|显示详细信息|\n|-t|测试压缩包是否完整|\n|-l|显示压缩包信息|\n|-c|写入标准输出，保持原始文件不变|\n|-1~9|压缩等级|\n\n**示例:**\n\n> 压缩test.txt，并删除.\n\n~~~shell\n$ gzip test.txt\n~~~\n\n> 压缩test.txt，不删除原文件，并且显示信息.\n\n~~~shell\n$ gzip -vk test.txt\n~~~\n\n> 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz\n\n~~~shell\n$ gzip -9cvk test.txt test2.txt > test.gz\n~~~\n\n> 解压test.gz\n\n~~~shell\n$ gzip -d test.gz\n~~~\n\n---\n\n介绍完上面的几种压缩软件，下面介绍一个打包软件**tar**\n\n我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。\n\n\n## 压缩\n\n这里注意第一个参数，它们分别代表使用什么压缩软件。\n\n> bz2\n~~~shell\n$ tar -jcvf test.tar.bz test/ \n~~~\n\n>xz\n~~~shell\n$ tar -Jcvf test.tar.xz test/\n~~~\n\n>gzip\n~~~shell\n$ tar -zcvf test.tar.gz test/\n~~~\n\n## 解压\n\n只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.\n\n\n~~~shell\n$ tar -Jxvf test.tar.xz test/\n~~~\n\n---\n","slug":"Linux中的解压与压缩","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoc8002romoo43cs2bq6","content":"<p>当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。</p>\n<a id=\"more\"></a>\n<p>在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。</p>\n<p>Linux下有三种主流常用的解压压缩软件可选:</p>\n<ul>\n<li><p>gzip (GNUzip)</p>\n</li>\n<li><p>bz2 (bzip2)</p>\n</li>\n<li><p>xz (xzutils)</p>\n</li>\n</ul>\n<p>三个软件的参数相同，只是命令不同:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> bzip2 [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> xz [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可选参数</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">参数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-d</td>\n<td>解压</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-k</td>\n<td>压缩时不删除源文件</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-r</td>\n<td>递归查找目录下的文件，并且压缩</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-v</td>\n<td>显示详细信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-t</td>\n<td>测试压缩包是否完整</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-l</td>\n<td>显示压缩包信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-c</td>\n<td>写入标准输出，保持原始文件不变</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-1~9</td>\n<td>压缩等级</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例:</strong></p>\n<blockquote>\n<p>压缩test.txt，并删除.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>压缩test.txt，不删除原文件，并且显示信息.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -vk test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -9cvk test.txt test2.txt &gt; test.gz</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解压test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -d test.gz</span><br></pre></td></tr></table></figure>\n<hr>\n<p>介绍完上面的几种压缩软件，下面介绍一个打包软件<strong>tar</strong></p>\n<p>我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。</p>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>这里注意第一个参数，它们分别代表使用什么压缩软件。</p>\n<blockquote>\n<p>bz2<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -jcvf test.tar.bz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>xz<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jcvf test.tar.xz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>gzip<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -zcvf test.tar.gz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h2><p>只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jxvf test.tar.xz test/</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<p>当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。</p>","more":"<p>在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。</p>\n<p>Linux下有三种主流常用的解压压缩软件可选:</p>\n<ul>\n<li><p>gzip (GNUzip)</p>\n</li>\n<li><p>bz2 (bzip2)</p>\n</li>\n<li><p>xz (xzutils)</p>\n</li>\n</ul>\n<p>三个软件的参数相同，只是命令不同:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> bzip2 [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> xz [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可选参数</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">参数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-d</td>\n<td>解压</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-k</td>\n<td>压缩时不删除源文件</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-r</td>\n<td>递归查找目录下的文件，并且压缩</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-v</td>\n<td>显示详细信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-t</td>\n<td>测试压缩包是否完整</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-l</td>\n<td>显示压缩包信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-c</td>\n<td>写入标准输出，保持原始文件不变</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-1~9</td>\n<td>压缩等级</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例:</strong></p>\n<blockquote>\n<p>压缩test.txt，并删除.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>压缩test.txt，不删除原文件，并且显示信息.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -vk test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -9cvk test.txt test2.txt &gt; test.gz</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解压test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -d test.gz</span><br></pre></td></tr></table></figure>\n<hr>\n<p>介绍完上面的几种压缩软件，下面介绍一个打包软件<strong>tar</strong></p>\n<p>我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。</p>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>这里注意第一个参数，它们分别代表使用什么压缩软件。</p>\n<blockquote>\n<p>bz2<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -jcvf test.tar.bz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>xz<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jcvf test.tar.xz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>gzip<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -zcvf test.tar.gz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h2><p>只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jxvf test.tar.xz test/</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"Mac下安装Rust","copyright":true,"date":"2019-08-19T18:30:40.000Z","_content":"\n本篇文章记录了我是如何在Mac下安装rust的过程.\n\n<!--more-->\n\n首先在你Shell的配置文件内加入下面两行:\n\n~~~\nexport RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static\nexport RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup\n~~~\n\n然后打开终端，输入:\n\n~~~\ncurl https://sh.rustup.rs -sSf | sh\n~~~\n\n中间稍微等待一下，选择安装的方式即可。\n\n安装好后记得执行:\n\n~~~\nsource $HOME/.cargo/env\n~~~\n\n最后再编辑$HOME/.cargo/config文件\n\n~~~\n[registry]\nindex = \"https://mirrors.ustc.edu.cn/crates.io-index/\"\n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'ustc'\n[source.ustc]\nregistry = \"https://mirrors.ustc.edu.cn/crates.io-index/\"\n~~~\n就大功告成啦，赶快写一个HelloWorld吧!\n","source":"_posts/Mac下安装Rust.md","raw":"---\ntitle: Mac下安装Rust\ncopyright: true\ndate: 2019-08-20 02:30:40\ncategories: 学习笔记\ntags: Rust\n---\n\n本篇文章记录了我是如何在Mac下安装rust的过程.\n\n<!--more-->\n\n首先在你Shell的配置文件内加入下面两行:\n\n~~~\nexport RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static\nexport RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup\n~~~\n\n然后打开终端，输入:\n\n~~~\ncurl https://sh.rustup.rs -sSf | sh\n~~~\n\n中间稍微等待一下，选择安装的方式即可。\n\n安装好后记得执行:\n\n~~~\nsource $HOME/.cargo/env\n~~~\n\n最后再编辑$HOME/.cargo/config文件\n\n~~~\n[registry]\nindex = \"https://mirrors.ustc.edu.cn/crates.io-index/\"\n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'ustc'\n[source.ustc]\nregistry = \"https://mirrors.ustc.edu.cn/crates.io-index/\"\n~~~\n就大功告成啦，赶快写一个HelloWorld吧!\n","slug":"Mac下安装Rust","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoca002womoo4n42k9yh","content":"<p>本篇文章记录了我是如何在Mac下安装rust的过程.</p>\n<a id=\"more\"></a>\n<p>首先在你Shell的配置文件内加入下面两行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</span><br><span class=\"line\">export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br></pre></td></tr></table></figure>\n<p>然后打开终端，输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>\n<p>中间稍微等待一下，选择安装的方式即可。</p>\n<p>安装好后记得执行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source $HOME/.cargo/env</span><br></pre></td></tr></table></figure>\n<p>最后再编辑$HOME/.cargo/config文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[registry]</span><br><span class=\"line\">index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br><span class=\"line\">[source.crates-io]</span><br><span class=\"line\">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class=\"line\">replace-with = &apos;ustc&apos;</span><br><span class=\"line\">[source.ustc]</span><br><span class=\"line\">registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br></pre></td></tr></table></figure>\n<p>就大功告成啦，赶快写一个HelloWorld吧!</p>\n","site":{"data":{}},"excerpt":"<p>本篇文章记录了我是如何在Mac下安装rust的过程.</p>","more":"<p>首先在你Shell的配置文件内加入下面两行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</span><br><span class=\"line\">export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br></pre></td></tr></table></figure>\n<p>然后打开终端，输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>\n<p>中间稍微等待一下，选择安装的方式即可。</p>\n<p>安装好后记得执行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source $HOME/.cargo/env</span><br></pre></td></tr></table></figure>\n<p>最后再编辑$HOME/.cargo/config文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[registry]</span><br><span class=\"line\">index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br><span class=\"line\">[source.crates-io]</span><br><span class=\"line\">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class=\"line\">replace-with = &apos;ustc&apos;</span><br><span class=\"line\">[source.ustc]</span><br><span class=\"line\">registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br></pre></td></tr></table></figure>\n<p>就大功告成啦，赶快写一个HelloWorld吧!</p>"},{"title":"Mac下超好用的风扇控制与温度监控软件————TG Pro","copyright":true,"date":"2019-08-19T17:56:37.000Z","_content":"\n鸽了好久的一篇文章，今天把它补上。\n\n<!--more-->\n\n`TG Pro是一款Mac下用于检测温度以及控制风扇转速的优秀软件`\n\n我们先来看看软件本体是怎样的:\n\n![软件预览图01](Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png) \n![软件预览图02](Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png) \n\n是不是感觉硬件的所有信息都简单明了的展示出来了？\n\n我们还可以对软件进行一些设置。\n\n\n","source":"_posts/Mac下超好用的风扇控制与温度监控软件————TG-Pro.md","raw":"---\ntitle: Mac下超好用的风扇控制与温度监控软件————TG Pro\ncopyright: true\ndate: 2019-08-20 01:56:37\ncategories: 软件分享\ntags:\n  - 软件分享\n---\n\n鸽了好久的一篇文章，今天把它补上。\n\n<!--more-->\n\n`TG Pro是一款Mac下用于检测温度以及控制风扇转速的优秀软件`\n\n我们先来看看软件本体是怎样的:\n\n![软件预览图01](Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png) \n![软件预览图02](Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png) \n\n是不是感觉硬件的所有信息都简单明了的展示出来了？\n\n我们还可以对软件进行一些设置。\n\n\n","slug":"Mac下超好用的风扇控制与温度监控软件————TG-Pro","published":1,"updated":"2020-01-19T03:49:51.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoca002yomoo74w8m1zy","content":"<p>鸽了好久的一篇文章，今天把它补上。</p>\n<a id=\"more\"></a>\n<p><code>TG Pro是一款Mac下用于检测温度以及控制风扇转速的优秀软件</code></p>\n<p>我们先来看看软件本体是怎样的:</p>\n<p><img src=\"/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png\" alt=\"软件预览图01\"><br><img src=\"/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png\" alt=\"软件预览图02\"> </p>\n<p>是不是感觉硬件的所有信息都简单明了的展示出来了？</p>\n<p>我们还可以对软件进行一些设置。</p>\n","site":{"data":{}},"excerpt":"<p>鸽了好久的一篇文章，今天把它补上。</p>","more":"<p><code>TG Pro是一款Mac下用于检测温度以及控制风扇转速的优秀软件</code></p>\n<p>我们先来看看软件本体是怎样的:</p>\n<p><img src=\"/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png\" alt=\"软件预览图01\"><br><img src=\"/2019/08/20/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png\" alt=\"软件预览图02\"> </p>\n<p>是不是感觉硬件的所有信息都简单明了的展示出来了？</p>\n<p>我们还可以对软件进行一些设置。</p>"},{"title":"ManjaroLinuxTG讨论群组","copyright":true,"date":"2019-05-15T16:01:58.000Z","_content":"\n创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。\n\n# [点击加入](https://t.me/manjarozhihu)\n","source":"_posts/ManjaroLinuxTG讨论群组.md","raw":"---\ntitle: ManjaroLinuxTG讨论群组\ncopyright: true\ndate: 2019-05-16 00:01:58\ncategories: 分享\ntags:\n - Telegram\n - Linux\n---\n\n创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。\n\n# [点击加入](https://t.me/manjarozhihu)\n","slug":"ManjaroLinuxTG讨论群组","published":1,"updated":"2020-01-19T03:49:51.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocf0031omoohc1lti0e","content":"<p>创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。</p>\n<h1 id=\"点击加入\"><a href=\"#点击加入\" class=\"headerlink\" title=\"点击加入\"></a><a href=\"https://t.me/manjarozhihu\" target=\"_blank\" rel=\"noopener\">点击加入</a></h1>","site":{"data":{}},"excerpt":"","more":"<p>创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。</p>\n<h1 id=\"点击加入\"><a href=\"#点击加入\" class=\"headerlink\" title=\"点击加入\"></a><a href=\"https://t.me/manjarozhihu\" target=\"_blank\" rel=\"noopener\">点击加入</a></h1>"},{"title":"ManjaroLinux的安装过程","date":"2019-04-23T08:37:18.000Z","copyright":"truu","_content":"\n![桌面](ManjaroLinux的安装过程/桌面.png)\n\n## 获取镜像\nManjaroLinux官方提供了多个桌面环境的镜像，分别是:\n- XFCE \n\n特点\n\n> 系统资源低耗，快速\n\n- KDE\n\n特点\n\n> 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+\n\n- GNOME\n\n特点\n\n> 简单易用，可定制化，美化较为简单，内存占用大\n\n并且ManjaroLinux在国内有4个镜像源可选，分别是:\n- [清华大学](https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/)\n- [中科大](http://mirrors.ustc.edu.cn/manjaro-cd/)\n- [华为](https://mirrors.huaweicloud.com/manjaro-cd/)\n- [浙江大学](http://mirrors.zju.edu.cn/manjaro/)\n\n我们也可以直接使用官方的镜像源获取镜像[Manjaro](https://manjaro.org/get-manjaro/)\n\n选择好自己要使用的桌面环境就可以开始制作启动盘了。\n\n## 制作启动盘\n\n**Windows:**\n\n推荐使用[Rufus](https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe)进行制作启动盘。\n\n下载好后直接选择镜像和要进行制作的U盘，选择开始。\n\n**开始时会让你勾选制作方式请选择dd模式**\n\n---\n\n**Linux:**\n\n只需要执行这几条命令\n\n~~~shell\n$ sudo lsblk #列出系统上的所有磁盘\n~~~\n\n找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是**sdb或sda**\n\n如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.\n\n~~~shell\n$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，\n~~~\n\n取消挂载之后就可以进行格式化了.\n\n~~~shell\n$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.\n~~~\n\n格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.\n\n~~~shell\n$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda\n~~~\n\n如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。\n\n## 开始安装\n\n**最好是在网络稳定的环境下进行**\n\n### 第一步\n\n如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:\n\n![安装选择界面](ManjaroLinux的安装过程/安装选择界面.png)\n\n**keytable**————设置键盘布局\n\n通常默认即可\n\n**lang**————设置语言\n\n设置为zh_CN，代表汉语\n\n**driver**————设置使用的驱动是开源的还是不开源的\n\n笔记本双显卡，想省电可以用free。\n\n台式机单显卡，推荐nofree。\n\n**Boot**————选择这个就开始安装了\n\n### 第二步\n\n等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)\n\n![开始安装-01](ManjaroLinux的安装过程/开始安装.png)\n\n这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。\n\n标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。\n\n点击后还可以设置一次语言，默认为中文了\n\n然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。\n\n下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。\n\n再下一步就是分区了，这一步是挺重要的，请认真看。\n\n默认情况下有两种选项:\n\n**抹除磁盘**\n\n将磁盘全部数据清除，分区是Manjaro自动帮你分配的.\n\n这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。\n\n**手动分区**\n\n选择手动分区之后，你将看到:\n\n![分区](ManjaroLinux的安装过程/分区.png)\n\n如果你是单硬盘(也就是只有一个硬盘,mdzz)\n\n那比较简单(就算有多个也没啥)\n\n点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视...)\n\n然后就可以看到有一个空闲空间，选中它，然后可以看到**创建**按钮可以点击了\n\n然后你就点击吧...\n\n你就可以看到创建分区的窗口，我们要创建的分区是**根目录,主目录，引导**\n\n> 引导的挂载点: /boot/efi\n\n记得标记点为:boot 和 esp\n\n> 根目录的挂载点: /\n\n记得标记点为:root\n\n> 主目录的挂载点: /home\n\n![分区标识](ManjaroLinux的安装过程/分区标识.png)\n\n如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。\n\n要注意的是主目录要选择扩展分区。\n\n下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。\n\n- 用户名首字母不要大写\n\n- 密码不要太简单\n\n下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。\n\n![摘要](ManjaroLinux的安装过程/摘要.png)\n\n静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。\n\n## 设置镜像源\n\n选择一个好的源是使用Linux体验是否良好的一个重要因素。\n\n### 官方软件包源\n\n~~~shell\n$ sudo pacman-mirrors -i -c China -m rank\n$ sudo pacman -Syu\n~~~\n\n随便选一个就好，推荐中科大的(USTC).\n### Aur软件包源\n\n~~~shell\n$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi\n\n$ sudo pacman -Syu\n~~~\n\n在最后一行输入:\n\n~~~\n[archlinuxcn]\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n~~~\n\n安装签名\n\n~~~shell\n$ sudo pacman -S archlinuxcn-keyring\n~~~\n\n### npm国内源\n\n首先你得先下载npm和nodejs\n\n~~~shell\n$ sudo pacman -S npm nodejs\n~~~\n\n打开终端输入:\n\n~~~\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n测试是否成功:\n\n~~~\n$ npm config get registry\n~~~\n\n如果看到上面这个链接就对了\n\n### pip国内源\n\n修改~/.pip/pip.conf\n\n(没有则创建)\n\n修改为:\n~~~\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\n~~~\n\n你也可以使用其他的源\n\n[清华](https://pypi.tuna.tsinghua.edu.cn/simple)\n\n[阿里云](http://mirrors.aliyun.com/pypi/simple/)\n\n[中国科技大学](https://pypi.mirrors.ustc.edu.cn/simple/)\n\n[豆瓣](http://pypi.douban.com/simple/)\n\n## 安装软件\n\n首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库\n\nInstall Yay\n\n~~~shell\n$ sudo pacman -S yay\n~~~\n\n安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8\n\nInstall Vim\n\n~~~shell\n$ sudo pacman -S Vim\n~~~\n\nInstall VSCode\n\n~~~shell\n$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制\n~~~\n\nInstall OracleJDK8\n\n~~~shell\n$ yay -S jdk8 #这里就是由第三方打包了的\n~~~\n\nInstall 搜狗输入法\n\n~~~shell\n$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin\n~~~\n\n再编辑配置文件~/.xprofile(若没有创建即可)\n\n修改为:\n\n~~~\nexport GTK_IM_MODULE=fcitx\n\nexport QT_IM_MODULE=fcitx\n\nexport XMODIFIERS=\"@im=fcitx\"\n~~~\n\n注销后就能使用搜狗输入法了\n\nInstall IDEA\n\n~~~shell\n$ yay -S intellij-idea-community-edition #社区版 IDEA\n$ yay -S intellij-idea-ultimate-edition #付费版 IDEA\n~~~\n\nInstall CLion\n\n~~~shell\n$ yay -S CLion\n~~~\n\nInstall 网易云音乐\n\n~~~shell\n$ sudo pacman -S netease-cloud-music  \n~~~\n\nInstall Chrome\n\n~~~shell\n$ sudo pacman -S google-chrome\n~~~\n\n这样就能完成基本的日常使用啦~\n\n## 使用体验总结\n\n稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6->15.9.4 LinuxMint17 ArchLinux \n\n最终还是选择了Manjaro-kde\n\n非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。\n\n这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。\n\n![Manjaro安装过程编写文章时截图](ManjaroLinux的安装过程/编辑文章时截图.png)\n\n---\n","source":"_posts/ManjaroLinux的安装过程.md","raw":"---\ntitle: 'ManjaroLinux的安装过程'\ndate: 2019-04-23 16:37:18\ncategories: 学习笔记\ntags:\n  - Linux\n  - 折腾\n  - 软件使用\ncopyright: truu\n---\n\n![桌面](ManjaroLinux的安装过程/桌面.png)\n\n## 获取镜像\nManjaroLinux官方提供了多个桌面环境的镜像，分别是:\n- XFCE \n\n特点\n\n> 系统资源低耗，快速\n\n- KDE\n\n特点\n\n> 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+\n\n- GNOME\n\n特点\n\n> 简单易用，可定制化，美化较为简单，内存占用大\n\n并且ManjaroLinux在国内有4个镜像源可选，分别是:\n- [清华大学](https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/)\n- [中科大](http://mirrors.ustc.edu.cn/manjaro-cd/)\n- [华为](https://mirrors.huaweicloud.com/manjaro-cd/)\n- [浙江大学](http://mirrors.zju.edu.cn/manjaro/)\n\n我们也可以直接使用官方的镜像源获取镜像[Manjaro](https://manjaro.org/get-manjaro/)\n\n选择好自己要使用的桌面环境就可以开始制作启动盘了。\n\n## 制作启动盘\n\n**Windows:**\n\n推荐使用[Rufus](https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe)进行制作启动盘。\n\n下载好后直接选择镜像和要进行制作的U盘，选择开始。\n\n**开始时会让你勾选制作方式请选择dd模式**\n\n---\n\n**Linux:**\n\n只需要执行这几条命令\n\n~~~shell\n$ sudo lsblk #列出系统上的所有磁盘\n~~~\n\n找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是**sdb或sda**\n\n如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.\n\n~~~shell\n$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，\n~~~\n\n取消挂载之后就可以进行格式化了.\n\n~~~shell\n$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.\n~~~\n\n格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.\n\n~~~shell\n$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda\n~~~\n\n如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。\n\n## 开始安装\n\n**最好是在网络稳定的环境下进行**\n\n### 第一步\n\n如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:\n\n![安装选择界面](ManjaroLinux的安装过程/安装选择界面.png)\n\n**keytable**————设置键盘布局\n\n通常默认即可\n\n**lang**————设置语言\n\n设置为zh_CN，代表汉语\n\n**driver**————设置使用的驱动是开源的还是不开源的\n\n笔记本双显卡，想省电可以用free。\n\n台式机单显卡，推荐nofree。\n\n**Boot**————选择这个就开始安装了\n\n### 第二步\n\n等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)\n\n![开始安装-01](ManjaroLinux的安装过程/开始安装.png)\n\n这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。\n\n标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。\n\n点击后还可以设置一次语言，默认为中文了\n\n然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。\n\n下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。\n\n再下一步就是分区了，这一步是挺重要的，请认真看。\n\n默认情况下有两种选项:\n\n**抹除磁盘**\n\n将磁盘全部数据清除，分区是Manjaro自动帮你分配的.\n\n这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。\n\n**手动分区**\n\n选择手动分区之后，你将看到:\n\n![分区](ManjaroLinux的安装过程/分区.png)\n\n如果你是单硬盘(也就是只有一个硬盘,mdzz)\n\n那比较简单(就算有多个也没啥)\n\n点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视...)\n\n然后就可以看到有一个空闲空间，选中它，然后可以看到**创建**按钮可以点击了\n\n然后你就点击吧...\n\n你就可以看到创建分区的窗口，我们要创建的分区是**根目录,主目录，引导**\n\n> 引导的挂载点: /boot/efi\n\n记得标记点为:boot 和 esp\n\n> 根目录的挂载点: /\n\n记得标记点为:root\n\n> 主目录的挂载点: /home\n\n![分区标识](ManjaroLinux的安装过程/分区标识.png)\n\n如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。\n\n要注意的是主目录要选择扩展分区。\n\n下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。\n\n- 用户名首字母不要大写\n\n- 密码不要太简单\n\n下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。\n\n![摘要](ManjaroLinux的安装过程/摘要.png)\n\n静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。\n\n## 设置镜像源\n\n选择一个好的源是使用Linux体验是否良好的一个重要因素。\n\n### 官方软件包源\n\n~~~shell\n$ sudo pacman-mirrors -i -c China -m rank\n$ sudo pacman -Syu\n~~~\n\n随便选一个就好，推荐中科大的(USTC).\n### Aur软件包源\n\n~~~shell\n$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi\n\n$ sudo pacman -Syu\n~~~\n\n在最后一行输入:\n\n~~~\n[archlinuxcn]\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n~~~\n\n安装签名\n\n~~~shell\n$ sudo pacman -S archlinuxcn-keyring\n~~~\n\n### npm国内源\n\n首先你得先下载npm和nodejs\n\n~~~shell\n$ sudo pacman -S npm nodejs\n~~~\n\n打开终端输入:\n\n~~~\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n测试是否成功:\n\n~~~\n$ npm config get registry\n~~~\n\n如果看到上面这个链接就对了\n\n### pip国内源\n\n修改~/.pip/pip.conf\n\n(没有则创建)\n\n修改为:\n~~~\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\n~~~\n\n你也可以使用其他的源\n\n[清华](https://pypi.tuna.tsinghua.edu.cn/simple)\n\n[阿里云](http://mirrors.aliyun.com/pypi/simple/)\n\n[中国科技大学](https://pypi.mirrors.ustc.edu.cn/simple/)\n\n[豆瓣](http://pypi.douban.com/simple/)\n\n## 安装软件\n\n首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库\n\nInstall Yay\n\n~~~shell\n$ sudo pacman -S yay\n~~~\n\n安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8\n\nInstall Vim\n\n~~~shell\n$ sudo pacman -S Vim\n~~~\n\nInstall VSCode\n\n~~~shell\n$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制\n~~~\n\nInstall OracleJDK8\n\n~~~shell\n$ yay -S jdk8 #这里就是由第三方打包了的\n~~~\n\nInstall 搜狗输入法\n\n~~~shell\n$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin\n~~~\n\n再编辑配置文件~/.xprofile(若没有创建即可)\n\n修改为:\n\n~~~\nexport GTK_IM_MODULE=fcitx\n\nexport QT_IM_MODULE=fcitx\n\nexport XMODIFIERS=\"@im=fcitx\"\n~~~\n\n注销后就能使用搜狗输入法了\n\nInstall IDEA\n\n~~~shell\n$ yay -S intellij-idea-community-edition #社区版 IDEA\n$ yay -S intellij-idea-ultimate-edition #付费版 IDEA\n~~~\n\nInstall CLion\n\n~~~shell\n$ yay -S CLion\n~~~\n\nInstall 网易云音乐\n\n~~~shell\n$ sudo pacman -S netease-cloud-music  \n~~~\n\nInstall Chrome\n\n~~~shell\n$ sudo pacman -S google-chrome\n~~~\n\n这样就能完成基本的日常使用啦~\n\n## 使用体验总结\n\n稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6->15.9.4 LinuxMint17 ArchLinux \n\n最终还是选择了Manjaro-kde\n\n非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。\n\n这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。\n\n![Manjaro安装过程编写文章时截图](ManjaroLinux的安装过程/编辑文章时截图.png)\n\n---\n","slug":"ManjaroLinux的安装过程","published":1,"updated":"2020-01-19T03:49:51.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocg0035omootchc9fa9","content":"<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/桌面.png\" alt=\"桌面\"></p>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p>\n<ul>\n<li>XFCE </li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>系统资源低耗，快速</p>\n</blockquote>\n<ul>\n<li>KDE</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p>\n</blockquote>\n<ul>\n<li>GNOME</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>简单易用，可定制化，美化较为简单，内存占用大</p>\n</blockquote>\n<p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p>\n<ul>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">清华大学</a></li>\n<li><a href=\"http://mirrors.ustc.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">中科大</a></li>\n<li><a href=\"https://mirrors.huaweicloud.com/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">华为</a></li>\n<li><a href=\"http://mirrors.zju.edu.cn/manjaro/\" target=\"_blank\" rel=\"noopener\">浙江大学</a></li>\n</ul>\n<p>我们也可以直接使用官方的镜像源获取镜像<a href=\"https://manjaro.org/get-manjaro/\" target=\"_blank\" rel=\"noopener\">Manjaro</a></p>\n<p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p>\n<h2 id=\"制作启动盘\"><a href=\"#制作启动盘\" class=\"headerlink\" title=\"制作启动盘\"></a>制作启动盘</h2><p><strong>Windows:</strong></p>\n<p>推荐使用<a href=\"https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe\" target=\"_blank\" rel=\"noopener\">Rufus</a>进行制作启动盘。</p>\n<p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p>\n<p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p>\n<hr>\n<p><strong>Linux:</strong></p>\n<p>只需要执行这几条命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure>\n<p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p>\n<p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure>\n<p>取消挂载之后就可以进行格式化了.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure>\n<p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure>\n<p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png\" alt=\"安装选择界面\"></p>\n<p><strong>keytable</strong>————设置键盘布局</p>\n<p>通常默认即可</p>\n<p><strong>lang</strong>————设置语言</p>\n<p>设置为zh_CN，代表汉语</p>\n<p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p>\n<p>笔记本双显卡，想省电可以用free。</p>\n<p>台式机单显卡，推荐nofree。</p>\n<p><strong>Boot</strong>————选择这个就开始安装了</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/开始安装.png\" alt=\"开始安装-01\"></p>\n<p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p>\n<p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p>\n<p>点击后还可以设置一次语言，默认为中文了</p>\n<p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p>\n<p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p>\n<p>再下一步就是分区了，这一步是挺重要的，请认真看。</p>\n<p>默认情况下有两种选项:</p>\n<p><strong>抹除磁盘</strong></p>\n<p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p>\n<p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p>\n<p><strong>手动分区</strong></p>\n<p>选择手动分区之后，你将看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区.png\" alt=\"分区\"></p>\n<p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p>\n<p>那比较简单(就算有多个也没啥)</p>\n<p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p>\n<p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p>\n<p>然后你就点击吧…</p>\n<p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p>\n<blockquote>\n<p>引导的挂载点: /boot/efi</p>\n</blockquote>\n<p>记得标记点为:boot 和 esp</p>\n<blockquote>\n<p>根目录的挂载点: /</p>\n</blockquote>\n<p>记得标记点为:root</p>\n<blockquote>\n<p>主目录的挂载点: /home</p>\n</blockquote>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区标识.png\" alt=\"分区标识\"></p>\n<p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p>\n<p>要注意的是主目录要选择扩展分区。</p>\n<p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p>\n<ul>\n<li><p>用户名首字母不要大写</p>\n</li>\n<li><p>密码不要太简单</p>\n</li>\n</ul>\n<p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/摘要.png\" alt=\"摘要\"></p>\n<p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p>\n<h2 id=\"设置镜像源\"><a href=\"#设置镜像源\" class=\"headerlink\" title=\"设置镜像源\"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p>\n<h3 id=\"官方软件包源\"><a href=\"#官方软件包源\" class=\"headerlink\" title=\"官方软件包源\"></a>官方软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>随便选一个就好，推荐中科大的(USTC).</p>\n<h3 id=\"Aur软件包源\"><a href=\"#Aur软件包源\" class=\"headerlink\" title=\"Aur软件包源\"></a>Aur软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>在最后一行输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>\n<p>安装签名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>\n<h3 id=\"npm国内源\"><a href=\"#npm国内源\" class=\"headerlink\" title=\"npm国内源\"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure>\n<p>打开终端输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>测试是否成功:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config get registry</span><br></pre></td></tr></table></figure>\n<p>如果看到上面这个链接就对了</p>\n<h3 id=\"pip国内源\"><a href=\"#pip国内源\" class=\"headerlink\" title=\"pip国内源\"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p>\n<p>(没有则创建)</p>\n<p>修改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p>\n<p>你也可以使用其他的源</p>\n<p><a href=\"https://pypi.tuna.tsinghua.edu.cn/simple\" target=\"_blank\" rel=\"noopener\">清华</a></p>\n<p><a href=\"http://mirrors.aliyun.com/pypi/simple/\" target=\"_blank\" rel=\"noopener\">阿里云</a></p>\n<p><a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\" target=\"_blank\" rel=\"noopener\">中国科技大学</a></p>\n<p><a href=\"http://pypi.douban.com/simple/\" target=\"_blank\" rel=\"noopener\">豆瓣</a></p>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p>\n<p>Install Yay</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure>\n<p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p>\n<p>Install Vim</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure>\n<p>Install VSCode</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure>\n<p>Install OracleJDK8</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure>\n<p>Install 搜狗输入法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure>\n<p>再编辑配置文件~/.xprofile(若没有创建即可)</p>\n<p>修改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>\n<p>注销后就能使用搜狗输入法了</p>\n<p>Install IDEA</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure>\n<p>Install CLion</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S CLion</span><br></pre></td></tr></table></figure>\n<p>Install 网易云音乐</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure>\n<p>Install Chrome</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure>\n<p>这样就能完成基本的日常使用啦~</p>\n<h2 id=\"使用体验总结\"><a href=\"#使用体验总结\" class=\"headerlink\" title=\"使用体验总结\"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p>\n<p>最终还是选择了Manjaro-kde</p>\n<p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p>\n<p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png\" alt=\"Manjaro安装过程编写文章时截图\"></p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/桌面.png\" alt=\"桌面\"></p>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p>\n<ul>\n<li>XFCE </li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>系统资源低耗，快速</p>\n</blockquote>\n<ul>\n<li>KDE</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p>\n</blockquote>\n<ul>\n<li>GNOME</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>简单易用，可定制化，美化较为简单，内存占用大</p>\n</blockquote>\n<p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p>\n<ul>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">清华大学</a></li>\n<li><a href=\"http://mirrors.ustc.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">中科大</a></li>\n<li><a href=\"https://mirrors.huaweicloud.com/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">华为</a></li>\n<li><a href=\"http://mirrors.zju.edu.cn/manjaro/\" target=\"_blank\" rel=\"noopener\">浙江大学</a></li>\n</ul>\n<p>我们也可以直接使用官方的镜像源获取镜像<a href=\"https://manjaro.org/get-manjaro/\" target=\"_blank\" rel=\"noopener\">Manjaro</a></p>\n<p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p>\n<h2 id=\"制作启动盘\"><a href=\"#制作启动盘\" class=\"headerlink\" title=\"制作启动盘\"></a>制作启动盘</h2><p><strong>Windows:</strong></p>\n<p>推荐使用<a href=\"https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe\" target=\"_blank\" rel=\"noopener\">Rufus</a>进行制作启动盘。</p>\n<p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p>\n<p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p>\n<hr>\n<p><strong>Linux:</strong></p>\n<p>只需要执行这几条命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure>\n<p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p>\n<p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure>\n<p>取消挂载之后就可以进行格式化了.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure>\n<p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure>\n<p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png\" alt=\"安装选择界面\"></p>\n<p><strong>keytable</strong>————设置键盘布局</p>\n<p>通常默认即可</p>\n<p><strong>lang</strong>————设置语言</p>\n<p>设置为zh_CN，代表汉语</p>\n<p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p>\n<p>笔记本双显卡，想省电可以用free。</p>\n<p>台式机单显卡，推荐nofree。</p>\n<p><strong>Boot</strong>————选择这个就开始安装了</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/开始安装.png\" alt=\"开始安装-01\"></p>\n<p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p>\n<p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p>\n<p>点击后还可以设置一次语言，默认为中文了</p>\n<p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p>\n<p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p>\n<p>再下一步就是分区了，这一步是挺重要的，请认真看。</p>\n<p>默认情况下有两种选项:</p>\n<p><strong>抹除磁盘</strong></p>\n<p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p>\n<p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p>\n<p><strong>手动分区</strong></p>\n<p>选择手动分区之后，你将看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区.png\" alt=\"分区\"></p>\n<p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p>\n<p>那比较简单(就算有多个也没啥)</p>\n<p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p>\n<p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p>\n<p>然后你就点击吧…</p>\n<p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p>\n<blockquote>\n<p>引导的挂载点: /boot/efi</p>\n</blockquote>\n<p>记得标记点为:boot 和 esp</p>\n<blockquote>\n<p>根目录的挂载点: /</p>\n</blockquote>\n<p>记得标记点为:root</p>\n<blockquote>\n<p>主目录的挂载点: /home</p>\n</blockquote>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区标识.png\" alt=\"分区标识\"></p>\n<p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p>\n<p>要注意的是主目录要选择扩展分区。</p>\n<p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p>\n<ul>\n<li><p>用户名首字母不要大写</p>\n</li>\n<li><p>密码不要太简单</p>\n</li>\n</ul>\n<p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/摘要.png\" alt=\"摘要\"></p>\n<p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p>\n<h2 id=\"设置镜像源\"><a href=\"#设置镜像源\" class=\"headerlink\" title=\"设置镜像源\"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p>\n<h3 id=\"官方软件包源\"><a href=\"#官方软件包源\" class=\"headerlink\" title=\"官方软件包源\"></a>官方软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>随便选一个就好，推荐中科大的(USTC).</p>\n<h3 id=\"Aur软件包源\"><a href=\"#Aur软件包源\" class=\"headerlink\" title=\"Aur软件包源\"></a>Aur软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>在最后一行输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>\n<p>安装签名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>\n<h3 id=\"npm国内源\"><a href=\"#npm国内源\" class=\"headerlink\" title=\"npm国内源\"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure>\n<p>打开终端输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>测试是否成功:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config get registry</span><br></pre></td></tr></table></figure>\n<p>如果看到上面这个链接就对了</p>\n<h3 id=\"pip国内源\"><a href=\"#pip国内源\" class=\"headerlink\" title=\"pip国内源\"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p>\n<p>(没有则创建)</p>\n<p>修改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p>\n<p>你也可以使用其他的源</p>\n<p><a href=\"https://pypi.tuna.tsinghua.edu.cn/simple\" target=\"_blank\" rel=\"noopener\">清华</a></p>\n<p><a href=\"http://mirrors.aliyun.com/pypi/simple/\" target=\"_blank\" rel=\"noopener\">阿里云</a></p>\n<p><a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\" target=\"_blank\" rel=\"noopener\">中国科技大学</a></p>\n<p><a href=\"http://pypi.douban.com/simple/\" target=\"_blank\" rel=\"noopener\">豆瓣</a></p>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p>\n<p>Install Yay</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure>\n<p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p>\n<p>Install Vim</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure>\n<p>Install VSCode</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure>\n<p>Install OracleJDK8</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure>\n<p>Install 搜狗输入法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure>\n<p>再编辑配置文件~/.xprofile(若没有创建即可)</p>\n<p>修改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>\n<p>注销后就能使用搜狗输入法了</p>\n<p>Install IDEA</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure>\n<p>Install CLion</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S CLion</span><br></pre></td></tr></table></figure>\n<p>Install 网易云音乐</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure>\n<p>Install Chrome</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure>\n<p>这样就能完成基本的日常使用啦~</p>\n<h2 id=\"使用体验总结\"><a href=\"#使用体验总结\" class=\"headerlink\" title=\"使用体验总结\"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p>\n<p>最终还是选择了Manjaro-kde</p>\n<p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p>\n<p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png\" alt=\"Manjaro安装过程编写文章时截图\"></p>\n<hr>\n"},{"title":"My-Monitor","copyright":true,"date":"2019-07-20T14:10:55.000Z","_content":"\nI had been trying to write an article about the monitor a few days ago, and tooday i finally __realized__.\n\n<!--more-->\n\n&emsp;I __met__ the monitor in 2015,When we were both __junior three students__.,Because I __dropped out__ of junior high school, I had __little contact__ with her in the __previous__ few years.__Probably__ since I went to college.I have __occasional__ contact with the monitor __who was about to face__ the college __entrance examination__ talked to me a lot about my school and her views. I also expressed my point of view, and we __exchanged__ our thoughts about life.\n\n&emsp;More and more, I feel that the monitor is more and more interesting. Many of her views are __similar__ to mine.We sometimes talk for a long time and forget the time.But our __relationship__ is still a friend.\n\n&emsp;__Towards the end of my freshman year__,my __relationship__ with the monitor changed __dramatically__,Which is why I wrote an article about the monitor.On a very normal day,the monitory __suddenly__ came to me and said that she wanted to come to my university,because my university is a __higher ranking__ university in Guangdong.Kind of me,__carefully__ answered some questions for her, and said that I really want to talk with the monitor of a university,I talk with the monitor more and more.We talk a lot to each other,whether it's about life,learning or even the future.\n\n&emsp;Gradually,I fell in love with the monitor.From the first time I sent a photo to her,to the first time I sent a video to her,I knew that I had __fallen__ in love with her.\n\n&emsp;I like the monitor's voice,her attitude when talking,her eyes,some of her little jokes,some of her small shortcomins,like all of her.Now that I have __identified__ everything. I will say to her __personally__ when I return to Guangzhou,\"I love you,my monitor.\"\n\n","source":"_posts/My-Monitor.md","raw":"---\ntitle: My-Monitor\ncopyright: true\ndate: 2019-07-20 22:10:55\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\nI had been trying to write an article about the monitor a few days ago, and tooday i finally __realized__.\n\n<!--more-->\n\n&emsp;I __met__ the monitor in 2015,When we were both __junior three students__.,Because I __dropped out__ of junior high school, I had __little contact__ with her in the __previous__ few years.__Probably__ since I went to college.I have __occasional__ contact with the monitor __who was about to face__ the college __entrance examination__ talked to me a lot about my school and her views. I also expressed my point of view, and we __exchanged__ our thoughts about life.\n\n&emsp;More and more, I feel that the monitor is more and more interesting. Many of her views are __similar__ to mine.We sometimes talk for a long time and forget the time.But our __relationship__ is still a friend.\n\n&emsp;__Towards the end of my freshman year__,my __relationship__ with the monitor changed __dramatically__,Which is why I wrote an article about the monitor.On a very normal day,the monitory __suddenly__ came to me and said that she wanted to come to my university,because my university is a __higher ranking__ university in Guangdong.Kind of me,__carefully__ answered some questions for her, and said that I really want to talk with the monitor of a university,I talk with the monitor more and more.We talk a lot to each other,whether it's about life,learning or even the future.\n\n&emsp;Gradually,I fell in love with the monitor.From the first time I sent a photo to her,to the first time I sent a video to her,I knew that I had __fallen__ in love with her.\n\n&emsp;I like the monitor's voice,her attitude when talking,her eyes,some of her little jokes,some of her small shortcomins,like all of her.Now that I have __identified__ everything. I will say to her __personally__ when I return to Guangzhou,\"I love you,my monitor.\"\n\n","slug":"My-Monitor","published":1,"updated":"2020-01-19T03:49:51.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocg0038omoo0rpck07a","content":"<p>I had been trying to write an article about the monitor a few days ago, and tooday i finally <strong>realized</strong>.</p>\n<a id=\"more\"></a>\n<p>&emsp;I <strong>met</strong> the monitor in 2015,When we were both <strong>junior three students</strong>.,Because I <strong>dropped out</strong> of junior high school, I had <strong>little contact</strong> with her in the <strong>previous</strong> few years.<strong>Probably</strong> since I went to college.I have <strong>occasional</strong> contact with the monitor <strong>who was about to face</strong> the college <strong>entrance examination</strong> talked to me a lot about my school and her views. I also expressed my point of view, and we <strong>exchanged</strong> our thoughts about life.</p>\n<p>&emsp;More and more, I feel that the monitor is more and more interesting. Many of her views are <strong>similar</strong> to mine.We sometimes talk for a long time and forget the time.But our <strong>relationship</strong> is still a friend.</p>\n<p>&emsp;<strong>Towards the end of my freshman year</strong>,my <strong>relationship</strong> with the monitor changed <strong>dramatically</strong>,Which is why I wrote an article about the monitor.On a very normal day,the monitory <strong>suddenly</strong> came to me and said that she wanted to come to my university,because my university is a <strong>higher ranking</strong> university in Guangdong.Kind of me,<strong>carefully</strong> answered some questions for her, and said that I really want to talk with the monitor of a university,I talk with the monitor more and more.We talk a lot to each other,whether it’s about life,learning or even the future.</p>\n<p>&emsp;Gradually,I fell in love with the monitor.From the first time I sent a photo to her,to the first time I sent a video to her,I knew that I had <strong>fallen</strong> in love with her.</p>\n<p>&emsp;I like the monitor’s voice,her attitude when talking,her eyes,some of her little jokes,some of her small shortcomins,like all of her.Now that I have <strong>identified</strong> everything. I will say to her <strong>personally</strong> when I return to Guangzhou,”I love you,my monitor.”</p>\n","site":{"data":{}},"excerpt":"<p>I had been trying to write an article about the monitor a few days ago, and tooday i finally <strong>realized</strong>.</p>","more":"<p>&emsp;I <strong>met</strong> the monitor in 2015,When we were both <strong>junior three students</strong>.,Because I <strong>dropped out</strong> of junior high school, I had <strong>little contact</strong> with her in the <strong>previous</strong> few years.<strong>Probably</strong> since I went to college.I have <strong>occasional</strong> contact with the monitor <strong>who was about to face</strong> the college <strong>entrance examination</strong> talked to me a lot about my school and her views. I also expressed my point of view, and we <strong>exchanged</strong> our thoughts about life.</p>\n<p>&emsp;More and more, I feel that the monitor is more and more interesting. Many of her views are <strong>similar</strong> to mine.We sometimes talk for a long time and forget the time.But our <strong>relationship</strong> is still a friend.</p>\n<p>&emsp;<strong>Towards the end of my freshman year</strong>,my <strong>relationship</strong> with the monitor changed <strong>dramatically</strong>,Which is why I wrote an article about the monitor.On a very normal day,the monitory <strong>suddenly</strong> came to me and said that she wanted to come to my university,because my university is a <strong>higher ranking</strong> university in Guangdong.Kind of me,<strong>carefully</strong> answered some questions for her, and said that I really want to talk with the monitor of a university,I talk with the monitor more and more.We talk a lot to each other,whether it’s about life,learning or even the future.</p>\n<p>&emsp;Gradually,I fell in love with the monitor.From the first time I sent a photo to her,to the first time I sent a video to her,I knew that I had <strong>fallen</strong> in love with her.</p>\n<p>&emsp;I like the monitor’s voice,her attitude when talking,her eyes,some of her little jokes,some of her small shortcomins,like all of her.Now that I have <strong>identified</strong> everything. I will say to her <strong>personally</strong> when I return to Guangzhou,”I love you,my monitor.”</p>"},{"title":"MyCollegeLife","copyright":true,"date":"2019-07-05T13:00:15.000Z","_content":"\n&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,__day and night accompany friend__.Of course,__including you__.\n\n&emsp;Three years after,I become a __college__ student，Maybe you guessed this __article__ is about my college life.About at 2019-9-1 start my college lift.I think I have very __excited__ at that time.\n\n&emsp;Before school start，I __participate in__ __Military training__.Remember that time ,about one hundred peoples __trained__ in a groups together,Instructor look we are tired,then he will say:\"Everyboby listen! Drop Down!\"，__In the twinkling of an eye__ one hundred peoples on the ground __lie__.This time nobody care isn't dirty，just look the sky，think，THE SKY SO BEATUIFUL.\n\n&emsp;__The fight of time__，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know's friend add WeChat Friend，Of course，me too.\n\n&emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It's because he teach for me so many __knowledge__.\n\n&emsp;At the last，I __sincerely__ thank my instructor，Peace!\n","source":"_posts/MyCollegeLife.md","raw":"---\ntitle: MyCollegeLife\ncopyright: true\ndate: 2019-07-05 21:00:15\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\n&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,__day and night accompany friend__.Of course,__including you__.\n\n&emsp;Three years after,I become a __college__ student，Maybe you guessed this __article__ is about my college life.About at 2019-9-1 start my college lift.I think I have very __excited__ at that time.\n\n&emsp;Before school start，I __participate in__ __Military training__.Remember that time ,about one hundred peoples __trained__ in a groups together,Instructor look we are tired,then he will say:\"Everyboby listen! Drop Down!\"，__In the twinkling of an eye__ one hundred peoples on the ground __lie__.This time nobody care isn't dirty，just look the sky，think，THE SKY SO BEATUIFUL.\n\n&emsp;__The fight of time__，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know's friend add WeChat Friend，Of course，me too.\n\n&emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It's because he teach for me so many __knowledge__.\n\n&emsp;At the last，I __sincerely__ thank my instructor，Peace!\n","slug":"MyCollegeLife","published":1,"updated":"2020-01-19T03:49:51.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoch003aomoo7bd461du","content":"<p>&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,<strong>day and night accompany friend</strong>.Of course,<strong>including you</strong>.</p>\n<p>&emsp;Three years after,I become a <strong>college</strong> student，Maybe you guessed this <strong>article</strong> is about my college life.About at 2019-9-1 start my college lift.I think I have very <strong>excited</strong> at that time.</p>\n<p>&emsp;Before school start，I <strong>participate in</strong> <strong>Military training</strong>.Remember that time ,about one hundred peoples <strong>trained</strong> in a groups together,Instructor look we are tired,then he will say:”Everyboby listen! Drop Down!”，<strong>In the twinkling of an eye</strong> one hundred peoples on the ground <strong>lie</strong>.This time nobody care isn’t dirty，just look the sky，think，THE SKY SO BEATUIFUL.</p>\n<p>&emsp;<strong>The fight of time</strong>，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know’s friend add WeChat Friend，Of course，me too.</p>\n<p>&emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It’s because he teach for me so many <strong>knowledge</strong>.</p>\n<p>&emsp;At the last，I <strong>sincerely</strong> thank my instructor，Peace!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,<strong>day and night accompany friend</strong>.Of course,<strong>including you</strong>.</p>\n<p>&emsp;Three years after,I become a <strong>college</strong> student，Maybe you guessed this <strong>article</strong> is about my college life.About at 2019-9-1 start my college lift.I think I have very <strong>excited</strong> at that time.</p>\n<p>&emsp;Before school start，I <strong>participate in</strong> <strong>Military training</strong>.Remember that time ,about one hundred peoples <strong>trained</strong> in a groups together,Instructor look we are tired,then he will say:”Everyboby listen! Drop Down!”，<strong>In the twinkling of an eye</strong> one hundred peoples on the ground <strong>lie</strong>.This time nobody care isn’t dirty，just look the sky，think，THE SKY SO BEATUIFUL.</p>\n<p>&emsp;<strong>The fight of time</strong>，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know’s friend add WeChat Friend，Of course，me too.</p>\n<p>&emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It’s because he teach for me so many <strong>knowledge</strong>.</p>\n<p>&emsp;At the last，I <strong>sincerely</strong> thank my instructor，Peace!</p>\n"},{"title":"MyCuteSister-0","copyright":true,"date":"2019-07-08T16:55:53.000Z","_content":"\nLast article is so bad,so this article i want is not bad.\n\n<!--more-->\n\n&emsp;I have a young sister,she is so cute and pretty.Now I will introduce her.Ok let's do it.\n\nShe have a black long hair,and clear and shinning eyes.When she lie on soft reading books，I always think she so beatuiful and cute.At this point,I will ask her,what book are reading? then she always say cartoon book,At this point,I say,Why you read cartoon book? She say,because i like it.\n\nLet's talk about she's not good,also many children's problems.It picky eaters,such as,she __dislike eggplant__，I tell her do not picky eaters,she say ok.\n\n\n\n","source":"_posts/MyCuteSister-0.md","raw":"---\ntitle: MyCuteSister-0\ncopyright: true\ndate: 2019-07-09 00:55:53\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\nLast article is so bad,so this article i want is not bad.\n\n<!--more-->\n\n&emsp;I have a young sister,she is so cute and pretty.Now I will introduce her.Ok let's do it.\n\nShe have a black long hair,and clear and shinning eyes.When she lie on soft reading books，I always think she so beatuiful and cute.At this point,I will ask her,what book are reading? then she always say cartoon book,At this point,I say,Why you read cartoon book? She say,because i like it.\n\nLet's talk about she's not good,also many children's problems.It picky eaters,such as,she __dislike eggplant__，I tell her do not picky eaters,she say ok.\n\n\n\n","slug":"MyCuteSister-0","published":1,"updated":"2020-01-19T03:49:51.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoci003eomoo9xxkm97y","content":"<p>Last article is so bad,so this article i want is not bad.</p>\n<a id=\"more\"></a>\n<p>&emsp;I have a young sister,she is so cute and pretty.Now I will introduce her.Ok let’s do it.</p>\n<p>She have a black long hair,and clear and shinning eyes.When she lie on soft reading books，I always think she so beatuiful and cute.At this point,I will ask her,what book are reading? then she always say cartoon book,At this point,I say,Why you read cartoon book? She say,because i like it.</p>\n<p>Let’s talk about she’s not good,also many children’s problems.It picky eaters,such as,she <strong>dislike eggplant</strong>，I tell her do not picky eaters,she say ok.</p>\n","site":{"data":{}},"excerpt":"<p>Last article is so bad,so this article i want is not bad.</p>","more":"<p>&emsp;I have a young sister,she is so cute and pretty.Now I will introduce her.Ok let’s do it.</p>\n<p>She have a black long hair,and clear and shinning eyes.When she lie on soft reading books，I always think she so beatuiful and cute.At this point,I will ask her,what book are reading? then she always say cartoon book,At this point,I say,Why you read cartoon book? She say,because i like it.</p>\n<p>Let’s talk about she’s not good,also many children’s problems.It picky eaters,such as,she <strong>dislike eggplant</strong>，I tell her do not picky eaters,she say ok.</p>"},{"title":"MyCuteSister-1","copyright":true,"date":"2019-07-09T16:10:29.000Z","_content":"\nThe article is the next article of \"MyCuteSister\".\n\n<!--more-->\n\n&emsp;Next article we talk about my sister something not bad and she's appearance,this article let's we talk about she's school work.\n\n&emsp;My sister is seven years old,she __attended Maria Kindergarten__ in GuangZhou.When she was a kindergraten student,she was excellent.She often become monitor of class.\n\n&emsp;She __can also__ draw.Since she attended kindergraten,almost every week draw a works,__So for__ about two hundred draw works stayed we home.\n\n&emsp;She __can also__ dance.She use weekend time learn dance,Since she can't __back bend__,__thwart split__ to be dance a complete dance.And She often join Kindergraten activites,__Our whole famliy is proud for her__.\n\n&emsp;By the way,She can also play the piano,__Whennever I am bored__.I watch the video of her playing the piano,Which make me feel better immediately.\n\n&emsp;She will become a __Primary Student__,Because she went up THE AFFILIATED SCHOOL OF GUANGDONG UNIVERSITY OF FOREIGN STUDIES,Bug she need stay at school,I think I will very miss her.\n\n&esp;This is my sister,And I LOVE HER.\n","source":"_posts/MyCuteSister-1.md","raw":"---\ntitle: MyCuteSister-1\ncopyright: true\ndate: 2019-07-10 00:10:29\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\nThe article is the next article of \"MyCuteSister\".\n\n<!--more-->\n\n&emsp;Next article we talk about my sister something not bad and she's appearance,this article let's we talk about she's school work.\n\n&emsp;My sister is seven years old,she __attended Maria Kindergarten__ in GuangZhou.When she was a kindergraten student,she was excellent.She often become monitor of class.\n\n&emsp;She __can also__ draw.Since she attended kindergraten,almost every week draw a works,__So for__ about two hundred draw works stayed we home.\n\n&emsp;She __can also__ dance.She use weekend time learn dance,Since she can't __back bend__,__thwart split__ to be dance a complete dance.And She often join Kindergraten activites,__Our whole famliy is proud for her__.\n\n&emsp;By the way,She can also play the piano,__Whennever I am bored__.I watch the video of her playing the piano,Which make me feel better immediately.\n\n&emsp;She will become a __Primary Student__,Because she went up THE AFFILIATED SCHOOL OF GUANGDONG UNIVERSITY OF FOREIGN STUDIES,Bug she need stay at school,I think I will very miss her.\n\n&esp;This is my sister,And I LOVE HER.\n","slug":"MyCuteSister-1","published":1,"updated":"2020-01-19T03:49:51.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocj003homooub6a09tl","content":"<p>The article is the next article of “MyCuteSister”.</p>\n<a id=\"more\"></a>\n<p>&emsp;Next article we talk about my sister something not bad and she’s appearance,this article let’s we talk about she’s school work.</p>\n<p>&emsp;My sister is seven years old,she <strong>attended Maria Kindergarten</strong> in GuangZhou.When she was a kindergraten student,she was excellent.She often become monitor of class.</p>\n<p>&emsp;She <strong>can also</strong> draw.Since she attended kindergraten,almost every week draw a works,<strong>So for</strong> about two hundred draw works stayed we home.</p>\n<p>&emsp;She <strong>can also</strong> dance.She use weekend time learn dance,Since she can’t <strong>back bend</strong>,<strong>thwart split</strong> to be dance a complete dance.And She often join Kindergraten activites,<strong>Our whole famliy is proud for her</strong>.</p>\n<p>&emsp;By the way,She can also play the piano,<strong>Whennever I am bored</strong>.I watch the video of her playing the piano,Which make me feel better immediately.</p>\n<p>&emsp;She will become a <strong>Primary Student</strong>,Because she went up THE AFFILIATED SCHOOL OF GUANGDONG UNIVERSITY OF FOREIGN STUDIES,Bug she need stay at school,I think I will very miss her.</p>\n<p>&esp;This is my sister,And I LOVE HER.</p>\n","site":{"data":{}},"excerpt":"<p>The article is the next article of “MyCuteSister”.</p>","more":"<p>&emsp;Next article we talk about my sister something not bad and she’s appearance,this article let’s we talk about she’s school work.</p>\n<p>&emsp;My sister is seven years old,she <strong>attended Maria Kindergarten</strong> in GuangZhou.When she was a kindergraten student,she was excellent.She often become monitor of class.</p>\n<p>&emsp;She <strong>can also</strong> draw.Since she attended kindergraten,almost every week draw a works,<strong>So for</strong> about two hundred draw works stayed we home.</p>\n<p>&emsp;She <strong>can also</strong> dance.She use weekend time learn dance,Since she can’t <strong>back bend</strong>,<strong>thwart split</strong> to be dance a complete dance.And She often join Kindergraten activites,<strong>Our whole famliy is proud for her</strong>.</p>\n<p>&emsp;By the way,She can also play the piano,<strong>Whennever I am bored</strong>.I watch the video of her playing the piano,Which make me feel better immediately.</p>\n<p>&emsp;She will become a <strong>Primary Student</strong>,Because she went up THE AFFILIATED SCHOOL OF GUANGDONG UNIVERSITY OF FOREIGN STUDIES,Bug she need stay at school,I think I will very miss her.</p>\n<p>&esp;This is my sister,And I LOVE HER.</p>"},{"title":"ProxyChains入门使用教程","copyright":true,"date":"2020-01-07T08:59:41.000Z","comments":1,"_content":"\n身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工\n具。\n<!--more-->\n\n# ArchLinux\n\nArch下直接安装`ProxyChains-ng`这个包即可。\n\n``` shell\nsudo pacman -S proxychains-ng\n```\n\n安装好后编辑`/etc/proxychains.conf`。\n\n找到最下面的`[ProxyList]`，往里面添加映射的类型，例如我想要`http`协议走代理就可\n以这么写。\n\n``` conf\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to \"tor\"\nhttp \t127.0.0.1 8000\n# socks5 127.0.0.1 1080\n```\n\n使用非常简单，可以直接在需要走代理的程序前加上`proxychains`即可。\n\n``` shell\n➜  ~ proxychains curl google.com\n[proxychains] config file found: /etc/proxychains.conf\n[proxychains] preloading /usr/lib/libproxychains4.so\n[proxychains] DLL init: proxychains-ng 4.14\n[proxychains] Strict chain  ...  127.0.0.1:8000  ...  google.com:80  ...  OK\n<HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<TITLE>301 Moved</TITLE></HEAD><BODY>\n<H1>301 Moved</H1>\nThe document has moved\n<A HREF=\"http://www.google.com/\">here</A>.\n</BODY></HTML>\n```\n\n如果闲命令太长可以写一个`alias`，在这里就不演示了。\n\n\n\n\n\n# MacOS\n\n如果你使用包管理器，例如`homebrew`可以直接执行:\n\n``` shell\n> brew install proxychains-ng\n```\n\n但是会很慢，所以有第二种方式————手动编译安装。\n\n``` shell\n> git clone --depth 1 git@github.com:rofl0r/proxychains-ng\n> cd proxychains-ng && ./configure --prfix=/usr --sysconfdir=/etc\n> make && make install\n> sudo make install-config # 生成proxychains.conf配置文件\n```\n\n这里可能会有一个坑————执行`make install`出错，想要解决很简单：\n\n进入`configure`目录，修改`config.mak`文件，将`bindir=/usr/bin`改为`bindir=/usr/local/bin`\n\n就算你安装好，并且配置好文件后可能照样不能使用，这一切都是因为苹果电脑的`SIP`保\n护系统，有关`SIP`的信息自己谷歌一下，再考虑要不要关闭。\n\n关闭分两种，一种是让`SIP`进入debug模式，再一种就是永久关闭（除非手动启动）。\n\n首先重启Mac，在重启时按住`option`键，进入选择启动磁盘项，然后按组合键\n`Command+R`即可进入恢复模式，进入恢复模式后先验证密码，然后在**顶栏找到实用工具\n的终端**,再看下一步吧。\n\ndebug模式\n\n``` shell\n> csrutil enable --without debug \n```\n\n永久关闭\n\n```shell\n> csrutil disable\n```\n\n进行设置了后重启打开终端输入`csrutil status`，如果显示`System Integrity\nProtection status:disbaled`则说明关闭成功了。\n\n除了配置文件路径不同其他都跟`Arch`下配置一样————`/usr/local/etc/proxychains.conf`\n\n","source":"_posts/ProxyChains入门使用教程.md","raw":"---\ntitle: ProxyChains入门使用教程\ncopyright: true\ndate: 2020-01-07 16:59:41\ncategories: 软件分享\ntags: \ncomments: true\n---\n\n身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工\n具。\n<!--more-->\n\n# ArchLinux\n\nArch下直接安装`ProxyChains-ng`这个包即可。\n\n``` shell\nsudo pacman -S proxychains-ng\n```\n\n安装好后编辑`/etc/proxychains.conf`。\n\n找到最下面的`[ProxyList]`，往里面添加映射的类型，例如我想要`http`协议走代理就可\n以这么写。\n\n``` conf\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to \"tor\"\nhttp \t127.0.0.1 8000\n# socks5 127.0.0.1 1080\n```\n\n使用非常简单，可以直接在需要走代理的程序前加上`proxychains`即可。\n\n``` shell\n➜  ~ proxychains curl google.com\n[proxychains] config file found: /etc/proxychains.conf\n[proxychains] preloading /usr/lib/libproxychains4.so\n[proxychains] DLL init: proxychains-ng 4.14\n[proxychains] Strict chain  ...  127.0.0.1:8000  ...  google.com:80  ...  OK\n<HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<TITLE>301 Moved</TITLE></HEAD><BODY>\n<H1>301 Moved</H1>\nThe document has moved\n<A HREF=\"http://www.google.com/\">here</A>.\n</BODY></HTML>\n```\n\n如果闲命令太长可以写一个`alias`，在这里就不演示了。\n\n\n\n\n\n# MacOS\n\n如果你使用包管理器，例如`homebrew`可以直接执行:\n\n``` shell\n> brew install proxychains-ng\n```\n\n但是会很慢，所以有第二种方式————手动编译安装。\n\n``` shell\n> git clone --depth 1 git@github.com:rofl0r/proxychains-ng\n> cd proxychains-ng && ./configure --prfix=/usr --sysconfdir=/etc\n> make && make install\n> sudo make install-config # 生成proxychains.conf配置文件\n```\n\n这里可能会有一个坑————执行`make install`出错，想要解决很简单：\n\n进入`configure`目录，修改`config.mak`文件，将`bindir=/usr/bin`改为`bindir=/usr/local/bin`\n\n就算你安装好，并且配置好文件后可能照样不能使用，这一切都是因为苹果电脑的`SIP`保\n护系统，有关`SIP`的信息自己谷歌一下，再考虑要不要关闭。\n\n关闭分两种，一种是让`SIP`进入debug模式，再一种就是永久关闭（除非手动启动）。\n\n首先重启Mac，在重启时按住`option`键，进入选择启动磁盘项，然后按组合键\n`Command+R`即可进入恢复模式，进入恢复模式后先验证密码，然后在**顶栏找到实用工具\n的终端**,再看下一步吧。\n\ndebug模式\n\n``` shell\n> csrutil enable --without debug \n```\n\n永久关闭\n\n```shell\n> csrutil disable\n```\n\n进行设置了后重启打开终端输入`csrutil status`，如果显示`System Integrity\nProtection status:disbaled`则说明关闭成功了。\n\n除了配置文件路径不同其他都跟`Arch`下配置一样————`/usr/local/etc/proxychains.conf`\n\n","slug":"ProxyChains入门使用教程","published":1,"updated":"2020-01-19T03:49:51.383Z","layout":"post","photos":[],"link":"","_id":"ck5oozock003komoowz87ww52","content":"<p>身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工<br>具。<br><a id=\"more\"></a></p>\n<h1 id=\"ArchLinux\"><a href=\"#ArchLinux\" class=\"headerlink\" title=\"ArchLinux\"></a>ArchLinux</h1><p>Arch下直接安装<code>ProxyChains-ng</code>这个包即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S proxychains-ng</span><br></pre></td></tr></table></figure>\n<p>安装好后编辑<code>/etc/proxychains.conf</code>。</p>\n<p>找到最下面的<code>[ProxyList]</code>，往里面添加映射的类型，例如我想要<code>http</code>协议走代理就可<br>以这么写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ProxyList]</span><br><span class=\"line\"># add proxy here ...</span><br><span class=\"line\"># meanwile</span><br><span class=\"line\"># defaults set to &quot;tor&quot;</span><br><span class=\"line\">http \t127.0.0.1 8000</span><br><span class=\"line\"># socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>\n<p>使用非常简单，可以直接在需要走代理的程序前加上<code>proxychains</code>即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ proxychains curl google.com</span><br><span class=\"line\">[proxychains] config file found: /etc/proxychains.conf</span><br><span class=\"line\">[proxychains] preloading /usr/lib/libproxychains4.so</span><br><span class=\"line\">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class=\"line\">[proxychains] Strict chain  ...  127.0.0.1:8000  ...  google.com:80  ...  OK</span><br><span class=\"line\">&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;</span><br><span class=\"line\">&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class=\"line\">&lt;H1&gt;301 Moved&lt;/H1&gt;</span><br><span class=\"line\">The document has moved</span><br><span class=\"line\">&lt;A HREF=\"http://www.google.com/\"&gt;here&lt;/A&gt;.</span><br><span class=\"line\">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>\n<p>如果闲命令太长可以写一个<code>alias</code>，在这里就不演示了。</p>\n<h1 id=\"MacOS\"><a href=\"#MacOS\" class=\"headerlink\" title=\"MacOS\"></a>MacOS</h1><p>如果你使用包管理器，例如<code>homebrew</code>可以直接执行:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> brew install proxychains-ng</span><br></pre></td></tr></table></figure>\n<p>但是会很慢，所以有第二种方式————手动编译安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> git clone --depth 1 git@github.com:rofl0r/proxychains-ng</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> cd proxychains-ng &amp;&amp; ./configure --prfix=/usr --sysconfdir=/etc</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> make &amp;&amp; make install</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> sudo make install-config # 生成proxychains.conf配置文件</span><br></pre></td></tr></table></figure>\n<p>这里可能会有一个坑————执行<code>make install</code>出错，想要解决很简单：</p>\n<p>进入<code>configure</code>目录，修改<code>config.mak</code>文件，将<code>bindir=/usr/bin</code>改为<code>bindir=/usr/local/bin</code></p>\n<p>就算你安装好，并且配置好文件后可能照样不能使用，这一切都是因为苹果电脑的<code>SIP</code>保<br>护系统，有关<code>SIP</code>的信息自己谷歌一下，再考虑要不要关闭。</p>\n<p>关闭分两种，一种是让<code>SIP</code>进入debug模式，再一种就是永久关闭（除非手动启动）。</p>\n<p>首先重启Mac，在重启时按住<code>option</code>键，进入选择启动磁盘项，然后按组合键<br><code>Command+R</code>即可进入恢复模式，进入恢复模式后先验证密码，然后在<strong>顶栏找到实用工具<br>的终端</strong>,再看下一步吧。</p>\n<p>debug模式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> csrutil enable --without debug</span><br></pre></td></tr></table></figure>\n<p>永久关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> csrutil disable</span><br></pre></td></tr></table></figure>\n<p>进行设置了后重启打开终端输入<code>csrutil status</code>，如果显示<code>System Integrity\nProtection status:disbaled</code>则说明关闭成功了。</p>\n<p>除了配置文件路径不同其他都跟<code>Arch</code>下配置一样————<code>/usr/local/etc/proxychains.conf</code></p>\n","site":{"data":{}},"excerpt":"<p>身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工<br>具。<br></p>","more":"<p></p>\n<h1 id=\"ArchLinux\"><a href=\"#ArchLinux\" class=\"headerlink\" title=\"ArchLinux\"></a>ArchLinux</h1><p>Arch下直接安装<code>ProxyChains-ng</code>这个包即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S proxychains-ng</span><br></pre></td></tr></table></figure>\n<p>安装好后编辑<code>/etc/proxychains.conf</code>。</p>\n<p>找到最下面的<code>[ProxyList]</code>，往里面添加映射的类型，例如我想要<code>http</code>协议走代理就可<br>以这么写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ProxyList]</span><br><span class=\"line\"># add proxy here ...</span><br><span class=\"line\"># meanwile</span><br><span class=\"line\"># defaults set to &quot;tor&quot;</span><br><span class=\"line\">http \t127.0.0.1 8000</span><br><span class=\"line\"># socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>\n<p>使用非常简单，可以直接在需要走代理的程序前加上<code>proxychains</code>即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ proxychains curl google.com</span><br><span class=\"line\">[proxychains] config file found: /etc/proxychains.conf</span><br><span class=\"line\">[proxychains] preloading /usr/lib/libproxychains4.so</span><br><span class=\"line\">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class=\"line\">[proxychains] Strict chain  ...  127.0.0.1:8000  ...  google.com:80  ...  OK</span><br><span class=\"line\">&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;</span><br><span class=\"line\">&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class=\"line\">&lt;H1&gt;301 Moved&lt;/H1&gt;</span><br><span class=\"line\">The document has moved</span><br><span class=\"line\">&lt;A HREF=\"http://www.google.com/\"&gt;here&lt;/A&gt;.</span><br><span class=\"line\">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>\n<p>如果闲命令太长可以写一个<code>alias</code>，在这里就不演示了。</p>\n<h1 id=\"MacOS\"><a href=\"#MacOS\" class=\"headerlink\" title=\"MacOS\"></a>MacOS</h1><p>如果你使用包管理器，例如<code>homebrew</code>可以直接执行:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> brew install proxychains-ng</span><br></pre></td></tr></table></figure>\n<p>但是会很慢，所以有第二种方式————手动编译安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> git clone --depth 1 git@github.com:rofl0r/proxychains-ng</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> cd proxychains-ng &amp;&amp; ./configure --prfix=/usr --sysconfdir=/etc</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> make &amp;&amp; make install</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> sudo make install-config # 生成proxychains.conf配置文件</span><br></pre></td></tr></table></figure>\n<p>这里可能会有一个坑————执行<code>make install</code>出错，想要解决很简单：</p>\n<p>进入<code>configure</code>目录，修改<code>config.mak</code>文件，将<code>bindir=/usr/bin</code>改为<code>bindir=/usr/local/bin</code></p>\n<p>就算你安装好，并且配置好文件后可能照样不能使用，这一切都是因为苹果电脑的<code>SIP</code>保<br>护系统，有关<code>SIP</code>的信息自己谷歌一下，再考虑要不要关闭。</p>\n<p>关闭分两种，一种是让<code>SIP</code>进入debug模式，再一种就是永久关闭（除非手动启动）。</p>\n<p>首先重启Mac，在重启时按住<code>option</code>键，进入选择启动磁盘项，然后按组合键<br><code>Command+R</code>即可进入恢复模式，进入恢复模式后先验证密码，然后在<strong>顶栏找到实用工具<br>的终端</strong>,再看下一步吧。</p>\n<p>debug模式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> csrutil enable --without debug</span><br></pre></td></tr></table></figure>\n<p>永久关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> csrutil disable</span><br></pre></td></tr></table></figure>\n<p>进行设置了后重启打开终端输入<code>csrutil status</code>，如果显示<code>System Integrity\nProtection status:disbaled</code>则说明关闭成功了。</p>\n<p>除了配置文件路径不同其他都跟<code>Arch</code>下配置一样————<code>/usr/local/etc/proxychains.conf</code></p>"},{"title":"[Python-01]Python教程基础","copyright":true,"date":"2019-08-28T16:25:46.000Z","_content":"\nPython系列第一章笔记，查看Python系列所有文章,请点击 [💿](https://evanmeek.github.io/Python/)\n<!--more-->\n\n# 编程语言是什么\n\n编程语言中的每个结构，都有固定的使用格式（称之为`语法`)以及精确的含义（称之为`语义`）。\n\n编程语言也分等级，例如C、C++、Java、Ruby等可以称为高级语言，而计算机`硬件`只能理解一种非常低级的编程语言，`机器语言`。\n\n# 解释型语言和编译型语言（两者区别）\n\n> 编译型语言\n\n编译型语言是指使用专门的编译器，对特定的操作系统（平台）将源代码一次性“翻译”为可被该操作系统（平台）硬件所执行的机器语言。\n\n优点：\n - 编译好后的可执行文件，可以在没有编译器的机器上独立运行。\n - 程序执行速度快\n\n缺点：\n - 跨平台不友好(如果是不同的平台，需要将源代码在特定的平台重新编译，甚至需要修改代码)\n\n> 解释型语言\n\n解释型语言由解释器完成将源代码转换成机器语言，在任何平台上必须安装解释器才可以运行，而不同的平台只需要安装解释器，代码不需要修改也可以被解释。\n\n优点：\n\n - 跨平台友好\n\n缺点：\n\n - 执行速度慢\n\n# Python是什么，Python简介\n\n> Python历史\n\n1989年，荷兰人`Guido van Rossum` 创造了Python.\n\n`Python`最初基于`ABC`教学语言.\n\n> Python简介\n\n`Python`可以和其他语言，如C、C++、Java的模块（方法/函数）轻松的结合在一起，因此`Python`又被称为“胶水”语言。\n\n> Python的设计哲学\n\n优雅、明确、简单。\n\n有些人说：“人生苦短，我用Python”\n\n# Python的特点（优点和缺点）\n\n> 简单易学\n\nPython虽然语法格式要求严格，但是语法却很简洁。\n\n> 开源\n\nPython是开源的，使用Python编写的程序可以做商业用途也不用付费，并且可以让第三方开发者为Python开发提供优秀的功能。\n\n> 高级语言\n\n在使用Python编写程序时，开发者无需考虑底层细节问题，而专注于编写程序。\n\n> 解释型语言\n\n可移植性优秀\n\n> 面向对象\n\nPython既支持面向过程编程，也支持面向对象编程。\n\n> 强大的功能\n\nPython可以从简单的字符串处理到复杂的3D图形编程，这些借助Python的扩展模块可以轻松完成。\n\n> 可扩展性\n\nPython具有脚本语言中最丰富和强大的类库，不管是I/O、GUI、网络编程、数据库编程等绝大部应用场景，都可以使用Python内置的类库完成。\n\nPython可以使用C或C++编写的代码，这样可以一定程度上的弥补执行速度慢的缺点。\n\n> 缺点\n\n速度慢，相比Java、C、C++编写的程序，运行效率都要慢。\n源代码加密困难，由于是解释型语言，不像编译型语言那样会被编译成各种目标程序，所以加密困难。\n\n# 学Python，不需要有编程基础\n\nPython语法简明易懂，不像C++或C语言等语法复杂，并且在学习Python中也不需要太过于专注底层的细节，很多事情解释器都已经帮忙做好了。所以对于零基础的初学者来说，Python非常合适。\n\n# Python能干什么，Python的应用领域\n\n> Web应用开发\n\nPython可以通过一些模块，使Python具备HTTP服务器与Python的Web程序之间的通信。\n\n全球最大的搜索引擎`Google`，在其搜索系统中就大量的使用Python。\n\n`豆瓣`也是由Python编写的。\n\n> 操作系统管理、自动化运维开发\n\n大部分操作系统中，Python都作为标准的系统组件，例如大多数Linux发行版，BSD系、Mac OS X都集成了Python。\n\n并且相对于Shell脚本来说，无论是可读性、性能、代码重用度以及扩展性方面都要优秀很多。\n\n> 游戏开发\n\n虽说Python的运行效率不算快，但很多游戏可以用C++编写高性能模块，而用Pyton编写游戏的逻辑。\n\n例如，`文明`这款游戏就是使用Python实现的。\n\n> 编写服务器软件\n\n由于Python对各种网络协议的支持完善，所以经常被用于编写服务器软件以及网络爬虫。\n\n> 科学计算\n\nPython内置了很多工具，可以让科研人员编写科学计算程序。\n\n# 怎样学习Python，才能成为Python高手？\n\n> 编程语言都是相通的\n\n如果你具备一定的编程基础，接触一门新的编程语言时会发现，不同的编程语言其实是相通的，大多数不同的地方在于语法规则。\n\n> Python对初学者友好\n\n- 多实践、积累代码量\n\n  任何编程语言知识都是大量的，如果不在学习编程时就开始练习，那么可能当你学完素有的语法后，却把前面的知识忘得一干二净。\n\n  所以，学习编程，需要多写代码，没有途径可走。\n\n- 时刻注意代码规范\n\n  在我们学习时，一定要养成良好的编程习惯，例如适当的编写注释，定义变量名称时不要随意使用无意义的字符。\n\n- 开发经验必不可少\n\n当你熟练的掌握一门编程语言的语法时，你还需要大中型产品的开发经验，它会让你学得更多，简而言之站得更高，看得更远。\n\n![Python知识体系图](Python-01-Python教程基础/Python知识体系框架.png)\n\n# Python 2.x和Python 3.x，初学者应该如何选择？\n\n推荐选择Python 3.x，因为Python将在2020不再更新Python 2.x，并且Python 3.x比Python 2.x 具有更多的特性与功能。\n\n这里只是推荐，详细看Python3和Python2的区别可以看这本:[📖《Python3和Python2的区别》](http://c.biancheng.net/view/4147.html)\n\n# Python版本区别，Python3和Python2区别详解\n\n学习完基础再来...暂时未编写😅\n\n不过可以知道的是，Python3相比与Python2在`语句输出、编码、运算和异常等`方面做出了调整。\n\n# Python2to3 自动将Python2.x代码转换成Python3.x代码\n\n学习完基础再来...暂时未编写😅\n\n学完完基础再来...暂时未编写\n\n# Python PEP 及时追踪Python最新变化\n\n为了追踪Python的更新动态，我们需要借助Python PEP 文档\n\n> Python PEP文档\n\nPython语法修改方案是由`邮件列表`的形式进行讨论，但Python的PEP文档发布了，新的变化才会生效。\n\n`PEP(Python Enhancement Proposal)`，中译为`Python改进方案`。它主要由三个用途\n\n- 通知: 汇总Python核心开发者重要信息\n\n- 标准化: 提供代码风格，文档或者其他指导意见\n\n- 设计: 对提交的新功能进行说明\n\n如果想要查看提交的`PEP`历史，可以点击这里:[PEP0文档](https://www.python.org/dev/peps/)\n\n# Python底层是用什么语言实现的\n\n大多数讨论的Python，所指的是CPython，它是用C语言编写的。\n\n不仅有用C语言编写的Python也有用其他语法编写的Python。\n\n不同语言实现Python的的原因，大部分是为了解决某些实际问题而创建的，例如：\n\n- 在嵌入式系统中运行Python代码\n\n- 在运行框架(Java/.NET)或其他语言做代码集成。\n\n- 在Web浏览器中运行Python代码\n\n以上所述使用CPython需要花费开发者大量精力也很难实现，所以才有了各种实现方式的Python.\n\n> Stackless Python\n\n`Stackless Python`自称为Python增强版，它没有依赖C语言的调用栈。\n\n其新添加的功能最重要的是:解释器管理的微线程\n\n支持版本是2.7.9和3.3.5，Stackless Python的所有额外功能都是内置stackiess模块内的框架。\n\n> JPython\n\n由Java实现的Python。它将代码编译为Java字节码，开发者可以在Pyton模块中无缝使用Java类\n\nJPython与CPython的主要区别:\n\n- 真正的Java垃圾回收机制\n\n- 没有`全局解释器锁(GlobalInterpreter Lock,GIL)`，在多线程应用中可以充分利用多个内核\n\n支持版本: 2.7\n\n缺点: 缺少对C/Python扩展API的支持，预计JPython3.x支持C/Python扩展API\n\n> IronPython\n\nIronPython将Python引入至.NET框架中。\n\n支持版本: 2.7.5\n\n缺点: 类似JPython\n\n相比于CPython的优点:\n\n- 没有全局解释器锁\n\n- 用.NET语言家族编写的代码可以轻松集成到IronPython中，反之亦然。\n\n- 通过`Silverlight`，在所有主流Web浏览器中都可运行。\n\n> PyPy\n\n社区内呼声最高的Python实现，它是由Python重写的Python。\n\n支持版本: 2.7完全兼容,PyPy3与3.25完全兼容\n\nPyPy与CPython实现的主要区别:\n\n- 使用垃圾回收\n\n- 集成跟踪JIT编译器，可以提高性能\n\n- 借鉴Stackless Python在应用层的无栈特性。\n\n缺点: 对C/Python扩展API不完善，但为CPyExt子系统C扩展提供了某种程度的支持。\n\n# 了解Jupyter Notebook，你已然超越了90%的Python程序员\n\n简单介绍下，Jupyter Notebook就是个整合了代码、计算输出、解释文档、多媒体资源的多功能科学运行平台。\n\n去看原文吧，这个知道有这个东西，以后再去学习。\n\n[💿原文传送门](http://c.biancheng.net/view/5279.html)\n","source":"_posts/Python-01-Python教程基础.md","raw":"---\ntitle: '[Python-01]Python教程基础'\ncopyright: true\ndate: 2019-08-29 00:25:46\ncategories: Python\ntags:\n - Python系列\n---\n\nPython系列第一章笔记，查看Python系列所有文章,请点击 [💿](https://evanmeek.github.io/Python/)\n<!--more-->\n\n# 编程语言是什么\n\n编程语言中的每个结构，都有固定的使用格式（称之为`语法`)以及精确的含义（称之为`语义`）。\n\n编程语言也分等级，例如C、C++、Java、Ruby等可以称为高级语言，而计算机`硬件`只能理解一种非常低级的编程语言，`机器语言`。\n\n# 解释型语言和编译型语言（两者区别）\n\n> 编译型语言\n\n编译型语言是指使用专门的编译器，对特定的操作系统（平台）将源代码一次性“翻译”为可被该操作系统（平台）硬件所执行的机器语言。\n\n优点：\n - 编译好后的可执行文件，可以在没有编译器的机器上独立运行。\n - 程序执行速度快\n\n缺点：\n - 跨平台不友好(如果是不同的平台，需要将源代码在特定的平台重新编译，甚至需要修改代码)\n\n> 解释型语言\n\n解释型语言由解释器完成将源代码转换成机器语言，在任何平台上必须安装解释器才可以运行，而不同的平台只需要安装解释器，代码不需要修改也可以被解释。\n\n优点：\n\n - 跨平台友好\n\n缺点：\n\n - 执行速度慢\n\n# Python是什么，Python简介\n\n> Python历史\n\n1989年，荷兰人`Guido van Rossum` 创造了Python.\n\n`Python`最初基于`ABC`教学语言.\n\n> Python简介\n\n`Python`可以和其他语言，如C、C++、Java的模块（方法/函数）轻松的结合在一起，因此`Python`又被称为“胶水”语言。\n\n> Python的设计哲学\n\n优雅、明确、简单。\n\n有些人说：“人生苦短，我用Python”\n\n# Python的特点（优点和缺点）\n\n> 简单易学\n\nPython虽然语法格式要求严格，但是语法却很简洁。\n\n> 开源\n\nPython是开源的，使用Python编写的程序可以做商业用途也不用付费，并且可以让第三方开发者为Python开发提供优秀的功能。\n\n> 高级语言\n\n在使用Python编写程序时，开发者无需考虑底层细节问题，而专注于编写程序。\n\n> 解释型语言\n\n可移植性优秀\n\n> 面向对象\n\nPython既支持面向过程编程，也支持面向对象编程。\n\n> 强大的功能\n\nPython可以从简单的字符串处理到复杂的3D图形编程，这些借助Python的扩展模块可以轻松完成。\n\n> 可扩展性\n\nPython具有脚本语言中最丰富和强大的类库，不管是I/O、GUI、网络编程、数据库编程等绝大部应用场景，都可以使用Python内置的类库完成。\n\nPython可以使用C或C++编写的代码，这样可以一定程度上的弥补执行速度慢的缺点。\n\n> 缺点\n\n速度慢，相比Java、C、C++编写的程序，运行效率都要慢。\n源代码加密困难，由于是解释型语言，不像编译型语言那样会被编译成各种目标程序，所以加密困难。\n\n# 学Python，不需要有编程基础\n\nPython语法简明易懂，不像C++或C语言等语法复杂，并且在学习Python中也不需要太过于专注底层的细节，很多事情解释器都已经帮忙做好了。所以对于零基础的初学者来说，Python非常合适。\n\n# Python能干什么，Python的应用领域\n\n> Web应用开发\n\nPython可以通过一些模块，使Python具备HTTP服务器与Python的Web程序之间的通信。\n\n全球最大的搜索引擎`Google`，在其搜索系统中就大量的使用Python。\n\n`豆瓣`也是由Python编写的。\n\n> 操作系统管理、自动化运维开发\n\n大部分操作系统中，Python都作为标准的系统组件，例如大多数Linux发行版，BSD系、Mac OS X都集成了Python。\n\n并且相对于Shell脚本来说，无论是可读性、性能、代码重用度以及扩展性方面都要优秀很多。\n\n> 游戏开发\n\n虽说Python的运行效率不算快，但很多游戏可以用C++编写高性能模块，而用Pyton编写游戏的逻辑。\n\n例如，`文明`这款游戏就是使用Python实现的。\n\n> 编写服务器软件\n\n由于Python对各种网络协议的支持完善，所以经常被用于编写服务器软件以及网络爬虫。\n\n> 科学计算\n\nPython内置了很多工具，可以让科研人员编写科学计算程序。\n\n# 怎样学习Python，才能成为Python高手？\n\n> 编程语言都是相通的\n\n如果你具备一定的编程基础，接触一门新的编程语言时会发现，不同的编程语言其实是相通的，大多数不同的地方在于语法规则。\n\n> Python对初学者友好\n\n- 多实践、积累代码量\n\n  任何编程语言知识都是大量的，如果不在学习编程时就开始练习，那么可能当你学完素有的语法后，却把前面的知识忘得一干二净。\n\n  所以，学习编程，需要多写代码，没有途径可走。\n\n- 时刻注意代码规范\n\n  在我们学习时，一定要养成良好的编程习惯，例如适当的编写注释，定义变量名称时不要随意使用无意义的字符。\n\n- 开发经验必不可少\n\n当你熟练的掌握一门编程语言的语法时，你还需要大中型产品的开发经验，它会让你学得更多，简而言之站得更高，看得更远。\n\n![Python知识体系图](Python-01-Python教程基础/Python知识体系框架.png)\n\n# Python 2.x和Python 3.x，初学者应该如何选择？\n\n推荐选择Python 3.x，因为Python将在2020不再更新Python 2.x，并且Python 3.x比Python 2.x 具有更多的特性与功能。\n\n这里只是推荐，详细看Python3和Python2的区别可以看这本:[📖《Python3和Python2的区别》](http://c.biancheng.net/view/4147.html)\n\n# Python版本区别，Python3和Python2区别详解\n\n学习完基础再来...暂时未编写😅\n\n不过可以知道的是，Python3相比与Python2在`语句输出、编码、运算和异常等`方面做出了调整。\n\n# Python2to3 自动将Python2.x代码转换成Python3.x代码\n\n学习完基础再来...暂时未编写😅\n\n学完完基础再来...暂时未编写\n\n# Python PEP 及时追踪Python最新变化\n\n为了追踪Python的更新动态，我们需要借助Python PEP 文档\n\n> Python PEP文档\n\nPython语法修改方案是由`邮件列表`的形式进行讨论，但Python的PEP文档发布了，新的变化才会生效。\n\n`PEP(Python Enhancement Proposal)`，中译为`Python改进方案`。它主要由三个用途\n\n- 通知: 汇总Python核心开发者重要信息\n\n- 标准化: 提供代码风格，文档或者其他指导意见\n\n- 设计: 对提交的新功能进行说明\n\n如果想要查看提交的`PEP`历史，可以点击这里:[PEP0文档](https://www.python.org/dev/peps/)\n\n# Python底层是用什么语言实现的\n\n大多数讨论的Python，所指的是CPython，它是用C语言编写的。\n\n不仅有用C语言编写的Python也有用其他语法编写的Python。\n\n不同语言实现Python的的原因，大部分是为了解决某些实际问题而创建的，例如：\n\n- 在嵌入式系统中运行Python代码\n\n- 在运行框架(Java/.NET)或其他语言做代码集成。\n\n- 在Web浏览器中运行Python代码\n\n以上所述使用CPython需要花费开发者大量精力也很难实现，所以才有了各种实现方式的Python.\n\n> Stackless Python\n\n`Stackless Python`自称为Python增强版，它没有依赖C语言的调用栈。\n\n其新添加的功能最重要的是:解释器管理的微线程\n\n支持版本是2.7.9和3.3.5，Stackless Python的所有额外功能都是内置stackiess模块内的框架。\n\n> JPython\n\n由Java实现的Python。它将代码编译为Java字节码，开发者可以在Pyton模块中无缝使用Java类\n\nJPython与CPython的主要区别:\n\n- 真正的Java垃圾回收机制\n\n- 没有`全局解释器锁(GlobalInterpreter Lock,GIL)`，在多线程应用中可以充分利用多个内核\n\n支持版本: 2.7\n\n缺点: 缺少对C/Python扩展API的支持，预计JPython3.x支持C/Python扩展API\n\n> IronPython\n\nIronPython将Python引入至.NET框架中。\n\n支持版本: 2.7.5\n\n缺点: 类似JPython\n\n相比于CPython的优点:\n\n- 没有全局解释器锁\n\n- 用.NET语言家族编写的代码可以轻松集成到IronPython中，反之亦然。\n\n- 通过`Silverlight`，在所有主流Web浏览器中都可运行。\n\n> PyPy\n\n社区内呼声最高的Python实现，它是由Python重写的Python。\n\n支持版本: 2.7完全兼容,PyPy3与3.25完全兼容\n\nPyPy与CPython实现的主要区别:\n\n- 使用垃圾回收\n\n- 集成跟踪JIT编译器，可以提高性能\n\n- 借鉴Stackless Python在应用层的无栈特性。\n\n缺点: 对C/Python扩展API不完善，但为CPyExt子系统C扩展提供了某种程度的支持。\n\n# 了解Jupyter Notebook，你已然超越了90%的Python程序员\n\n简单介绍下，Jupyter Notebook就是个整合了代码、计算输出、解释文档、多媒体资源的多功能科学运行平台。\n\n去看原文吧，这个知道有这个东西，以后再去学习。\n\n[💿原文传送门](http://c.biancheng.net/view/5279.html)\n","slug":"Python-01-Python教程基础","published":1,"updated":"2020-01-19T03:49:51.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocl003oomoo5f0lhoev","content":"<p>Python系列第一章笔记，查看Python系列所有文章,请点击 <a href=\"https://evanmeek.github.io/Python/\">💿</a><br><a id=\"more\"></a></p>\n<h1 id=\"编程语言是什么\"><a href=\"#编程语言是什么\" class=\"headerlink\" title=\"编程语言是什么\"></a>编程语言是什么</h1><p>编程语言中的每个结构，都有固定的使用格式（称之为<code>语法</code>)以及精确的含义（称之为<code>语义</code>）。</p>\n<p>编程语言也分等级，例如C、C++、Java、Ruby等可以称为高级语言，而计算机<code>硬件</code>只能理解一种非常低级的编程语言，<code>机器语言</code>。</p>\n<h1 id=\"解释型语言和编译型语言（两者区别）\"><a href=\"#解释型语言和编译型语言（两者区别）\" class=\"headerlink\" title=\"解释型语言和编译型语言（两者区别）\"></a>解释型语言和编译型语言（两者区别）</h1><blockquote>\n<p>编译型语言</p>\n</blockquote>\n<p>编译型语言是指使用专门的编译器，对特定的操作系统（平台）将源代码一次性“翻译”为可被该操作系统（平台）硬件所执行的机器语言。</p>\n<p>优点：</p>\n<ul>\n<li>编译好后的可执行文件，可以在没有编译器的机器上独立运行。</li>\n<li>程序执行速度快</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>跨平台不友好(如果是不同的平台，需要将源代码在特定的平台重新编译，甚至需要修改代码)</li>\n</ul>\n<blockquote>\n<p>解释型语言</p>\n</blockquote>\n<p>解释型语言由解释器完成将源代码转换成机器语言，在任何平台上必须安装解释器才可以运行，而不同的平台只需要安装解释器，代码不需要修改也可以被解释。</p>\n<p>优点：</p>\n<ul>\n<li>跨平台友好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>执行速度慢</li>\n</ul>\n<h1 id=\"Python是什么，Python简介\"><a href=\"#Python是什么，Python简介\" class=\"headerlink\" title=\"Python是什么，Python简介\"></a>Python是什么，Python简介</h1><blockquote>\n<p>Python历史</p>\n</blockquote>\n<p>1989年，荷兰人<code>Guido van Rossum</code> 创造了Python.</p>\n<p><code>Python</code>最初基于<code>ABC</code>教学语言.</p>\n<blockquote>\n<p>Python简介</p>\n</blockquote>\n<p><code>Python</code>可以和其他语言，如C、C++、Java的模块（方法/函数）轻松的结合在一起，因此<code>Python</code>又被称为“胶水”语言。</p>\n<blockquote>\n<p>Python的设计哲学</p>\n</blockquote>\n<p>优雅、明确、简单。</p>\n<p>有些人说：“人生苦短，我用Python”</p>\n<h1 id=\"Python的特点（优点和缺点）\"><a href=\"#Python的特点（优点和缺点）\" class=\"headerlink\" title=\"Python的特点（优点和缺点）\"></a>Python的特点（优点和缺点）</h1><blockquote>\n<p>简单易学</p>\n</blockquote>\n<p>Python虽然语法格式要求严格，但是语法却很简洁。</p>\n<blockquote>\n<p>开源</p>\n</blockquote>\n<p>Python是开源的，使用Python编写的程序可以做商业用途也不用付费，并且可以让第三方开发者为Python开发提供优秀的功能。</p>\n<blockquote>\n<p>高级语言</p>\n</blockquote>\n<p>在使用Python编写程序时，开发者无需考虑底层细节问题，而专注于编写程序。</p>\n<blockquote>\n<p>解释型语言</p>\n</blockquote>\n<p>可移植性优秀</p>\n<blockquote>\n<p>面向对象</p>\n</blockquote>\n<p>Python既支持面向过程编程，也支持面向对象编程。</p>\n<blockquote>\n<p>强大的功能</p>\n</blockquote>\n<p>Python可以从简单的字符串处理到复杂的3D图形编程，这些借助Python的扩展模块可以轻松完成。</p>\n<blockquote>\n<p>可扩展性</p>\n</blockquote>\n<p>Python具有脚本语言中最丰富和强大的类库，不管是I/O、GUI、网络编程、数据库编程等绝大部应用场景，都可以使用Python内置的类库完成。</p>\n<p>Python可以使用C或C++编写的代码，这样可以一定程度上的弥补执行速度慢的缺点。</p>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<p>速度慢，相比Java、C、C++编写的程序，运行效率都要慢。<br>源代码加密困难，由于是解释型语言，不像编译型语言那样会被编译成各种目标程序，所以加密困难。</p>\n<h1 id=\"学Python，不需要有编程基础\"><a href=\"#学Python，不需要有编程基础\" class=\"headerlink\" title=\"学Python，不需要有编程基础\"></a>学Python，不需要有编程基础</h1><p>Python语法简明易懂，不像C++或C语言等语法复杂，并且在学习Python中也不需要太过于专注底层的细节，很多事情解释器都已经帮忙做好了。所以对于零基础的初学者来说，Python非常合适。</p>\n<h1 id=\"Python能干什么，Python的应用领域\"><a href=\"#Python能干什么，Python的应用领域\" class=\"headerlink\" title=\"Python能干什么，Python的应用领域\"></a>Python能干什么，Python的应用领域</h1><blockquote>\n<p>Web应用开发</p>\n</blockquote>\n<p>Python可以通过一些模块，使Python具备HTTP服务器与Python的Web程序之间的通信。</p>\n<p>全球最大的搜索引擎<code>Google</code>，在其搜索系统中就大量的使用Python。</p>\n<p><code>豆瓣</code>也是由Python编写的。</p>\n<blockquote>\n<p>操作系统管理、自动化运维开发</p>\n</blockquote>\n<p>大部分操作系统中，Python都作为标准的系统组件，例如大多数Linux发行版，BSD系、Mac OS X都集成了Python。</p>\n<p>并且相对于Shell脚本来说，无论是可读性、性能、代码重用度以及扩展性方面都要优秀很多。</p>\n<blockquote>\n<p>游戏开发</p>\n</blockquote>\n<p>虽说Python的运行效率不算快，但很多游戏可以用C++编写高性能模块，而用Pyton编写游戏的逻辑。</p>\n<p>例如，<code>文明</code>这款游戏就是使用Python实现的。</p>\n<blockquote>\n<p>编写服务器软件</p>\n</blockquote>\n<p>由于Python对各种网络协议的支持完善，所以经常被用于编写服务器软件以及网络爬虫。</p>\n<blockquote>\n<p>科学计算</p>\n</blockquote>\n<p>Python内置了很多工具，可以让科研人员编写科学计算程序。</p>\n<h1 id=\"怎样学习Python，才能成为Python高手？\"><a href=\"#怎样学习Python，才能成为Python高手？\" class=\"headerlink\" title=\"怎样学习Python，才能成为Python高手？\"></a>怎样学习Python，才能成为Python高手？</h1><blockquote>\n<p>编程语言都是相通的</p>\n</blockquote>\n<p>如果你具备一定的编程基础，接触一门新的编程语言时会发现，不同的编程语言其实是相通的，大多数不同的地方在于语法规则。</p>\n<blockquote>\n<p>Python对初学者友好</p>\n</blockquote>\n<ul>\n<li><p>多实践、积累代码量</p>\n<p>任何编程语言知识都是大量的，如果不在学习编程时就开始练习，那么可能当你学完素有的语法后，却把前面的知识忘得一干二净。</p>\n<p>所以，学习编程，需要多写代码，没有途径可走。</p>\n</li>\n<li><p>时刻注意代码规范</p>\n<p>在我们学习时，一定要养成良好的编程习惯，例如适当的编写注释，定义变量名称时不要随意使用无意义的字符。</p>\n</li>\n<li><p>开发经验必不可少</p>\n</li>\n</ul>\n<p>当你熟练的掌握一门编程语言的语法时，你还需要大中型产品的开发经验，它会让你学得更多，简而言之站得更高，看得更远。</p>\n<p><img src=\"/2019/08/29/Python-01-Python教程基础/Python知识体系框架.png\" alt=\"Python知识体系图\"></p>\n<h1 id=\"Python-2-x和Python-3-x，初学者应该如何选择？\"><a href=\"#Python-2-x和Python-3-x，初学者应该如何选择？\" class=\"headerlink\" title=\"Python 2.x和Python 3.x，初学者应该如何选择？\"></a>Python 2.x和Python 3.x，初学者应该如何选择？</h1><p>推荐选择Python 3.x，因为Python将在2020不再更新Python 2.x，并且Python 3.x比Python 2.x 具有更多的特性与功能。</p>\n<p>这里只是推荐，详细看Python3和Python2的区别可以看这本:<a href=\"http://c.biancheng.net/view/4147.html\" target=\"_blank\" rel=\"noopener\">📖《Python3和Python2的区别》</a></p>\n<h1 id=\"Python版本区别，Python3和Python2区别详解\"><a href=\"#Python版本区别，Python3和Python2区别详解\" class=\"headerlink\" title=\"Python版本区别，Python3和Python2区别详解\"></a>Python版本区别，Python3和Python2区别详解</h1><p>学习完基础再来…暂时未编写😅</p>\n<p>不过可以知道的是，Python3相比与Python2在<code>语句输出、编码、运算和异常等</code>方面做出了调整。</p>\n<h1 id=\"Python2to3-自动将Python2-x代码转换成Python3-x代码\"><a href=\"#Python2to3-自动将Python2-x代码转换成Python3-x代码\" class=\"headerlink\" title=\"Python2to3 自动将Python2.x代码转换成Python3.x代码\"></a>Python2to3 自动将Python2.x代码转换成Python3.x代码</h1><p>学习完基础再来…暂时未编写😅</p>\n<p>学完完基础再来…暂时未编写</p>\n<h1 id=\"Python-PEP-及时追踪Python最新变化\"><a href=\"#Python-PEP-及时追踪Python最新变化\" class=\"headerlink\" title=\"Python PEP 及时追踪Python最新变化\"></a>Python PEP 及时追踪Python最新变化</h1><p>为了追踪Python的更新动态，我们需要借助Python PEP 文档</p>\n<blockquote>\n<p>Python PEP文档</p>\n</blockquote>\n<p>Python语法修改方案是由<code>邮件列表</code>的形式进行讨论，但Python的PEP文档发布了，新的变化才会生效。</p>\n<p><code>PEP(Python Enhancement Proposal)</code>，中译为<code>Python改进方案</code>。它主要由三个用途</p>\n<ul>\n<li><p>通知: 汇总Python核心开发者重要信息</p>\n</li>\n<li><p>标准化: 提供代码风格，文档或者其他指导意见</p>\n</li>\n<li><p>设计: 对提交的新功能进行说明</p>\n</li>\n</ul>\n<p>如果想要查看提交的<code>PEP</code>历史，可以点击这里:<a href=\"https://www.python.org/dev/peps/\" target=\"_blank\" rel=\"noopener\">PEP0文档</a></p>\n<h1 id=\"Python底层是用什么语言实现的\"><a href=\"#Python底层是用什么语言实现的\" class=\"headerlink\" title=\"Python底层是用什么语言实现的\"></a>Python底层是用什么语言实现的</h1><p>大多数讨论的Python，所指的是CPython，它是用C语言编写的。</p>\n<p>不仅有用C语言编写的Python也有用其他语法编写的Python。</p>\n<p>不同语言实现Python的的原因，大部分是为了解决某些实际问题而创建的，例如：</p>\n<ul>\n<li><p>在嵌入式系统中运行Python代码</p>\n</li>\n<li><p>在运行框架(Java/.NET)或其他语言做代码集成。</p>\n</li>\n<li><p>在Web浏览器中运行Python代码</p>\n</li>\n</ul>\n<p>以上所述使用CPython需要花费开发者大量精力也很难实现，所以才有了各种实现方式的Python.</p>\n<blockquote>\n<p>Stackless Python</p>\n</blockquote>\n<p><code>Stackless Python</code>自称为Python增强版，它没有依赖C语言的调用栈。</p>\n<p>其新添加的功能最重要的是:解释器管理的微线程</p>\n<p>支持版本是2.7.9和3.3.5，Stackless Python的所有额外功能都是内置stackiess模块内的框架。</p>\n<blockquote>\n<p>JPython</p>\n</blockquote>\n<p>由Java实现的Python。它将代码编译为Java字节码，开发者可以在Pyton模块中无缝使用Java类</p>\n<p>JPython与CPython的主要区别:</p>\n<ul>\n<li><p>真正的Java垃圾回收机制</p>\n</li>\n<li><p>没有<code>全局解释器锁(GlobalInterpreter Lock,GIL)</code>，在多线程应用中可以充分利用多个内核</p>\n</li>\n</ul>\n<p>支持版本: 2.7</p>\n<p>缺点: 缺少对C/Python扩展API的支持，预计JPython3.x支持C/Python扩展API</p>\n<blockquote>\n<p>IronPython</p>\n</blockquote>\n<p>IronPython将Python引入至.NET框架中。</p>\n<p>支持版本: 2.7.5</p>\n<p>缺点: 类似JPython</p>\n<p>相比于CPython的优点:</p>\n<ul>\n<li><p>没有全局解释器锁</p>\n</li>\n<li><p>用.NET语言家族编写的代码可以轻松集成到IronPython中，反之亦然。</p>\n</li>\n<li><p>通过<code>Silverlight</code>，在所有主流Web浏览器中都可运行。</p>\n</li>\n</ul>\n<blockquote>\n<p>PyPy</p>\n</blockquote>\n<p>社区内呼声最高的Python实现，它是由Python重写的Python。</p>\n<p>支持版本: 2.7完全兼容,PyPy3与3.25完全兼容</p>\n<p>PyPy与CPython实现的主要区别:</p>\n<ul>\n<li><p>使用垃圾回收</p>\n</li>\n<li><p>集成跟踪JIT编译器，可以提高性能</p>\n</li>\n<li><p>借鉴Stackless Python在应用层的无栈特性。</p>\n</li>\n</ul>\n<p>缺点: 对C/Python扩展API不完善，但为CPyExt子系统C扩展提供了某种程度的支持。</p>\n<h1 id=\"了解Jupyter-Notebook，你已然超越了90-的Python程序员\"><a href=\"#了解Jupyter-Notebook，你已然超越了90-的Python程序员\" class=\"headerlink\" title=\"了解Jupyter Notebook，你已然超越了90%的Python程序员\"></a>了解Jupyter Notebook，你已然超越了90%的Python程序员</h1><p>简单介绍下，Jupyter Notebook就是个整合了代码、计算输出、解释文档、多媒体资源的多功能科学运行平台。</p>\n<p>去看原文吧，这个知道有这个东西，以后再去学习。</p>\n<p><a href=\"http://c.biancheng.net/view/5279.html\" target=\"_blank\" rel=\"noopener\">💿原文传送门</a></p>\n","site":{"data":{}},"excerpt":"<p>Python系列第一章笔记，查看Python系列所有文章,请点击 <a href=\"https://evanmeek.github.io/Python/\">💿</a><br></p>","more":"<p></p>\n<h1 id=\"编程语言是什么\"><a href=\"#编程语言是什么\" class=\"headerlink\" title=\"编程语言是什么\"></a>编程语言是什么</h1><p>编程语言中的每个结构，都有固定的使用格式（称之为<code>语法</code>)以及精确的含义（称之为<code>语义</code>）。</p>\n<p>编程语言也分等级，例如C、C++、Java、Ruby等可以称为高级语言，而计算机<code>硬件</code>只能理解一种非常低级的编程语言，<code>机器语言</code>。</p>\n<h1 id=\"解释型语言和编译型语言（两者区别）\"><a href=\"#解释型语言和编译型语言（两者区别）\" class=\"headerlink\" title=\"解释型语言和编译型语言（两者区别）\"></a>解释型语言和编译型语言（两者区别）</h1><blockquote>\n<p>编译型语言</p>\n</blockquote>\n<p>编译型语言是指使用专门的编译器，对特定的操作系统（平台）将源代码一次性“翻译”为可被该操作系统（平台）硬件所执行的机器语言。</p>\n<p>优点：</p>\n<ul>\n<li>编译好后的可执行文件，可以在没有编译器的机器上独立运行。</li>\n<li>程序执行速度快</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>跨平台不友好(如果是不同的平台，需要将源代码在特定的平台重新编译，甚至需要修改代码)</li>\n</ul>\n<blockquote>\n<p>解释型语言</p>\n</blockquote>\n<p>解释型语言由解释器完成将源代码转换成机器语言，在任何平台上必须安装解释器才可以运行，而不同的平台只需要安装解释器，代码不需要修改也可以被解释。</p>\n<p>优点：</p>\n<ul>\n<li>跨平台友好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>执行速度慢</li>\n</ul>\n<h1 id=\"Python是什么，Python简介\"><a href=\"#Python是什么，Python简介\" class=\"headerlink\" title=\"Python是什么，Python简介\"></a>Python是什么，Python简介</h1><blockquote>\n<p>Python历史</p>\n</blockquote>\n<p>1989年，荷兰人<code>Guido van Rossum</code> 创造了Python.</p>\n<p><code>Python</code>最初基于<code>ABC</code>教学语言.</p>\n<blockquote>\n<p>Python简介</p>\n</blockquote>\n<p><code>Python</code>可以和其他语言，如C、C++、Java的模块（方法/函数）轻松的结合在一起，因此<code>Python</code>又被称为“胶水”语言。</p>\n<blockquote>\n<p>Python的设计哲学</p>\n</blockquote>\n<p>优雅、明确、简单。</p>\n<p>有些人说：“人生苦短，我用Python”</p>\n<h1 id=\"Python的特点（优点和缺点）\"><a href=\"#Python的特点（优点和缺点）\" class=\"headerlink\" title=\"Python的特点（优点和缺点）\"></a>Python的特点（优点和缺点）</h1><blockquote>\n<p>简单易学</p>\n</blockquote>\n<p>Python虽然语法格式要求严格，但是语法却很简洁。</p>\n<blockquote>\n<p>开源</p>\n</blockquote>\n<p>Python是开源的，使用Python编写的程序可以做商业用途也不用付费，并且可以让第三方开发者为Python开发提供优秀的功能。</p>\n<blockquote>\n<p>高级语言</p>\n</blockquote>\n<p>在使用Python编写程序时，开发者无需考虑底层细节问题，而专注于编写程序。</p>\n<blockquote>\n<p>解释型语言</p>\n</blockquote>\n<p>可移植性优秀</p>\n<blockquote>\n<p>面向对象</p>\n</blockquote>\n<p>Python既支持面向过程编程，也支持面向对象编程。</p>\n<blockquote>\n<p>强大的功能</p>\n</blockquote>\n<p>Python可以从简单的字符串处理到复杂的3D图形编程，这些借助Python的扩展模块可以轻松完成。</p>\n<blockquote>\n<p>可扩展性</p>\n</blockquote>\n<p>Python具有脚本语言中最丰富和强大的类库，不管是I/O、GUI、网络编程、数据库编程等绝大部应用场景，都可以使用Python内置的类库完成。</p>\n<p>Python可以使用C或C++编写的代码，这样可以一定程度上的弥补执行速度慢的缺点。</p>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<p>速度慢，相比Java、C、C++编写的程序，运行效率都要慢。<br>源代码加密困难，由于是解释型语言，不像编译型语言那样会被编译成各种目标程序，所以加密困难。</p>\n<h1 id=\"学Python，不需要有编程基础\"><a href=\"#学Python，不需要有编程基础\" class=\"headerlink\" title=\"学Python，不需要有编程基础\"></a>学Python，不需要有编程基础</h1><p>Python语法简明易懂，不像C++或C语言等语法复杂，并且在学习Python中也不需要太过于专注底层的细节，很多事情解释器都已经帮忙做好了。所以对于零基础的初学者来说，Python非常合适。</p>\n<h1 id=\"Python能干什么，Python的应用领域\"><a href=\"#Python能干什么，Python的应用领域\" class=\"headerlink\" title=\"Python能干什么，Python的应用领域\"></a>Python能干什么，Python的应用领域</h1><blockquote>\n<p>Web应用开发</p>\n</blockquote>\n<p>Python可以通过一些模块，使Python具备HTTP服务器与Python的Web程序之间的通信。</p>\n<p>全球最大的搜索引擎<code>Google</code>，在其搜索系统中就大量的使用Python。</p>\n<p><code>豆瓣</code>也是由Python编写的。</p>\n<blockquote>\n<p>操作系统管理、自动化运维开发</p>\n</blockquote>\n<p>大部分操作系统中，Python都作为标准的系统组件，例如大多数Linux发行版，BSD系、Mac OS X都集成了Python。</p>\n<p>并且相对于Shell脚本来说，无论是可读性、性能、代码重用度以及扩展性方面都要优秀很多。</p>\n<blockquote>\n<p>游戏开发</p>\n</blockquote>\n<p>虽说Python的运行效率不算快，但很多游戏可以用C++编写高性能模块，而用Pyton编写游戏的逻辑。</p>\n<p>例如，<code>文明</code>这款游戏就是使用Python实现的。</p>\n<blockquote>\n<p>编写服务器软件</p>\n</blockquote>\n<p>由于Python对各种网络协议的支持完善，所以经常被用于编写服务器软件以及网络爬虫。</p>\n<blockquote>\n<p>科学计算</p>\n</blockquote>\n<p>Python内置了很多工具，可以让科研人员编写科学计算程序。</p>\n<h1 id=\"怎样学习Python，才能成为Python高手？\"><a href=\"#怎样学习Python，才能成为Python高手？\" class=\"headerlink\" title=\"怎样学习Python，才能成为Python高手？\"></a>怎样学习Python，才能成为Python高手？</h1><blockquote>\n<p>编程语言都是相通的</p>\n</blockquote>\n<p>如果你具备一定的编程基础，接触一门新的编程语言时会发现，不同的编程语言其实是相通的，大多数不同的地方在于语法规则。</p>\n<blockquote>\n<p>Python对初学者友好</p>\n</blockquote>\n<ul>\n<li><p>多实践、积累代码量</p>\n<p>任何编程语言知识都是大量的，如果不在学习编程时就开始练习，那么可能当你学完素有的语法后，却把前面的知识忘得一干二净。</p>\n<p>所以，学习编程，需要多写代码，没有途径可走。</p>\n</li>\n<li><p>时刻注意代码规范</p>\n<p>在我们学习时，一定要养成良好的编程习惯，例如适当的编写注释，定义变量名称时不要随意使用无意义的字符。</p>\n</li>\n<li><p>开发经验必不可少</p>\n</li>\n</ul>\n<p>当你熟练的掌握一门编程语言的语法时，你还需要大中型产品的开发经验，它会让你学得更多，简而言之站得更高，看得更远。</p>\n<p><img src=\"/2019/08/29/Python-01-Python教程基础/Python知识体系框架.png\" alt=\"Python知识体系图\"></p>\n<h1 id=\"Python-2-x和Python-3-x，初学者应该如何选择？\"><a href=\"#Python-2-x和Python-3-x，初学者应该如何选择？\" class=\"headerlink\" title=\"Python 2.x和Python 3.x，初学者应该如何选择？\"></a>Python 2.x和Python 3.x，初学者应该如何选择？</h1><p>推荐选择Python 3.x，因为Python将在2020不再更新Python 2.x，并且Python 3.x比Python 2.x 具有更多的特性与功能。</p>\n<p>这里只是推荐，详细看Python3和Python2的区别可以看这本:<a href=\"http://c.biancheng.net/view/4147.html\" target=\"_blank\" rel=\"noopener\">📖《Python3和Python2的区别》</a></p>\n<h1 id=\"Python版本区别，Python3和Python2区别详解\"><a href=\"#Python版本区别，Python3和Python2区别详解\" class=\"headerlink\" title=\"Python版本区别，Python3和Python2区别详解\"></a>Python版本区别，Python3和Python2区别详解</h1><p>学习完基础再来…暂时未编写😅</p>\n<p>不过可以知道的是，Python3相比与Python2在<code>语句输出、编码、运算和异常等</code>方面做出了调整。</p>\n<h1 id=\"Python2to3-自动将Python2-x代码转换成Python3-x代码\"><a href=\"#Python2to3-自动将Python2-x代码转换成Python3-x代码\" class=\"headerlink\" title=\"Python2to3 自动将Python2.x代码转换成Python3.x代码\"></a>Python2to3 自动将Python2.x代码转换成Python3.x代码</h1><p>学习完基础再来…暂时未编写😅</p>\n<p>学完完基础再来…暂时未编写</p>\n<h1 id=\"Python-PEP-及时追踪Python最新变化\"><a href=\"#Python-PEP-及时追踪Python最新变化\" class=\"headerlink\" title=\"Python PEP 及时追踪Python最新变化\"></a>Python PEP 及时追踪Python最新变化</h1><p>为了追踪Python的更新动态，我们需要借助Python PEP 文档</p>\n<blockquote>\n<p>Python PEP文档</p>\n</blockquote>\n<p>Python语法修改方案是由<code>邮件列表</code>的形式进行讨论，但Python的PEP文档发布了，新的变化才会生效。</p>\n<p><code>PEP(Python Enhancement Proposal)</code>，中译为<code>Python改进方案</code>。它主要由三个用途</p>\n<ul>\n<li><p>通知: 汇总Python核心开发者重要信息</p>\n</li>\n<li><p>标准化: 提供代码风格，文档或者其他指导意见</p>\n</li>\n<li><p>设计: 对提交的新功能进行说明</p>\n</li>\n</ul>\n<p>如果想要查看提交的<code>PEP</code>历史，可以点击这里:<a href=\"https://www.python.org/dev/peps/\" target=\"_blank\" rel=\"noopener\">PEP0文档</a></p>\n<h1 id=\"Python底层是用什么语言实现的\"><a href=\"#Python底层是用什么语言实现的\" class=\"headerlink\" title=\"Python底层是用什么语言实现的\"></a>Python底层是用什么语言实现的</h1><p>大多数讨论的Python，所指的是CPython，它是用C语言编写的。</p>\n<p>不仅有用C语言编写的Python也有用其他语法编写的Python。</p>\n<p>不同语言实现Python的的原因，大部分是为了解决某些实际问题而创建的，例如：</p>\n<ul>\n<li><p>在嵌入式系统中运行Python代码</p>\n</li>\n<li><p>在运行框架(Java/.NET)或其他语言做代码集成。</p>\n</li>\n<li><p>在Web浏览器中运行Python代码</p>\n</li>\n</ul>\n<p>以上所述使用CPython需要花费开发者大量精力也很难实现，所以才有了各种实现方式的Python.</p>\n<blockquote>\n<p>Stackless Python</p>\n</blockquote>\n<p><code>Stackless Python</code>自称为Python增强版，它没有依赖C语言的调用栈。</p>\n<p>其新添加的功能最重要的是:解释器管理的微线程</p>\n<p>支持版本是2.7.9和3.3.5，Stackless Python的所有额外功能都是内置stackiess模块内的框架。</p>\n<blockquote>\n<p>JPython</p>\n</blockquote>\n<p>由Java实现的Python。它将代码编译为Java字节码，开发者可以在Pyton模块中无缝使用Java类</p>\n<p>JPython与CPython的主要区别:</p>\n<ul>\n<li><p>真正的Java垃圾回收机制</p>\n</li>\n<li><p>没有<code>全局解释器锁(GlobalInterpreter Lock,GIL)</code>，在多线程应用中可以充分利用多个内核</p>\n</li>\n</ul>\n<p>支持版本: 2.7</p>\n<p>缺点: 缺少对C/Python扩展API的支持，预计JPython3.x支持C/Python扩展API</p>\n<blockquote>\n<p>IronPython</p>\n</blockquote>\n<p>IronPython将Python引入至.NET框架中。</p>\n<p>支持版本: 2.7.5</p>\n<p>缺点: 类似JPython</p>\n<p>相比于CPython的优点:</p>\n<ul>\n<li><p>没有全局解释器锁</p>\n</li>\n<li><p>用.NET语言家族编写的代码可以轻松集成到IronPython中，反之亦然。</p>\n</li>\n<li><p>通过<code>Silverlight</code>，在所有主流Web浏览器中都可运行。</p>\n</li>\n</ul>\n<blockquote>\n<p>PyPy</p>\n</blockquote>\n<p>社区内呼声最高的Python实现，它是由Python重写的Python。</p>\n<p>支持版本: 2.7完全兼容,PyPy3与3.25完全兼容</p>\n<p>PyPy与CPython实现的主要区别:</p>\n<ul>\n<li><p>使用垃圾回收</p>\n</li>\n<li><p>集成跟踪JIT编译器，可以提高性能</p>\n</li>\n<li><p>借鉴Stackless Python在应用层的无栈特性。</p>\n</li>\n</ul>\n<p>缺点: 对C/Python扩展API不完善，但为CPyExt子系统C扩展提供了某种程度的支持。</p>\n<h1 id=\"了解Jupyter-Notebook，你已然超越了90-的Python程序员\"><a href=\"#了解Jupyter-Notebook，你已然超越了90-的Python程序员\" class=\"headerlink\" title=\"了解Jupyter Notebook，你已然超越了90%的Python程序员\"></a>了解Jupyter Notebook，你已然超越了90%的Python程序员</h1><p>简单介绍下，Jupyter Notebook就是个整合了代码、计算输出、解释文档、多媒体资源的多功能科学运行平台。</p>\n<p>去看原文吧，这个知道有这个东西，以后再去学习。</p>\n<p><a href=\"http://c.biancheng.net/view/5279.html\" target=\"_blank\" rel=\"noopener\">💿原文传送门</a></p>"},{"title":"[Python-02]Python初探","copyright":true,"date":"2019-08-29T03:52:56.000Z","_content":"\nPython系列第二章笔记，查看Python系列所有文章，请点击[💿](https://evanmeek.github.io/Python/)\n\n<!--more-->\n\n# Mac安装Python环境\n\n由于我目前的设备只有一台Mac Book，所以我就只记录Mac安装Python的过程。\n\n最新的Mac OS X以及集成了Python 2，打开终端(Terminal)输入:`python`检查是否已安装\n\n![Python2运行](Python-02-Python初探/python2运行.png)\n\n安装Python3可以在这个页面进行下载:[💿Python下载页面](https://www.python.org/downloads/)\n\n# python不是内部或外部命令的解决方法\n\n由于这个问题只有Windows才会出现，所以遇到问题的话，去看下原文吧[💿点我看原文解决方案](http://c.biancheng.net/view/4171.html)\n\n# 第一个Python程序\n\n打开终端，输入`python3`命令，进入交互式解释器\n\n~~~\nprint(\"hello,world!\")\n~~~\n即可输出包括在双引号之间的字符\n\n注意点:\n\n- 小括号与双引号必须在英文半角状态下输入\n\n- print必须全部为小写\n\n> 文本编辑器编写并执行Python程序\n\n可以使用Vim编辑器编写Python源代码，然后终端中执行\n\n注意点:\n\n- 不要使用Word或Windows的记事本程序编写Python源码，因为这两款软件会为源代码添加隐藏符号，而这些符号不被Python所解释，程序将会报错。\n\n# Python交互式解释器及用法\n\n交互式解释器是为了让开发者快速学习、则是Python的功能。\n\n在终端内执行`python`命令即可打开\n\n![python3运行](Python-02-Python初探/python3运行.png)\n\n其中`>>>`提示符，我们写的命令都是能被python解释器所执行的Python命令，如果输入的内容没有定义，那么解释器将会报错。\n\n# IDE(集成开发环境)是什么\n\n`IDE(Intergreated Development Environment)`,用来辅助开发者开发的应用软件。\n\n集成开发环境是一些列开发工具的组合套装，例如我们编写Python程序，不仅需要解释器，而且还需要一些辅助工具，例如:语言编辑器、自动构建工具、除错器。\n\n# Python IDE有哪些，哪款适合初学者？\n\n首先说明，合适自己的才是最好的。\n\n> PyCharm\n\n由JetBrains公司开发的Python开发工具\n\n优点:\n\n- 跨平台\n\n- 支持语法高粱、项目代码管理、智能提示、自动完成、调试、单元测试、版本控制等\n\n- 支持Django Web开发框架\n\n- 社区版本免费\n\n缺点:\n\n- 软件较大，比较重\n\n- 专业版，收费\n\n> Microsoft Visual Studio\n\n由微软开发用于进行C#和.NET等应用的开发工具，简称VS。\n\n要让VS支持Python，需要安装`PTVS`插件。\n\n优点:\n\n- PTVS插件开源\n\n- 支持编辑、浏览、智能感知、混合Python/C++调试、Django\n\n缺点:\n\n- 不跨平台，只支持Windows\n\n- 软件较大，比较重\n\n- 非学生收费\n\n# Python IDLE使用方法详解\n\n由于本人不使用IDLE作为我的Python开发工具，所以这里就不提了。\n\n想了解的，看原文[💿点击查看原文](http://c.biancheng.net/view/4221.html)\n\n# Python注释(多行注释和单行注释)\n\n注释是写给人看的，是用来用自然语言解释代码给开发者看的。\n\n注释不被解释器所执行。\n\nPython允许在任何地方差人注释和字符串，除了在标志符和字符串之间。\n\nPython中有三种注释分别是:\n\n> 单行注释\n\n语法格式\n~~~\n# 注释内容\n~~~\n\n单行注释所在位置可以是代码的上一行，可以是当前行的末尾。\n\n> Python多行注释\n\n语法格式\n\n~~~\n```\n注释内容\n```\n~~~\n\n多行注释使用三个成对的`单引号`或三个成对的`双引号`作为多行注释块\n\n通常用法: 为Python文件、模块、类或者函数等添加版权、功能描述等信息。\n\n注意事项: 若多行注释作为语句的一部分(在语句中)将不会被认为是多行注释，而是Python字符串的标志。\n\n> Python中文编码声明注释\n\n在Python2.x中，不支持在源码中直接写中文。所以如果需要加入中文，必须在行首加上以下注释:\n\n~~~\n# coding=utf-8\n~~~\n\nPython3.x不需要\n\n# Python缩进规则(包含快捷键)\n\nPython采用代码缩进和冒号来区分代码块之间的层次\n\n在Python中，类定义、函数定义、流程控制语句、异常处理语句等，行位的冒号代表代码块的开始，而同一个代码块内部代码的缩紧格式必须相同（不然Python不能知道当前代码块何时结束)，否则会出现SyntaxError\n\n# Python编码规范\n\n这里所提到的规范都是PEP8所定义的。\n\n需要严格遵守的代码编写规范:\n\n- 每个import语句只导入一个模块\n\n~~~\n# 推荐\nimport os\nimport sys\n\n# 避免\nimport os sys\n~~~\n\n- 不在行尾添加分号，一行只放一条语句\n\n~~~\n# 避免\nheight = float(input(\"input height:\")); weight=float(input(\"input weight\"));\n~~~\n\n- 单行不超过80个字符，如果超过可以使用小括号将多行内容隐式的连接。\n\n~~~\n# 推荐\ntext=(\"aaaaaaaaaaaaaaaaaaaaaaaa\"\n\"bbbbbbbbb\")\n~~~\n\n- 适当使用空行，增加代码可读性\n\n- 适当使用空格分隔运算符之间，函数之间，以及逗号两侧。\n\n[💿PEP 8官方介绍](https://www.python.org/dev/peps/pep-0008/)\n\n# Python标识符命名规范\n\nPython标识符规范:\n\n- 由字母、下划线、数字组成，但首字符不能为数字。\n\n- 不能与Python内置的关键字相同，例如我们前面提到的import就是Python关键字。\n\n- Python中，标识符的命名区分字母大小写。\n\n- Python的标识符前后具有下划线代表由特殊意义。\n\n推荐命名规范(不遵守此规范程序不会无法运行，但这基本是行业标准):\n\n- 标识模块名时，尽量短小，由下划线分割标识符单词。\n\n- 标识包名时，尽量短小，由英文句号作为分割。\n\n- 标识类名时，单词首字母大写。\n\n- 函数名、类属性，方法名，使用小写，多个单词之间使用下划线\n\n# 编码规范的重要性\n\n编码的规范是为了提高开发效率。\n\n我们编码时需要遵守准则: 阅读者 > 编程者 > 机器\n\n# Python关键字(保留字)\n\nPython关键字是Python内置的单词，其被赋予特殊的意义。\n\n所有的关键字表如下:\n\n| 关键字表 |      |        |          |        |          |\n|----------|------|--------|----------|--------|----------|\n| and      | as   | assert | break    | class  | continue |\n| def      | del  | elif   | else     | except | finally  |\n| for      | from | False  | globl    | if     | import   |\n| in       | is   | lambda | nonlocal | not    | None     |\n| or       | pass | raise  | return   | try    | True     |\n| while    | with | yield  |\n\n# Python内置函数\n\nPython具有内置函数，可由开发者直接调用。\n\n有关内置函数的用法和解释可由访问[💿Python内置函数]进行查看.\n","source":"_posts/Python-02-Python初探.md","raw":"---\ntitle: '[Python-02]Python初探'\ncopyright: true\ndate: 2019-08-29 11:52:56\ncategories: Python\ntags:\n  - Python系列\n---\n\nPython系列第二章笔记，查看Python系列所有文章，请点击[💿](https://evanmeek.github.io/Python/)\n\n<!--more-->\n\n# Mac安装Python环境\n\n由于我目前的设备只有一台Mac Book，所以我就只记录Mac安装Python的过程。\n\n最新的Mac OS X以及集成了Python 2，打开终端(Terminal)输入:`python`检查是否已安装\n\n![Python2运行](Python-02-Python初探/python2运行.png)\n\n安装Python3可以在这个页面进行下载:[💿Python下载页面](https://www.python.org/downloads/)\n\n# python不是内部或外部命令的解决方法\n\n由于这个问题只有Windows才会出现，所以遇到问题的话，去看下原文吧[💿点我看原文解决方案](http://c.biancheng.net/view/4171.html)\n\n# 第一个Python程序\n\n打开终端，输入`python3`命令，进入交互式解释器\n\n~~~\nprint(\"hello,world!\")\n~~~\n即可输出包括在双引号之间的字符\n\n注意点:\n\n- 小括号与双引号必须在英文半角状态下输入\n\n- print必须全部为小写\n\n> 文本编辑器编写并执行Python程序\n\n可以使用Vim编辑器编写Python源代码，然后终端中执行\n\n注意点:\n\n- 不要使用Word或Windows的记事本程序编写Python源码，因为这两款软件会为源代码添加隐藏符号，而这些符号不被Python所解释，程序将会报错。\n\n# Python交互式解释器及用法\n\n交互式解释器是为了让开发者快速学习、则是Python的功能。\n\n在终端内执行`python`命令即可打开\n\n![python3运行](Python-02-Python初探/python3运行.png)\n\n其中`>>>`提示符，我们写的命令都是能被python解释器所执行的Python命令，如果输入的内容没有定义，那么解释器将会报错。\n\n# IDE(集成开发环境)是什么\n\n`IDE(Intergreated Development Environment)`,用来辅助开发者开发的应用软件。\n\n集成开发环境是一些列开发工具的组合套装，例如我们编写Python程序，不仅需要解释器，而且还需要一些辅助工具，例如:语言编辑器、自动构建工具、除错器。\n\n# Python IDE有哪些，哪款适合初学者？\n\n首先说明，合适自己的才是最好的。\n\n> PyCharm\n\n由JetBrains公司开发的Python开发工具\n\n优点:\n\n- 跨平台\n\n- 支持语法高粱、项目代码管理、智能提示、自动完成、调试、单元测试、版本控制等\n\n- 支持Django Web开发框架\n\n- 社区版本免费\n\n缺点:\n\n- 软件较大，比较重\n\n- 专业版，收费\n\n> Microsoft Visual Studio\n\n由微软开发用于进行C#和.NET等应用的开发工具，简称VS。\n\n要让VS支持Python，需要安装`PTVS`插件。\n\n优点:\n\n- PTVS插件开源\n\n- 支持编辑、浏览、智能感知、混合Python/C++调试、Django\n\n缺点:\n\n- 不跨平台，只支持Windows\n\n- 软件较大，比较重\n\n- 非学生收费\n\n# Python IDLE使用方法详解\n\n由于本人不使用IDLE作为我的Python开发工具，所以这里就不提了。\n\n想了解的，看原文[💿点击查看原文](http://c.biancheng.net/view/4221.html)\n\n# Python注释(多行注释和单行注释)\n\n注释是写给人看的，是用来用自然语言解释代码给开发者看的。\n\n注释不被解释器所执行。\n\nPython允许在任何地方差人注释和字符串，除了在标志符和字符串之间。\n\nPython中有三种注释分别是:\n\n> 单行注释\n\n语法格式\n~~~\n# 注释内容\n~~~\n\n单行注释所在位置可以是代码的上一行，可以是当前行的末尾。\n\n> Python多行注释\n\n语法格式\n\n~~~\n```\n注释内容\n```\n~~~\n\n多行注释使用三个成对的`单引号`或三个成对的`双引号`作为多行注释块\n\n通常用法: 为Python文件、模块、类或者函数等添加版权、功能描述等信息。\n\n注意事项: 若多行注释作为语句的一部分(在语句中)将不会被认为是多行注释，而是Python字符串的标志。\n\n> Python中文编码声明注释\n\n在Python2.x中，不支持在源码中直接写中文。所以如果需要加入中文，必须在行首加上以下注释:\n\n~~~\n# coding=utf-8\n~~~\n\nPython3.x不需要\n\n# Python缩进规则(包含快捷键)\n\nPython采用代码缩进和冒号来区分代码块之间的层次\n\n在Python中，类定义、函数定义、流程控制语句、异常处理语句等，行位的冒号代表代码块的开始，而同一个代码块内部代码的缩紧格式必须相同（不然Python不能知道当前代码块何时结束)，否则会出现SyntaxError\n\n# Python编码规范\n\n这里所提到的规范都是PEP8所定义的。\n\n需要严格遵守的代码编写规范:\n\n- 每个import语句只导入一个模块\n\n~~~\n# 推荐\nimport os\nimport sys\n\n# 避免\nimport os sys\n~~~\n\n- 不在行尾添加分号，一行只放一条语句\n\n~~~\n# 避免\nheight = float(input(\"input height:\")); weight=float(input(\"input weight\"));\n~~~\n\n- 单行不超过80个字符，如果超过可以使用小括号将多行内容隐式的连接。\n\n~~~\n# 推荐\ntext=(\"aaaaaaaaaaaaaaaaaaaaaaaa\"\n\"bbbbbbbbb\")\n~~~\n\n- 适当使用空行，增加代码可读性\n\n- 适当使用空格分隔运算符之间，函数之间，以及逗号两侧。\n\n[💿PEP 8官方介绍](https://www.python.org/dev/peps/pep-0008/)\n\n# Python标识符命名规范\n\nPython标识符规范:\n\n- 由字母、下划线、数字组成，但首字符不能为数字。\n\n- 不能与Python内置的关键字相同，例如我们前面提到的import就是Python关键字。\n\n- Python中，标识符的命名区分字母大小写。\n\n- Python的标识符前后具有下划线代表由特殊意义。\n\n推荐命名规范(不遵守此规范程序不会无法运行，但这基本是行业标准):\n\n- 标识模块名时，尽量短小，由下划线分割标识符单词。\n\n- 标识包名时，尽量短小，由英文句号作为分割。\n\n- 标识类名时，单词首字母大写。\n\n- 函数名、类属性，方法名，使用小写，多个单词之间使用下划线\n\n# 编码规范的重要性\n\n编码的规范是为了提高开发效率。\n\n我们编码时需要遵守准则: 阅读者 > 编程者 > 机器\n\n# Python关键字(保留字)\n\nPython关键字是Python内置的单词，其被赋予特殊的意义。\n\n所有的关键字表如下:\n\n| 关键字表 |      |        |          |        |          |\n|----------|------|--------|----------|--------|----------|\n| and      | as   | assert | break    | class  | continue |\n| def      | del  | elif   | else     | except | finally  |\n| for      | from | False  | globl    | if     | import   |\n| in       | is   | lambda | nonlocal | not    | None     |\n| or       | pass | raise  | return   | try    | True     |\n| while    | with | yield  |\n\n# Python内置函数\n\nPython具有内置函数，可由开发者直接调用。\n\n有关内置函数的用法和解释可由访问[💿Python内置函数]进行查看.\n","slug":"Python-02-Python初探","published":1,"updated":"2020-01-19T03:49:51.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocn003romoo5ieqwa9i","content":"<p>Python系列第二章笔记，查看Python系列所有文章，请点击<a href=\"https://evanmeek.github.io/Python/\">💿</a></p>\n<a id=\"more\"></a>\n<h1 id=\"Mac安装Python环境\"><a href=\"#Mac安装Python环境\" class=\"headerlink\" title=\"Mac安装Python环境\"></a>Mac安装Python环境</h1><p>由于我目前的设备只有一台Mac Book，所以我就只记录Mac安装Python的过程。</p>\n<p>最新的Mac OS X以及集成了Python 2，打开终端(Terminal)输入:<code>python</code>检查是否已安装</p>\n<p><img src=\"/2019/08/29/Python-02-Python初探/python2运行.png\" alt=\"Python2运行\"></p>\n<p>安装Python3可以在这个页面进行下载:<a href=\"https://www.python.org/downloads/\" target=\"_blank\" rel=\"noopener\">💿Python下载页面</a></p>\n<h1 id=\"python不是内部或外部命令的解决方法\"><a href=\"#python不是内部或外部命令的解决方法\" class=\"headerlink\" title=\"python不是内部或外部命令的解决方法\"></a>python不是内部或外部命令的解决方法</h1><p>由于这个问题只有Windows才会出现，所以遇到问题的话，去看下原文吧<a href=\"http://c.biancheng.net/view/4171.html\" target=\"_blank\" rel=\"noopener\">💿点我看原文解决方案</a></p>\n<h1 id=\"第一个Python程序\"><a href=\"#第一个Python程序\" class=\"headerlink\" title=\"第一个Python程序\"></a>第一个Python程序</h1><p>打开终端，输入<code>python3</code>命令，进入交互式解释器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;hello,world!&quot;)</span><br></pre></td></tr></table></figure>\n<p>即可输出包括在双引号之间的字符</p>\n<p>注意点:</p>\n<ul>\n<li><p>小括号与双引号必须在英文半角状态下输入</p>\n</li>\n<li><p>print必须全部为小写</p>\n</li>\n</ul>\n<blockquote>\n<p>文本编辑器编写并执行Python程序</p>\n</blockquote>\n<p>可以使用Vim编辑器编写Python源代码，然后终端中执行</p>\n<p>注意点:</p>\n<ul>\n<li>不要使用Word或Windows的记事本程序编写Python源码，因为这两款软件会为源代码添加隐藏符号，而这些符号不被Python所解释，程序将会报错。</li>\n</ul>\n<h1 id=\"Python交互式解释器及用法\"><a href=\"#Python交互式解释器及用法\" class=\"headerlink\" title=\"Python交互式解释器及用法\"></a>Python交互式解释器及用法</h1><p>交互式解释器是为了让开发者快速学习、则是Python的功能。</p>\n<p>在终端内执行<code>python</code>命令即可打开</p>\n<p><img src=\"/2019/08/29/Python-02-Python初探/python3运行.png\" alt=\"python3运行\"></p>\n<p>其中<code>&gt;&gt;&gt;</code>提示符，我们写的命令都是能被python解释器所执行的Python命令，如果输入的内容没有定义，那么解释器将会报错。</p>\n<h1 id=\"IDE-集成开发环境-是什么\"><a href=\"#IDE-集成开发环境-是什么\" class=\"headerlink\" title=\"IDE(集成开发环境)是什么\"></a>IDE(集成开发环境)是什么</h1><p><code>IDE(Intergreated Development Environment)</code>,用来辅助开发者开发的应用软件。</p>\n<p>集成开发环境是一些列开发工具的组合套装，例如我们编写Python程序，不仅需要解释器，而且还需要一些辅助工具，例如:语言编辑器、自动构建工具、除错器。</p>\n<h1 id=\"Python-IDE有哪些，哪款适合初学者？\"><a href=\"#Python-IDE有哪些，哪款适合初学者？\" class=\"headerlink\" title=\"Python IDE有哪些，哪款适合初学者？\"></a>Python IDE有哪些，哪款适合初学者？</h1><p>首先说明，合适自己的才是最好的。</p>\n<blockquote>\n<p>PyCharm</p>\n</blockquote>\n<p>由JetBrains公司开发的Python开发工具</p>\n<p>优点:</p>\n<ul>\n<li><p>跨平台</p>\n</li>\n<li><p>支持语法高粱、项目代码管理、智能提示、自动完成、调试、单元测试、版本控制等</p>\n</li>\n<li><p>支持Django Web开发框架</p>\n</li>\n<li><p>社区版本免费</p>\n</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li><p>软件较大，比较重</p>\n</li>\n<li><p>专业版，收费</p>\n</li>\n</ul>\n<blockquote>\n<p>Microsoft Visual Studio</p>\n</blockquote>\n<p>由微软开发用于进行C#和.NET等应用的开发工具，简称VS。</p>\n<p>要让VS支持Python，需要安装<code>PTVS</code>插件。</p>\n<p>优点:</p>\n<ul>\n<li><p>PTVS插件开源</p>\n</li>\n<li><p>支持编辑、浏览、智能感知、混合Python/C++调试、Django</p>\n</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li><p>不跨平台，只支持Windows</p>\n</li>\n<li><p>软件较大，比较重</p>\n</li>\n<li><p>非学生收费</p>\n</li>\n</ul>\n<h1 id=\"Python-IDLE使用方法详解\"><a href=\"#Python-IDLE使用方法详解\" class=\"headerlink\" title=\"Python IDLE使用方法详解\"></a>Python IDLE使用方法详解</h1><p>由于本人不使用IDLE作为我的Python开发工具，所以这里就不提了。</p>\n<p>想了解的，看原文<a href=\"http://c.biancheng.net/view/4221.html\" target=\"_blank\" rel=\"noopener\">💿点击查看原文</a></p>\n<h1 id=\"Python注释-多行注释和单行注释\"><a href=\"#Python注释-多行注释和单行注释\" class=\"headerlink\" title=\"Python注释(多行注释和单行注释)\"></a>Python注释(多行注释和单行注释)</h1><p>注释是写给人看的，是用来用自然语言解释代码给开发者看的。</p>\n<p>注释不被解释器所执行。</p>\n<p>Python允许在任何地方差人注释和字符串，除了在标志符和字符串之间。</p>\n<p>Python中有三种注释分别是:</p>\n<blockquote>\n<p>单行注释</p>\n</blockquote>\n<p>语法格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 注释内容</span><br></pre></td></tr></table></figure></p>\n<p>单行注释所在位置可以是代码的上一行，可以是当前行的末尾。</p>\n<blockquote>\n<p>Python多行注释</p>\n</blockquote>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">注释内容</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>多行注释使用三个成对的<code>单引号</code>或三个成对的<code>双引号</code>作为多行注释块</p>\n<p>通常用法: 为Python文件、模块、类或者函数等添加版权、功能描述等信息。</p>\n<p>注意事项: 若多行注释作为语句的一部分(在语句中)将不会被认为是多行注释，而是Python字符串的标志。</p>\n<blockquote>\n<p>Python中文编码声明注释</p>\n</blockquote>\n<p>在Python2.x中，不支持在源码中直接写中文。所以如果需要加入中文，必须在行首加上以下注释:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding=utf-8</span><br></pre></td></tr></table></figure>\n<p>Python3.x不需要</p>\n<h1 id=\"Python缩进规则-包含快捷键\"><a href=\"#Python缩进规则-包含快捷键\" class=\"headerlink\" title=\"Python缩进规则(包含快捷键)\"></a>Python缩进规则(包含快捷键)</h1><p>Python采用代码缩进和冒号来区分代码块之间的层次</p>\n<p>在Python中，类定义、函数定义、流程控制语句、异常处理语句等，行位的冒号代表代码块的开始，而同一个代码块内部代码的缩紧格式必须相同（不然Python不能知道当前代码块何时结束)，否则会出现SyntaxError</p>\n<h1 id=\"Python编码规范\"><a href=\"#Python编码规范\" class=\"headerlink\" title=\"Python编码规范\"></a>Python编码规范</h1><p>这里所提到的规范都是PEP8所定义的。</p>\n<p>需要严格遵守的代码编写规范:</p>\n<ul>\n<li>每个import语句只导入一个模块</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 推荐</span><br><span class=\"line\">import os</span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\"># 避免</span><br><span class=\"line\">import os sys</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不在行尾添加分号，一行只放一条语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 避免</span><br><span class=\"line\">height = float(input(&quot;input height:&quot;)); weight=float(input(&quot;input weight&quot;));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单行不超过80个字符，如果超过可以使用小括号将多行内容隐式的连接。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 推荐</span><br><span class=\"line\">text=(&quot;aaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class=\"line\">&quot;bbbbbbbbb&quot;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>适当使用空行，增加代码可读性</p>\n</li>\n<li><p>适当使用空格分隔运算符之间，函数之间，以及逗号两侧。</p>\n</li>\n</ul>\n<p><a href=\"https://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"noopener\">💿PEP 8官方介绍</a></p>\n<h1 id=\"Python标识符命名规范\"><a href=\"#Python标识符命名规范\" class=\"headerlink\" title=\"Python标识符命名规范\"></a>Python标识符命名规范</h1><p>Python标识符规范:</p>\n<ul>\n<li><p>由字母、下划线、数字组成，但首字符不能为数字。</p>\n</li>\n<li><p>不能与Python内置的关键字相同，例如我们前面提到的import就是Python关键字。</p>\n</li>\n<li><p>Python中，标识符的命名区分字母大小写。</p>\n</li>\n<li><p>Python的标识符前后具有下划线代表由特殊意义。</p>\n</li>\n</ul>\n<p>推荐命名规范(不遵守此规范程序不会无法运行，但这基本是行业标准):</p>\n<ul>\n<li><p>标识模块名时，尽量短小，由下划线分割标识符单词。</p>\n</li>\n<li><p>标识包名时，尽量短小，由英文句号作为分割。</p>\n</li>\n<li><p>标识类名时，单词首字母大写。</p>\n</li>\n<li><p>函数名、类属性，方法名，使用小写，多个单词之间使用下划线</p>\n</li>\n</ul>\n<h1 id=\"编码规范的重要性\"><a href=\"#编码规范的重要性\" class=\"headerlink\" title=\"编码规范的重要性\"></a>编码规范的重要性</h1><p>编码的规范是为了提高开发效率。</p>\n<p>我们编码时需要遵守准则: 阅读者 &gt; 编程者 &gt; 机器</p>\n<h1 id=\"Python关键字-保留字\"><a href=\"#Python关键字-保留字\" class=\"headerlink\" title=\"Python关键字(保留字)\"></a>Python关键字(保留字)</h1><p>Python关键字是Python内置的单词，其被赋予特殊的意义。</p>\n<p>所有的关键字表如下:</p>\n<table>\n<thead>\n<tr>\n<th>关键字表</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>as</td>\n<td>assert</td>\n<td>break</td>\n<td>class</td>\n<td>continue</td>\n</tr>\n<tr>\n<td>def</td>\n<td>del</td>\n<td>elif</td>\n<td>else</td>\n<td>except</td>\n<td>finally</td>\n</tr>\n<tr>\n<td>for</td>\n<td>from</td>\n<td>False</td>\n<td>globl</td>\n<td>if</td>\n<td>import</td>\n</tr>\n<tr>\n<td>in</td>\n<td>is</td>\n<td>lambda</td>\n<td>nonlocal</td>\n<td>not</td>\n<td>None</td>\n</tr>\n<tr>\n<td>or</td>\n<td>pass</td>\n<td>raise</td>\n<td>return</td>\n<td>try</td>\n<td>True</td>\n</tr>\n<tr>\n<td>while</td>\n<td>with</td>\n<td>yield</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Python内置函数\"><a href=\"#Python内置函数\" class=\"headerlink\" title=\"Python内置函数\"></a>Python内置函数</h1><p>Python具有内置函数，可由开发者直接调用。</p>\n<p>有关内置函数的用法和解释可由访问[💿Python内置函数]进行查看.</p>\n","site":{"data":{}},"excerpt":"<p>Python系列第二章笔记，查看Python系列所有文章，请点击<a href=\"https://evanmeek.github.io/Python/\">💿</a></p>","more":"<h1 id=\"Mac安装Python环境\"><a href=\"#Mac安装Python环境\" class=\"headerlink\" title=\"Mac安装Python环境\"></a>Mac安装Python环境</h1><p>由于我目前的设备只有一台Mac Book，所以我就只记录Mac安装Python的过程。</p>\n<p>最新的Mac OS X以及集成了Python 2，打开终端(Terminal)输入:<code>python</code>检查是否已安装</p>\n<p><img src=\"/2019/08/29/Python-02-Python初探/python2运行.png\" alt=\"Python2运行\"></p>\n<p>安装Python3可以在这个页面进行下载:<a href=\"https://www.python.org/downloads/\" target=\"_blank\" rel=\"noopener\">💿Python下载页面</a></p>\n<h1 id=\"python不是内部或外部命令的解决方法\"><a href=\"#python不是内部或外部命令的解决方法\" class=\"headerlink\" title=\"python不是内部或外部命令的解决方法\"></a>python不是内部或外部命令的解决方法</h1><p>由于这个问题只有Windows才会出现，所以遇到问题的话，去看下原文吧<a href=\"http://c.biancheng.net/view/4171.html\" target=\"_blank\" rel=\"noopener\">💿点我看原文解决方案</a></p>\n<h1 id=\"第一个Python程序\"><a href=\"#第一个Python程序\" class=\"headerlink\" title=\"第一个Python程序\"></a>第一个Python程序</h1><p>打开终端，输入<code>python3</code>命令，进入交互式解释器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;hello,world!&quot;)</span><br></pre></td></tr></table></figure>\n<p>即可输出包括在双引号之间的字符</p>\n<p>注意点:</p>\n<ul>\n<li><p>小括号与双引号必须在英文半角状态下输入</p>\n</li>\n<li><p>print必须全部为小写</p>\n</li>\n</ul>\n<blockquote>\n<p>文本编辑器编写并执行Python程序</p>\n</blockquote>\n<p>可以使用Vim编辑器编写Python源代码，然后终端中执行</p>\n<p>注意点:</p>\n<ul>\n<li>不要使用Word或Windows的记事本程序编写Python源码，因为这两款软件会为源代码添加隐藏符号，而这些符号不被Python所解释，程序将会报错。</li>\n</ul>\n<h1 id=\"Python交互式解释器及用法\"><a href=\"#Python交互式解释器及用法\" class=\"headerlink\" title=\"Python交互式解释器及用法\"></a>Python交互式解释器及用法</h1><p>交互式解释器是为了让开发者快速学习、则是Python的功能。</p>\n<p>在终端内执行<code>python</code>命令即可打开</p>\n<p><img src=\"/2019/08/29/Python-02-Python初探/python3运行.png\" alt=\"python3运行\"></p>\n<p>其中<code>&gt;&gt;&gt;</code>提示符，我们写的命令都是能被python解释器所执行的Python命令，如果输入的内容没有定义，那么解释器将会报错。</p>\n<h1 id=\"IDE-集成开发环境-是什么\"><a href=\"#IDE-集成开发环境-是什么\" class=\"headerlink\" title=\"IDE(集成开发环境)是什么\"></a>IDE(集成开发环境)是什么</h1><p><code>IDE(Intergreated Development Environment)</code>,用来辅助开发者开发的应用软件。</p>\n<p>集成开发环境是一些列开发工具的组合套装，例如我们编写Python程序，不仅需要解释器，而且还需要一些辅助工具，例如:语言编辑器、自动构建工具、除错器。</p>\n<h1 id=\"Python-IDE有哪些，哪款适合初学者？\"><a href=\"#Python-IDE有哪些，哪款适合初学者？\" class=\"headerlink\" title=\"Python IDE有哪些，哪款适合初学者？\"></a>Python IDE有哪些，哪款适合初学者？</h1><p>首先说明，合适自己的才是最好的。</p>\n<blockquote>\n<p>PyCharm</p>\n</blockquote>\n<p>由JetBrains公司开发的Python开发工具</p>\n<p>优点:</p>\n<ul>\n<li><p>跨平台</p>\n</li>\n<li><p>支持语法高粱、项目代码管理、智能提示、自动完成、调试、单元测试、版本控制等</p>\n</li>\n<li><p>支持Django Web开发框架</p>\n</li>\n<li><p>社区版本免费</p>\n</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li><p>软件较大，比较重</p>\n</li>\n<li><p>专业版，收费</p>\n</li>\n</ul>\n<blockquote>\n<p>Microsoft Visual Studio</p>\n</blockquote>\n<p>由微软开发用于进行C#和.NET等应用的开发工具，简称VS。</p>\n<p>要让VS支持Python，需要安装<code>PTVS</code>插件。</p>\n<p>优点:</p>\n<ul>\n<li><p>PTVS插件开源</p>\n</li>\n<li><p>支持编辑、浏览、智能感知、混合Python/C++调试、Django</p>\n</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li><p>不跨平台，只支持Windows</p>\n</li>\n<li><p>软件较大，比较重</p>\n</li>\n<li><p>非学生收费</p>\n</li>\n</ul>\n<h1 id=\"Python-IDLE使用方法详解\"><a href=\"#Python-IDLE使用方法详解\" class=\"headerlink\" title=\"Python IDLE使用方法详解\"></a>Python IDLE使用方法详解</h1><p>由于本人不使用IDLE作为我的Python开发工具，所以这里就不提了。</p>\n<p>想了解的，看原文<a href=\"http://c.biancheng.net/view/4221.html\" target=\"_blank\" rel=\"noopener\">💿点击查看原文</a></p>\n<h1 id=\"Python注释-多行注释和单行注释\"><a href=\"#Python注释-多行注释和单行注释\" class=\"headerlink\" title=\"Python注释(多行注释和单行注释)\"></a>Python注释(多行注释和单行注释)</h1><p>注释是写给人看的，是用来用自然语言解释代码给开发者看的。</p>\n<p>注释不被解释器所执行。</p>\n<p>Python允许在任何地方差人注释和字符串，除了在标志符和字符串之间。</p>\n<p>Python中有三种注释分别是:</p>\n<blockquote>\n<p>单行注释</p>\n</blockquote>\n<p>语法格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 注释内容</span><br></pre></td></tr></table></figure></p>\n<p>单行注释所在位置可以是代码的上一行，可以是当前行的末尾。</p>\n<blockquote>\n<p>Python多行注释</p>\n</blockquote>\n<p>语法格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">注释内容</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>多行注释使用三个成对的<code>单引号</code>或三个成对的<code>双引号</code>作为多行注释块</p>\n<p>通常用法: 为Python文件、模块、类或者函数等添加版权、功能描述等信息。</p>\n<p>注意事项: 若多行注释作为语句的一部分(在语句中)将不会被认为是多行注释，而是Python字符串的标志。</p>\n<blockquote>\n<p>Python中文编码声明注释</p>\n</blockquote>\n<p>在Python2.x中，不支持在源码中直接写中文。所以如果需要加入中文，必须在行首加上以下注释:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding=utf-8</span><br></pre></td></tr></table></figure>\n<p>Python3.x不需要</p>\n<h1 id=\"Python缩进规则-包含快捷键\"><a href=\"#Python缩进规则-包含快捷键\" class=\"headerlink\" title=\"Python缩进规则(包含快捷键)\"></a>Python缩进规则(包含快捷键)</h1><p>Python采用代码缩进和冒号来区分代码块之间的层次</p>\n<p>在Python中，类定义、函数定义、流程控制语句、异常处理语句等，行位的冒号代表代码块的开始，而同一个代码块内部代码的缩紧格式必须相同（不然Python不能知道当前代码块何时结束)，否则会出现SyntaxError</p>\n<h1 id=\"Python编码规范\"><a href=\"#Python编码规范\" class=\"headerlink\" title=\"Python编码规范\"></a>Python编码规范</h1><p>这里所提到的规范都是PEP8所定义的。</p>\n<p>需要严格遵守的代码编写规范:</p>\n<ul>\n<li>每个import语句只导入一个模块</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 推荐</span><br><span class=\"line\">import os</span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\"># 避免</span><br><span class=\"line\">import os sys</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不在行尾添加分号，一行只放一条语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 避免</span><br><span class=\"line\">height = float(input(&quot;input height:&quot;)); weight=float(input(&quot;input weight&quot;));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单行不超过80个字符，如果超过可以使用小括号将多行内容隐式的连接。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 推荐</span><br><span class=\"line\">text=(&quot;aaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class=\"line\">&quot;bbbbbbbbb&quot;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>适当使用空行，增加代码可读性</p>\n</li>\n<li><p>适当使用空格分隔运算符之间，函数之间，以及逗号两侧。</p>\n</li>\n</ul>\n<p><a href=\"https://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"noopener\">💿PEP 8官方介绍</a></p>\n<h1 id=\"Python标识符命名规范\"><a href=\"#Python标识符命名规范\" class=\"headerlink\" title=\"Python标识符命名规范\"></a>Python标识符命名规范</h1><p>Python标识符规范:</p>\n<ul>\n<li><p>由字母、下划线、数字组成，但首字符不能为数字。</p>\n</li>\n<li><p>不能与Python内置的关键字相同，例如我们前面提到的import就是Python关键字。</p>\n</li>\n<li><p>Python中，标识符的命名区分字母大小写。</p>\n</li>\n<li><p>Python的标识符前后具有下划线代表由特殊意义。</p>\n</li>\n</ul>\n<p>推荐命名规范(不遵守此规范程序不会无法运行，但这基本是行业标准):</p>\n<ul>\n<li><p>标识模块名时，尽量短小，由下划线分割标识符单词。</p>\n</li>\n<li><p>标识包名时，尽量短小，由英文句号作为分割。</p>\n</li>\n<li><p>标识类名时，单词首字母大写。</p>\n</li>\n<li><p>函数名、类属性，方法名，使用小写，多个单词之间使用下划线</p>\n</li>\n</ul>\n<h1 id=\"编码规范的重要性\"><a href=\"#编码规范的重要性\" class=\"headerlink\" title=\"编码规范的重要性\"></a>编码规范的重要性</h1><p>编码的规范是为了提高开发效率。</p>\n<p>我们编码时需要遵守准则: 阅读者 &gt; 编程者 &gt; 机器</p>\n<h1 id=\"Python关键字-保留字\"><a href=\"#Python关键字-保留字\" class=\"headerlink\" title=\"Python关键字(保留字)\"></a>Python关键字(保留字)</h1><p>Python关键字是Python内置的单词，其被赋予特殊的意义。</p>\n<p>所有的关键字表如下:</p>\n<table>\n<thead>\n<tr>\n<th>关键字表</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>as</td>\n<td>assert</td>\n<td>break</td>\n<td>class</td>\n<td>continue</td>\n</tr>\n<tr>\n<td>def</td>\n<td>del</td>\n<td>elif</td>\n<td>else</td>\n<td>except</td>\n<td>finally</td>\n</tr>\n<tr>\n<td>for</td>\n<td>from</td>\n<td>False</td>\n<td>globl</td>\n<td>if</td>\n<td>import</td>\n</tr>\n<tr>\n<td>in</td>\n<td>is</td>\n<td>lambda</td>\n<td>nonlocal</td>\n<td>not</td>\n<td>None</td>\n</tr>\n<tr>\n<td>or</td>\n<td>pass</td>\n<td>raise</td>\n<td>return</td>\n<td>try</td>\n<td>True</td>\n</tr>\n<tr>\n<td>while</td>\n<td>with</td>\n<td>yield</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Python内置函数\"><a href=\"#Python内置函数\" class=\"headerlink\" title=\"Python内置函数\"></a>Python内置函数</h1><p>Python具有内置函数，可由开发者直接调用。</p>\n<p>有关内置函数的用法和解释可由访问[💿Python内置函数]进行查看.</p>"},{"title":"[Python-03]Python变量类型和运算符","copyright":true,"date":"2019-08-31T07:03:13.000Z","_content":"Python系列第三章笔记，查看Python系列所有文章，请点击[💿](https://evanmeek.github.io/Python/)\n<!--more-->\n\n__本章重点:Python变量数据类型、运算符。__\n\nPython是弱类型语言。\n\n弱类型含义:\n\n- 所有变量无需声明即可使用。\n\n- 变量的数据类型随时可变。\n\n# Python变量及其使用\n\n变量:\n\n- 数据可发生无数次变化。\n\n- 数据类型可发生变化。\n\n\n常量: 一旦保存数据，则不可修改。\n\n\n赋值运算符: `=`\n\n__type()作用:__查看变量的数据类型\n\n# Python数值类型（整型、浮点型和复数）及其用法\n\nPython中的数值类型都是不可变的。\n\n有些人可能会问，不是不可变么，为什么我定义的int类型变量的值仍然可以变化，那是因为底层实现将新的值存放到新的一块内存中，然后将修改变量指针的指向。\n\n> Python整型\n\n整型是用来表示没有小数部分的数，整数包括：正整数、0、负整数\n\n\nPython整型的四种表示形式：\n\n- 十进制(0-9)\n\n- 二进制(0-1)\n\n- 八进制(0-7)\n\n- 十六进制(0-9-A-F/a-f)\n\n> Python浮点型\n\n浮点型是用来保存带小数的数值，浮点数包括:十进制形式、科学计数形式。\n\n十进制形式的写法:\n\n~~~\nfloat_dex = 1.100111\n~~~\n\n科学计数形式\n\n~~~\nfloat2 = 2e3\n~~~\n\n> Python复数\n\n我跳过了本节，如果读者想看，可以点击进行访问[💿Python复数](http://c.biancheng.net/view/2173.html)\n\n# Python字符串详解(包含长字符串和原始字符串)\n\nPython字符串必须使用引号括起来，可以是单引号也可以是双引号，但必须成对。\n\n如果字符串内仍然包含引号，可以使用以下两种方法解决:\n\n__用另一种成对的引号包括起来__\n\n~~~\nstr1 = \"I'm EvanMeek.\"\n\nstr2 = 'Evan:\"Hello World.\"'\n~~~\n\n__用转义字符进行转义__\n\n~~~\nstr1 = 'I\\'m EvanMeek'\n~~~\n\n转义字符还可以用来转义换行符，应用场景通常是:\n\n__字符串过长，转义换行符，使其不换行__\n\n~~~\nprint(\"mac mac macmac mac macmac mac mac \\\nmac mac macmac mac mac\")\n~~~\n\n> Python长字符串\n\n长字符串常用场景是:\n\n__定义大段文本内容为字符串时__\n\n~~~\nstr1 = ''' \"Fuck you ! Bitch!\",said he.\n\"Mother fuck!\",said she.\n~~~\n\n> Python原始字符串\n\n在Windows下,路径是使用反斜杠作为路径区分的，如果需要将反斜杠转义，那必须再加一个反斜杠，这样非常麻烦，就可以使用下面的案例来解决:\n\n__转义反斜杠写路径__\n\n~~~\npath = 'C:\\\\User\\\\Admin\\\\Desktop'\n~~~\n\n__使用原始字符串写反斜杠__\n\n~~~\npath = r'C:\\User\\Admin\\Desktop'\n~~~\n\n注意: 原始字符串中的引号同样需要使用`\\`进行转义\n\n# Python bytes类型及用法\n\nbytes类型代表了字节串。\n\n字节串与字符串不同的是:\n\n- 字节串是以字节为单位进行操作\n\n- 字节串可直接用于网络通信数据互联\n\n字节串是由多个字节组成的，每个字节由8个bit位组成。\n\n字节串保存的数据都是二进制格式的数据。\n\n字节串可以转换成字符串，而字符串也能恢复成字节串。\n\n> 字节串转换为字符串\n\n__创建字节串__\n\n~~~\n# 创建一个空的bytes\nb1 = bytes()\n# 创建一个空的bytes值\nb2 = b''\n# 创建一个非空的字节串\nb3 = b'hello'\n~~~\n\n__字符串转换为字节串__\n\n~~~\n# 使用encode方法将字符串以utf-8字符集转换为字节串\nb4 = \"I love Python\".encode('utf-8')\n\n# 创建bytes对象时将字符串的字符集指定为'utf-8'，自动转换为字节串\nb5 = bytes('I love Python', encoding='utf-8')\n~~~\n\n> 字节串转换为字符串\n\n~~~\n# 使用字节串对象的方法decode，指定字符集转化字节串\nstr1 = b'I love Python'.decode('utf-8')\n~~~\n\n# Python bool布尔类型\n\nbool变量只有两个值分别是: True,False。它们都是Python的关键字。\n\nTrue代表真\n\nFalse代表假\n\n例如表达式:\n\n~~~\n3 > 5\n~~~\n\n结果是False\n\nPython中所有对象都可以进行真假值的测试。\n\n# Python len()函数详解：获取字符串长度或字节数\n\nlen()函数是Python内置函数，用于获取字符串或字节串的长度（数量）。\n\n例子:\n\n__统计字符串的长度__\n\n~~~\nprint(len(\"Hello World\"))\n~~~\n\n输出结果: 11\n\n__统计字节串的长度__\n\n~~~\nprint(len(\"你好世界\".encode()))\n~~~\n\n输出结果: 12\n\n不同的语言所占的字节数不同，并且不同的编码格式所占的字节数也不同。\n\n例如，汉字使用utf-8编码格式，占用3个字节，中文标点符号使用GBK编码格式占用2个字节。\n\n# Python input()函数：获取用户输入的字符串\n\ninput()是Python的内置函数，其作用是输出一段信息然后请求用户输入，并且将获取的值传入接收的对象。\n\ninput()函数将会把用户输入的任何字符都作为字符串读入。\n\n例子:\n\n~~~\na = input(\"Please input something:\")\nprint(type(a))\n~~~\n\n运行:\n\n~~~\nPlease input something > 19\n<class 'str'>\n~~~\n\n__注意: Python2.x中，要求input()函数读入的内容必须是符合Python语法表达式的。__\n\n例如: 输入字符串时，必须带双引号，否则将会报错。\n\n# Python print()函数的高级用法\n\n> 输出多个参数\n\n例子:\n\n~~~\nname = \"EvanMeek\"\nage = 18\nprint(\"我叫:\", name, \"age\", 18)\n~~~\n\n输出:\n\n~~~\n我叫: EvanMeek age 18\n~~~\n\n> 指定输出多个参数时的分隔符(默认的分割符为空格)\n\n~~~\nname = \"EvanMeek\"\nage = 18\nprint(\"我叫:\", name, \"age\", 18)\nprint(\"我叫:\", name, \"age\", 18, sep='|')\n~~~\n\n结果:\n\n~~~\n我叫: EvanMeek age 18\n我叫:|EvanMeek|age|18\n~~~\n\n> 指定结束符(默认结束符为换行符\\n)\n\n~~~\nprint(10,'\\t',end=\"\")\nprint(11,'\\t',end=\"\")\nprint(12,'\\t',end=\"\")\n~~~\n\n结果:\n\n~~~\n10 \t11 \t12 \t\n~~~\n\n> 指定输出目标(默认输出为标准输出)\n\n~~~\nf = open(\"test.txt\", \"w\")\n\nprint('Just Test', file = f)\n\nf.close()\n~~~\n\n结果: 将 'Just Test' 写入到 tes.txt文件内\n\n# Python格式化字符串(格式化输出)\n\nPython中的格式化字符串可以对各种类型的数据进行格式化输出。\n\n例子:\n\n__格式化输出整型数据__\n\n~~~\nnumber = 100\nprint(\"Number is:%s\" % number)\n~~~\n\n格式化分为三个部分，分别是被包括在双引号内的占位符(`%s`)、以及中间部分的 格式化分隔符(`%`)与对应占位符的变量或表达式(`number`)\n\n`%s`被称为占位符,又可以说是转换说明符(Conversion Specifier)\n\n| 转换说明符 | 说明                                 |\n|------------|--------------------------------------|\n| %d,%i      | 转换为带符号的十进制形式的整数       |\n| %o         | 转换为带符号的八进制形式的整数       |\n| %x,%X      | 转换为带符号的十六进制形式额整数     |\n| %e         | 转换为科学计数法标识的浮点数(e小写)  |\n| %E         | 转换为科学计数法标识的浮点数(E大写)  |\n| %f,%F      | 转换为十进制形式的浮点数             |\n| %g         | 智能选择使用%f或%e格式               |\n| %G         | 智能选择使用%F或%E格式               |\n| %c         | 格式化字符及其ASCII码                |\n| %r         | 使用repr()将变量或表达式转换成字符串 |\n| %s         | 使用str()将变量或表达式转换为字符串  |\n\nPython允许aaaaqaz123在占位符前添加一个标志用来指定对齐：\n\n- `-`(减号) :指定左对齐\n\n- `+`(加号) : 表示数值总要带着符号.\n\n- `0`,表示不补充空格，而是补充0。\n\n例子:\n\n~~~\nprint(\"%06d\" % num2)\n\nprint(\"%+06d\" % num2)\n\nprint(\"%-6d\" % num2)\n~~~\n\n输出结果:\n\n~~~\n000030\n+00030\n30    \n~~~\n\n精度值：用于指定小数点后的数字位数，如果是字符串时指定转换后字符串的最大字符数\n\n# Python转义字符及用法\n\n转义字符是指在指定字符前添加反斜杠`\\`，对特殊的字符进行转义。\n\n表格请点击此链接查看👉[💿Python常用/支持的转义字符\n](http://c.biancheng.net/view/2176.html)\n\n# Python类型转换，Python数据类型转换函数大全\n\nPython身为弱类型编程语言，不需要为变量声明数据类型，但在某些场景下，仍然需要进行类型转换，而Python内置了很多常用数据类型的转换函数，请看下表。\n\n| 函数                  | 作用                                             |\n|-----------------------|--------------------------------------------------|\n| int(x)                | 将x转换成整数类型                                |\n| float(x)              | 将x转换成浮点数类型                              |\n| complex(real,[,imag]) | 创建一个复数                                     |\n| str(x)                | 将x转换成字符串                                  |\n| repr(x)               | 将x转换成表达式字符串                            |\n| eval(str)             | 计算在字符串中的有效Python表达式，并返回一个对象 |\n| chr(x)                | 将整数x转换成一个字符                            |\n| ord(x)                | 将字符x转化成它对应的整数值                      |\n| hex(x)                | 将一个整数x转换成一个十六进制的字符串            |\n| oct(x)                | 将一个整数x转换成一个八进制的字符串              |\n\n使用类型转换函数时，被转换的数据必须是有意义的，例如，在使用int()函数时无法将一个费阿拉伯数字的字符串进行转换。\n\n# Python算术运算符及用法详解\n\n算术运算符用于处理四则运算的符号，在数字的处理中应用得最多。\n\n![Python常用算术运算符](Python-03-Python变量类型和运算符/Python常用算术运算符.png)\n\n> 加法运算符\n\n算术运算例子:\n\n~~~\na = 10\nb = 20\nprint(\"%d\" % (a+b))\n~~~\n\n输出:`30`\n\n字符串拼接例子:\n\n~~~\nhello = \"Hello\"\nworld = \"World\"\nprint(\"%s\" % hello+world)\n~~~\n\n输出:`HelloWorld`\n\n> - 减法运算符\n\n减法算术例子:\n\n~~~\n\na = 10\nb = 5\nprint(\"%d\" % (10-5))\n~~~\n\n输出:`5`\n\n求负算术例子:\n\n~~~\na = 10\na = -a\nprint(a)\n~~~\n\n输出: `-10`\n\n> *乘法运算符\n\n乘法算术例子:\n\n~~~\na =10.5\nprint(a*a)\n~~~\n\n输出:`110.25`\n\n字符串连接例子:\n\n~~~\nstr=\"test \"\nprint(str*3)\n~~~\n\n输出:`test test test `\n\n> /和//除法运算符\n\n普通除法算术例子(除不尽产生小数):\n\n~~~\na = 10\nb = 3\nprint(a/b)\n~~~\n\n输出:`3.3333333333333335`\n\n整除除法算术例子(除不尽舍去小数):\n\n~~~\na = 10\nb = 3\nprint(a//b)\n~~~\n\n输出:`3`\n\n__注意:Python中不可使用0作为除数，否则会引发`ZeroDivisionError`错误__\n\n__注意:Python2.x中没有整除运算符__\n\nPython2.x的的求整除的规则是:\n\n- 当两个操作数都是整数时，`/`作为整除运算符\n\n- 当两个操作数其中一个是浮点数时，`/`作为非整除运算符\n\n> %求余运算符\n\n- Python不需要求余的两个操作数是整数\n\n- Python不允许求余运算的第二个操作数为0\n\n求余运算例子:\n\n~~~\nprint(\"10 % 3 = \",(10%3))\nprint(\"10.5 % 3.5 = \",(10.5%3.5))\n~~~\n\n输出:\n\n~~~\n10 % 3 =  1\n10.5 % 3.5 =  0.0\n~~~\n\n注意:\n\n- 若求余运算第二个操作符为负数，那么结果也一定是负数。\n\n> **乘方运算符\n\n乘方+开方运算例子:\n\n~~~\nprint('5 的 2 次方：', 5 ** 2) # 25\nprint('4 的 3 次方：', 4 ** 3) # 64\nprint('4 的开平方：', 4 ** 0.5) # 2.0\nprint('27 的开 3 次方：',27 **(1 / 3 )) # 3.0\n~~~\n\n输出:\n\n~~~\n5 的 2 次方： 25\n4 的 3 次方： 64\n4 的开平方： 2.0\n27 的开 3 次方： 3.0\n~~~\n\n# Python赋值运算符（入门必读）\n\n赋值运算符常用于将运算符右侧的值赋值给左侧的容器。\n\n> 基本赋值运算符\n\n将赋值运算符右侧的表达式赋值给左侧的容器。\n\n~~~\na = 10\nb = a\nc = a+b\nprint(a,b,c)\n~~~\n\n输出:`10 10 20`\n\n> 扩展后的赋值运算符\n\n`=`赋值运算符与其他运算符结合后，将成为功能更强大的赋值运算符。\n\n![Python常用赋值运算符](Python-03-Python变量类型和运算符/Python常用赋值运算符.png)\n\n# Python位运算符详解\n\n`初学者可暂时跳过本章`\n\n位运算符通常使用场景是：图形、图像处理、创建设备驱动等底层开发。\n\nPython位运算符的操作对象为整数类型，它会把数字看做相应的二进制来进行计算。\n\n![python位运算符](Python-03-Python变量类型和运算符/Python位运算符.png)\n\n> &按位与运算符\n\n有两个操作数\n\n运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为1时，则结果为0，否则为1。\n\n例如:\n\n~~~\na = 10\nb = 5\nprint(bin(a), bin(b), a & b)\n~~~\n\n输出结果:\n\n~~~\n0b1010 0b101 0\n~~~\n\n> |按位或 运算符\n\n`|`是其运算符，具有两个操作数。\n\n运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为0时，则结果才为0，否则为1。\n\n> ^按位异或运算符\n\n`^`是其运算符，具有两个操作数。\n\n运算符法则：按位将两个操作数对应的二进制进行一一对应，对应时，若对应数位都为0或1，则结果为0，否则为1\n\n> ~按位取反运算符\n\n`~`是其运算符，具有1个操作数\n\n运算符法则：将其操作数的二进制进行取反，也就是：原本为0的取反为1，原本为1的取反为0.\n\n其他：原码、反码、补码是什么\n\n- 原码: 将某数值转换为二进制数，若此数值为正数或0则代表可以是无符号的，那么最高位则不需要一个符号位，若为负数则需要一个符号位。\n\n- 反码: 对原码按位取反，但符号位不变。\n\n- 补码: 负数的补码是其反码+1，正数或0的补码与原码相同。\n\n> <<左移运算符\n\n`<<`是其运算符，具有两个操作数\n\n将操作数按补码形式进行整体向左移动。移动后，溢出的丢弃，空出的以0填补。\n\n> \\>\\> 右移运算符\n\n`>>`是其运算符，具有两个擦作数\n\n将操作数按补码形式进行整体向右移动。移动后，溢出的丢弃，空出的以符号位填补。。\n\n# Python比较运算符(关系运算符)\n\n比较运算符又称为关系运算符，其作用是对各种表达式，容器结果进行大小、真假等比较。如果比较结果为真，则返回True(真)否则返回False(假)。\n\n![Python比较运算符表](Python-03-Python变量类型和运算符/Python比较运算符.png)\n\n> 比较运算符 == 和 is区别\n\n== 比较的是值\n\nis 比较的所引用对象的地址\n\n# Python逻辑运算符及其用法\n\n逻辑运算符也是对真假（布尔类型）进行运算符，其返回值也为bool。\n\n![Python比较运算符表](Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png)\n\n# Python三目运算符(三元运算符)用法详解 \n\nPython利用if来实现三目运算符的功能。\n\n语法格式：\n\n~~~\nTrue_statements if expression else False_statements\n~~~\n\n运算法则: 先对`expression`(表达式)求值，如果为True则执行`True_statements`否则执行`False_statements`\n\n例子:\n\n~~~\na = 10\nb = 20\nprint(\"a>b\") if a > b else print(\"a<b\")\n~~~\n\n结果:\n~~~\na<b\n~~~\n\nPython允许在三目运算符的`False_statements`或`True_statements`放置多条语句。\n\n两种放置方式:\n\n- 以英文逗号隔开，将每条语句执行结果，组成元组。\n\n- 以英文分号隔开，只返回一条语句的结果。 \n\n例子:\n\n~~~\na = 20\nb = 20\n\nprint(\"a>b\") if a > b else (print(\"a<b\") if a < b else print(\"a=b\"))\n~~~\n\n结果:\n\n~~~\na = b\n~~~\n\n# Python运算符优先级\n\n不同的运算符有一个优先级，在用于在表达式中进行区别执行顺序。\n\n![Python比较运算符表](Python-03-Python变量类型和运算符/Python运算符优先级.png)\n","source":"_posts/Python-03-Python变量类型和运算符.md","raw":"---\ntitle: '[Python-03]Python变量类型和运算符'\ncopyright: true\ndate: 2019-08-31 15:03:13\ncategories: Python\ntags:\n  - Python系列\n---\nPython系列第三章笔记，查看Python系列所有文章，请点击[💿](https://evanmeek.github.io/Python/)\n<!--more-->\n\n__本章重点:Python变量数据类型、运算符。__\n\nPython是弱类型语言。\n\n弱类型含义:\n\n- 所有变量无需声明即可使用。\n\n- 变量的数据类型随时可变。\n\n# Python变量及其使用\n\n变量:\n\n- 数据可发生无数次变化。\n\n- 数据类型可发生变化。\n\n\n常量: 一旦保存数据，则不可修改。\n\n\n赋值运算符: `=`\n\n__type()作用:__查看变量的数据类型\n\n# Python数值类型（整型、浮点型和复数）及其用法\n\nPython中的数值类型都是不可变的。\n\n有些人可能会问，不是不可变么，为什么我定义的int类型变量的值仍然可以变化，那是因为底层实现将新的值存放到新的一块内存中，然后将修改变量指针的指向。\n\n> Python整型\n\n整型是用来表示没有小数部分的数，整数包括：正整数、0、负整数\n\n\nPython整型的四种表示形式：\n\n- 十进制(0-9)\n\n- 二进制(0-1)\n\n- 八进制(0-7)\n\n- 十六进制(0-9-A-F/a-f)\n\n> Python浮点型\n\n浮点型是用来保存带小数的数值，浮点数包括:十进制形式、科学计数形式。\n\n十进制形式的写法:\n\n~~~\nfloat_dex = 1.100111\n~~~\n\n科学计数形式\n\n~~~\nfloat2 = 2e3\n~~~\n\n> Python复数\n\n我跳过了本节，如果读者想看，可以点击进行访问[💿Python复数](http://c.biancheng.net/view/2173.html)\n\n# Python字符串详解(包含长字符串和原始字符串)\n\nPython字符串必须使用引号括起来，可以是单引号也可以是双引号，但必须成对。\n\n如果字符串内仍然包含引号，可以使用以下两种方法解决:\n\n__用另一种成对的引号包括起来__\n\n~~~\nstr1 = \"I'm EvanMeek.\"\n\nstr2 = 'Evan:\"Hello World.\"'\n~~~\n\n__用转义字符进行转义__\n\n~~~\nstr1 = 'I\\'m EvanMeek'\n~~~\n\n转义字符还可以用来转义换行符，应用场景通常是:\n\n__字符串过长，转义换行符，使其不换行__\n\n~~~\nprint(\"mac mac macmac mac macmac mac mac \\\nmac mac macmac mac mac\")\n~~~\n\n> Python长字符串\n\n长字符串常用场景是:\n\n__定义大段文本内容为字符串时__\n\n~~~\nstr1 = ''' \"Fuck you ! Bitch!\",said he.\n\"Mother fuck!\",said she.\n~~~\n\n> Python原始字符串\n\n在Windows下,路径是使用反斜杠作为路径区分的，如果需要将反斜杠转义，那必须再加一个反斜杠，这样非常麻烦，就可以使用下面的案例来解决:\n\n__转义反斜杠写路径__\n\n~~~\npath = 'C:\\\\User\\\\Admin\\\\Desktop'\n~~~\n\n__使用原始字符串写反斜杠__\n\n~~~\npath = r'C:\\User\\Admin\\Desktop'\n~~~\n\n注意: 原始字符串中的引号同样需要使用`\\`进行转义\n\n# Python bytes类型及用法\n\nbytes类型代表了字节串。\n\n字节串与字符串不同的是:\n\n- 字节串是以字节为单位进行操作\n\n- 字节串可直接用于网络通信数据互联\n\n字节串是由多个字节组成的，每个字节由8个bit位组成。\n\n字节串保存的数据都是二进制格式的数据。\n\n字节串可以转换成字符串，而字符串也能恢复成字节串。\n\n> 字节串转换为字符串\n\n__创建字节串__\n\n~~~\n# 创建一个空的bytes\nb1 = bytes()\n# 创建一个空的bytes值\nb2 = b''\n# 创建一个非空的字节串\nb3 = b'hello'\n~~~\n\n__字符串转换为字节串__\n\n~~~\n# 使用encode方法将字符串以utf-8字符集转换为字节串\nb4 = \"I love Python\".encode('utf-8')\n\n# 创建bytes对象时将字符串的字符集指定为'utf-8'，自动转换为字节串\nb5 = bytes('I love Python', encoding='utf-8')\n~~~\n\n> 字节串转换为字符串\n\n~~~\n# 使用字节串对象的方法decode，指定字符集转化字节串\nstr1 = b'I love Python'.decode('utf-8')\n~~~\n\n# Python bool布尔类型\n\nbool变量只有两个值分别是: True,False。它们都是Python的关键字。\n\nTrue代表真\n\nFalse代表假\n\n例如表达式:\n\n~~~\n3 > 5\n~~~\n\n结果是False\n\nPython中所有对象都可以进行真假值的测试。\n\n# Python len()函数详解：获取字符串长度或字节数\n\nlen()函数是Python内置函数，用于获取字符串或字节串的长度（数量）。\n\n例子:\n\n__统计字符串的长度__\n\n~~~\nprint(len(\"Hello World\"))\n~~~\n\n输出结果: 11\n\n__统计字节串的长度__\n\n~~~\nprint(len(\"你好世界\".encode()))\n~~~\n\n输出结果: 12\n\n不同的语言所占的字节数不同，并且不同的编码格式所占的字节数也不同。\n\n例如，汉字使用utf-8编码格式，占用3个字节，中文标点符号使用GBK编码格式占用2个字节。\n\n# Python input()函数：获取用户输入的字符串\n\ninput()是Python的内置函数，其作用是输出一段信息然后请求用户输入，并且将获取的值传入接收的对象。\n\ninput()函数将会把用户输入的任何字符都作为字符串读入。\n\n例子:\n\n~~~\na = input(\"Please input something:\")\nprint(type(a))\n~~~\n\n运行:\n\n~~~\nPlease input something > 19\n<class 'str'>\n~~~\n\n__注意: Python2.x中，要求input()函数读入的内容必须是符合Python语法表达式的。__\n\n例如: 输入字符串时，必须带双引号，否则将会报错。\n\n# Python print()函数的高级用法\n\n> 输出多个参数\n\n例子:\n\n~~~\nname = \"EvanMeek\"\nage = 18\nprint(\"我叫:\", name, \"age\", 18)\n~~~\n\n输出:\n\n~~~\n我叫: EvanMeek age 18\n~~~\n\n> 指定输出多个参数时的分隔符(默认的分割符为空格)\n\n~~~\nname = \"EvanMeek\"\nage = 18\nprint(\"我叫:\", name, \"age\", 18)\nprint(\"我叫:\", name, \"age\", 18, sep='|')\n~~~\n\n结果:\n\n~~~\n我叫: EvanMeek age 18\n我叫:|EvanMeek|age|18\n~~~\n\n> 指定结束符(默认结束符为换行符\\n)\n\n~~~\nprint(10,'\\t',end=\"\")\nprint(11,'\\t',end=\"\")\nprint(12,'\\t',end=\"\")\n~~~\n\n结果:\n\n~~~\n10 \t11 \t12 \t\n~~~\n\n> 指定输出目标(默认输出为标准输出)\n\n~~~\nf = open(\"test.txt\", \"w\")\n\nprint('Just Test', file = f)\n\nf.close()\n~~~\n\n结果: 将 'Just Test' 写入到 tes.txt文件内\n\n# Python格式化字符串(格式化输出)\n\nPython中的格式化字符串可以对各种类型的数据进行格式化输出。\n\n例子:\n\n__格式化输出整型数据__\n\n~~~\nnumber = 100\nprint(\"Number is:%s\" % number)\n~~~\n\n格式化分为三个部分，分别是被包括在双引号内的占位符(`%s`)、以及中间部分的 格式化分隔符(`%`)与对应占位符的变量或表达式(`number`)\n\n`%s`被称为占位符,又可以说是转换说明符(Conversion Specifier)\n\n| 转换说明符 | 说明                                 |\n|------------|--------------------------------------|\n| %d,%i      | 转换为带符号的十进制形式的整数       |\n| %o         | 转换为带符号的八进制形式的整数       |\n| %x,%X      | 转换为带符号的十六进制形式额整数     |\n| %e         | 转换为科学计数法标识的浮点数(e小写)  |\n| %E         | 转换为科学计数法标识的浮点数(E大写)  |\n| %f,%F      | 转换为十进制形式的浮点数             |\n| %g         | 智能选择使用%f或%e格式               |\n| %G         | 智能选择使用%F或%E格式               |\n| %c         | 格式化字符及其ASCII码                |\n| %r         | 使用repr()将变量或表达式转换成字符串 |\n| %s         | 使用str()将变量或表达式转换为字符串  |\n\nPython允许aaaaqaz123在占位符前添加一个标志用来指定对齐：\n\n- `-`(减号) :指定左对齐\n\n- `+`(加号) : 表示数值总要带着符号.\n\n- `0`,表示不补充空格，而是补充0。\n\n例子:\n\n~~~\nprint(\"%06d\" % num2)\n\nprint(\"%+06d\" % num2)\n\nprint(\"%-6d\" % num2)\n~~~\n\n输出结果:\n\n~~~\n000030\n+00030\n30    \n~~~\n\n精度值：用于指定小数点后的数字位数，如果是字符串时指定转换后字符串的最大字符数\n\n# Python转义字符及用法\n\n转义字符是指在指定字符前添加反斜杠`\\`，对特殊的字符进行转义。\n\n表格请点击此链接查看👉[💿Python常用/支持的转义字符\n](http://c.biancheng.net/view/2176.html)\n\n# Python类型转换，Python数据类型转换函数大全\n\nPython身为弱类型编程语言，不需要为变量声明数据类型，但在某些场景下，仍然需要进行类型转换，而Python内置了很多常用数据类型的转换函数，请看下表。\n\n| 函数                  | 作用                                             |\n|-----------------------|--------------------------------------------------|\n| int(x)                | 将x转换成整数类型                                |\n| float(x)              | 将x转换成浮点数类型                              |\n| complex(real,[,imag]) | 创建一个复数                                     |\n| str(x)                | 将x转换成字符串                                  |\n| repr(x)               | 将x转换成表达式字符串                            |\n| eval(str)             | 计算在字符串中的有效Python表达式，并返回一个对象 |\n| chr(x)                | 将整数x转换成一个字符                            |\n| ord(x)                | 将字符x转化成它对应的整数值                      |\n| hex(x)                | 将一个整数x转换成一个十六进制的字符串            |\n| oct(x)                | 将一个整数x转换成一个八进制的字符串              |\n\n使用类型转换函数时，被转换的数据必须是有意义的，例如，在使用int()函数时无法将一个费阿拉伯数字的字符串进行转换。\n\n# Python算术运算符及用法详解\n\n算术运算符用于处理四则运算的符号，在数字的处理中应用得最多。\n\n![Python常用算术运算符](Python-03-Python变量类型和运算符/Python常用算术运算符.png)\n\n> 加法运算符\n\n算术运算例子:\n\n~~~\na = 10\nb = 20\nprint(\"%d\" % (a+b))\n~~~\n\n输出:`30`\n\n字符串拼接例子:\n\n~~~\nhello = \"Hello\"\nworld = \"World\"\nprint(\"%s\" % hello+world)\n~~~\n\n输出:`HelloWorld`\n\n> - 减法运算符\n\n减法算术例子:\n\n~~~\n\na = 10\nb = 5\nprint(\"%d\" % (10-5))\n~~~\n\n输出:`5`\n\n求负算术例子:\n\n~~~\na = 10\na = -a\nprint(a)\n~~~\n\n输出: `-10`\n\n> *乘法运算符\n\n乘法算术例子:\n\n~~~\na =10.5\nprint(a*a)\n~~~\n\n输出:`110.25`\n\n字符串连接例子:\n\n~~~\nstr=\"test \"\nprint(str*3)\n~~~\n\n输出:`test test test `\n\n> /和//除法运算符\n\n普通除法算术例子(除不尽产生小数):\n\n~~~\na = 10\nb = 3\nprint(a/b)\n~~~\n\n输出:`3.3333333333333335`\n\n整除除法算术例子(除不尽舍去小数):\n\n~~~\na = 10\nb = 3\nprint(a//b)\n~~~\n\n输出:`3`\n\n__注意:Python中不可使用0作为除数，否则会引发`ZeroDivisionError`错误__\n\n__注意:Python2.x中没有整除运算符__\n\nPython2.x的的求整除的规则是:\n\n- 当两个操作数都是整数时，`/`作为整除运算符\n\n- 当两个操作数其中一个是浮点数时，`/`作为非整除运算符\n\n> %求余运算符\n\n- Python不需要求余的两个操作数是整数\n\n- Python不允许求余运算的第二个操作数为0\n\n求余运算例子:\n\n~~~\nprint(\"10 % 3 = \",(10%3))\nprint(\"10.5 % 3.5 = \",(10.5%3.5))\n~~~\n\n输出:\n\n~~~\n10 % 3 =  1\n10.5 % 3.5 =  0.0\n~~~\n\n注意:\n\n- 若求余运算第二个操作符为负数，那么结果也一定是负数。\n\n> **乘方运算符\n\n乘方+开方运算例子:\n\n~~~\nprint('5 的 2 次方：', 5 ** 2) # 25\nprint('4 的 3 次方：', 4 ** 3) # 64\nprint('4 的开平方：', 4 ** 0.5) # 2.0\nprint('27 的开 3 次方：',27 **(1 / 3 )) # 3.0\n~~~\n\n输出:\n\n~~~\n5 的 2 次方： 25\n4 的 3 次方： 64\n4 的开平方： 2.0\n27 的开 3 次方： 3.0\n~~~\n\n# Python赋值运算符（入门必读）\n\n赋值运算符常用于将运算符右侧的值赋值给左侧的容器。\n\n> 基本赋值运算符\n\n将赋值运算符右侧的表达式赋值给左侧的容器。\n\n~~~\na = 10\nb = a\nc = a+b\nprint(a,b,c)\n~~~\n\n输出:`10 10 20`\n\n> 扩展后的赋值运算符\n\n`=`赋值运算符与其他运算符结合后，将成为功能更强大的赋值运算符。\n\n![Python常用赋值运算符](Python-03-Python变量类型和运算符/Python常用赋值运算符.png)\n\n# Python位运算符详解\n\n`初学者可暂时跳过本章`\n\n位运算符通常使用场景是：图形、图像处理、创建设备驱动等底层开发。\n\nPython位运算符的操作对象为整数类型，它会把数字看做相应的二进制来进行计算。\n\n![python位运算符](Python-03-Python变量类型和运算符/Python位运算符.png)\n\n> &按位与运算符\n\n有两个操作数\n\n运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为1时，则结果为0，否则为1。\n\n例如:\n\n~~~\na = 10\nb = 5\nprint(bin(a), bin(b), a & b)\n~~~\n\n输出结果:\n\n~~~\n0b1010 0b101 0\n~~~\n\n> |按位或 运算符\n\n`|`是其运算符，具有两个操作数。\n\n运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为0时，则结果才为0，否则为1。\n\n> ^按位异或运算符\n\n`^`是其运算符，具有两个操作数。\n\n运算符法则：按位将两个操作数对应的二进制进行一一对应，对应时，若对应数位都为0或1，则结果为0，否则为1\n\n> ~按位取反运算符\n\n`~`是其运算符，具有1个操作数\n\n运算符法则：将其操作数的二进制进行取反，也就是：原本为0的取反为1，原本为1的取反为0.\n\n其他：原码、反码、补码是什么\n\n- 原码: 将某数值转换为二进制数，若此数值为正数或0则代表可以是无符号的，那么最高位则不需要一个符号位，若为负数则需要一个符号位。\n\n- 反码: 对原码按位取反，但符号位不变。\n\n- 补码: 负数的补码是其反码+1，正数或0的补码与原码相同。\n\n> <<左移运算符\n\n`<<`是其运算符，具有两个操作数\n\n将操作数按补码形式进行整体向左移动。移动后，溢出的丢弃，空出的以0填补。\n\n> \\>\\> 右移运算符\n\n`>>`是其运算符，具有两个擦作数\n\n将操作数按补码形式进行整体向右移动。移动后，溢出的丢弃，空出的以符号位填补。。\n\n# Python比较运算符(关系运算符)\n\n比较运算符又称为关系运算符，其作用是对各种表达式，容器结果进行大小、真假等比较。如果比较结果为真，则返回True(真)否则返回False(假)。\n\n![Python比较运算符表](Python-03-Python变量类型和运算符/Python比较运算符.png)\n\n> 比较运算符 == 和 is区别\n\n== 比较的是值\n\nis 比较的所引用对象的地址\n\n# Python逻辑运算符及其用法\n\n逻辑运算符也是对真假（布尔类型）进行运算符，其返回值也为bool。\n\n![Python比较运算符表](Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png)\n\n# Python三目运算符(三元运算符)用法详解 \n\nPython利用if来实现三目运算符的功能。\n\n语法格式：\n\n~~~\nTrue_statements if expression else False_statements\n~~~\n\n运算法则: 先对`expression`(表达式)求值，如果为True则执行`True_statements`否则执行`False_statements`\n\n例子:\n\n~~~\na = 10\nb = 20\nprint(\"a>b\") if a > b else print(\"a<b\")\n~~~\n\n结果:\n~~~\na<b\n~~~\n\nPython允许在三目运算符的`False_statements`或`True_statements`放置多条语句。\n\n两种放置方式:\n\n- 以英文逗号隔开，将每条语句执行结果，组成元组。\n\n- 以英文分号隔开，只返回一条语句的结果。 \n\n例子:\n\n~~~\na = 20\nb = 20\n\nprint(\"a>b\") if a > b else (print(\"a<b\") if a < b else print(\"a=b\"))\n~~~\n\n结果:\n\n~~~\na = b\n~~~\n\n# Python运算符优先级\n\n不同的运算符有一个优先级，在用于在表达式中进行区别执行顺序。\n\n![Python比较运算符表](Python-03-Python变量类型和运算符/Python运算符优先级.png)\n","slug":"Python-03-Python变量类型和运算符","published":1,"updated":"2020-01-19T03:49:51.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoco003womoow59myfdw","content":"<p>Python系列第三章笔记，查看Python系列所有文章，请点击<a href=\"https://evanmeek.github.io/Python/\">💿</a><br><a id=\"more\"></a></p>\n<p><strong>本章重点:Python变量数据类型、运算符。</strong></p>\n<p>Python是弱类型语言。</p>\n<p>弱类型含义:</p>\n<ul>\n<li><p>所有变量无需声明即可使用。</p>\n</li>\n<li><p>变量的数据类型随时可变。</p>\n</li>\n</ul>\n<h1 id=\"Python变量及其使用\"><a href=\"#Python变量及其使用\" class=\"headerlink\" title=\"Python变量及其使用\"></a>Python变量及其使用</h1><p>变量:</p>\n<ul>\n<li><p>数据可发生无数次变化。</p>\n</li>\n<li><p>数据类型可发生变化。</p>\n</li>\n</ul>\n<p>常量: 一旦保存数据，则不可修改。</p>\n<p>赋值运算符: <code>=</code></p>\n<p><strong>type()作用:</strong>查看变量的数据类型</p>\n<h1 id=\"Python数值类型（整型、浮点型和复数）及其用法\"><a href=\"#Python数值类型（整型、浮点型和复数）及其用法\" class=\"headerlink\" title=\"Python数值类型（整型、浮点型和复数）及其用法\"></a>Python数值类型（整型、浮点型和复数）及其用法</h1><p>Python中的数值类型都是不可变的。</p>\n<p>有些人可能会问，不是不可变么，为什么我定义的int类型变量的值仍然可以变化，那是因为底层实现将新的值存放到新的一块内存中，然后将修改变量指针的指向。</p>\n<blockquote>\n<p>Python整型</p>\n</blockquote>\n<p>整型是用来表示没有小数部分的数，整数包括：正整数、0、负整数</p>\n<p>Python整型的四种表示形式：</p>\n<ul>\n<li><p>十进制(0-9)</p>\n</li>\n<li><p>二进制(0-1)</p>\n</li>\n<li><p>八进制(0-7)</p>\n</li>\n<li><p>十六进制(0-9-A-F/a-f)</p>\n</li>\n</ul>\n<blockquote>\n<p>Python浮点型</p>\n</blockquote>\n<p>浮点型是用来保存带小数的数值，浮点数包括:十进制形式、科学计数形式。</p>\n<p>十进制形式的写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float_dex = 1.100111</span><br></pre></td></tr></table></figure>\n<p>科学计数形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float2 = 2e3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Python复数</p>\n</blockquote>\n<p>我跳过了本节，如果读者想看，可以点击进行访问<a href=\"http://c.biancheng.net/view/2173.html\" target=\"_blank\" rel=\"noopener\">💿Python复数</a></p>\n<h1 id=\"Python字符串详解-包含长字符串和原始字符串\"><a href=\"#Python字符串详解-包含长字符串和原始字符串\" class=\"headerlink\" title=\"Python字符串详解(包含长字符串和原始字符串)\"></a>Python字符串详解(包含长字符串和原始字符串)</h1><p>Python字符串必须使用引号括起来，可以是单引号也可以是双引号，但必须成对。</p>\n<p>如果字符串内仍然包含引号，可以使用以下两种方法解决:</p>\n<p><strong>用另一种成对的引号包括起来</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;I&apos;m EvanMeek.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">str2 = &apos;Evan:&quot;Hello World.&quot;&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>用转义字符进行转义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &apos;I\\&apos;m EvanMeek&apos;</span><br></pre></td></tr></table></figure>\n<p>转义字符还可以用来转义换行符，应用场景通常是:</p>\n<p><strong>字符串过长，转义换行符，使其不换行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;mac mac macmac mac macmac mac mac \\</span><br><span class=\"line\">mac mac macmac mac mac&quot;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Python长字符串</p>\n</blockquote>\n<p>长字符串常用场景是:</p>\n<p><strong>定义大段文本内容为字符串时</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &apos;&apos;&apos; &quot;Fuck you ! Bitch!&quot;,said he.</span><br><span class=\"line\">&quot;Mother fuck!&quot;,said she.</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Python原始字符串</p>\n</blockquote>\n<p>在Windows下,路径是使用反斜杠作为路径区分的，如果需要将反斜杠转义，那必须再加一个反斜杠，这样非常麻烦，就可以使用下面的案例来解决:</p>\n<p><strong>转义反斜杠写路径</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = &apos;C:\\\\User\\\\Admin\\\\Desktop&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>使用原始字符串写反斜杠</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = r&apos;C:\\User\\Admin\\Desktop&apos;</span><br></pre></td></tr></table></figure>\n<p>注意: 原始字符串中的引号同样需要使用<code>\\</code>进行转义</p>\n<h1 id=\"Python-bytes类型及用法\"><a href=\"#Python-bytes类型及用法\" class=\"headerlink\" title=\"Python bytes类型及用法\"></a>Python bytes类型及用法</h1><p>bytes类型代表了字节串。</p>\n<p>字节串与字符串不同的是:</p>\n<ul>\n<li><p>字节串是以字节为单位进行操作</p>\n</li>\n<li><p>字节串可直接用于网络通信数据互联</p>\n</li>\n</ul>\n<p>字节串是由多个字节组成的，每个字节由8个bit位组成。</p>\n<p>字节串保存的数据都是二进制格式的数据。</p>\n<p>字节串可以转换成字符串，而字符串也能恢复成字节串。</p>\n<blockquote>\n<p>字节串转换为字符串</p>\n</blockquote>\n<p><strong>创建字节串</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建一个空的bytes</span><br><span class=\"line\">b1 = bytes()</span><br><span class=\"line\"># 创建一个空的bytes值</span><br><span class=\"line\">b2 = b&apos;&apos;</span><br><span class=\"line\"># 创建一个非空的字节串</span><br><span class=\"line\">b3 = b&apos;hello&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>字符串转换为字节串</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用encode方法将字符串以utf-8字符集转换为字节串</span><br><span class=\"line\">b4 = &quot;I love Python&quot;.encode(&apos;utf-8&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建bytes对象时将字符串的字符集指定为&apos;utf-8&apos;，自动转换为字节串</span><br><span class=\"line\">b5 = bytes(&apos;I love Python&apos;, encoding=&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>字节串转换为字符串</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用字节串对象的方法decode，指定字符集转化字节串</span><br><span class=\"line\">str1 = b&apos;I love Python&apos;.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-bool布尔类型\"><a href=\"#Python-bool布尔类型\" class=\"headerlink\" title=\"Python bool布尔类型\"></a>Python bool布尔类型</h1><p>bool变量只有两个值分别是: True,False。它们都是Python的关键字。</p>\n<p>True代表真</p>\n<p>False代表假</p>\n<p>例如表达式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 &gt; 5</span><br></pre></td></tr></table></figure>\n<p>结果是False</p>\n<p>Python中所有对象都可以进行真假值的测试。</p>\n<h1 id=\"Python-len-函数详解：获取字符串长度或字节数\"><a href=\"#Python-len-函数详解：获取字符串长度或字节数\" class=\"headerlink\" title=\"Python len()函数详解：获取字符串长度或字节数\"></a>Python len()函数详解：获取字符串长度或字节数</h1><p>len()函数是Python内置函数，用于获取字符串或字节串的长度（数量）。</p>\n<p>例子:</p>\n<p><strong>统计字符串的长度</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(len(&quot;Hello World&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果: 11</p>\n<p><strong>统计字节串的长度</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(len(&quot;你好世界&quot;.encode()))</span><br></pre></td></tr></table></figure>\n<p>输出结果: 12</p>\n<p>不同的语言所占的字节数不同，并且不同的编码格式所占的字节数也不同。</p>\n<p>例如，汉字使用utf-8编码格式，占用3个字节，中文标点符号使用GBK编码格式占用2个字节。</p>\n<h1 id=\"Python-input-函数：获取用户输入的字符串\"><a href=\"#Python-input-函数：获取用户输入的字符串\" class=\"headerlink\" title=\"Python input()函数：获取用户输入的字符串\"></a>Python input()函数：获取用户输入的字符串</h1><p>input()是Python的内置函数，其作用是输出一段信息然后请求用户输入，并且将获取的值传入接收的对象。</p>\n<p>input()函数将会把用户输入的任何字符都作为字符串读入。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = input(&quot;Please input something:&quot;)</span><br><span class=\"line\">print(type(a))</span><br></pre></td></tr></table></figure>\n<p>运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please input something &gt; 19</span><br><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意: Python2.x中，要求input()函数读入的内容必须是符合Python语法表达式的。</strong></p>\n<p>例如: 输入字符串时，必须带双引号，否则将会报错。</p>\n<h1 id=\"Python-print-函数的高级用法\"><a href=\"#Python-print-函数的高级用法\" class=\"headerlink\" title=\"Python print()函数的高级用法\"></a>Python print()函数的高级用法</h1><blockquote>\n<p>输出多个参数</p>\n</blockquote>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &quot;EvanMeek&quot;</span><br><span class=\"line\">age = 18</span><br><span class=\"line\">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我叫: EvanMeek age 18</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定输出多个参数时的分隔符(默认的分割符为空格)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &quot;EvanMeek&quot;</span><br><span class=\"line\">age = 18</span><br><span class=\"line\">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)</span><br><span class=\"line\">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18, sep=&apos;|&apos;)</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我叫: EvanMeek age 18</span><br><span class=\"line\">我叫:|EvanMeek|age|18</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定结束符(默认结束符为换行符\\n)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(10,&apos;\\t&apos;,end=&quot;&quot;)</span><br><span class=\"line\">print(11,&apos;\\t&apos;,end=&quot;&quot;)</span><br><span class=\"line\">print(12,&apos;\\t&apos;,end=&quot;&quot;)</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 \t11 \t12</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定输出目标(默认输出为标准输出)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(&quot;test.txt&quot;, &quot;w&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">print(&apos;Just Test&apos;, file = f)</span><br><span class=\"line\"></span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n<p>结果: 将 ‘Just Test’ 写入到 tes.txt文件内</p>\n<h1 id=\"Python格式化字符串-格式化输出\"><a href=\"#Python格式化字符串-格式化输出\" class=\"headerlink\" title=\"Python格式化字符串(格式化输出)\"></a>Python格式化字符串(格式化输出)</h1><p>Python中的格式化字符串可以对各种类型的数据进行格式化输出。</p>\n<p>例子:</p>\n<p><strong>格式化输出整型数据</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">number = 100</span><br><span class=\"line\">print(&quot;Number is:%s&quot; % number)</span><br></pre></td></tr></table></figure>\n<p>格式化分为三个部分，分别是被包括在双引号内的占位符(<code>%s</code>)、以及中间部分的 格式化分隔符(<code>%</code>)与对应占位符的变量或表达式(<code>number</code>)</p>\n<p><code>%s</code>被称为占位符,又可以说是转换说明符(Conversion Specifier)</p>\n<table>\n<thead>\n<tr>\n<th>转换说明符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%d,%i</td>\n<td>转换为带符号的十进制形式的整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>转换为带符号的八进制形式的整数</td>\n</tr>\n<tr>\n<td>%x,%X</td>\n<td>转换为带符号的十六进制形式额整数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>转换为科学计数法标识的浮点数(e小写)</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>转换为科学计数法标识的浮点数(E大写)</td>\n</tr>\n<tr>\n<td>%f,%F</td>\n<td>转换为十进制形式的浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>智能选择使用%f或%e格式</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>智能选择使用%F或%E格式</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>格式化字符及其ASCII码</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>使用repr()将变量或表达式转换成字符串</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>使用str()将变量或表达式转换为字符串</td>\n</tr>\n</tbody>\n</table>\n<p>Python允许aaaaqaz123在占位符前添加一个标志用来指定对齐：</p>\n<ul>\n<li><p><code>-</code>(减号) :指定左对齐</p>\n</li>\n<li><p><code>+</code>(加号) : 表示数值总要带着符号.</p>\n</li>\n<li><p><code>0</code>,表示不补充空格，而是补充0。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;%06d&quot; % num2)</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;%+06d&quot; % num2)</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;%-6d&quot; % num2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">000030</span><br><span class=\"line\">+00030</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n<p>精度值：用于指定小数点后的数字位数，如果是字符串时指定转换后字符串的最大字符数</p>\n<h1 id=\"Python转义字符及用法\"><a href=\"#Python转义字符及用法\" class=\"headerlink\" title=\"Python转义字符及用法\"></a>Python转义字符及用法</h1><p>转义字符是指在指定字符前添加反斜杠<code>\\</code>，对特殊的字符进行转义。</p>\n<p>表格请点击此链接查看👉<a href=\"http://c.biancheng.net/view/2176.html\" target=\"_blank\" rel=\"noopener\">💿Python常用/支持的转义字符\n</a></p>\n<h1 id=\"Python类型转换，Python数据类型转换函数大全\"><a href=\"#Python类型转换，Python数据类型转换函数大全\" class=\"headerlink\" title=\"Python类型转换，Python数据类型转换函数大全\"></a>Python类型转换，Python数据类型转换函数大全</h1><p>Python身为弱类型编程语言，不需要为变量声明数据类型，但在某些场景下，仍然需要进行类型转换，而Python内置了很多常用数据类型的转换函数，请看下表。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int(x)</td>\n<td>将x转换成整数类型</td>\n</tr>\n<tr>\n<td>float(x)</td>\n<td>将x转换成浮点数类型</td>\n</tr>\n<tr>\n<td>complex(real,[,imag])</td>\n<td>创建一个复数</td>\n</tr>\n<tr>\n<td>str(x)</td>\n<td>将x转换成字符串</td>\n</tr>\n<tr>\n<td>repr(x)</td>\n<td>将x转换成表达式字符串</td>\n</tr>\n<tr>\n<td>eval(str)</td>\n<td>计算在字符串中的有效Python表达式，并返回一个对象</td>\n</tr>\n<tr>\n<td>chr(x)</td>\n<td>将整数x转换成一个字符</td>\n</tr>\n<tr>\n<td>ord(x)</td>\n<td>将字符x转化成它对应的整数值</td>\n</tr>\n<tr>\n<td>hex(x)</td>\n<td>将一个整数x转换成一个十六进制的字符串</td>\n</tr>\n<tr>\n<td>oct(x)</td>\n<td>将一个整数x转换成一个八进制的字符串</td>\n</tr>\n</tbody>\n</table>\n<p>使用类型转换函数时，被转换的数据必须是有意义的，例如，在使用int()函数时无法将一个费阿拉伯数字的字符串进行转换。</p>\n<h1 id=\"Python算术运算符及用法详解\"><a href=\"#Python算术运算符及用法详解\" class=\"headerlink\" title=\"Python算术运算符及用法详解\"></a>Python算术运算符及用法详解</h1><p>算术运算符用于处理四则运算的符号，在数字的处理中应用得最多。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python常用算术运算符.png\" alt=\"Python常用算术运算符\"></p>\n<blockquote>\n<p>加法运算符</p>\n</blockquote>\n<p>算术运算例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 20</span><br><span class=\"line\">print(&quot;%d&quot; % (a+b))</span><br></pre></td></tr></table></figure>\n<p>输出:<code>30</code></p>\n<p>字符串拼接例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello = &quot;Hello&quot;</span><br><span class=\"line\">world = &quot;World&quot;</span><br><span class=\"line\">print(&quot;%s&quot; % hello+world)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>HelloWorld</code></p>\n<blockquote>\n<ul>\n<li>减法运算符</li>\n</ul>\n</blockquote>\n<p>减法算术例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">a = 10</span><br><span class=\"line\">b = 5</span><br><span class=\"line\">print(&quot;%d&quot; % (10-5))</span><br></pre></td></tr></table></figure>\n<p>输出:<code>5</code></p>\n<p>求负算术例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">a = -a</span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure>\n<p>输出: <code>-10</code></p>\n<blockquote>\n<p>*乘法运算符</p>\n</blockquote>\n<p>乘法算术例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a =10.5</span><br><span class=\"line\">print(a*a)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>110.25</code></p>\n<p>字符串连接例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=&quot;test &quot;</span><br><span class=\"line\">print(str*3)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>test test test</code></p>\n<blockquote>\n<p>/和//除法运算符</p>\n</blockquote>\n<p>普通除法算术例子(除不尽产生小数):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 3</span><br><span class=\"line\">print(a/b)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>3.3333333333333335</code></p>\n<p>整除除法算术例子(除不尽舍去小数):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 3</span><br><span class=\"line\">print(a//b)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>3</code></p>\n<p><strong>注意:Python中不可使用0作为除数，否则会引发<code>ZeroDivisionError</code>错误</strong></p>\n<p><strong>注意:Python2.x中没有整除运算符</strong></p>\n<p>Python2.x的的求整除的规则是:</p>\n<ul>\n<li><p>当两个操作数都是整数时，<code>/</code>作为整除运算符</p>\n</li>\n<li><p>当两个操作数其中一个是浮点数时，<code>/</code>作为非整除运算符</p>\n</li>\n</ul>\n<blockquote>\n<p>%求余运算符</p>\n</blockquote>\n<ul>\n<li><p>Python不需要求余的两个操作数是整数</p>\n</li>\n<li><p>Python不允许求余运算的第二个操作数为0</p>\n</li>\n</ul>\n<p>求余运算例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;10 % 3 = &quot;,(10%3))</span><br><span class=\"line\">print(&quot;10.5 % 3.5 = &quot;,(10.5%3.5))</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 % 3 =  1</span><br><span class=\"line\">10.5 % 3.5 =  0.0</span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<ul>\n<li>若求余运算第二个操作符为负数，那么结果也一定是负数。</li>\n</ul>\n<blockquote>\n<p>**乘方运算符</p>\n</blockquote>\n<p>乘方+开方运算例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&apos;5 的 2 次方：&apos;, 5 ** 2) # 25</span><br><span class=\"line\">print(&apos;4 的 3 次方：&apos;, 4 ** 3) # 64</span><br><span class=\"line\">print(&apos;4 的开平方：&apos;, 4 ** 0.5) # 2.0</span><br><span class=\"line\">print(&apos;27 的开 3 次方：&apos;,27 **(1 / 3 )) # 3.0</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 的 2 次方： 25</span><br><span class=\"line\">4 的 3 次方： 64</span><br><span class=\"line\">4 的开平方： 2.0</span><br><span class=\"line\">27 的开 3 次方： 3.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python赋值运算符（入门必读）\"><a href=\"#Python赋值运算符（入门必读）\" class=\"headerlink\" title=\"Python赋值运算符（入门必读）\"></a>Python赋值运算符（入门必读）</h1><p>赋值运算符常用于将运算符右侧的值赋值给左侧的容器。</p>\n<blockquote>\n<p>基本赋值运算符</p>\n</blockquote>\n<p>将赋值运算符右侧的表达式赋值给左侧的容器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = a</span><br><span class=\"line\">c = a+b</span><br><span class=\"line\">print(a,b,c)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>10 10 20</code></p>\n<blockquote>\n<p>扩展后的赋值运算符</p>\n</blockquote>\n<p><code>=</code>赋值运算符与其他运算符结合后，将成为功能更强大的赋值运算符。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python常用赋值运算符.png\" alt=\"Python常用赋值运算符\"></p>\n<h1 id=\"Python位运算符详解\"><a href=\"#Python位运算符详解\" class=\"headerlink\" title=\"Python位运算符详解\"></a>Python位运算符详解</h1><p><code>初学者可暂时跳过本章</code></p>\n<p>位运算符通常使用场景是：图形、图像处理、创建设备驱动等底层开发。</p>\n<p>Python位运算符的操作对象为整数类型，它会把数字看做相应的二进制来进行计算。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python位运算符.png\" alt=\"python位运算符\"></p>\n<blockquote>\n<p>&amp;按位与运算符</p>\n</blockquote>\n<p>有两个操作数</p>\n<p>运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为1时，则结果为0，否则为1。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 5</span><br><span class=\"line\">print(bin(a), bin(b), a &amp; b)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0b1010 0b101 0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>|按位或 运算符</p>\n</blockquote>\n<p><code>|</code>是其运算符，具有两个操作数。</p>\n<p>运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为0时，则结果才为0，否则为1。</p>\n<blockquote>\n<p>^按位异或运算符</p>\n</blockquote>\n<p><code>^</code>是其运算符，具有两个操作数。</p>\n<p>运算符法则：按位将两个操作数对应的二进制进行一一对应，对应时，若对应数位都为0或1，则结果为0，否则为1</p>\n<blockquote>\n<p>~按位取反运算符</p>\n</blockquote>\n<p><code>~</code>是其运算符，具有1个操作数</p>\n<p>运算符法则：将其操作数的二进制进行取反，也就是：原本为0的取反为1，原本为1的取反为0.</p>\n<p>其他：原码、反码、补码是什么</p>\n<ul>\n<li><p>原码: 将某数值转换为二进制数，若此数值为正数或0则代表可以是无符号的，那么最高位则不需要一个符号位，若为负数则需要一个符号位。</p>\n</li>\n<li><p>反码: 对原码按位取反，但符号位不变。</p>\n</li>\n<li><p>补码: 负数的补码是其反码+1，正数或0的补码与原码相同。</p>\n</li>\n</ul>\n<blockquote>\n<p>&lt;&lt;左移运算符</p>\n</blockquote>\n<p><code>&lt;&lt;</code>是其运算符，具有两个操作数</p>\n<p>将操作数按补码形式进行整体向左移动。移动后，溢出的丢弃，空出的以0填补。</p>\n<blockquote>\n<p>>> 右移运算符</p>\n</blockquote>\n<p><code>&gt;&gt;</code>是其运算符，具有两个擦作数</p>\n<p>将操作数按补码形式进行整体向右移动。移动后，溢出的丢弃，空出的以符号位填补。。</p>\n<h1 id=\"Python比较运算符-关系运算符\"><a href=\"#Python比较运算符-关系运算符\" class=\"headerlink\" title=\"Python比较运算符(关系运算符)\"></a>Python比较运算符(关系运算符)</h1><p>比较运算符又称为关系运算符，其作用是对各种表达式，容器结果进行大小、真假等比较。如果比较结果为真，则返回True(真)否则返回False(假)。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python比较运算符.png\" alt=\"Python比较运算符表\"></p>\n<blockquote>\n<p>比较运算符 == 和 is区别</p>\n</blockquote>\n<p>== 比较的是值</p>\n<p>is 比较的所引用对象的地址</p>\n<h1 id=\"Python逻辑运算符及其用法\"><a href=\"#Python逻辑运算符及其用法\" class=\"headerlink\" title=\"Python逻辑运算符及其用法\"></a>Python逻辑运算符及其用法</h1><p>逻辑运算符也是对真假（布尔类型）进行运算符，其返回值也为bool。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png\" alt=\"Python比较运算符表\"></p>\n<h1 id=\"Python三目运算符-三元运算符-用法详解\"><a href=\"#Python三目运算符-三元运算符-用法详解\" class=\"headerlink\" title=\"Python三目运算符(三元运算符)用法详解\"></a>Python三目运算符(三元运算符)用法详解</h1><p>Python利用if来实现三目运算符的功能。</p>\n<p>语法格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">True_statements if expression else False_statements</span><br></pre></td></tr></table></figure>\n<p>运算法则: 先对<code>expression</code>(表达式)求值，如果为True则执行<code>True_statements</code>否则执行<code>False_statements</code></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 20</span><br><span class=\"line\">print(&quot;a&gt;b&quot;) if a &gt; b else print(&quot;a&lt;b&quot;)</span><br></pre></td></tr></table></figure>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a&lt;b</span><br></pre></td></tr></table></figure></p>\n<p>Python允许在三目运算符的<code>False_statements</code>或<code>True_statements</code>放置多条语句。</p>\n<p>两种放置方式:</p>\n<ul>\n<li><p>以英文逗号隔开，将每条语句执行结果，组成元组。</p>\n</li>\n<li><p>以英文分号隔开，只返回一条语句的结果。 </p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 20</span><br><span class=\"line\">b = 20</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;a&gt;b&quot;) if a &gt; b else (print(&quot;a&lt;b&quot;) if a &lt; b else print(&quot;a=b&quot;))</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python运算符优先级\"><a href=\"#Python运算符优先级\" class=\"headerlink\" title=\"Python运算符优先级\"></a>Python运算符优先级</h1><p>不同的运算符有一个优先级，在用于在表达式中进行区别执行顺序。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python运算符优先级.png\" alt=\"Python比较运算符表\"></p>\n","site":{"data":{}},"excerpt":"<p>Python系列第三章笔记，查看Python系列所有文章，请点击<a href=\"https://evanmeek.github.io/Python/\">💿</a><br></p>","more":"<p></p>\n<p><strong>本章重点:Python变量数据类型、运算符。</strong></p>\n<p>Python是弱类型语言。</p>\n<p>弱类型含义:</p>\n<ul>\n<li><p>所有变量无需声明即可使用。</p>\n</li>\n<li><p>变量的数据类型随时可变。</p>\n</li>\n</ul>\n<h1 id=\"Python变量及其使用\"><a href=\"#Python变量及其使用\" class=\"headerlink\" title=\"Python变量及其使用\"></a>Python变量及其使用</h1><p>变量:</p>\n<ul>\n<li><p>数据可发生无数次变化。</p>\n</li>\n<li><p>数据类型可发生变化。</p>\n</li>\n</ul>\n<p>常量: 一旦保存数据，则不可修改。</p>\n<p>赋值运算符: <code>=</code></p>\n<p><strong>type()作用:</strong>查看变量的数据类型</p>\n<h1 id=\"Python数值类型（整型、浮点型和复数）及其用法\"><a href=\"#Python数值类型（整型、浮点型和复数）及其用法\" class=\"headerlink\" title=\"Python数值类型（整型、浮点型和复数）及其用法\"></a>Python数值类型（整型、浮点型和复数）及其用法</h1><p>Python中的数值类型都是不可变的。</p>\n<p>有些人可能会问，不是不可变么，为什么我定义的int类型变量的值仍然可以变化，那是因为底层实现将新的值存放到新的一块内存中，然后将修改变量指针的指向。</p>\n<blockquote>\n<p>Python整型</p>\n</blockquote>\n<p>整型是用来表示没有小数部分的数，整数包括：正整数、0、负整数</p>\n<p>Python整型的四种表示形式：</p>\n<ul>\n<li><p>十进制(0-9)</p>\n</li>\n<li><p>二进制(0-1)</p>\n</li>\n<li><p>八进制(0-7)</p>\n</li>\n<li><p>十六进制(0-9-A-F/a-f)</p>\n</li>\n</ul>\n<blockquote>\n<p>Python浮点型</p>\n</blockquote>\n<p>浮点型是用来保存带小数的数值，浮点数包括:十进制形式、科学计数形式。</p>\n<p>十进制形式的写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float_dex = 1.100111</span><br></pre></td></tr></table></figure>\n<p>科学计数形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float2 = 2e3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Python复数</p>\n</blockquote>\n<p>我跳过了本节，如果读者想看，可以点击进行访问<a href=\"http://c.biancheng.net/view/2173.html\" target=\"_blank\" rel=\"noopener\">💿Python复数</a></p>\n<h1 id=\"Python字符串详解-包含长字符串和原始字符串\"><a href=\"#Python字符串详解-包含长字符串和原始字符串\" class=\"headerlink\" title=\"Python字符串详解(包含长字符串和原始字符串)\"></a>Python字符串详解(包含长字符串和原始字符串)</h1><p>Python字符串必须使用引号括起来，可以是单引号也可以是双引号，但必须成对。</p>\n<p>如果字符串内仍然包含引号，可以使用以下两种方法解决:</p>\n<p><strong>用另一种成对的引号包括起来</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;I&apos;m EvanMeek.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">str2 = &apos;Evan:&quot;Hello World.&quot;&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>用转义字符进行转义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &apos;I\\&apos;m EvanMeek&apos;</span><br></pre></td></tr></table></figure>\n<p>转义字符还可以用来转义换行符，应用场景通常是:</p>\n<p><strong>字符串过长，转义换行符，使其不换行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;mac mac macmac mac macmac mac mac \\</span><br><span class=\"line\">mac mac macmac mac mac&quot;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Python长字符串</p>\n</blockquote>\n<p>长字符串常用场景是:</p>\n<p><strong>定义大段文本内容为字符串时</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &apos;&apos;&apos; &quot;Fuck you ! Bitch!&quot;,said he.</span><br><span class=\"line\">&quot;Mother fuck!&quot;,said she.</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Python原始字符串</p>\n</blockquote>\n<p>在Windows下,路径是使用反斜杠作为路径区分的，如果需要将反斜杠转义，那必须再加一个反斜杠，这样非常麻烦，就可以使用下面的案例来解决:</p>\n<p><strong>转义反斜杠写路径</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = &apos;C:\\\\User\\\\Admin\\\\Desktop&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>使用原始字符串写反斜杠</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = r&apos;C:\\User\\Admin\\Desktop&apos;</span><br></pre></td></tr></table></figure>\n<p>注意: 原始字符串中的引号同样需要使用<code>\\</code>进行转义</p>\n<h1 id=\"Python-bytes类型及用法\"><a href=\"#Python-bytes类型及用法\" class=\"headerlink\" title=\"Python bytes类型及用法\"></a>Python bytes类型及用法</h1><p>bytes类型代表了字节串。</p>\n<p>字节串与字符串不同的是:</p>\n<ul>\n<li><p>字节串是以字节为单位进行操作</p>\n</li>\n<li><p>字节串可直接用于网络通信数据互联</p>\n</li>\n</ul>\n<p>字节串是由多个字节组成的，每个字节由8个bit位组成。</p>\n<p>字节串保存的数据都是二进制格式的数据。</p>\n<p>字节串可以转换成字符串，而字符串也能恢复成字节串。</p>\n<blockquote>\n<p>字节串转换为字符串</p>\n</blockquote>\n<p><strong>创建字节串</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建一个空的bytes</span><br><span class=\"line\">b1 = bytes()</span><br><span class=\"line\"># 创建一个空的bytes值</span><br><span class=\"line\">b2 = b&apos;&apos;</span><br><span class=\"line\"># 创建一个非空的字节串</span><br><span class=\"line\">b3 = b&apos;hello&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>字符串转换为字节串</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用encode方法将字符串以utf-8字符集转换为字节串</span><br><span class=\"line\">b4 = &quot;I love Python&quot;.encode(&apos;utf-8&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建bytes对象时将字符串的字符集指定为&apos;utf-8&apos;，自动转换为字节串</span><br><span class=\"line\">b5 = bytes(&apos;I love Python&apos;, encoding=&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>字节串转换为字符串</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用字节串对象的方法decode，指定字符集转化字节串</span><br><span class=\"line\">str1 = b&apos;I love Python&apos;.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-bool布尔类型\"><a href=\"#Python-bool布尔类型\" class=\"headerlink\" title=\"Python bool布尔类型\"></a>Python bool布尔类型</h1><p>bool变量只有两个值分别是: True,False。它们都是Python的关键字。</p>\n<p>True代表真</p>\n<p>False代表假</p>\n<p>例如表达式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 &gt; 5</span><br></pre></td></tr></table></figure>\n<p>结果是False</p>\n<p>Python中所有对象都可以进行真假值的测试。</p>\n<h1 id=\"Python-len-函数详解：获取字符串长度或字节数\"><a href=\"#Python-len-函数详解：获取字符串长度或字节数\" class=\"headerlink\" title=\"Python len()函数详解：获取字符串长度或字节数\"></a>Python len()函数详解：获取字符串长度或字节数</h1><p>len()函数是Python内置函数，用于获取字符串或字节串的长度（数量）。</p>\n<p>例子:</p>\n<p><strong>统计字符串的长度</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(len(&quot;Hello World&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果: 11</p>\n<p><strong>统计字节串的长度</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(len(&quot;你好世界&quot;.encode()))</span><br></pre></td></tr></table></figure>\n<p>输出结果: 12</p>\n<p>不同的语言所占的字节数不同，并且不同的编码格式所占的字节数也不同。</p>\n<p>例如，汉字使用utf-8编码格式，占用3个字节，中文标点符号使用GBK编码格式占用2个字节。</p>\n<h1 id=\"Python-input-函数：获取用户输入的字符串\"><a href=\"#Python-input-函数：获取用户输入的字符串\" class=\"headerlink\" title=\"Python input()函数：获取用户输入的字符串\"></a>Python input()函数：获取用户输入的字符串</h1><p>input()是Python的内置函数，其作用是输出一段信息然后请求用户输入，并且将获取的值传入接收的对象。</p>\n<p>input()函数将会把用户输入的任何字符都作为字符串读入。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = input(&quot;Please input something:&quot;)</span><br><span class=\"line\">print(type(a))</span><br></pre></td></tr></table></figure>\n<p>运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please input something &gt; 19</span><br><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意: Python2.x中，要求input()函数读入的内容必须是符合Python语法表达式的。</strong></p>\n<p>例如: 输入字符串时，必须带双引号，否则将会报错。</p>\n<h1 id=\"Python-print-函数的高级用法\"><a href=\"#Python-print-函数的高级用法\" class=\"headerlink\" title=\"Python print()函数的高级用法\"></a>Python print()函数的高级用法</h1><blockquote>\n<p>输出多个参数</p>\n</blockquote>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &quot;EvanMeek&quot;</span><br><span class=\"line\">age = 18</span><br><span class=\"line\">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我叫: EvanMeek age 18</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定输出多个参数时的分隔符(默认的分割符为空格)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &quot;EvanMeek&quot;</span><br><span class=\"line\">age = 18</span><br><span class=\"line\">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)</span><br><span class=\"line\">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18, sep=&apos;|&apos;)</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我叫: EvanMeek age 18</span><br><span class=\"line\">我叫:|EvanMeek|age|18</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定结束符(默认结束符为换行符\\n)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(10,&apos;\\t&apos;,end=&quot;&quot;)</span><br><span class=\"line\">print(11,&apos;\\t&apos;,end=&quot;&quot;)</span><br><span class=\"line\">print(12,&apos;\\t&apos;,end=&quot;&quot;)</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 \t11 \t12</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定输出目标(默认输出为标准输出)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(&quot;test.txt&quot;, &quot;w&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">print(&apos;Just Test&apos;, file = f)</span><br><span class=\"line\"></span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n<p>结果: 将 ‘Just Test’ 写入到 tes.txt文件内</p>\n<h1 id=\"Python格式化字符串-格式化输出\"><a href=\"#Python格式化字符串-格式化输出\" class=\"headerlink\" title=\"Python格式化字符串(格式化输出)\"></a>Python格式化字符串(格式化输出)</h1><p>Python中的格式化字符串可以对各种类型的数据进行格式化输出。</p>\n<p>例子:</p>\n<p><strong>格式化输出整型数据</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">number = 100</span><br><span class=\"line\">print(&quot;Number is:%s&quot; % number)</span><br></pre></td></tr></table></figure>\n<p>格式化分为三个部分，分别是被包括在双引号内的占位符(<code>%s</code>)、以及中间部分的 格式化分隔符(<code>%</code>)与对应占位符的变量或表达式(<code>number</code>)</p>\n<p><code>%s</code>被称为占位符,又可以说是转换说明符(Conversion Specifier)</p>\n<table>\n<thead>\n<tr>\n<th>转换说明符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%d,%i</td>\n<td>转换为带符号的十进制形式的整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>转换为带符号的八进制形式的整数</td>\n</tr>\n<tr>\n<td>%x,%X</td>\n<td>转换为带符号的十六进制形式额整数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>转换为科学计数法标识的浮点数(e小写)</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>转换为科学计数法标识的浮点数(E大写)</td>\n</tr>\n<tr>\n<td>%f,%F</td>\n<td>转换为十进制形式的浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>智能选择使用%f或%e格式</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>智能选择使用%F或%E格式</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>格式化字符及其ASCII码</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>使用repr()将变量或表达式转换成字符串</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>使用str()将变量或表达式转换为字符串</td>\n</tr>\n</tbody>\n</table>\n<p>Python允许aaaaqaz123在占位符前添加一个标志用来指定对齐：</p>\n<ul>\n<li><p><code>-</code>(减号) :指定左对齐</p>\n</li>\n<li><p><code>+</code>(加号) : 表示数值总要带着符号.</p>\n</li>\n<li><p><code>0</code>,表示不补充空格，而是补充0。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;%06d&quot; % num2)</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;%+06d&quot; % num2)</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;%-6d&quot; % num2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">000030</span><br><span class=\"line\">+00030</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n<p>精度值：用于指定小数点后的数字位数，如果是字符串时指定转换后字符串的最大字符数</p>\n<h1 id=\"Python转义字符及用法\"><a href=\"#Python转义字符及用法\" class=\"headerlink\" title=\"Python转义字符及用法\"></a>Python转义字符及用法</h1><p>转义字符是指在指定字符前添加反斜杠<code>\\</code>，对特殊的字符进行转义。</p>\n<p>表格请点击此链接查看👉<a href=\"http://c.biancheng.net/view/2176.html\" target=\"_blank\" rel=\"noopener\">💿Python常用/支持的转义字符\n</a></p>\n<h1 id=\"Python类型转换，Python数据类型转换函数大全\"><a href=\"#Python类型转换，Python数据类型转换函数大全\" class=\"headerlink\" title=\"Python类型转换，Python数据类型转换函数大全\"></a>Python类型转换，Python数据类型转换函数大全</h1><p>Python身为弱类型编程语言，不需要为变量声明数据类型，但在某些场景下，仍然需要进行类型转换，而Python内置了很多常用数据类型的转换函数，请看下表。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int(x)</td>\n<td>将x转换成整数类型</td>\n</tr>\n<tr>\n<td>float(x)</td>\n<td>将x转换成浮点数类型</td>\n</tr>\n<tr>\n<td>complex(real,[,imag])</td>\n<td>创建一个复数</td>\n</tr>\n<tr>\n<td>str(x)</td>\n<td>将x转换成字符串</td>\n</tr>\n<tr>\n<td>repr(x)</td>\n<td>将x转换成表达式字符串</td>\n</tr>\n<tr>\n<td>eval(str)</td>\n<td>计算在字符串中的有效Python表达式，并返回一个对象</td>\n</tr>\n<tr>\n<td>chr(x)</td>\n<td>将整数x转换成一个字符</td>\n</tr>\n<tr>\n<td>ord(x)</td>\n<td>将字符x转化成它对应的整数值</td>\n</tr>\n<tr>\n<td>hex(x)</td>\n<td>将一个整数x转换成一个十六进制的字符串</td>\n</tr>\n<tr>\n<td>oct(x)</td>\n<td>将一个整数x转换成一个八进制的字符串</td>\n</tr>\n</tbody>\n</table>\n<p>使用类型转换函数时，被转换的数据必须是有意义的，例如，在使用int()函数时无法将一个费阿拉伯数字的字符串进行转换。</p>\n<h1 id=\"Python算术运算符及用法详解\"><a href=\"#Python算术运算符及用法详解\" class=\"headerlink\" title=\"Python算术运算符及用法详解\"></a>Python算术运算符及用法详解</h1><p>算术运算符用于处理四则运算的符号，在数字的处理中应用得最多。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python常用算术运算符.png\" alt=\"Python常用算术运算符\"></p>\n<blockquote>\n<p>加法运算符</p>\n</blockquote>\n<p>算术运算例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 20</span><br><span class=\"line\">print(&quot;%d&quot; % (a+b))</span><br></pre></td></tr></table></figure>\n<p>输出:<code>30</code></p>\n<p>字符串拼接例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello = &quot;Hello&quot;</span><br><span class=\"line\">world = &quot;World&quot;</span><br><span class=\"line\">print(&quot;%s&quot; % hello+world)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>HelloWorld</code></p>\n<blockquote>\n<ul>\n<li>减法运算符</li>\n</ul>\n</blockquote>\n<p>减法算术例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">a = 10</span><br><span class=\"line\">b = 5</span><br><span class=\"line\">print(&quot;%d&quot; % (10-5))</span><br></pre></td></tr></table></figure>\n<p>输出:<code>5</code></p>\n<p>求负算术例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">a = -a</span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure>\n<p>输出: <code>-10</code></p>\n<blockquote>\n<p>*乘法运算符</p>\n</blockquote>\n<p>乘法算术例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a =10.5</span><br><span class=\"line\">print(a*a)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>110.25</code></p>\n<p>字符串连接例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=&quot;test &quot;</span><br><span class=\"line\">print(str*3)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>test test test</code></p>\n<blockquote>\n<p>/和//除法运算符</p>\n</blockquote>\n<p>普通除法算术例子(除不尽产生小数):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 3</span><br><span class=\"line\">print(a/b)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>3.3333333333333335</code></p>\n<p>整除除法算术例子(除不尽舍去小数):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 3</span><br><span class=\"line\">print(a//b)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>3</code></p>\n<p><strong>注意:Python中不可使用0作为除数，否则会引发<code>ZeroDivisionError</code>错误</strong></p>\n<p><strong>注意:Python2.x中没有整除运算符</strong></p>\n<p>Python2.x的的求整除的规则是:</p>\n<ul>\n<li><p>当两个操作数都是整数时，<code>/</code>作为整除运算符</p>\n</li>\n<li><p>当两个操作数其中一个是浮点数时，<code>/</code>作为非整除运算符</p>\n</li>\n</ul>\n<blockquote>\n<p>%求余运算符</p>\n</blockquote>\n<ul>\n<li><p>Python不需要求余的两个操作数是整数</p>\n</li>\n<li><p>Python不允许求余运算的第二个操作数为0</p>\n</li>\n</ul>\n<p>求余运算例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;10 % 3 = &quot;,(10%3))</span><br><span class=\"line\">print(&quot;10.5 % 3.5 = &quot;,(10.5%3.5))</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 % 3 =  1</span><br><span class=\"line\">10.5 % 3.5 =  0.0</span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<ul>\n<li>若求余运算第二个操作符为负数，那么结果也一定是负数。</li>\n</ul>\n<blockquote>\n<p>**乘方运算符</p>\n</blockquote>\n<p>乘方+开方运算例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&apos;5 的 2 次方：&apos;, 5 ** 2) # 25</span><br><span class=\"line\">print(&apos;4 的 3 次方：&apos;, 4 ** 3) # 64</span><br><span class=\"line\">print(&apos;4 的开平方：&apos;, 4 ** 0.5) # 2.0</span><br><span class=\"line\">print(&apos;27 的开 3 次方：&apos;,27 **(1 / 3 )) # 3.0</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 的 2 次方： 25</span><br><span class=\"line\">4 的 3 次方： 64</span><br><span class=\"line\">4 的开平方： 2.0</span><br><span class=\"line\">27 的开 3 次方： 3.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python赋值运算符（入门必读）\"><a href=\"#Python赋值运算符（入门必读）\" class=\"headerlink\" title=\"Python赋值运算符（入门必读）\"></a>Python赋值运算符（入门必读）</h1><p>赋值运算符常用于将运算符右侧的值赋值给左侧的容器。</p>\n<blockquote>\n<p>基本赋值运算符</p>\n</blockquote>\n<p>将赋值运算符右侧的表达式赋值给左侧的容器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = a</span><br><span class=\"line\">c = a+b</span><br><span class=\"line\">print(a,b,c)</span><br></pre></td></tr></table></figure>\n<p>输出:<code>10 10 20</code></p>\n<blockquote>\n<p>扩展后的赋值运算符</p>\n</blockquote>\n<p><code>=</code>赋值运算符与其他运算符结合后，将成为功能更强大的赋值运算符。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python常用赋值运算符.png\" alt=\"Python常用赋值运算符\"></p>\n<h1 id=\"Python位运算符详解\"><a href=\"#Python位运算符详解\" class=\"headerlink\" title=\"Python位运算符详解\"></a>Python位运算符详解</h1><p><code>初学者可暂时跳过本章</code></p>\n<p>位运算符通常使用场景是：图形、图像处理、创建设备驱动等底层开发。</p>\n<p>Python位运算符的操作对象为整数类型，它会把数字看做相应的二进制来进行计算。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python位运算符.png\" alt=\"python位运算符\"></p>\n<blockquote>\n<p>&amp;按位与运算符</p>\n</blockquote>\n<p>有两个操作数</p>\n<p>运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为1时，则结果为0，否则为1。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 5</span><br><span class=\"line\">print(bin(a), bin(b), a &amp; b)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0b1010 0b101 0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>|按位或 运算符</p>\n</blockquote>\n<p><code>|</code>是其运算符，具有两个操作数。</p>\n<p>运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为0时，则结果才为0，否则为1。</p>\n<blockquote>\n<p>^按位异或运算符</p>\n</blockquote>\n<p><code>^</code>是其运算符，具有两个操作数。</p>\n<p>运算符法则：按位将两个操作数对应的二进制进行一一对应，对应时，若对应数位都为0或1，则结果为0，否则为1</p>\n<blockquote>\n<p>~按位取反运算符</p>\n</blockquote>\n<p><code>~</code>是其运算符，具有1个操作数</p>\n<p>运算符法则：将其操作数的二进制进行取反，也就是：原本为0的取反为1，原本为1的取反为0.</p>\n<p>其他：原码、反码、补码是什么</p>\n<ul>\n<li><p>原码: 将某数值转换为二进制数，若此数值为正数或0则代表可以是无符号的，那么最高位则不需要一个符号位，若为负数则需要一个符号位。</p>\n</li>\n<li><p>反码: 对原码按位取反，但符号位不变。</p>\n</li>\n<li><p>补码: 负数的补码是其反码+1，正数或0的补码与原码相同。</p>\n</li>\n</ul>\n<blockquote>\n<p>&lt;&lt;左移运算符</p>\n</blockquote>\n<p><code>&lt;&lt;</code>是其运算符，具有两个操作数</p>\n<p>将操作数按补码形式进行整体向左移动。移动后，溢出的丢弃，空出的以0填补。</p>\n<blockquote>\n<p>>> 右移运算符</p>\n</blockquote>\n<p><code>&gt;&gt;</code>是其运算符，具有两个擦作数</p>\n<p>将操作数按补码形式进行整体向右移动。移动后，溢出的丢弃，空出的以符号位填补。。</p>\n<h1 id=\"Python比较运算符-关系运算符\"><a href=\"#Python比较运算符-关系运算符\" class=\"headerlink\" title=\"Python比较运算符(关系运算符)\"></a>Python比较运算符(关系运算符)</h1><p>比较运算符又称为关系运算符，其作用是对各种表达式，容器结果进行大小、真假等比较。如果比较结果为真，则返回True(真)否则返回False(假)。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python比较运算符.png\" alt=\"Python比较运算符表\"></p>\n<blockquote>\n<p>比较运算符 == 和 is区别</p>\n</blockquote>\n<p>== 比较的是值</p>\n<p>is 比较的所引用对象的地址</p>\n<h1 id=\"Python逻辑运算符及其用法\"><a href=\"#Python逻辑运算符及其用法\" class=\"headerlink\" title=\"Python逻辑运算符及其用法\"></a>Python逻辑运算符及其用法</h1><p>逻辑运算符也是对真假（布尔类型）进行运算符，其返回值也为bool。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png\" alt=\"Python比较运算符表\"></p>\n<h1 id=\"Python三目运算符-三元运算符-用法详解\"><a href=\"#Python三目运算符-三元运算符-用法详解\" class=\"headerlink\" title=\"Python三目运算符(三元运算符)用法详解\"></a>Python三目运算符(三元运算符)用法详解</h1><p>Python利用if来实现三目运算符的功能。</p>\n<p>语法格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">True_statements if expression else False_statements</span><br></pre></td></tr></table></figure>\n<p>运算法则: 先对<code>expression</code>(表达式)求值，如果为True则执行<code>True_statements</code>否则执行<code>False_statements</code></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 10</span><br><span class=\"line\">b = 20</span><br><span class=\"line\">print(&quot;a&gt;b&quot;) if a &gt; b else print(&quot;a&lt;b&quot;)</span><br></pre></td></tr></table></figure>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a&lt;b</span><br></pre></td></tr></table></figure></p>\n<p>Python允许在三目运算符的<code>False_statements</code>或<code>True_statements</code>放置多条语句。</p>\n<p>两种放置方式:</p>\n<ul>\n<li><p>以英文逗号隔开，将每条语句执行结果，组成元组。</p>\n</li>\n<li><p>以英文分号隔开，只返回一条语句的结果。 </p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 20</span><br><span class=\"line\">b = 20</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;a&gt;b&quot;) if a &gt; b else (print(&quot;a&lt;b&quot;) if a &lt; b else print(&quot;a=b&quot;))</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python运算符优先级\"><a href=\"#Python运算符优先级\" class=\"headerlink\" title=\"Python运算符优先级\"></a>Python运算符优先级</h1><p>不同的运算符有一个优先级，在用于在表达式中进行区别执行顺序。</p>\n<p><img src=\"/2019/08/31/Python-03-Python变量类型和运算符/Python运算符优先级.png\" alt=\"Python比较运算符表\"></p>"},{"title":"[Python-04]Python列表、元组、字典和集合","copyright":true,"date":"2019-09-08T07:00:28.000Z","_content":"\nPython系列第四章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/list_tuple_dict/)\n\n<!--more-->\n\n# 什么是序列，Python序列详解（包括序列类型和常用操作）\n\n序列：一块可存放多个且连续的内存空间，并且这些值有顺序，可通过索引进行访问。\n\n常见的序列有: 字符串、列表、元组、集合和字典。\n\n这些常见的序列，除了集合和字典不支持索引、切片、相加和相乘的操作，其余的都可以。\n\n## 序列索引\n\n索引就是一个序列中每个元素的编号。第一个元素的索引是0，也就是说想要访问某个序列的第一个元素，那么它的索引就是0，而想要访问最后一个元素，那么它的索引就是序列长度-1\n\n索引还分为正索引值和负索引值，它们的区别仅仅在于访问方式不同。\n\n__注意:__\n\n- 正索引值的起始位置是0，结束位置是序列长度-1\n\n- 负索引值的起始位置是-1,结束位置是-(序列长度-1)\n\n例子:\n\n__根据索引访问序列元素__\n\n~~~\nstr = \"Hello World\"\nprint(\"str 的第一个字符是:%s，最后一个字符是:%s\" % (str[0],str[len(str)-1]))\n~~~\n\n输出结果:\n~~~\nstr 的第一个字符是:H，最后一个字符是:d\n~~~\n\n## 序列切片\n\n刚刚我们通过索引值进行访问序列元素，那么序列切片也是可以做到的，它可以访问某个范围内的元素。\n\n语法格式:\n\n~~~\nsname[start:end:step]\n~~~\n\n- sname:序列名称\n\n- start:切片开始的索引位置（包括该位置），此参数可不指定，默认为0。\n\n- end:切片结束的索引位置(不包括该位置)，此参数可不指定，默认为序列的长度。\n\n- step:切片的范围，也就是每次取元素时，要隔多少个位置，此参数可不指定，可以直接忽略最后一个冒号\n\n例子:\n\n~~~\nstr = \"Hello World\"\n# 获取整个字符串\nprint(str[:])\n# 从索引4开始，一直到最后一个，没隔2个字符取一次。\nprint(str[4::2])\n~~~\n\n输出结果:\n\n~~~\nHello World\noWrd\n~~~\n\n## 序列相加\n\n序列可以使用`+`运算符，进行相加操作，他会将两个序列进行连接，但不会去除重复的元素。\n\n例子:\n\n~~~\nstr1=\"hello\"\nstr2=\"world\"\nprint(str1+str2)\n~~~\n\n输出结果:`helloworld`\n\n## 序列相乘\n\n使用`*`运算符，可以将序列的元素进行重复。\n\n例子:\n\n~~~\nstr1 = \"hello\\t\"\nprint(str1*3)\n~~~\n\n输出结果:`hello\thello\thello\t`\n\n__tips:可以使用序列相乘，创建指定长度空列表__\n\n~~~\ntest_list = [None]*5\n~~~\n\n## 检查元素是否包含在序列中\n\n使用`in`关键字可以检查序列中的元素是否存在。 \n\n语法格式:\n\n~~~\nvalue in sequence\n~~~\n\n例子:\n\n~~~\nstr1=\"Hello\"\nprint('o' in str1)\n~~~\n\n输出结果: `True`\n\n__tips:使用`not in`关键字可以检查是否不存在__\n\n\n## 和序列相关的内置函数\n\nPython提供了几个用于操作序列的内置函数，可以很方便的操作序列。\n\n![Python序列内置函数](Python-04-Python列表、元组、字典和集合/Python序列内置函数.png)\n\n# Python list列表详解\n\nPython提供了一种数据结构————`list`(列表)\n\n__列表可以存储多个不同数据类型的元素。__\n\n\n## Python创建列表\n\n创建列表分为两种方式\n\n使用`=`运算符创建列表\n\n语法格式:\n\n~~~\nlistname = [element1,element2...elementn]\n~~~\n\nlistname: 列表的名称\n\nelement1: 列表的元素\n\n例子:\n\n~~~\n# 创建一个列表\ntest_list1 =[\"one\",1,True,1.0]\nprint(test_list1)\n# 创建一个空列表\nempty_list = []\nprint(empty_list)\n~~~\n\n输出结果:\n\n~~~\n['one', 1, True, 1.0]\n[]\n~~~\n\n__使用list()函数创建列表__\n\n例子:\n\n~~~\nstr1=\"HelloWorld\"\ntest_list = list(str1)\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']\n~~~\n\n## 访问列表元素\n\n两种方式：通过索引访问和通过切片访问。\n\n## 删除列表\n\n不常用，因为Python具有垃圾回收机制，有些不需要再使用的列表将会自动回收。\n\n使用`del`关键字进行删除\n\n语法格式:\n\n~~~\ndel listname\n~~~\n\n__注意:删除后的列表不能再次使用__\n\n# Python list列表添加元素的3种方法\n\n## Python append()方法添加元素\n\n`append()`方法在列表的末尾追加元素。\n\n语法格式:\n\n~~~\nlistname.append(obj)\n~~~\n\nlistname代表要添加元素的列表;obj代表要添加到列表末尾的数据。\n\nobj可以是单个元素，也可以是其他序列。\n\n例子:\n\n~~~\n# 追加单个元素\nlist1 = [0,1,2,3]\nprint(list1)\nlist1.append(4)\nprint(list1)\n# 追加一个列表\nlist2 = [5,6,7,8]\nprint(list2)\nlist1.append(list2)\nprint(list1)\n~~~\n\n输出结果:\n~~~\n[0, 1, 2, 3]\n[0, 1, 2, 3, 4]\n[5, 6, 7, 8]\n[0, 1, 2, 3, 4, [5, 6, 7, 8]]\n~~~\n\n__注意:使用append()函数时，如果是传递的单个数据，将会直接追加到列表后，但是如果传入的是个列表（序列），那么则会追加一个列表形式的元素。__\n\n想要访问刚刚追加的列表元素的其中一个可以这样：\n\n~~~\nlist1 = [0,1,2]\nlist2 = [3,4,5]\nlist1.append(list2)\nprint(list1[3][2])\n~~~\n\n输出结果:`5`\n\n## Python extend()方法添加元素\n\n刚刚我们使用`append()`函数追加了个列表元素，但是并没有像添加单个字符一样作为一个整体添加，而我们只需要使用`extend()`方法就可以将列表以整体的方式添加进去。\n\n例子:\n\n~~~\nlist1 = [0,1,2,3]\nprint(list1)\nlist2 = [5,6,7,8]\nprint(list2)\nlist1.extend(list2)\nprint(list1)\n~~~\n\n输出结果:\n\n~~~\n[0, 1, 2, 3]\n[5, 6, 7, 8]\n[0, 1, 2, 3, 5, 6, 7, 8]\n~~~\n\n## Python insert()方法插入元素\n\n需要指定插入列表元素的位置时，可以使用insert()方法。\n\n语法格式:\n\n~~~\nlistname.insert(index,obj)\n~~~\n\nindex: 将obj插入到listname列表的索引\n\n例子:\n\n~~~\ntest_list1 = list(range(1,11))\nprint(test_list1)\n\nprint(len(test_list1))\ntest_list1.insert(len(test_list1),11)\nprint(test_list1)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n~~~\n\n## Pyhton list列表删除元素(3种方法)\n\n> del删除\n\n__del语句在Python中可以删除变量、列表的元素__\n\n~~~\ntest_list = list(range(1, 11))\nprint(test_list)\ndel test_list[1::2]\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 3, 5, 7, 9]\n~~~\n\n> 根据元素值进行删除\n\n可以使用remove()方法来删除列表元素。\n\n删除第一个被查找到的元素。\n\n__注意:remove()方法不是根据索引来删除元素的，而是查找元素本身，再进行删除，所以如果找不到元素，则会报错__\n\n例子:\n\n~~~\ntest_list = ['test', 30, 'test2', 10, 30]\ntest_list.remove('test')\ntest_list.remove(30)\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n['test2', 10, 30]\n~~~\n\n> 删除列表所有元素\n\n使用clear()方法可以删除列表的所有元素。\n\n例子:\n\n~~~\ntest_list = ['test', 30, 'test2', 10, 30]\ntest_list.clear()\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n[]\n~~~\n\n# Python list列表修改元素\n\n修改列表元素，可以通过列表索引获取元素进行赋值。\n\n~~~\ntestlist = list(range(1,10))\nprint(testlist)\ntestlist[len(testlist)-1] = 100\nprint(testlist)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 100]\n\n[Process exited 0]\n~~~\n\n使用slice语法对列表部分进行赋值。\n\nslice语法，不要求新赋值的元素个数与原来的元素个数相等。也就是说使用slice剩余法既可以为列表增加元素，也可以为列表删除元素。\n\n~~~\nb_list = list(range(1,5))\nprint(b_list)\n\nb_list[1:3] = ['a','b']\nprint(b_list)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4]\n[1, 'a', 'b', 4]\n~~~\n\n# Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略\n\nPyhton为list提供了一些常用的方法。\n\n我们使用dir(list)方法可以看到列表包含的所有方法。\n\n```\nprint(dir(list))\n```\n\n输出结果:\n\n```\n  6 _', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__',\n  5 '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setat\n  4 tr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'c\n  3 lear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse'\n  2 , 'sort']\n```\n\n**注意，方法名包含双下划线的不推荐使用** \n\n## count()方法\n\ncount()方法用于统计列表中某个元素出现的次数\n\n语法格式\n\n`listname.count(obj)` \n\nlistname:列表名称\n\nobj:表示判断是否存在的元素\n\n例子:\n\n```\na_list = [2]*5\nprint(a_list)\nprint(\"2出现%d次\" % a_list.count(2))\n```\n\n```\n[2, 2, 2, 2, 2]\n2出现5次\n```\n\n## index()用法\n\nindex()方法用于定位某元素在列表的索引位置，如果该元素没有出现，则会引发ValueError错误。 \n\n语法格式:\n\n`listname.index(obj,start,end)`\n\nindex()方法可以传入start,end参数，用于指定在列表的某范围内搜索元素\n\n例子:\n\n```\ntest_list = list(range(1,10))\nprint(test_list)\nprint(test_list.index(9))\n```\n\n输出结果:\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n8\n```\n## pop用法\n\npop()方法会溢出列表中指定索引处的元素，如果没有传入参数，则会移除列表中最后一个元素。\n\n语法格式:\n\n`listname.pop(index)` \n\n例子:\n\n```\ntest_list = list(range(1,10))\nprint(test_list)\n# 默认移除最后一个元素\ntest_list.pop()\nprint(test_list)\n# 移除第一次元素\nprint(test_list.pop(0))\nprint(test_list)\n```\n\n输出结果:\n\n```\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8]\n1\n[2, 3, 4, 5, 6, 7, 8]\n```\n\n## reverse()方法\n\nreverse()方法会将列表中所有元素反向存放。\n\n语法格式;\n\n`listname.reverse()`\n\n例子:\n\n```\ntest_list = list(range(1,11))\nprint(test_list)\ntest_list.reverse()\nprint(test_list)\n```\n\n输出结果:\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n## sort()用法\n\nsort()方法用于对列表元素进行排序。\n\n语法格式:\n\n`listname.sort(key=None,reserse=Fale)`\n\n- key参数用于指定从每个元素中提取一个用于比较的键。\n\n- reverse参数用于设置是否需要逆序，默认为False也就是从小打到排序，否则反之。\n\n例子:\n\n```\na_list = [123,213,1,325,1,51,213,5132,4156]\nprint(a_list)\n# 对列表进行排序\na_list.sort()\nprint(a_list)\n# 逆序排序\na_list.sort(reverse=True)\nprint(a_list)\n```\n\n输出结果:\n\n```\n[123, 213, 1, 325, 1, 51, 213, 5132, 4156]\n[1, 1, 51, 123, 213, 213, 325, 4156, 5132]\n[5132, 4156, 325, 213, 213, 123, 51, 1, 1]\n```\n\n# Python range()快速初始化数字列表\n\nPython的range()函数能够生成一系列的数字。\n\n```\nfor value in range(1,5):\n  print(value)\n```\n\n输出结果:\n\n```\n1\n2\n3\n4\n```\n\nrange()方法是指定从第一个值开始，生成连续的数字，直到指定的第二值为止(不包括第二个值)\n\nrange()方法可以指定步长，也就是说，每次连续增加时所增加的数值。\n\n# Python tuple元组详解\n\n与列表类似，元组也可以存储任何Python的数据类型，但元组是不可变的，一旦赋值则不可修改。\n\nPython中，使用`()`小括号包住的一列数据，被称为元组，而各数据之间又由`,`逗号隔开。\n\n元组的数据类型是:`tuple`\n\n```\ntest_tuple = tuple(range(1,11))\nprint(type(test_tuple))\n```\n输出结果:\n\n```\n<class 'tuple'>\n\n[Process exited 0]\n```\n\n## Python创建元组\n\n### = 运算符直接创建元组\n\n可以使用赋值运算符`=`将一个元组赋值给变量。\n\n语法格式:\n\n```\ntuplename = (element1,element2...elementn)\n```\n\n其中tuplename表示要创建的元组名,element代表元素。\n\n例子:\n\n```\nnum_tuple = tuple(range(1,11))\nstr_tuple = (\"Just A Test\",)\nobject_tuple = (\"a\",1,2.22,num_tuple,list(range(1,5)))\n\nprint(num_tuple)\nprint(str_tuple)\nprint(object_tuple)\n```\n\n输出结果:\n\n```\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nJust A Test\n('a', 1, 2.22, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), [1, 2, 3, 4])\n```\n\n**注意** :创建元组时，如果元组内只有一个元素，那么必须要在元素后加上一个逗号，否则Python解释器将会一位是字符串。\n\n```\ntest_str = (\"Just a Test\")\nstr_tuple = (\"Jest a Test\",)\nprint(type(test_str))\nprint(type(str_tuple))\n```\n\n输出结果:\n\n```\n<class 'str'>\n<class 'tuple'>\n```\n\n### 使用tuple()函数创建元组\n\nPython提供了tuple()函数创建元组，我们可以将一些常见的对象，转化成元组。\n\n语法格式:\n\n`tuple(iterable: Iterable[_T_co]=...)`\n\n例子:\n\n```\ntest_list = list(range(1,21,2))\ntest_tuple = tuple(test_list)\n\nprint(type(test_list))\nprint(type(test_tuple))\n```\n\n输出结果:\n\n```\n<class 'list'>\n<class 'tuple'>\n```\n\n## Python访问元组元素\n\n可以通过元素的下标获取或通过切片操作获取。\n\n## Python修改元组元素\n\n虽然前面提到元组是不可变序列，但还是可以通过一些手段进行修改元组内的数据。\n\n### 重新赋值\n\n```\ntest_tuple = tuple(range(1,6))\nprint(test_tuple)\ntest_tuple = tuple(range(1,20))\nprint(test_tuple)\n```\n\n输出结果:\n\n```\n(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\n```\n\n### 连接多个元组\n\n```\ntest_tuple = tuple(range(1,6))\nprint(test_tuple)\ntest_tuple2 = tuple(range(6,11))\ntest_tuple += test_tuple2\nprint(test_tuple)\n```\n\n输出结果:\n\n```\n(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\n## Python删除元组\n\n若创建的元组不再使用可以使用`del`语句将其删除。\n\n# Python元组和列表的区别\n\n本节讨论元组和列表的区别:\n\n| 区别                 | 元组 | 列表 |\n|----------------------|------|------|\n| 元素是否允许任意修改 | ❌   | ⭕   |\n| 是否能作为map的key   | ⭕   | ❌   |\n| 内存占用小           | ⭕   | ❌   |\n\n# Python列表和元组的底层实现\n\n这里就不记录笔记了，总的来说就是列表是一个长度可变且连续的内存空间，当列表的元素满了后，将会申请更多的内存空间，再将原本的内存空间拷贝过去。而元组则是一个空间带下固定且连续的内存空间。Python对元组进行了优化，例如为了避免系统老是释放和申请内存空间这一繁琐且耗时的操作，所以每次释放元组时其实是将其放入一个缓存中，如果下次还需要申请相同数据的元组，则可以直接从缓存中拿到。\n\n具体介绍看这里[💿Python列表和元组的底层实现](http://c.biancheng.net/view/5360.html) \n\n# Python dict字典\n\ndict字典属于可变序列，但是无序的序列，其内容是键值对的形式保存的。\n\n键值对也可以称为映射，所以字典的值与键是互相对应的关系。\n\nPython字典特征\n\n| 特征                           | 解释                                                                                        |\n|--------------------------------|---------------------------------------------------------------------------------------------|\n| 通过键读取元素                 | 通过字典中的键来获取指定项，而不是通过索引获取                                              |\n| 字典是任意数据类型的无序集合   | 和列表、元组不同，索引值可以通过数字获取对应的元素，而字典中的元素是无序的。                |\n| 字典是可变的，并且可以任意嵌套 | 字典可以在原处增长或缩短，并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其他字典   |\n| 字典中的键必须是唯一的         | 字典中不允许出现相同的键，否则只会保留最后一个键值对                                        |\n| 字典中的键必须是不可变的       | 字典中的值是不可变的，所以只能使用数字、或元组、字符串等，不能使用可变，例如可变序列：列表 |\n\n**Python中字典的数据类型为`dict`** \n\n## Python创建字典\n\n### 花括号语法创建字典\n\n字典中每个元素都包含两个部分，分别是键和值。因此在创建字典元素时，需要在键和值之间以冒号`:`分隔，相邻元素之间使用逗号分隔，所有元素放下大括号`{}`间。\n\n语法格式:\n\n`dictname = {'key1':'value',\"key2\":\"value\"}`\n\n其中`dictname` 代表字典名，`key:value` 表示各个元素的键值对。\n\n使用花括号创建字典例子:\n\n```\ntest_dict = {\"语文\":80,\"数学\":12}\nprint(test_dict)\n\n```\n\n输出结果\n\n`{'语文': 80, '数学': 12}`\n\n### 通过fromkey()方法创建字典\n\nPython中使用dict字典类型提供的fromkeys()方法创建所有键值为空的字典。\n\n语法格式\n\n`dictname=dict.fromkeys(list,value=None)` \n\nlist参数表示字典中键的列表，value参数默认为None，表示所有键对应的值。\n\n例子:\n\n```\nknowledge = {'语文','数学','英语'}\nscores = dict.fromkeys(knowledge,100)\nprint(scores)\n```\n\n输出结果:\n\n```\n{'语文': 100, '英语': 100, '数学': 100}\n```\n\n### 通过dict()映射函数创建字典\n\ndict()函数常用创建字典方法\n\n![dict()函数创建字典](Python-04-Python列表、元组、字典和集合/dict()函数创建字典.png)\n\n## Pyton访问字典\n\ndict()通过元素的键进行访问值，不能像列表或元组通过下标或切片的形式来访问。\n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\nprint(type(test_dict))\nprint(test_dict['姓名'])\nprint(test_dict.get(\"性别\"))\n```\n\n## Python删除字典\n\n如需手动删除，可以使用del语句。\n\n# Pythton dict字典基本操作(包括添加、修改、删除键值对)\n\n本小节对字典实现常见的操作:\n\n- 向字典中添加新的键值对\n\n- 修改字典中的键值对\n\n- 从字典中删除指定的键值对\n\n- 判断字典中是否存在指定的键值对\n\n## Python字典添加键值对\n\n为字典中添加新的键值对只需要为不存在的`key`赋值。\n\n语法格式:\n\n`dict[key]= value` \n\n`dict`表示字典名称,`key`代表新建键值对的键,`value`代表新建键值对的值\n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ntest_dict['班级'] = 502\nprint(test_dict.get(\"班级\"))\n```\n\n输出结果:\n\n`502` \n\n## Python字典修改键值对\n\n这里的修改是指:修改键值对的值。\n\n**Python中如果新添加的键值对的键存在，那么则会覆盖原本的键值对的值** \n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ntest_dict['班级'] = 502\nprint(test_dict.get(\"班级\"))\ntest_dict['班级'] = 999\nprint(test_dict.get(\"班级\"))\n```\n\n输出结果:\n\n```\n502\n999\n```\n\n## Python字典删除键值对\n\n如果要删除字典中的键值对，则可以使用`del`语句，指定要删除的键值对的键。\n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ntest_dict['班级'] = 502\nprint(test_dict.get(\"班级\"))\ndel test_dict['班级']\nprint(test_dict.get(\"班级\"))\n```\n\n输出结果:\n\n```\n502\nNone\n```\n\n## 判断字典中是否存在指定键值对\n\n如果需要判断字典是否存在指定键值对的键，可以使用`in`或`not in`运算符。\n\n**注意:这里的`in`或`not in`运算符都是基于`key`来判断字典中某个键值对是否存在的.** \n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ndel test_dict['姓名']\nprint(test_dict.get(\"姓名\"))\nprint('姓名' in test_dict)\n```\n\n输出结果:\n\n```\nNone\nFalse\n```\n\n# Python dict字典方法完全攻略(全)\n\n想查看`dict`该类包包含哪些方法，可以使用`dir()`方法进行查看。\n\n## Python keys(),values()和items()方法\n\n这三个方法可以获取字典中特定的数据.\n\n`keys()`方法用于返回字典中的所有键;\n\n`values()`用于返回字典中所有键对应的值;\n\n`items()`用于返回字典中所有的键值对;\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\nprint(test_dict.keys())\nprint(test_dict.values())\nprint(test_dict.items())\n```\n\n输出结果:\n\n```\ndict_keys(['英语', '语文', '数学'])\ndict_values([100, 100, 100])\ndict_items([('英语', 100), ('语文', 100), ('数学', 100)])\n```\n\n**注意:`Python2.x`中，上面提到的方法的返回值是列表类型。但在`Python3.x`中，以上方法返回的类型不是序列类型。** \n\n## Python copy()方法\n\n`copy()`方法用于返回一个具有相同键值对的新字典:\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\ntest_dict2 = test_dict.copy()\nprint(test_dict,\"\\n\",test_dict2)\n```\n\n输出结果:\n\n```\n{'英语': 100, '语文': 100, '数学': 100}\n{'英语': 100, '语文': 100, '数学': 100}\n```\n\n**注意Python的copy()方法涉及到`深拷贝`与`浅拷贝`的关系，当字典A拷贝键值对给字典B后，那么拷贝的数据(字典B内)将会在字典A对键值对进行修改时发生变化，而字典A添加新的键值对，字典B不收影响。** \n\n## Python update()方法\n\nupdae()方法可以使用一个字典所包含的键值对来更新已有的字典。\n\n如果被更新的字典中已存在对应的键值对，那么原键值对值将会被覆盖，否则将会被添加。\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\ntest_dict2 = test_dict.copy()\nprint(type(test_dict))\ntest_dict['语文']=100\ntest_dict2['物理']=200\ntest_dict2.update(test_dict)\nprint(test_dict,\"\\n\",test_dict2)\nprint(test_dict,\"\\n\",test_dict2)\n```\n\n输出结果:\n\n```\n<class 'dict'>\n{'英语': 100, '数学': 100, '语文': 100}\n{'英语': 100, '数学': 100, '语文': 100, '物理': 200}\n{'英语': 100, '数学': 100, '语文': 100}\n{'英语': 100, '数学': 100, '语文': 100, '物理': 200}\n```\n\n## Python pop方法\n\npop()方法可以获取指定key的value，并删除。\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\nprint(test_dict.pop('语文'))\n```\n\n输出结果:\n\n```\n100\n{'英语': 100, '数学': 100}\n```\n\n## Python popitem()方法\n\npopitem()方法用于弹出字典中最后一个键值对(这里的最后一个其实是随机的，因为字典是无序序列，所以并不能说的某个键值对的位置取向).\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\nprint(test_dict.popitem())\nprint(test_dict)\n```\n\n输出结果:\n\n```\n('数学', 100)\n{'英语': 100, '语文': 100}\n```\n\n## Python setdefault()方法\n\nsetdefault()方法用于根据key来获取value，但有两种场景，第一种是，如果获取的键值对的key存在字典中，则会直接获取改键值对的value，不存在则会为该key先将value设置为默认的value，然后再返回该key对应的value。\n\n\n**特点:setdefault方法总能返回指定key对应的value;**\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\n# 要设置的键值对的key不存在.\ntest_dict.setdefault('物理',120)\nprint(test_dict)\n# 要设置的键值对的key存在.\ntest_dict.setdefault('语文',200)\nprint(test_dict)\n```\n\n输出结果:\n\n```\n{'数学': 100, '英语': 100, '语文': 100, '物理': 120}\n{'数学': 100, '英语': 100, '语文': 100, '物理': 120}\n```\n\n# Python使用字典格式化字符串\n\n我们知道，在格式化字符串时，如果格式化字符串模板中包含多个变量时，则后面月必须按顺序加上相同个数的变量，如果变量过多，则会十分麻烦，Python提供了用字典格式化字符串的方式来解决。\n\n例子:\n\n```\nstudent = '姓名:%(name)s\\t班级:%(class)d\\t综合成绩:%(score)f'\nstudent_info = {'name':'LTy','class':604,'score':99.5}\nprint(student % student_info)\n```\n\n输出结果:\n\n```\n姓名:LTy        班级:604        综合成绩:99.500000\n```\n\n# Python set集合详解\n\nset集合的特点:\n\n- 数据唯一性(必须保证集合中每种数据元素是唯一的)\n\n- 数据不可变(只允许存储不可变的数据类型，例如列表、字典、集合则是不允许存储在集合中的)\n\n- 集合是无序的，所以每次输出元素时，排序顺序可能都不同。\n\n## Python创建set集合\n\n有两种创建`set`集合的方法，分别是使用{}创建和使用set()函数将列表、元组等数据类型转化为集合。\n\n### 使用{}创建\n\n语法格式:\n\n`setname = {element1,element2...elementn}`\n\nsetname代表集合的名称。\n\n例子:\n\n```\ntest_set = {1,2,3,4}\nprint(test_set)\n```\n\n输出结果:\n\n```\n{1, 2, 3, 4}\n```\n\n### 使用set()函数创建集合\n\nset()函数为Python的内置函数，其可以将字符串、列表、元组以及range对象等可迭代的对象转换成集合。\n\n语法格式:\n\n`setname = set(iteration)` \n\niteration就表示可迭代的对象。\n\n```\nset1 = set(\"I Love China\")\nset2 = set(list(range(1,6)))\nset3 = set(tuple(range(1,6)))\nset4 = set(range(1,6))\nprint(set1)\nprint(set2)\nprint(set3)\nprint(set4)\n```\n\n输出结果:\n\n```\n# 从输出结果看，字符串被打乱了\n{'a', 'L', 'h', ' ', 'C', 'e', 'n', 'i', 'I', 'v', 'o'}\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5}\n```\n\n**注意:如果想要创建空集合，必须使用`set()`函数实现，因为如果只给一对`{}`，Python解释器会将其视为一个空字典。**\n\n## Python访问set集合元素\n\n由于`set`集合是无序的，所以无法通过下标索引进行访问，但是我们可通过遍历`set`集合访问元素。\n\n```\nset1 = set(\"I Love China\")\n\nfor ele in set1:\n    print(ele,end='')\n```\n\n输出结果:\n\n```\noCenaL Ihvi\n```\n\n## Python删除set集合\n\n想要手动删除`set`集合可以使用`del()`方法。\n\n```\nset1 = set(\"I Love China\")\nprint(set1)\ndel(set1)\nprint(set1)\n```\n\n输出结果:\n\n```\n{'a', 'i', 'e', ' ', 'L', 'C', 'o', 'h', 'I', 'n', 'v'}\nTraceback (most recent call last):\n  File \"test.py\", line 4, in <module>\n  │ print(set1)\nNameError: name 'set1' is not defined\n```\n\n# Python set集合基本操作(添加、删除、交集、并集、差集)\n\n`set`集合最常用的场景是添加、删除元素以及在多个集合之间做交集、并集、差集等运算。 \n\n## 向set集合中添加元素\n\nPython为`set`集合提供了`add()`方法，其可以向`set`集合添加元素。\n\n语法格式:\n\n`setname.add(element)` \n\nsetname表示要添加元素的集合，element代表添加的元素。\n\n**注意:element不可为可变数据类型** \n\n## 从set集合中删除元素\n\n想要从集合中删除某个元素可以使用`remove()`方法\n\n语法格式:\n\n`setname.remove(element)` \n\n例子:\n\n```\nset1 = {1,2,3,4}\nprint(set1)\nset1.remove(1)\nprint(set1)\n```\n\n输出结果:\n\n```\n{1, 2, 3, 4}\n{2, 3, 4}\n```\n\n**注意:如果要删除的元素已经被删除，再次删除则会引发`KeyError`错误**\n\n如果想要在删除失败时不抛出异常，我们可以使用`discard()`方法。\n\n例子:\n\n```\nset1 = {1,2,3,4}\nprint(set1)\nset1.remove(1)\nprint(set1)\nset1.discard(1)\nprint(set1)\nset1.remove(1)\nprint(set1)\n\n```\n\n输出结果:\n\n```\n{1, 2, 3, 4}\n{2, 3, 4}\n{2, 3, 4}\nTraceback (most recent call last):\n  File \"test.py\", line 7, in <module>\n  │ set1.remove(1)\nKeyError: 1\n```\n\n`discard()`方法与`remove()`方法的唯一区别在于:**删除失败时是否抛出异常** o\n\n## Python set集合做交集、并集、差集运算\n\n`set`集合最常用的操作也就是进行交集、并集、差集以及对称差集运算了，首先看这张图:\n\n![集合示意图](Python-04-Python列表、元组、字典和集合/Python集合示意图.png) \n\n图中有两个集合，分别是:\n\n- `set1={1,2,3}`\n\n- `set2={3,4,5}`\n\n下面的表格展示了不同的运算，得到的不同的结果。\n\n![集合运算图](Python-04-Python列表、元组、字典和集合/Python集合运算.png) \n\n# Python set集合方法详解(全)\n\n如果想要看`set`集合所有的方法，可以使用`dir(set)`进行查看。\n\nPython set方法\n\n| 方法名                        | 语法格式                               | 功能                                                                 |\n|-------------------------------|----------------------------------------|----------------------------------------------------------------------|\n| add()                         | set1.add()                             | 向set1集合中添加非可变元素                                           |\n| clear()                       | set1.clear()                           | 清空set1集合中所有的元素                                             |\n| copy()                        | set2=set1.copy()                       | 拷贝set1集合中的元素给set2                                           |\n| difference()                  | set3=set1.difference(set2)             | 将set1中有而set2中没有的元素给set3                                   |\n| difference_update()           | set1.difference_update(set2)           | 从set1中删除与set2相同的元素                                         |\n| discard()                     | set1.discard(element)                  | 删除set1中的element元素                                              |\n| intersection()                | set3=set1.intersection(set2)           | 取set1和set2的交集赋值给set3                                         |\n| intersection_update()         | set1.intersection_update(set2)         | 取set1和set2的交集并且将值赋值给set1(更新set1的值为set1与set2的交集) |\n| isdisjoint()                  | set1.isdisjoint(set2)                  | 判断set1和set2是否没有交集，有交集返回False;没有则返回True           |\n| issubset()                    | set1.issubset(set2)                    | 判断set1是否是set2的子集                                             |\n| issuperset()                  | set1.issuperset(set2)                  | 判断set2是否是set1的子集                                             |\n| pop()                         | a = set1.pop()                         | 取出set1中一个元素并赋值给a                                          |\n| remove()                      | set1.remove(element)                   | 移除set1中的element元素                                              |\n| symmetric_difference()        | set3=set1.symmetric_difference(set2)   | 取set1和set2中互不相同的元素给set3                                   |\n| symmetric_difference_update() | set1.symmetric_difference_update(set2) | 取set1和set2中互不相同的元素并更新set1的值                           |\n| union()                       | set3=set1.union(set2)                  | 取set1和set2的并集，赋值给set3                                       |\n| update()                      | set1.update(element)                   | 添加列表或集合中的元素到set1                                         |\n\n# Python frozenset(set集合的不可变版本)\n\n前面我们所学习的`set`集合是可变的，而frozenset则是`set`集合的不可变版本，它不具备`set`集合的所有能改变集合本身的方法。\n\nfrozenset的主要使用场景:\n\n- 当集合元素不需要改变的时候，使用frozenset替代set将会更加安全。\n\n- 当某些API需要不可变对象作为参数时，必须用到frozenset替代set。\n\n\n# 深入底层了解Python字典和集合、一眼看穿他们的本质\n\n本小节涉及到未知的知识，推荐去原文看**[查看原文](http://c.biancheng.net/view/5302.html) \n\n# Python深拷贝和浅拷贝详解\n\n本小节涉及到未知的知识，推荐去原文看[查看原文](http://c.biancheng.net/view/5358.html) \n\n","source":"_posts/Python-04-Python列表、元组、字典和集合.md","raw":"---\ntitle: '[Python-04]Python列表、元组、字典和集合'\ncopyright: true\ndate: 2019-09-08 15:00:28\ncategories: Python\ntags:\n - Python系列\n---\n\nPython系列第四章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/list_tuple_dict/)\n\n<!--more-->\n\n# 什么是序列，Python序列详解（包括序列类型和常用操作）\n\n序列：一块可存放多个且连续的内存空间，并且这些值有顺序，可通过索引进行访问。\n\n常见的序列有: 字符串、列表、元组、集合和字典。\n\n这些常见的序列，除了集合和字典不支持索引、切片、相加和相乘的操作，其余的都可以。\n\n## 序列索引\n\n索引就是一个序列中每个元素的编号。第一个元素的索引是0，也就是说想要访问某个序列的第一个元素，那么它的索引就是0，而想要访问最后一个元素，那么它的索引就是序列长度-1\n\n索引还分为正索引值和负索引值，它们的区别仅仅在于访问方式不同。\n\n__注意:__\n\n- 正索引值的起始位置是0，结束位置是序列长度-1\n\n- 负索引值的起始位置是-1,结束位置是-(序列长度-1)\n\n例子:\n\n__根据索引访问序列元素__\n\n~~~\nstr = \"Hello World\"\nprint(\"str 的第一个字符是:%s，最后一个字符是:%s\" % (str[0],str[len(str)-1]))\n~~~\n\n输出结果:\n~~~\nstr 的第一个字符是:H，最后一个字符是:d\n~~~\n\n## 序列切片\n\n刚刚我们通过索引值进行访问序列元素，那么序列切片也是可以做到的，它可以访问某个范围内的元素。\n\n语法格式:\n\n~~~\nsname[start:end:step]\n~~~\n\n- sname:序列名称\n\n- start:切片开始的索引位置（包括该位置），此参数可不指定，默认为0。\n\n- end:切片结束的索引位置(不包括该位置)，此参数可不指定，默认为序列的长度。\n\n- step:切片的范围，也就是每次取元素时，要隔多少个位置，此参数可不指定，可以直接忽略最后一个冒号\n\n例子:\n\n~~~\nstr = \"Hello World\"\n# 获取整个字符串\nprint(str[:])\n# 从索引4开始，一直到最后一个，没隔2个字符取一次。\nprint(str[4::2])\n~~~\n\n输出结果:\n\n~~~\nHello World\noWrd\n~~~\n\n## 序列相加\n\n序列可以使用`+`运算符，进行相加操作，他会将两个序列进行连接，但不会去除重复的元素。\n\n例子:\n\n~~~\nstr1=\"hello\"\nstr2=\"world\"\nprint(str1+str2)\n~~~\n\n输出结果:`helloworld`\n\n## 序列相乘\n\n使用`*`运算符，可以将序列的元素进行重复。\n\n例子:\n\n~~~\nstr1 = \"hello\\t\"\nprint(str1*3)\n~~~\n\n输出结果:`hello\thello\thello\t`\n\n__tips:可以使用序列相乘，创建指定长度空列表__\n\n~~~\ntest_list = [None]*5\n~~~\n\n## 检查元素是否包含在序列中\n\n使用`in`关键字可以检查序列中的元素是否存在。 \n\n语法格式:\n\n~~~\nvalue in sequence\n~~~\n\n例子:\n\n~~~\nstr1=\"Hello\"\nprint('o' in str1)\n~~~\n\n输出结果: `True`\n\n__tips:使用`not in`关键字可以检查是否不存在__\n\n\n## 和序列相关的内置函数\n\nPython提供了几个用于操作序列的内置函数，可以很方便的操作序列。\n\n![Python序列内置函数](Python-04-Python列表、元组、字典和集合/Python序列内置函数.png)\n\n# Python list列表详解\n\nPython提供了一种数据结构————`list`(列表)\n\n__列表可以存储多个不同数据类型的元素。__\n\n\n## Python创建列表\n\n创建列表分为两种方式\n\n使用`=`运算符创建列表\n\n语法格式:\n\n~~~\nlistname = [element1,element2...elementn]\n~~~\n\nlistname: 列表的名称\n\nelement1: 列表的元素\n\n例子:\n\n~~~\n# 创建一个列表\ntest_list1 =[\"one\",1,True,1.0]\nprint(test_list1)\n# 创建一个空列表\nempty_list = []\nprint(empty_list)\n~~~\n\n输出结果:\n\n~~~\n['one', 1, True, 1.0]\n[]\n~~~\n\n__使用list()函数创建列表__\n\n例子:\n\n~~~\nstr1=\"HelloWorld\"\ntest_list = list(str1)\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']\n~~~\n\n## 访问列表元素\n\n两种方式：通过索引访问和通过切片访问。\n\n## 删除列表\n\n不常用，因为Python具有垃圾回收机制，有些不需要再使用的列表将会自动回收。\n\n使用`del`关键字进行删除\n\n语法格式:\n\n~~~\ndel listname\n~~~\n\n__注意:删除后的列表不能再次使用__\n\n# Python list列表添加元素的3种方法\n\n## Python append()方法添加元素\n\n`append()`方法在列表的末尾追加元素。\n\n语法格式:\n\n~~~\nlistname.append(obj)\n~~~\n\nlistname代表要添加元素的列表;obj代表要添加到列表末尾的数据。\n\nobj可以是单个元素，也可以是其他序列。\n\n例子:\n\n~~~\n# 追加单个元素\nlist1 = [0,1,2,3]\nprint(list1)\nlist1.append(4)\nprint(list1)\n# 追加一个列表\nlist2 = [5,6,7,8]\nprint(list2)\nlist1.append(list2)\nprint(list1)\n~~~\n\n输出结果:\n~~~\n[0, 1, 2, 3]\n[0, 1, 2, 3, 4]\n[5, 6, 7, 8]\n[0, 1, 2, 3, 4, [5, 6, 7, 8]]\n~~~\n\n__注意:使用append()函数时，如果是传递的单个数据，将会直接追加到列表后，但是如果传入的是个列表（序列），那么则会追加一个列表形式的元素。__\n\n想要访问刚刚追加的列表元素的其中一个可以这样：\n\n~~~\nlist1 = [0,1,2]\nlist2 = [3,4,5]\nlist1.append(list2)\nprint(list1[3][2])\n~~~\n\n输出结果:`5`\n\n## Python extend()方法添加元素\n\n刚刚我们使用`append()`函数追加了个列表元素，但是并没有像添加单个字符一样作为一个整体添加，而我们只需要使用`extend()`方法就可以将列表以整体的方式添加进去。\n\n例子:\n\n~~~\nlist1 = [0,1,2,3]\nprint(list1)\nlist2 = [5,6,7,8]\nprint(list2)\nlist1.extend(list2)\nprint(list1)\n~~~\n\n输出结果:\n\n~~~\n[0, 1, 2, 3]\n[5, 6, 7, 8]\n[0, 1, 2, 3, 5, 6, 7, 8]\n~~~\n\n## Python insert()方法插入元素\n\n需要指定插入列表元素的位置时，可以使用insert()方法。\n\n语法格式:\n\n~~~\nlistname.insert(index,obj)\n~~~\n\nindex: 将obj插入到listname列表的索引\n\n例子:\n\n~~~\ntest_list1 = list(range(1,11))\nprint(test_list1)\n\nprint(len(test_list1))\ntest_list1.insert(len(test_list1),11)\nprint(test_list1)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n~~~\n\n## Pyhton list列表删除元素(3种方法)\n\n> del删除\n\n__del语句在Python中可以删除变量、列表的元素__\n\n~~~\ntest_list = list(range(1, 11))\nprint(test_list)\ndel test_list[1::2]\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 3, 5, 7, 9]\n~~~\n\n> 根据元素值进行删除\n\n可以使用remove()方法来删除列表元素。\n\n删除第一个被查找到的元素。\n\n__注意:remove()方法不是根据索引来删除元素的，而是查找元素本身，再进行删除，所以如果找不到元素，则会报错__\n\n例子:\n\n~~~\ntest_list = ['test', 30, 'test2', 10, 30]\ntest_list.remove('test')\ntest_list.remove(30)\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n['test2', 10, 30]\n~~~\n\n> 删除列表所有元素\n\n使用clear()方法可以删除列表的所有元素。\n\n例子:\n\n~~~\ntest_list = ['test', 30, 'test2', 10, 30]\ntest_list.clear()\nprint(test_list)\n~~~\n\n输出结果:\n\n~~~\n[]\n~~~\n\n# Python list列表修改元素\n\n修改列表元素，可以通过列表索引获取元素进行赋值。\n\n~~~\ntestlist = list(range(1,10))\nprint(testlist)\ntestlist[len(testlist)-1] = 100\nprint(testlist)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 100]\n\n[Process exited 0]\n~~~\n\n使用slice语法对列表部分进行赋值。\n\nslice语法，不要求新赋值的元素个数与原来的元素个数相等。也就是说使用slice剩余法既可以为列表增加元素，也可以为列表删除元素。\n\n~~~\nb_list = list(range(1,5))\nprint(b_list)\n\nb_list[1:3] = ['a','b']\nprint(b_list)\n~~~\n\n输出结果:\n\n~~~\n[1, 2, 3, 4]\n[1, 'a', 'b', 4]\n~~~\n\n# Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略\n\nPyhton为list提供了一些常用的方法。\n\n我们使用dir(list)方法可以看到列表包含的所有方法。\n\n```\nprint(dir(list))\n```\n\n输出结果:\n\n```\n  6 _', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__',\n  5 '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setat\n  4 tr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'c\n  3 lear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse'\n  2 , 'sort']\n```\n\n**注意，方法名包含双下划线的不推荐使用** \n\n## count()方法\n\ncount()方法用于统计列表中某个元素出现的次数\n\n语法格式\n\n`listname.count(obj)` \n\nlistname:列表名称\n\nobj:表示判断是否存在的元素\n\n例子:\n\n```\na_list = [2]*5\nprint(a_list)\nprint(\"2出现%d次\" % a_list.count(2))\n```\n\n```\n[2, 2, 2, 2, 2]\n2出现5次\n```\n\n## index()用法\n\nindex()方法用于定位某元素在列表的索引位置，如果该元素没有出现，则会引发ValueError错误。 \n\n语法格式:\n\n`listname.index(obj,start,end)`\n\nindex()方法可以传入start,end参数，用于指定在列表的某范围内搜索元素\n\n例子:\n\n```\ntest_list = list(range(1,10))\nprint(test_list)\nprint(test_list.index(9))\n```\n\n输出结果:\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n8\n```\n## pop用法\n\npop()方法会溢出列表中指定索引处的元素，如果没有传入参数，则会移除列表中最后一个元素。\n\n语法格式:\n\n`listname.pop(index)` \n\n例子:\n\n```\ntest_list = list(range(1,10))\nprint(test_list)\n# 默认移除最后一个元素\ntest_list.pop()\nprint(test_list)\n# 移除第一次元素\nprint(test_list.pop(0))\nprint(test_list)\n```\n\n输出结果:\n\n```\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8]\n1\n[2, 3, 4, 5, 6, 7, 8]\n```\n\n## reverse()方法\n\nreverse()方法会将列表中所有元素反向存放。\n\n语法格式;\n\n`listname.reverse()`\n\n例子:\n\n```\ntest_list = list(range(1,11))\nprint(test_list)\ntest_list.reverse()\nprint(test_list)\n```\n\n输出结果:\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n## sort()用法\n\nsort()方法用于对列表元素进行排序。\n\n语法格式:\n\n`listname.sort(key=None,reserse=Fale)`\n\n- key参数用于指定从每个元素中提取一个用于比较的键。\n\n- reverse参数用于设置是否需要逆序，默认为False也就是从小打到排序，否则反之。\n\n例子:\n\n```\na_list = [123,213,1,325,1,51,213,5132,4156]\nprint(a_list)\n# 对列表进行排序\na_list.sort()\nprint(a_list)\n# 逆序排序\na_list.sort(reverse=True)\nprint(a_list)\n```\n\n输出结果:\n\n```\n[123, 213, 1, 325, 1, 51, 213, 5132, 4156]\n[1, 1, 51, 123, 213, 213, 325, 4156, 5132]\n[5132, 4156, 325, 213, 213, 123, 51, 1, 1]\n```\n\n# Python range()快速初始化数字列表\n\nPython的range()函数能够生成一系列的数字。\n\n```\nfor value in range(1,5):\n  print(value)\n```\n\n输出结果:\n\n```\n1\n2\n3\n4\n```\n\nrange()方法是指定从第一个值开始，生成连续的数字，直到指定的第二值为止(不包括第二个值)\n\nrange()方法可以指定步长，也就是说，每次连续增加时所增加的数值。\n\n# Python tuple元组详解\n\n与列表类似，元组也可以存储任何Python的数据类型，但元组是不可变的，一旦赋值则不可修改。\n\nPython中，使用`()`小括号包住的一列数据，被称为元组，而各数据之间又由`,`逗号隔开。\n\n元组的数据类型是:`tuple`\n\n```\ntest_tuple = tuple(range(1,11))\nprint(type(test_tuple))\n```\n输出结果:\n\n```\n<class 'tuple'>\n\n[Process exited 0]\n```\n\n## Python创建元组\n\n### = 运算符直接创建元组\n\n可以使用赋值运算符`=`将一个元组赋值给变量。\n\n语法格式:\n\n```\ntuplename = (element1,element2...elementn)\n```\n\n其中tuplename表示要创建的元组名,element代表元素。\n\n例子:\n\n```\nnum_tuple = tuple(range(1,11))\nstr_tuple = (\"Just A Test\",)\nobject_tuple = (\"a\",1,2.22,num_tuple,list(range(1,5)))\n\nprint(num_tuple)\nprint(str_tuple)\nprint(object_tuple)\n```\n\n输出结果:\n\n```\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nJust A Test\n('a', 1, 2.22, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), [1, 2, 3, 4])\n```\n\n**注意** :创建元组时，如果元组内只有一个元素，那么必须要在元素后加上一个逗号，否则Python解释器将会一位是字符串。\n\n```\ntest_str = (\"Just a Test\")\nstr_tuple = (\"Jest a Test\",)\nprint(type(test_str))\nprint(type(str_tuple))\n```\n\n输出结果:\n\n```\n<class 'str'>\n<class 'tuple'>\n```\n\n### 使用tuple()函数创建元组\n\nPython提供了tuple()函数创建元组，我们可以将一些常见的对象，转化成元组。\n\n语法格式:\n\n`tuple(iterable: Iterable[_T_co]=...)`\n\n例子:\n\n```\ntest_list = list(range(1,21,2))\ntest_tuple = tuple(test_list)\n\nprint(type(test_list))\nprint(type(test_tuple))\n```\n\n输出结果:\n\n```\n<class 'list'>\n<class 'tuple'>\n```\n\n## Python访问元组元素\n\n可以通过元素的下标获取或通过切片操作获取。\n\n## Python修改元组元素\n\n虽然前面提到元组是不可变序列，但还是可以通过一些手段进行修改元组内的数据。\n\n### 重新赋值\n\n```\ntest_tuple = tuple(range(1,6))\nprint(test_tuple)\ntest_tuple = tuple(range(1,20))\nprint(test_tuple)\n```\n\n输出结果:\n\n```\n(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\n```\n\n### 连接多个元组\n\n```\ntest_tuple = tuple(range(1,6))\nprint(test_tuple)\ntest_tuple2 = tuple(range(6,11))\ntest_tuple += test_tuple2\nprint(test_tuple)\n```\n\n输出结果:\n\n```\n(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\n## Python删除元组\n\n若创建的元组不再使用可以使用`del`语句将其删除。\n\n# Python元组和列表的区别\n\n本节讨论元组和列表的区别:\n\n| 区别                 | 元组 | 列表 |\n|----------------------|------|------|\n| 元素是否允许任意修改 | ❌   | ⭕   |\n| 是否能作为map的key   | ⭕   | ❌   |\n| 内存占用小           | ⭕   | ❌   |\n\n# Python列表和元组的底层实现\n\n这里就不记录笔记了，总的来说就是列表是一个长度可变且连续的内存空间，当列表的元素满了后，将会申请更多的内存空间，再将原本的内存空间拷贝过去。而元组则是一个空间带下固定且连续的内存空间。Python对元组进行了优化，例如为了避免系统老是释放和申请内存空间这一繁琐且耗时的操作，所以每次释放元组时其实是将其放入一个缓存中，如果下次还需要申请相同数据的元组，则可以直接从缓存中拿到。\n\n具体介绍看这里[💿Python列表和元组的底层实现](http://c.biancheng.net/view/5360.html) \n\n# Python dict字典\n\ndict字典属于可变序列，但是无序的序列，其内容是键值对的形式保存的。\n\n键值对也可以称为映射，所以字典的值与键是互相对应的关系。\n\nPython字典特征\n\n| 特征                           | 解释                                                                                        |\n|--------------------------------|---------------------------------------------------------------------------------------------|\n| 通过键读取元素                 | 通过字典中的键来获取指定项，而不是通过索引获取                                              |\n| 字典是任意数据类型的无序集合   | 和列表、元组不同，索引值可以通过数字获取对应的元素，而字典中的元素是无序的。                |\n| 字典是可变的，并且可以任意嵌套 | 字典可以在原处增长或缩短，并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其他字典   |\n| 字典中的键必须是唯一的         | 字典中不允许出现相同的键，否则只会保留最后一个键值对                                        |\n| 字典中的键必须是不可变的       | 字典中的值是不可变的，所以只能使用数字、或元组、字符串等，不能使用可变，例如可变序列：列表 |\n\n**Python中字典的数据类型为`dict`** \n\n## Python创建字典\n\n### 花括号语法创建字典\n\n字典中每个元素都包含两个部分，分别是键和值。因此在创建字典元素时，需要在键和值之间以冒号`:`分隔，相邻元素之间使用逗号分隔，所有元素放下大括号`{}`间。\n\n语法格式:\n\n`dictname = {'key1':'value',\"key2\":\"value\"}`\n\n其中`dictname` 代表字典名，`key:value` 表示各个元素的键值对。\n\n使用花括号创建字典例子:\n\n```\ntest_dict = {\"语文\":80,\"数学\":12}\nprint(test_dict)\n\n```\n\n输出结果\n\n`{'语文': 80, '数学': 12}`\n\n### 通过fromkey()方法创建字典\n\nPython中使用dict字典类型提供的fromkeys()方法创建所有键值为空的字典。\n\n语法格式\n\n`dictname=dict.fromkeys(list,value=None)` \n\nlist参数表示字典中键的列表，value参数默认为None，表示所有键对应的值。\n\n例子:\n\n```\nknowledge = {'语文','数学','英语'}\nscores = dict.fromkeys(knowledge,100)\nprint(scores)\n```\n\n输出结果:\n\n```\n{'语文': 100, '英语': 100, '数学': 100}\n```\n\n### 通过dict()映射函数创建字典\n\ndict()函数常用创建字典方法\n\n![dict()函数创建字典](Python-04-Python列表、元组、字典和集合/dict()函数创建字典.png)\n\n## Pyton访问字典\n\ndict()通过元素的键进行访问值，不能像列表或元组通过下标或切片的形式来访问。\n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\nprint(type(test_dict))\nprint(test_dict['姓名'])\nprint(test_dict.get(\"性别\"))\n```\n\n## Python删除字典\n\n如需手动删除，可以使用del语句。\n\n# Pythton dict字典基本操作(包括添加、修改、删除键值对)\n\n本小节对字典实现常见的操作:\n\n- 向字典中添加新的键值对\n\n- 修改字典中的键值对\n\n- 从字典中删除指定的键值对\n\n- 判断字典中是否存在指定的键值对\n\n## Python字典添加键值对\n\n为字典中添加新的键值对只需要为不存在的`key`赋值。\n\n语法格式:\n\n`dict[key]= value` \n\n`dict`表示字典名称,`key`代表新建键值对的键,`value`代表新建键值对的值\n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ntest_dict['班级'] = 502\nprint(test_dict.get(\"班级\"))\n```\n\n输出结果:\n\n`502` \n\n## Python字典修改键值对\n\n这里的修改是指:修改键值对的值。\n\n**Python中如果新添加的键值对的键存在，那么则会覆盖原本的键值对的值** \n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ntest_dict['班级'] = 502\nprint(test_dict.get(\"班级\"))\ntest_dict['班级'] = 999\nprint(test_dict.get(\"班级\"))\n```\n\n输出结果:\n\n```\n502\n999\n```\n\n## Python字典删除键值对\n\n如果要删除字典中的键值对，则可以使用`del`语句，指定要删除的键值对的键。\n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ntest_dict['班级'] = 502\nprint(test_dict.get(\"班级\"))\ndel test_dict['班级']\nprint(test_dict.get(\"班级\"))\n```\n\n输出结果:\n\n```\n502\nNone\n```\n\n## 判断字典中是否存在指定键值对\n\n如果需要判断字典是否存在指定键值对的键，可以使用`in`或`not in`运算符。\n\n**注意:这里的`in`或`not in`运算符都是基于`key`来判断字典中某个键值对是否存在的.** \n\n例子:\n\n```\ntest_dict = (['姓名','LTy'],['性别',True])\ntest_dict = dict(test_dict)\ndel test_dict['姓名']\nprint(test_dict.get(\"姓名\"))\nprint('姓名' in test_dict)\n```\n\n输出结果:\n\n```\nNone\nFalse\n```\n\n# Python dict字典方法完全攻略(全)\n\n想查看`dict`该类包包含哪些方法，可以使用`dir()`方法进行查看。\n\n## Python keys(),values()和items()方法\n\n这三个方法可以获取字典中特定的数据.\n\n`keys()`方法用于返回字典中的所有键;\n\n`values()`用于返回字典中所有键对应的值;\n\n`items()`用于返回字典中所有的键值对;\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\nprint(test_dict.keys())\nprint(test_dict.values())\nprint(test_dict.items())\n```\n\n输出结果:\n\n```\ndict_keys(['英语', '语文', '数学'])\ndict_values([100, 100, 100])\ndict_items([('英语', 100), ('语文', 100), ('数学', 100)])\n```\n\n**注意:`Python2.x`中，上面提到的方法的返回值是列表类型。但在`Python3.x`中，以上方法返回的类型不是序列类型。** \n\n## Python copy()方法\n\n`copy()`方法用于返回一个具有相同键值对的新字典:\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\ntest_dict2 = test_dict.copy()\nprint(test_dict,\"\\n\",test_dict2)\n```\n\n输出结果:\n\n```\n{'英语': 100, '语文': 100, '数学': 100}\n{'英语': 100, '语文': 100, '数学': 100}\n```\n\n**注意Python的copy()方法涉及到`深拷贝`与`浅拷贝`的关系，当字典A拷贝键值对给字典B后，那么拷贝的数据(字典B内)将会在字典A对键值对进行修改时发生变化，而字典A添加新的键值对，字典B不收影响。** \n\n## Python update()方法\n\nupdae()方法可以使用一个字典所包含的键值对来更新已有的字典。\n\n如果被更新的字典中已存在对应的键值对，那么原键值对值将会被覆盖，否则将会被添加。\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\ntest_dict2 = test_dict.copy()\nprint(type(test_dict))\ntest_dict['语文']=100\ntest_dict2['物理']=200\ntest_dict2.update(test_dict)\nprint(test_dict,\"\\n\",test_dict2)\nprint(test_dict,\"\\n\",test_dict2)\n```\n\n输出结果:\n\n```\n<class 'dict'>\n{'英语': 100, '数学': 100, '语文': 100}\n{'英语': 100, '数学': 100, '语文': 100, '物理': 200}\n{'英语': 100, '数学': 100, '语文': 100}\n{'英语': 100, '数学': 100, '语文': 100, '物理': 200}\n```\n\n## Python pop方法\n\npop()方法可以获取指定key的value，并删除。\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\nprint(test_dict.pop('语文'))\n```\n\n输出结果:\n\n```\n100\n{'英语': 100, '数学': 100}\n```\n\n## Python popitem()方法\n\npopitem()方法用于弹出字典中最后一个键值对(这里的最后一个其实是随机的，因为字典是无序序列，所以并不能说的某个键值对的位置取向).\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\nprint(test_dict.popitem())\nprint(test_dict)\n```\n\n输出结果:\n\n```\n('数学', 100)\n{'英语': 100, '语文': 100}\n```\n\n## Python setdefault()方法\n\nsetdefault()方法用于根据key来获取value，但有两种场景，第一种是，如果获取的键值对的key存在字典中，则会直接获取改键值对的value，不存在则会为该key先将value设置为默认的value，然后再返回该key对应的value。\n\n\n**特点:setdefault方法总能返回指定key对应的value;**\n\n例子:\n\n```\ntest_dict = {'语文','数学','英语'}\ntest_dict = dict.fromkeys(test_dict,100)\n# 要设置的键值对的key不存在.\ntest_dict.setdefault('物理',120)\nprint(test_dict)\n# 要设置的键值对的key存在.\ntest_dict.setdefault('语文',200)\nprint(test_dict)\n```\n\n输出结果:\n\n```\n{'数学': 100, '英语': 100, '语文': 100, '物理': 120}\n{'数学': 100, '英语': 100, '语文': 100, '物理': 120}\n```\n\n# Python使用字典格式化字符串\n\n我们知道，在格式化字符串时，如果格式化字符串模板中包含多个变量时，则后面月必须按顺序加上相同个数的变量，如果变量过多，则会十分麻烦，Python提供了用字典格式化字符串的方式来解决。\n\n例子:\n\n```\nstudent = '姓名:%(name)s\\t班级:%(class)d\\t综合成绩:%(score)f'\nstudent_info = {'name':'LTy','class':604,'score':99.5}\nprint(student % student_info)\n```\n\n输出结果:\n\n```\n姓名:LTy        班级:604        综合成绩:99.500000\n```\n\n# Python set集合详解\n\nset集合的特点:\n\n- 数据唯一性(必须保证集合中每种数据元素是唯一的)\n\n- 数据不可变(只允许存储不可变的数据类型，例如列表、字典、集合则是不允许存储在集合中的)\n\n- 集合是无序的，所以每次输出元素时，排序顺序可能都不同。\n\n## Python创建set集合\n\n有两种创建`set`集合的方法，分别是使用{}创建和使用set()函数将列表、元组等数据类型转化为集合。\n\n### 使用{}创建\n\n语法格式:\n\n`setname = {element1,element2...elementn}`\n\nsetname代表集合的名称。\n\n例子:\n\n```\ntest_set = {1,2,3,4}\nprint(test_set)\n```\n\n输出结果:\n\n```\n{1, 2, 3, 4}\n```\n\n### 使用set()函数创建集合\n\nset()函数为Python的内置函数，其可以将字符串、列表、元组以及range对象等可迭代的对象转换成集合。\n\n语法格式:\n\n`setname = set(iteration)` \n\niteration就表示可迭代的对象。\n\n```\nset1 = set(\"I Love China\")\nset2 = set(list(range(1,6)))\nset3 = set(tuple(range(1,6)))\nset4 = set(range(1,6))\nprint(set1)\nprint(set2)\nprint(set3)\nprint(set4)\n```\n\n输出结果:\n\n```\n# 从输出结果看，字符串被打乱了\n{'a', 'L', 'h', ' ', 'C', 'e', 'n', 'i', 'I', 'v', 'o'}\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5}\n```\n\n**注意:如果想要创建空集合，必须使用`set()`函数实现，因为如果只给一对`{}`，Python解释器会将其视为一个空字典。**\n\n## Python访问set集合元素\n\n由于`set`集合是无序的，所以无法通过下标索引进行访问，但是我们可通过遍历`set`集合访问元素。\n\n```\nset1 = set(\"I Love China\")\n\nfor ele in set1:\n    print(ele,end='')\n```\n\n输出结果:\n\n```\noCenaL Ihvi\n```\n\n## Python删除set集合\n\n想要手动删除`set`集合可以使用`del()`方法。\n\n```\nset1 = set(\"I Love China\")\nprint(set1)\ndel(set1)\nprint(set1)\n```\n\n输出结果:\n\n```\n{'a', 'i', 'e', ' ', 'L', 'C', 'o', 'h', 'I', 'n', 'v'}\nTraceback (most recent call last):\n  File \"test.py\", line 4, in <module>\n  │ print(set1)\nNameError: name 'set1' is not defined\n```\n\n# Python set集合基本操作(添加、删除、交集、并集、差集)\n\n`set`集合最常用的场景是添加、删除元素以及在多个集合之间做交集、并集、差集等运算。 \n\n## 向set集合中添加元素\n\nPython为`set`集合提供了`add()`方法，其可以向`set`集合添加元素。\n\n语法格式:\n\n`setname.add(element)` \n\nsetname表示要添加元素的集合，element代表添加的元素。\n\n**注意:element不可为可变数据类型** \n\n## 从set集合中删除元素\n\n想要从集合中删除某个元素可以使用`remove()`方法\n\n语法格式:\n\n`setname.remove(element)` \n\n例子:\n\n```\nset1 = {1,2,3,4}\nprint(set1)\nset1.remove(1)\nprint(set1)\n```\n\n输出结果:\n\n```\n{1, 2, 3, 4}\n{2, 3, 4}\n```\n\n**注意:如果要删除的元素已经被删除，再次删除则会引发`KeyError`错误**\n\n如果想要在删除失败时不抛出异常，我们可以使用`discard()`方法。\n\n例子:\n\n```\nset1 = {1,2,3,4}\nprint(set1)\nset1.remove(1)\nprint(set1)\nset1.discard(1)\nprint(set1)\nset1.remove(1)\nprint(set1)\n\n```\n\n输出结果:\n\n```\n{1, 2, 3, 4}\n{2, 3, 4}\n{2, 3, 4}\nTraceback (most recent call last):\n  File \"test.py\", line 7, in <module>\n  │ set1.remove(1)\nKeyError: 1\n```\n\n`discard()`方法与`remove()`方法的唯一区别在于:**删除失败时是否抛出异常** o\n\n## Python set集合做交集、并集、差集运算\n\n`set`集合最常用的操作也就是进行交集、并集、差集以及对称差集运算了，首先看这张图:\n\n![集合示意图](Python-04-Python列表、元组、字典和集合/Python集合示意图.png) \n\n图中有两个集合，分别是:\n\n- `set1={1,2,3}`\n\n- `set2={3,4,5}`\n\n下面的表格展示了不同的运算，得到的不同的结果。\n\n![集合运算图](Python-04-Python列表、元组、字典和集合/Python集合运算.png) \n\n# Python set集合方法详解(全)\n\n如果想要看`set`集合所有的方法，可以使用`dir(set)`进行查看。\n\nPython set方法\n\n| 方法名                        | 语法格式                               | 功能                                                                 |\n|-------------------------------|----------------------------------------|----------------------------------------------------------------------|\n| add()                         | set1.add()                             | 向set1集合中添加非可变元素                                           |\n| clear()                       | set1.clear()                           | 清空set1集合中所有的元素                                             |\n| copy()                        | set2=set1.copy()                       | 拷贝set1集合中的元素给set2                                           |\n| difference()                  | set3=set1.difference(set2)             | 将set1中有而set2中没有的元素给set3                                   |\n| difference_update()           | set1.difference_update(set2)           | 从set1中删除与set2相同的元素                                         |\n| discard()                     | set1.discard(element)                  | 删除set1中的element元素                                              |\n| intersection()                | set3=set1.intersection(set2)           | 取set1和set2的交集赋值给set3                                         |\n| intersection_update()         | set1.intersection_update(set2)         | 取set1和set2的交集并且将值赋值给set1(更新set1的值为set1与set2的交集) |\n| isdisjoint()                  | set1.isdisjoint(set2)                  | 判断set1和set2是否没有交集，有交集返回False;没有则返回True           |\n| issubset()                    | set1.issubset(set2)                    | 判断set1是否是set2的子集                                             |\n| issuperset()                  | set1.issuperset(set2)                  | 判断set2是否是set1的子集                                             |\n| pop()                         | a = set1.pop()                         | 取出set1中一个元素并赋值给a                                          |\n| remove()                      | set1.remove(element)                   | 移除set1中的element元素                                              |\n| symmetric_difference()        | set3=set1.symmetric_difference(set2)   | 取set1和set2中互不相同的元素给set3                                   |\n| symmetric_difference_update() | set1.symmetric_difference_update(set2) | 取set1和set2中互不相同的元素并更新set1的值                           |\n| union()                       | set3=set1.union(set2)                  | 取set1和set2的并集，赋值给set3                                       |\n| update()                      | set1.update(element)                   | 添加列表或集合中的元素到set1                                         |\n\n# Python frozenset(set集合的不可变版本)\n\n前面我们所学习的`set`集合是可变的，而frozenset则是`set`集合的不可变版本，它不具备`set`集合的所有能改变集合本身的方法。\n\nfrozenset的主要使用场景:\n\n- 当集合元素不需要改变的时候，使用frozenset替代set将会更加安全。\n\n- 当某些API需要不可变对象作为参数时，必须用到frozenset替代set。\n\n\n# 深入底层了解Python字典和集合、一眼看穿他们的本质\n\n本小节涉及到未知的知识，推荐去原文看**[查看原文](http://c.biancheng.net/view/5302.html) \n\n# Python深拷贝和浅拷贝详解\n\n本小节涉及到未知的知识，推荐去原文看[查看原文](http://c.biancheng.net/view/5358.html) \n\n","slug":"Python-04-Python列表、元组、字典和集合","published":1,"updated":"2020-01-19T03:49:51.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocp003zomoog6fcvtkn","content":"<p>Python系列第四章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/list_tuple_dict/\" target=\"_blank\" rel=\"noopener\">💿</a></p>\n<a id=\"more\"></a>\n<h1 id=\"什么是序列，Python序列详解（包括序列类型和常用操作）\"><a href=\"#什么是序列，Python序列详解（包括序列类型和常用操作）\" class=\"headerlink\" title=\"什么是序列，Python序列详解（包括序列类型和常用操作）\"></a>什么是序列，Python序列详解（包括序列类型和常用操作）</h1><p>序列：一块可存放多个且连续的内存空间，并且这些值有顺序，可通过索引进行访问。</p>\n<p>常见的序列有: 字符串、列表、元组、集合和字典。</p>\n<p>这些常见的序列，除了集合和字典不支持索引、切片、相加和相乘的操作，其余的都可以。</p>\n<h2 id=\"序列索引\"><a href=\"#序列索引\" class=\"headerlink\" title=\"序列索引\"></a>序列索引</h2><p>索引就是一个序列中每个元素的编号。第一个元素的索引是0，也就是说想要访问某个序列的第一个元素，那么它的索引就是0，而想要访问最后一个元素，那么它的索引就是序列长度-1</p>\n<p>索引还分为正索引值和负索引值，它们的区别仅仅在于访问方式不同。</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li><p>正索引值的起始位置是0，结束位置是序列长度-1</p>\n</li>\n<li><p>负索引值的起始位置是-1,结束位置是-(序列长度-1)</p>\n</li>\n</ul>\n<p>例子:</p>\n<p><strong>根据索引访问序列元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = &quot;Hello World&quot;</span><br><span class=\"line\">print(&quot;str 的第一个字符是:%s，最后一个字符是:%s&quot; % (str[0],str[len(str)-1]))</span><br></pre></td></tr></table></figure>\n<p>输出结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str 的第一个字符是:H，最后一个字符是:d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"序列切片\"><a href=\"#序列切片\" class=\"headerlink\" title=\"序列切片\"></a>序列切片</h2><p>刚刚我们通过索引值进行访问序列元素，那么序列切片也是可以做到的，它可以访问某个范围内的元素。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sname[start:end:step]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>sname:序列名称</p>\n</li>\n<li><p>start:切片开始的索引位置（包括该位置），此参数可不指定，默认为0。</p>\n</li>\n<li><p>end:切片结束的索引位置(不包括该位置)，此参数可不指定，默认为序列的长度。</p>\n</li>\n<li><p>step:切片的范围，也就是每次取元素时，要隔多少个位置，此参数可不指定，可以直接忽略最后一个冒号</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = &quot;Hello World&quot;</span><br><span class=\"line\"># 获取整个字符串</span><br><span class=\"line\">print(str[:])</span><br><span class=\"line\"># 从索引4开始，一直到最后一个，没隔2个字符取一次。</span><br><span class=\"line\">print(str[4::2])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br><span class=\"line\">oWrd</span><br></pre></td></tr></table></figure>\n<h2 id=\"序列相加\"><a href=\"#序列相加\" class=\"headerlink\" title=\"序列相加\"></a>序列相加</h2><p>序列可以使用<code>+</code>运算符，进行相加操作，他会将两个序列进行连接，但不会去除重复的元素。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;hello&quot;</span><br><span class=\"line\">str2=&quot;world&quot;</span><br><span class=\"line\">print(str1+str2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>helloworld</code></p>\n<h2 id=\"序列相乘\"><a href=\"#序列相乘\" class=\"headerlink\" title=\"序列相乘\"></a>序列相乘</h2><p>使用<code>*</code>运算符，可以将序列的元素进行重复。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;hello\\t&quot;</span><br><span class=\"line\">print(str1*3)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>hello    hello    hello</code></p>\n<p><strong>tips:可以使用序列相乘，创建指定长度空列表</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [None]*5</span><br></pre></td></tr></table></figure>\n<h2 id=\"检查元素是否包含在序列中\"><a href=\"#检查元素是否包含在序列中\" class=\"headerlink\" title=\"检查元素是否包含在序列中\"></a>检查元素是否包含在序列中</h2><p>使用<code>in</code>关键字可以检查序列中的元素是否存在。 </p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value in sequence</span><br></pre></td></tr></table></figure>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;Hello&quot;</span><br><span class=\"line\">print(&apos;o&apos; in str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果: <code>True</code></p>\n<p><strong>tips:使用<code>not in</code>关键字可以检查是否不存在</strong></p>\n<h2 id=\"和序列相关的内置函数\"><a href=\"#和序列相关的内置函数\" class=\"headerlink\" title=\"和序列相关的内置函数\"></a>和序列相关的内置函数</h2><p>Python提供了几个用于操作序列的内置函数，可以很方便的操作序列。</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/Python序列内置函数.png\" alt=\"Python序列内置函数\"></p>\n<h1 id=\"Python-list列表详解\"><a href=\"#Python-list列表详解\" class=\"headerlink\" title=\"Python list列表详解\"></a>Python list列表详解</h1><p>Python提供了一种数据结构————<code>list</code>(列表)</p>\n<p><strong>列表可以存储多个不同数据类型的元素。</strong></p>\n<h2 id=\"Python创建列表\"><a href=\"#Python创建列表\" class=\"headerlink\" title=\"Python创建列表\"></a>Python创建列表</h2><p>创建列表分为两种方式</p>\n<p>使用<code>=</code>运算符创建列表</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listname = [element1,element2...elementn]</span><br></pre></td></tr></table></figure>\n<p>listname: 列表的名称</p>\n<p>element1: 列表的元素</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建一个列表</span><br><span class=\"line\">test_list1 =[&quot;one&quot;,1,True,1.0]</span><br><span class=\"line\">print(test_list1)</span><br><span class=\"line\"># 创建一个空列表</span><br><span class=\"line\">empty_list = []</span><br><span class=\"line\">print(empty_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;one&apos;, 1, True, 1.0]</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n<p><strong>使用list()函数创建列表</strong></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;HelloWorld&quot;</span><br><span class=\"line\">test_list = list(str1)</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;W&apos;, &apos;o&apos;, &apos;r&apos;, &apos;l&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问列表元素\"><a href=\"#访问列表元素\" class=\"headerlink\" title=\"访问列表元素\"></a>访问列表元素</h2><p>两种方式：通过索引访问和通过切片访问。</p>\n<h2 id=\"删除列表\"><a href=\"#删除列表\" class=\"headerlink\" title=\"删除列表\"></a>删除列表</h2><p>不常用，因为Python具有垃圾回收机制，有些不需要再使用的列表将会自动回收。</p>\n<p>使用<code>del</code>关键字进行删除</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del listname</span><br></pre></td></tr></table></figure>\n<p><strong>注意:删除后的列表不能再次使用</strong></p>\n<h1 id=\"Python-list列表添加元素的3种方法\"><a href=\"#Python-list列表添加元素的3种方法\" class=\"headerlink\" title=\"Python list列表添加元素的3种方法\"></a>Python list列表添加元素的3种方法</h1><h2 id=\"Python-append-方法添加元素\"><a href=\"#Python-append-方法添加元素\" class=\"headerlink\" title=\"Python append()方法添加元素\"></a>Python append()方法添加元素</h2><p><code>append()</code>方法在列表的末尾追加元素。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listname.append(obj)</span><br></pre></td></tr></table></figure>\n<p>listname代表要添加元素的列表;obj代表要添加到列表末尾的数据。</p>\n<p>obj可以是单个元素，也可以是其他序列。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 追加单个元素</span><br><span class=\"line\">list1 = [0,1,2,3]</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\">list1.append(4)</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\"># 追加一个列表</span><br><span class=\"line\">list2 = [5,6,7,8]</span><br><span class=\"line\">print(list2)</span><br><span class=\"line\">list1.append(list2)</span><br><span class=\"line\">print(list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0, 1, 2, 3]</span><br><span class=\"line\">[0, 1, 2, 3, 4]</span><br><span class=\"line\">[5, 6, 7, 8]</span><br><span class=\"line\">[0, 1, 2, 3, 4, [5, 6, 7, 8]]</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意:使用append()函数时，如果是传递的单个数据，将会直接追加到列表后，但是如果传入的是个列表（序列），那么则会追加一个列表形式的元素。</strong></p>\n<p>想要访问刚刚追加的列表元素的其中一个可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [0,1,2]</span><br><span class=\"line\">list2 = [3,4,5]</span><br><span class=\"line\">list1.append(list2)</span><br><span class=\"line\">print(list1[3][2])</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>5</code></p>\n<h2 id=\"Python-extend-方法添加元素\"><a href=\"#Python-extend-方法添加元素\" class=\"headerlink\" title=\"Python extend()方法添加元素\"></a>Python extend()方法添加元素</h2><p>刚刚我们使用<code>append()</code>函数追加了个列表元素，但是并没有像添加单个字符一样作为一个整体添加，而我们只需要使用<code>extend()</code>方法就可以将列表以整体的方式添加进去。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [0,1,2,3]</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\">list2 = [5,6,7,8]</span><br><span class=\"line\">print(list2)</span><br><span class=\"line\">list1.extend(list2)</span><br><span class=\"line\">print(list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0, 1, 2, 3]</span><br><span class=\"line\">[5, 6, 7, 8]</span><br><span class=\"line\">[0, 1, 2, 3, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-insert-方法插入元素\"><a href=\"#Python-insert-方法插入元素\" class=\"headerlink\" title=\"Python insert()方法插入元素\"></a>Python insert()方法插入元素</h2><p>需要指定插入列表元素的位置时，可以使用insert()方法。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listname.insert(index,obj)</span><br></pre></td></tr></table></figure>\n<p>index: 将obj插入到listname列表的索引</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list1 = list(range(1,11))</span><br><span class=\"line\">print(test_list1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(len(test_list1))</span><br><span class=\"line\">test_list1.insert(len(test_list1),11)</span><br><span class=\"line\">print(test_list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">10</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Pyhton-list列表删除元素-3种方法\"><a href=\"#Pyhton-list列表删除元素-3种方法\" class=\"headerlink\" title=\"Pyhton list列表删除元素(3种方法)\"></a>Pyhton list列表删除元素(3种方法)</h2><blockquote>\n<p>del删除</p>\n</blockquote>\n<p><strong>del语句在Python中可以删除变量、列表的元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1, 11))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">del test_list[1::2]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>根据元素值进行删除</p>\n</blockquote>\n<p>可以使用remove()方法来删除列表元素。</p>\n<p>删除第一个被查找到的元素。</p>\n<p><strong>注意:remove()方法不是根据索引来删除元素的，而是查找元素本身，再进行删除，所以如果找不到元素，则会报错</strong></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]</span><br><span class=\"line\">test_list.remove(&apos;test&apos;)</span><br><span class=\"line\">test_list.remove(30)</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;test2&apos;, 10, 30]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>删除列表所有元素</p>\n</blockquote>\n<p>使用clear()方法可以删除列表的所有元素。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]</span><br><span class=\"line\">test_list.clear()</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-list列表修改元素\"><a href=\"#Python-list列表修改元素\" class=\"headerlink\" title=\"Python list列表修改元素\"></a>Python list列表修改元素</h1><p>修改列表元素，可以通过列表索引获取元素进行赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testlist = list(range(1,10))</span><br><span class=\"line\">print(testlist)</span><br><span class=\"line\">testlist[len(testlist)-1] = 100</span><br><span class=\"line\">print(testlist)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 100]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>使用slice语法对列表部分进行赋值。</p>\n<p>slice语法，不要求新赋值的元素个数与原来的元素个数相等。也就是说使用slice剩余法既可以为列表增加元素，也可以为列表删除元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b_list = list(range(1,5))</span><br><span class=\"line\">print(b_list)</span><br><span class=\"line\"></span><br><span class=\"line\">b_list[1:3] = [&apos;a&apos;,&apos;b&apos;]</span><br><span class=\"line\">print(b_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\">[1, &apos;a&apos;, &apos;b&apos;, 4]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Pyhthon-list常用方法-count、index、pop、reverse和sort-快速攻略\"><a href=\"#Pyhthon-list常用方法-count、index、pop、reverse和sort-快速攻略\" class=\"headerlink\" title=\"Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略\"></a>Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略</h1><p>Pyhton为list提供了一些常用的方法。</p>\n<p>我们使用dir(list)方法可以看到列表包含的所有方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(dir(list))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 _&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;,</span><br><span class=\"line\">5 &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setat</span><br><span class=\"line\">4 tr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;c</span><br><span class=\"line\">3 lear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;</span><br><span class=\"line\">2 , &apos;sort&apos;]</span><br></pre></td></tr></table></figure>\n<p><strong>注意，方法名包含双下划线的不推荐使用</strong> </p>\n<h2 id=\"count-方法\"><a href=\"#count-方法\" class=\"headerlink\" title=\"count()方法\"></a>count()方法</h2><p>count()方法用于统计列表中某个元素出现的次数</p>\n<p>语法格式</p>\n<p><code>listname.count(obj)</code> </p>\n<p>listname:列表名称</p>\n<p>obj:表示判断是否存在的元素</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_list = [2]*5</span><br><span class=\"line\">print(a_list)</span><br><span class=\"line\">print(&quot;2出现%d次&quot; % a_list.count(2))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2, 2, 2, 2, 2]</span><br><span class=\"line\">2出现5次</span><br></pre></td></tr></table></figure>\n<h2 id=\"index-用法\"><a href=\"#index-用法\" class=\"headerlink\" title=\"index()用法\"></a>index()用法</h2><p>index()方法用于定位某元素在列表的索引位置，如果该元素没有出现，则会引发ValueError错误。 </p>\n<p>语法格式:</p>\n<p><code>listname.index(obj,start,end)</code></p>\n<p>index()方法可以传入start,end参数，用于指定在列表的某范围内搜索元素</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,10))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">print(test_list.index(9))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<h2 id=\"pop用法\"><a href=\"#pop用法\" class=\"headerlink\" title=\"pop用法\"></a>pop用法</h2><p>pop()方法会溢出列表中指定索引处的元素，如果没有传入参数，则会移除列表中最后一个元素。</p>\n<p>语法格式:</p>\n<p><code>listname.pop(index)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,10))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\"># 默认移除最后一个元素</span><br><span class=\"line\">test_list.pop()</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\"># 移除第一次元素</span><br><span class=\"line\">print(test_list.pop(0))</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class=\"line\">1</span><br><span class=\"line\">[2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>\n<h2 id=\"reverse-方法\"><a href=\"#reverse-方法\" class=\"headerlink\" title=\"reverse()方法\"></a>reverse()方法</h2><p>reverse()方法会将列表中所有元素反向存放。</p>\n<p>语法格式;</p>\n<p><code>listname.reverse()</code></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,11))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">test_list.reverse()</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>\n<h2 id=\"sort-用法\"><a href=\"#sort-用法\" class=\"headerlink\" title=\"sort()用法\"></a>sort()用法</h2><p>sort()方法用于对列表元素进行排序。</p>\n<p>语法格式:</p>\n<p><code>listname.sort(key=None,reserse=Fale)</code></p>\n<ul>\n<li><p>key参数用于指定从每个元素中提取一个用于比较的键。</p>\n</li>\n<li><p>reverse参数用于设置是否需要逆序，默认为False也就是从小打到排序，否则反之。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_list = [123,213,1,325,1,51,213,5132,4156]</span><br><span class=\"line\">print(a_list)</span><br><span class=\"line\"># 对列表进行排序</span><br><span class=\"line\">a_list.sort()</span><br><span class=\"line\">print(a_list)</span><br><span class=\"line\"># 逆序排序</span><br><span class=\"line\">a_list.sort(reverse=True)</span><br><span class=\"line\">print(a_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[123, 213, 1, 325, 1, 51, 213, 5132, 4156]</span><br><span class=\"line\">[1, 1, 51, 123, 213, 213, 325, 4156, 5132]</span><br><span class=\"line\">[5132, 4156, 325, 213, 213, 123, 51, 1, 1]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-range-快速初始化数字列表\"><a href=\"#Python-range-快速初始化数字列表\" class=\"headerlink\" title=\"Python range()快速初始化数字列表\"></a>Python range()快速初始化数字列表</h1><p>Python的range()函数能够生成一系列的数字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for value in range(1,5):</span><br><span class=\"line\">  print(value)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<p>range()方法是指定从第一个值开始，生成连续的数字，直到指定的第二值为止(不包括第二个值)</p>\n<p>range()方法可以指定步长，也就是说，每次连续增加时所增加的数值。</p>\n<h1 id=\"Python-tuple元组详解\"><a href=\"#Python-tuple元组详解\" class=\"headerlink\" title=\"Python tuple元组详解\"></a>Python tuple元组详解</h1><p>与列表类似，元组也可以存储任何Python的数据类型，但元组是不可变的，一旦赋值则不可修改。</p>\n<p>Python中，使用<code>()</code>小括号包住的一列数据，被称为元组，而各数据之间又由<code>,</code>逗号隔开。</p>\n<p>元组的数据类型是:<code>tuple</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_tuple = tuple(range(1,11))</span><br><span class=\"line\">print(type(test_tuple))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python创建元组\"><a href=\"#Python创建元组\" class=\"headerlink\" title=\"Python创建元组\"></a>Python创建元组</h2><h3 id=\"运算符直接创建元组\"><a href=\"#运算符直接创建元组\" class=\"headerlink\" title=\"= 运算符直接创建元组\"></a>= 运算符直接创建元组</h3><p>可以使用赋值运算符<code>=</code>将一个元组赋值给变量。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tuplename = (element1,element2...elementn)</span><br></pre></td></tr></table></figure>\n<p>其中tuplename表示要创建的元组名,element代表元素。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_tuple = tuple(range(1,11))</span><br><span class=\"line\">str_tuple = (&quot;Just A Test&quot;,)</span><br><span class=\"line\">object_tuple = (&quot;a&quot;,1,2.22,num_tuple,list(range(1,5)))</span><br><span class=\"line\"></span><br><span class=\"line\">print(num_tuple)</span><br><span class=\"line\">print(str_tuple)</span><br><span class=\"line\">print(object_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class=\"line\">Just A Test</span><br><span class=\"line\">(&apos;a&apos;, 1, 2.22, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), [1, 2, 3, 4])</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong> :创建元组时，如果元组内只有一个元素，那么必须要在元素后加上一个逗号，否则Python解释器将会一位是字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_str = (&quot;Just a Test&quot;)</span><br><span class=\"line\">str_tuple = (&quot;Jest a Test&quot;,)</span><br><span class=\"line\">print(type(test_str))</span><br><span class=\"line\">print(type(str_tuple))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用tuple-函数创建元组\"><a href=\"#使用tuple-函数创建元组\" class=\"headerlink\" title=\"使用tuple()函数创建元组\"></a>使用tuple()函数创建元组</h3><p>Python提供了tuple()函数创建元组，我们可以将一些常见的对象，转化成元组。</p>\n<p>语法格式:</p>\n<p><code>tuple(iterable: Iterable[_T_co]=...)</code></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,21,2))</span><br><span class=\"line\">test_tuple = tuple(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\">print(type(test_list))</span><br><span class=\"line\">print(type(test_tuple))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;list&apos;&gt;</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python访问元组元素\"><a href=\"#Python访问元组元素\" class=\"headerlink\" title=\"Python访问元组元素\"></a>Python访问元组元素</h2><p>可以通过元素的下标获取或通过切片操作获取。</p>\n<h2 id=\"Python修改元组元素\"><a href=\"#Python修改元组元素\" class=\"headerlink\" title=\"Python修改元组元素\"></a>Python修改元组元素</h2><p>虽然前面提到元组是不可变序列，但还是可以通过一些手段进行修改元组内的数据。</p>\n<h3 id=\"重新赋值\"><a href=\"#重新赋值\" class=\"headerlink\" title=\"重新赋值\"></a>重新赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_tuple = tuple(range(1,6))</span><br><span class=\"line\">print(test_tuple)</span><br><span class=\"line\">test_tuple = tuple(range(1,20))</span><br><span class=\"line\">print(test_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1, 2, 3, 4, 5)</span><br><span class=\"line\">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接多个元组\"><a href=\"#连接多个元组\" class=\"headerlink\" title=\"连接多个元组\"></a>连接多个元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_tuple = tuple(range(1,6))</span><br><span class=\"line\">print(test_tuple)</span><br><span class=\"line\">test_tuple2 = tuple(range(6,11))</span><br><span class=\"line\">test_tuple += test_tuple2</span><br><span class=\"line\">print(test_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1, 2, 3, 4, 5)</span><br><span class=\"line\">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python删除元组\"><a href=\"#Python删除元组\" class=\"headerlink\" title=\"Python删除元组\"></a>Python删除元组</h2><p>若创建的元组不再使用可以使用<code>del</code>语句将其删除。</p>\n<h1 id=\"Python元组和列表的区别\"><a href=\"#Python元组和列表的区别\" class=\"headerlink\" title=\"Python元组和列表的区别\"></a>Python元组和列表的区别</h1><p>本节讨论元组和列表的区别:</p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>元组</th>\n<th>列表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>元素是否允许任意修改</td>\n<td>❌</td>\n<td>⭕</td>\n</tr>\n<tr>\n<td>是否能作为map的key</td>\n<td>⭕</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>内存占用小</td>\n<td>⭕</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Python列表和元组的底层实现\"><a href=\"#Python列表和元组的底层实现\" class=\"headerlink\" title=\"Python列表和元组的底层实现\"></a>Python列表和元组的底层实现</h1><p>这里就不记录笔记了，总的来说就是列表是一个长度可变且连续的内存空间，当列表的元素满了后，将会申请更多的内存空间，再将原本的内存空间拷贝过去。而元组则是一个空间带下固定且连续的内存空间。Python对元组进行了优化，例如为了避免系统老是释放和申请内存空间这一繁琐且耗时的操作，所以每次释放元组时其实是将其放入一个缓存中，如果下次还需要申请相同数据的元组，则可以直接从缓存中拿到。</p>\n<p>具体介绍看这里<a href=\"http://c.biancheng.net/view/5360.html\" target=\"_blank\" rel=\"noopener\">💿Python列表和元组的底层实现</a> </p>\n<h1 id=\"Python-dict字典\"><a href=\"#Python-dict字典\" class=\"headerlink\" title=\"Python dict字典\"></a>Python dict字典</h1><p>dict字典属于可变序列，但是无序的序列，其内容是键值对的形式保存的。</p>\n<p>键值对也可以称为映射，所以字典的值与键是互相对应的关系。</p>\n<p>Python字典特征</p>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通过键读取元素</td>\n<td>通过字典中的键来获取指定项，而不是通过索引获取</td>\n</tr>\n<tr>\n<td>字典是任意数据类型的无序集合</td>\n<td>和列表、元组不同，索引值可以通过数字获取对应的元素，而字典中的元素是无序的。</td>\n</tr>\n<tr>\n<td>字典是可变的，并且可以任意嵌套</td>\n<td>字典可以在原处增长或缩短，并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其他字典</td>\n</tr>\n<tr>\n<td>字典中的键必须是唯一的</td>\n<td>字典中不允许出现相同的键，否则只会保留最后一个键值对</td>\n</tr>\n<tr>\n<td>字典中的键必须是不可变的</td>\n<td>字典中的值是不可变的，所以只能使用数字、或元组、字符串等，不能使用可变，例如可变序列：列表</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Python中字典的数据类型为<code>dict</code></strong> </p>\n<h2 id=\"Python创建字典\"><a href=\"#Python创建字典\" class=\"headerlink\" title=\"Python创建字典\"></a>Python创建字典</h2><h3 id=\"花括号语法创建字典\"><a href=\"#花括号语法创建字典\" class=\"headerlink\" title=\"花括号语法创建字典\"></a>花括号语法创建字典</h3><p>字典中每个元素都包含两个部分，分别是键和值。因此在创建字典元素时，需要在键和值之间以冒号<code>:</code>分隔，相邻元素之间使用逗号分隔，所有元素放下大括号<code>{}</code>间。</p>\n<p>语法格式:</p>\n<p><code>dictname = {&#39;key1&#39;:&#39;value&#39;,&quot;key2&quot;:&quot;value&quot;}</code></p>\n<p>其中<code>dictname</code> 代表字典名，<code>key:value</code> 表示各个元素的键值对。</p>\n<p>使用花括号创建字典例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&quot;语文&quot;:80,&quot;数学&quot;:12&#125;</span><br><span class=\"line\">print(test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<p><code>{&#39;语文&#39;: 80, &#39;数学&#39;: 12}</code></p>\n<h3 id=\"通过fromkey-方法创建字典\"><a href=\"#通过fromkey-方法创建字典\" class=\"headerlink\" title=\"通过fromkey()方法创建字典\"></a>通过fromkey()方法创建字典</h3><p>Python中使用dict字典类型提供的fromkeys()方法创建所有键值为空的字典。</p>\n<p>语法格式</p>\n<p><code>dictname=dict.fromkeys(list,value=None)</code> </p>\n<p>list参数表示字典中键的列表，value参数默认为None，表示所有键对应的值。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">knowledge = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">scores = dict.fromkeys(knowledge,100)</span><br><span class=\"line\">print(scores)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;语文&apos;: 100, &apos;英语&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过dict-映射函数创建字典\"><a href=\"#通过dict-映射函数创建字典\" class=\"headerlink\" title=\"通过dict()映射函数创建字典\"></a>通过dict()映射函数创建字典</h3><p>dict()函数常用创建字典方法</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/dict(\" alt=\"dict()函数创建字典\">函数创建字典.png)</p>\n<h2 id=\"Pyton访问字典\"><a href=\"#Pyton访问字典\" class=\"headerlink\" title=\"Pyton访问字典\"></a>Pyton访问字典</h2><p>dict()通过元素的键进行访问值，不能像列表或元组通过下标或切片的形式来访问。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">print(type(test_dict))</span><br><span class=\"line\">print(test_dict[&apos;姓名&apos;])</span><br><span class=\"line\">print(test_dict.get(&quot;性别&quot;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python删除字典\"><a href=\"#Python删除字典\" class=\"headerlink\" title=\"Python删除字典\"></a>Python删除字典</h2><p>如需手动删除，可以使用del语句。</p>\n<h1 id=\"Pythton-dict字典基本操作-包括添加、修改、删除键值对\"><a href=\"#Pythton-dict字典基本操作-包括添加、修改、删除键值对\" class=\"headerlink\" title=\"Pythton dict字典基本操作(包括添加、修改、删除键值对)\"></a>Pythton dict字典基本操作(包括添加、修改、删除键值对)</h1><p>本小节对字典实现常见的操作:</p>\n<ul>\n<li><p>向字典中添加新的键值对</p>\n</li>\n<li><p>修改字典中的键值对</p>\n</li>\n<li><p>从字典中删除指定的键值对</p>\n</li>\n<li><p>判断字典中是否存在指定的键值对</p>\n</li>\n</ul>\n<h2 id=\"Python字典添加键值对\"><a href=\"#Python字典添加键值对\" class=\"headerlink\" title=\"Python字典添加键值对\"></a>Python字典添加键值对</h2><p>为字典中添加新的键值对只需要为不存在的<code>key</code>赋值。</p>\n<p>语法格式:</p>\n<p><code>dict[key]= value</code> </p>\n<p><code>dict</code>表示字典名称,<code>key</code>代表新建键值对的键,<code>value</code>代表新建键值对的值</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 502</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>502</code> </p>\n<h2 id=\"Python字典修改键值对\"><a href=\"#Python字典修改键值对\" class=\"headerlink\" title=\"Python字典修改键值对\"></a>Python字典修改键值对</h2><p>这里的修改是指:修改键值对的值。</p>\n<p><strong>Python中如果新添加的键值对的键存在，那么则会覆盖原本的键值对的值</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 502</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 999</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">502</span><br><span class=\"line\">999</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python字典删除键值对\"><a href=\"#Python字典删除键值对\" class=\"headerlink\" title=\"Python字典删除键值对\"></a>Python字典删除键值对</h2><p>如果要删除字典中的键值对，则可以使用<code>del</code>语句，指定要删除的键值对的键。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 502</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br><span class=\"line\">del test_dict[&apos;班级&apos;]</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">502</span><br><span class=\"line\">None</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断字典中是否存在指定键值对\"><a href=\"#判断字典中是否存在指定键值对\" class=\"headerlink\" title=\"判断字典中是否存在指定键值对\"></a>判断字典中是否存在指定键值对</h2><p>如果需要判断字典是否存在指定键值对的键，可以使用<code>in</code>或<code>not in</code>运算符。</p>\n<p><strong>注意:这里的<code>in</code>或<code>not in</code>运算符都是基于<code>key</code>来判断字典中某个键值对是否存在的.</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">del test_dict[&apos;姓名&apos;]</span><br><span class=\"line\">print(test_dict.get(&quot;姓名&quot;))</span><br><span class=\"line\">print(&apos;姓名&apos; in test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">None</span><br><span class=\"line\">False</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-dict字典方法完全攻略-全\"><a href=\"#Python-dict字典方法完全攻略-全\" class=\"headerlink\" title=\"Python dict字典方法完全攻略(全)\"></a>Python dict字典方法完全攻略(全)</h1><p>想查看<code>dict</code>该类包包含哪些方法，可以使用<code>dir()</code>方法进行查看。</p>\n<h2 id=\"Python-keys-values-和items-方法\"><a href=\"#Python-keys-values-和items-方法\" class=\"headerlink\" title=\"Python keys(),values()和items()方法\"></a>Python keys(),values()和items()方法</h2><p>这三个方法可以获取字典中特定的数据.</p>\n<p><code>keys()</code>方法用于返回字典中的所有键;</p>\n<p><code>values()</code>用于返回字典中所有键对应的值;</p>\n<p><code>items()</code>用于返回字典中所有的键值对;</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">print(test_dict.keys())</span><br><span class=\"line\">print(test_dict.values())</span><br><span class=\"line\">print(test_dict.items())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict_keys([&apos;英语&apos;, &apos;语文&apos;, &apos;数学&apos;])</span><br><span class=\"line\">dict_values([100, 100, 100])</span><br><span class=\"line\">dict_items([(&apos;英语&apos;, 100), (&apos;语文&apos;, 100), (&apos;数学&apos;, 100)])</span><br></pre></td></tr></table></figure>\n<p><strong>注意:<code>Python2.x</code>中，上面提到的方法的返回值是列表类型。但在<code>Python3.x</code>中，以上方法返回的类型不是序列类型。</strong> </p>\n<h2 id=\"Python-copy-方法\"><a href=\"#Python-copy-方法\" class=\"headerlink\" title=\"Python copy()方法\"></a>Python copy()方法</h2><p><code>copy()</code>方法用于返回一个具有相同键值对的新字典:</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">test_dict2 = test_dict.copy()</span><br><span class=\"line\">print(test_dict,&quot;\\n&quot;,test_dict2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意Python的copy()方法涉及到<code>深拷贝</code>与<code>浅拷贝</code>的关系，当字典A拷贝键值对给字典B后，那么拷贝的数据(字典B内)将会在字典A对键值对进行修改时发生变化，而字典A添加新的键值对，字典B不收影响。</strong> </p>\n<h2 id=\"Python-update-方法\"><a href=\"#Python-update-方法\" class=\"headerlink\" title=\"Python update()方法\"></a>Python update()方法</h2><p>updae()方法可以使用一个字典所包含的键值对来更新已有的字典。</p>\n<p>如果被更新的字典中已存在对应的键值对，那么原键值对值将会被覆盖，否则将会被添加。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">test_dict2 = test_dict.copy()</span><br><span class=\"line\">print(type(test_dict))</span><br><span class=\"line\">test_dict[&apos;语文&apos;]=100</span><br><span class=\"line\">test_dict2[&apos;物理&apos;]=200</span><br><span class=\"line\">test_dict2.update(test_dict)</span><br><span class=\"line\">print(test_dict,&quot;\\n&quot;,test_dict2)</span><br><span class=\"line\">print(test_dict,&quot;\\n&quot;,test_dict2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-pop方法\"><a href=\"#Python-pop方法\" class=\"headerlink\" title=\"Python pop方法\"></a>Python pop方法</h2><p>pop()方法可以获取指定key的value，并删除。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">print(test_dict.pop(&apos;语文&apos;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-popitem-方法\"><a href=\"#Python-popitem-方法\" class=\"headerlink\" title=\"Python popitem()方法\"></a>Python popitem()方法</h2><p>popitem()方法用于弹出字典中最后一个键值对(这里的最后一个其实是随机的，因为字典是无序序列，所以并不能说的某个键值对的位置取向).</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">print(test_dict.popitem())</span><br><span class=\"line\">print(test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&apos;数学&apos;, 100)</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-setdefault-方法\"><a href=\"#Python-setdefault-方法\" class=\"headerlink\" title=\"Python setdefault()方法\"></a>Python setdefault()方法</h2><p>setdefault()方法用于根据key来获取value，但有两种场景，第一种是，如果获取的键值对的key存在字典中，则会直接获取改键值对的value，不存在则会为该key先将value设置为默认的value，然后再返回该key对应的value。</p>\n<p><strong>特点:setdefault方法总能返回指定key对应的value;</strong></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\"># 要设置的键值对的key不存在.</span><br><span class=\"line\">test_dict.setdefault(&apos;物理&apos;,120)</span><br><span class=\"line\">print(test_dict)</span><br><span class=\"line\"># 要设置的键值对的key存在.</span><br><span class=\"line\">test_dict.setdefault(&apos;语文&apos;,200)</span><br><span class=\"line\">print(test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;</span><br><span class=\"line\">&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python使用字典格式化字符串\"><a href=\"#Python使用字典格式化字符串\" class=\"headerlink\" title=\"Python使用字典格式化字符串\"></a>Python使用字典格式化字符串</h1><p>我们知道，在格式化字符串时，如果格式化字符串模板中包含多个变量时，则后面月必须按顺序加上相同个数的变量，如果变量过多，则会十分麻烦，Python提供了用字典格式化字符串的方式来解决。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student = &apos;姓名:%(name)s\\t班级:%(class)d\\t综合成绩:%(score)f&apos;</span><br><span class=\"line\">student_info = &#123;&apos;name&apos;:&apos;LTy&apos;,&apos;class&apos;:604,&apos;score&apos;:99.5&#125;</span><br><span class=\"line\">print(student % student_info)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">姓名:LTy        班级:604        综合成绩:99.500000</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-set集合详解\"><a href=\"#Python-set集合详解\" class=\"headerlink\" title=\"Python set集合详解\"></a>Python set集合详解</h1><p>set集合的特点:</p>\n<ul>\n<li><p>数据唯一性(必须保证集合中每种数据元素是唯一的)</p>\n</li>\n<li><p>数据不可变(只允许存储不可变的数据类型，例如列表、字典、集合则是不允许存储在集合中的)</p>\n</li>\n<li><p>集合是无序的，所以每次输出元素时，排序顺序可能都不同。</p>\n</li>\n</ul>\n<h2 id=\"Python创建set集合\"><a href=\"#Python创建set集合\" class=\"headerlink\" title=\"Python创建set集合\"></a>Python创建set集合</h2><p>有两种创建<code>set</code>集合的方法，分别是使用{}创建和使用set()函数将列表、元组等数据类型转化为集合。</p>\n<h3 id=\"使用-创建\"><a href=\"#使用-创建\" class=\"headerlink\" title=\"使用{}创建\"></a>使用{}创建</h3><p>语法格式:</p>\n<p><code>setname = {element1,element2...elementn}</code></p>\n<p>setname代表集合的名称。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_set = &#123;1,2,3,4&#125;</span><br><span class=\"line\">print(test_set)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用set-函数创建集合\"><a href=\"#使用set-函数创建集合\" class=\"headerlink\" title=\"使用set()函数创建集合\"></a>使用set()函数创建集合</h3><p>set()函数为Python的内置函数，其可以将字符串、列表、元组以及range对象等可迭代的对象转换成集合。</p>\n<p>语法格式:</p>\n<p><code>setname = set(iteration)</code> </p>\n<p>iteration就表示可迭代的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = set(&quot;I Love China&quot;)</span><br><span class=\"line\">set2 = set(list(range(1,6)))</span><br><span class=\"line\">set3 = set(tuple(range(1,6)))</span><br><span class=\"line\">set4 = set(range(1,6))</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">print(set2)</span><br><span class=\"line\">print(set3)</span><br><span class=\"line\">print(set4)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从输出结果看，字符串被打乱了</span><br><span class=\"line\">&#123;&apos;a&apos;, &apos;L&apos;, &apos;h&apos;, &apos; &apos;, &apos;C&apos;, &apos;e&apos;, &apos;n&apos;, &apos;i&apos;, &apos;I&apos;, &apos;v&apos;, &apos;o&apos;&#125;</span><br><span class=\"line\">&#123;1, 2, 3, 4, 5&#125;</span><br><span class=\"line\">&#123;1, 2, 3, 4, 5&#125;</span><br><span class=\"line\">&#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意:如果想要创建空集合，必须使用<code>set()</code>函数实现，因为如果只给一对<code>{}</code>，Python解释器会将其视为一个空字典。</strong></p>\n<h2 id=\"Python访问set集合元素\"><a href=\"#Python访问set集合元素\" class=\"headerlink\" title=\"Python访问set集合元素\"></a>Python访问set集合元素</h2><p>由于<code>set</code>集合是无序的，所以无法通过下标索引进行访问，但是我们可通过遍历<code>set</code>集合访问元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = set(&quot;I Love China&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">for ele in set1:</span><br><span class=\"line\">    print(ele,end=&apos;&apos;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oCenaL Ihvi</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python删除set集合\"><a href=\"#Python删除set集合\" class=\"headerlink\" title=\"Python删除set集合\"></a>Python删除set集合</h2><p>想要手动删除<code>set</code>集合可以使用<code>del()</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = set(&quot;I Love China&quot;)</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">del(set1)</span><br><span class=\"line\">print(set1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;a&apos;, &apos;i&apos;, &apos;e&apos;, &apos; &apos;, &apos;L&apos;, &apos;C&apos;, &apos;o&apos;, &apos;h&apos;, &apos;I&apos;, &apos;n&apos;, &apos;v&apos;&#125;</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 4, in &lt;module&gt;</span><br><span class=\"line\">  │ print(set1)</span><br><span class=\"line\">NameError: name &apos;set1&apos; is not defined</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-set集合基本操作-添加、删除、交集、并集、差集\"><a href=\"#Python-set集合基本操作-添加、删除、交集、并集、差集\" class=\"headerlink\" title=\"Python set集合基本操作(添加、删除、交集、并集、差集)\"></a>Python set集合基本操作(添加、删除、交集、并集、差集)</h1><p><code>set</code>集合最常用的场景是添加、删除元素以及在多个集合之间做交集、并集、差集等运算。 </p>\n<h2 id=\"向set集合中添加元素\"><a href=\"#向set集合中添加元素\" class=\"headerlink\" title=\"向set集合中添加元素\"></a>向set集合中添加元素</h2><p>Python为<code>set</code>集合提供了<code>add()</code>方法，其可以向<code>set</code>集合添加元素。</p>\n<p>语法格式:</p>\n<p><code>setname.add(element)</code> </p>\n<p>setname表示要添加元素的集合，element代表添加的元素。</p>\n<p><strong>注意:element不可为可变数据类型</strong> </p>\n<h2 id=\"从set集合中删除元素\"><a href=\"#从set集合中删除元素\" class=\"headerlink\" title=\"从set集合中删除元素\"></a>从set集合中删除元素</h2><p>想要从集合中删除某个元素可以使用<code>remove()</code>方法</p>\n<p>语法格式:</p>\n<p><code>setname.remove(element)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;1,2,3,4&#125;</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.remove(1)</span><br><span class=\"line\">print(set1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br><span class=\"line\">&#123;2, 3, 4&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意:如果要删除的元素已经被删除，再次删除则会引发<code>KeyError</code>错误</strong></p>\n<p>如果想要在删除失败时不抛出异常，我们可以使用<code>discard()</code>方法。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;1,2,3,4&#125;</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.remove(1)</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.discard(1)</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.remove(1)</span><br><span class=\"line\">print(set1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br><span class=\"line\">&#123;2, 3, 4&#125;</span><br><span class=\"line\">&#123;2, 3, 4&#125;</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">  │ set1.remove(1)</span><br><span class=\"line\">KeyError: 1</span><br></pre></td></tr></table></figure>\n<p><code>discard()</code>方法与<code>remove()</code>方法的唯一区别在于:<strong>删除失败时是否抛出异常</strong> o</p>\n<h2 id=\"Python-set集合做交集、并集、差集运算\"><a href=\"#Python-set集合做交集、并集、差集运算\" class=\"headerlink\" title=\"Python set集合做交集、并集、差集运算\"></a>Python set集合做交集、并集、差集运算</h2><p><code>set</code>集合最常用的操作也就是进行交集、并集、差集以及对称差集运算了，首先看这张图:</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合示意图.png\" alt=\"集合示意图\"> </p>\n<p>图中有两个集合，分别是:</p>\n<ul>\n<li><p><code>set1={1,2,3}</code></p>\n</li>\n<li><p><code>set2={3,4,5}</code></p>\n</li>\n</ul>\n<p>下面的表格展示了不同的运算，得到的不同的结果。</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合运算.png\" alt=\"集合运算图\"> </p>\n<h1 id=\"Python-set集合方法详解-全\"><a href=\"#Python-set集合方法详解-全\" class=\"headerlink\" title=\"Python set集合方法详解(全)\"></a>Python set集合方法详解(全)</h1><p>如果想要看<code>set</code>集合所有的方法，可以使用<code>dir(set)</code>进行查看。</p>\n<p>Python set方法</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>语法格式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add()</td>\n<td>set1.add()</td>\n<td>向set1集合中添加非可变元素</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td>set1.clear()</td>\n<td>清空set1集合中所有的元素</td>\n</tr>\n<tr>\n<td>copy()</td>\n<td>set2=set1.copy()</td>\n<td>拷贝set1集合中的元素给set2</td>\n</tr>\n<tr>\n<td>difference()</td>\n<td>set3=set1.difference(set2)</td>\n<td>将set1中有而set2中没有的元素给set3</td>\n</tr>\n<tr>\n<td>difference_update()</td>\n<td>set1.difference_update(set2)</td>\n<td>从set1中删除与set2相同的元素</td>\n</tr>\n<tr>\n<td>discard()</td>\n<td>set1.discard(element)</td>\n<td>删除set1中的element元素</td>\n</tr>\n<tr>\n<td>intersection()</td>\n<td>set3=set1.intersection(set2)</td>\n<td>取set1和set2的交集赋值给set3</td>\n</tr>\n<tr>\n<td>intersection_update()</td>\n<td>set1.intersection_update(set2)</td>\n<td>取set1和set2的交集并且将值赋值给set1(更新set1的值为set1与set2的交集)</td>\n</tr>\n<tr>\n<td>isdisjoint()</td>\n<td>set1.isdisjoint(set2)</td>\n<td>判断set1和set2是否没有交集，有交集返回False;没有则返回True</td>\n</tr>\n<tr>\n<td>issubset()</td>\n<td>set1.issubset(set2)</td>\n<td>判断set1是否是set2的子集</td>\n</tr>\n<tr>\n<td>issuperset()</td>\n<td>set1.issuperset(set2)</td>\n<td>判断set2是否是set1的子集</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>a = set1.pop()</td>\n<td>取出set1中一个元素并赋值给a</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>set1.remove(element)</td>\n<td>移除set1中的element元素</td>\n</tr>\n<tr>\n<td>symmetric_difference()</td>\n<td>set3=set1.symmetric_difference(set2)</td>\n<td>取set1和set2中互不相同的元素给set3</td>\n</tr>\n<tr>\n<td>symmetric_difference_update()</td>\n<td>set1.symmetric_difference_update(set2)</td>\n<td>取set1和set2中互不相同的元素并更新set1的值</td>\n</tr>\n<tr>\n<td>union()</td>\n<td>set3=set1.union(set2)</td>\n<td>取set1和set2的并集，赋值给set3</td>\n</tr>\n<tr>\n<td>update()</td>\n<td>set1.update(element)</td>\n<td>添加列表或集合中的元素到set1</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Python-frozenset-set集合的不可变版本\"><a href=\"#Python-frozenset-set集合的不可变版本\" class=\"headerlink\" title=\"Python frozenset(set集合的不可变版本)\"></a>Python frozenset(set集合的不可变版本)</h1><p>前面我们所学习的<code>set</code>集合是可变的，而frozenset则是<code>set</code>集合的不可变版本，它不具备<code>set</code>集合的所有能改变集合本身的方法。</p>\n<p>frozenset的主要使用场景:</p>\n<ul>\n<li><p>当集合元素不需要改变的时候，使用frozenset替代set将会更加安全。</p>\n</li>\n<li><p>当某些API需要不可变对象作为参数时，必须用到frozenset替代set。</p>\n</li>\n</ul>\n<h1 id=\"深入底层了解Python字典和集合、一眼看穿他们的本质\"><a href=\"#深入底层了解Python字典和集合、一眼看穿他们的本质\" class=\"headerlink\" title=\"深入底层了解Python字典和集合、一眼看穿他们的本质\"></a>深入底层了解Python字典和集合、一眼看穿他们的本质</h1><p>本小节涉及到未知的知识，推荐去原文看**<a href=\"http://c.biancheng.net/view/5302.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python深拷贝和浅拷贝详解\"><a href=\"#Python深拷贝和浅拷贝详解\" class=\"headerlink\" title=\"Python深拷贝和浅拷贝详解\"></a>Python深拷贝和浅拷贝详解</h1><p>本小节涉及到未知的知识，推荐去原文看<a href=\"http://c.biancheng.net/view/5358.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n","site":{"data":{}},"excerpt":"<p>Python系列第四章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/list_tuple_dict/\" target=\"_blank\" rel=\"noopener\">💿</a></p>","more":"<h1 id=\"什么是序列，Python序列详解（包括序列类型和常用操作）\"><a href=\"#什么是序列，Python序列详解（包括序列类型和常用操作）\" class=\"headerlink\" title=\"什么是序列，Python序列详解（包括序列类型和常用操作）\"></a>什么是序列，Python序列详解（包括序列类型和常用操作）</h1><p>序列：一块可存放多个且连续的内存空间，并且这些值有顺序，可通过索引进行访问。</p>\n<p>常见的序列有: 字符串、列表、元组、集合和字典。</p>\n<p>这些常见的序列，除了集合和字典不支持索引、切片、相加和相乘的操作，其余的都可以。</p>\n<h2 id=\"序列索引\"><a href=\"#序列索引\" class=\"headerlink\" title=\"序列索引\"></a>序列索引</h2><p>索引就是一个序列中每个元素的编号。第一个元素的索引是0，也就是说想要访问某个序列的第一个元素，那么它的索引就是0，而想要访问最后一个元素，那么它的索引就是序列长度-1</p>\n<p>索引还分为正索引值和负索引值，它们的区别仅仅在于访问方式不同。</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li><p>正索引值的起始位置是0，结束位置是序列长度-1</p>\n</li>\n<li><p>负索引值的起始位置是-1,结束位置是-(序列长度-1)</p>\n</li>\n</ul>\n<p>例子:</p>\n<p><strong>根据索引访问序列元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = &quot;Hello World&quot;</span><br><span class=\"line\">print(&quot;str 的第一个字符是:%s，最后一个字符是:%s&quot; % (str[0],str[len(str)-1]))</span><br></pre></td></tr></table></figure>\n<p>输出结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str 的第一个字符是:H，最后一个字符是:d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"序列切片\"><a href=\"#序列切片\" class=\"headerlink\" title=\"序列切片\"></a>序列切片</h2><p>刚刚我们通过索引值进行访问序列元素，那么序列切片也是可以做到的，它可以访问某个范围内的元素。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sname[start:end:step]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>sname:序列名称</p>\n</li>\n<li><p>start:切片开始的索引位置（包括该位置），此参数可不指定，默认为0。</p>\n</li>\n<li><p>end:切片结束的索引位置(不包括该位置)，此参数可不指定，默认为序列的长度。</p>\n</li>\n<li><p>step:切片的范围，也就是每次取元素时，要隔多少个位置，此参数可不指定，可以直接忽略最后一个冒号</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = &quot;Hello World&quot;</span><br><span class=\"line\"># 获取整个字符串</span><br><span class=\"line\">print(str[:])</span><br><span class=\"line\"># 从索引4开始，一直到最后一个，没隔2个字符取一次。</span><br><span class=\"line\">print(str[4::2])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br><span class=\"line\">oWrd</span><br></pre></td></tr></table></figure>\n<h2 id=\"序列相加\"><a href=\"#序列相加\" class=\"headerlink\" title=\"序列相加\"></a>序列相加</h2><p>序列可以使用<code>+</code>运算符，进行相加操作，他会将两个序列进行连接，但不会去除重复的元素。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;hello&quot;</span><br><span class=\"line\">str2=&quot;world&quot;</span><br><span class=\"line\">print(str1+str2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>helloworld</code></p>\n<h2 id=\"序列相乘\"><a href=\"#序列相乘\" class=\"headerlink\" title=\"序列相乘\"></a>序列相乘</h2><p>使用<code>*</code>运算符，可以将序列的元素进行重复。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;hello\\t&quot;</span><br><span class=\"line\">print(str1*3)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>hello    hello    hello</code></p>\n<p><strong>tips:可以使用序列相乘，创建指定长度空列表</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [None]*5</span><br></pre></td></tr></table></figure>\n<h2 id=\"检查元素是否包含在序列中\"><a href=\"#检查元素是否包含在序列中\" class=\"headerlink\" title=\"检查元素是否包含在序列中\"></a>检查元素是否包含在序列中</h2><p>使用<code>in</code>关键字可以检查序列中的元素是否存在。 </p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value in sequence</span><br></pre></td></tr></table></figure>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;Hello&quot;</span><br><span class=\"line\">print(&apos;o&apos; in str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果: <code>True</code></p>\n<p><strong>tips:使用<code>not in</code>关键字可以检查是否不存在</strong></p>\n<h2 id=\"和序列相关的内置函数\"><a href=\"#和序列相关的内置函数\" class=\"headerlink\" title=\"和序列相关的内置函数\"></a>和序列相关的内置函数</h2><p>Python提供了几个用于操作序列的内置函数，可以很方便的操作序列。</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/Python序列内置函数.png\" alt=\"Python序列内置函数\"></p>\n<h1 id=\"Python-list列表详解\"><a href=\"#Python-list列表详解\" class=\"headerlink\" title=\"Python list列表详解\"></a>Python list列表详解</h1><p>Python提供了一种数据结构————<code>list</code>(列表)</p>\n<p><strong>列表可以存储多个不同数据类型的元素。</strong></p>\n<h2 id=\"Python创建列表\"><a href=\"#Python创建列表\" class=\"headerlink\" title=\"Python创建列表\"></a>Python创建列表</h2><p>创建列表分为两种方式</p>\n<p>使用<code>=</code>运算符创建列表</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listname = [element1,element2...elementn]</span><br></pre></td></tr></table></figure>\n<p>listname: 列表的名称</p>\n<p>element1: 列表的元素</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建一个列表</span><br><span class=\"line\">test_list1 =[&quot;one&quot;,1,True,1.0]</span><br><span class=\"line\">print(test_list1)</span><br><span class=\"line\"># 创建一个空列表</span><br><span class=\"line\">empty_list = []</span><br><span class=\"line\">print(empty_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;one&apos;, 1, True, 1.0]</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n<p><strong>使用list()函数创建列表</strong></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;HelloWorld&quot;</span><br><span class=\"line\">test_list = list(str1)</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;W&apos;, &apos;o&apos;, &apos;r&apos;, &apos;l&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问列表元素\"><a href=\"#访问列表元素\" class=\"headerlink\" title=\"访问列表元素\"></a>访问列表元素</h2><p>两种方式：通过索引访问和通过切片访问。</p>\n<h2 id=\"删除列表\"><a href=\"#删除列表\" class=\"headerlink\" title=\"删除列表\"></a>删除列表</h2><p>不常用，因为Python具有垃圾回收机制，有些不需要再使用的列表将会自动回收。</p>\n<p>使用<code>del</code>关键字进行删除</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del listname</span><br></pre></td></tr></table></figure>\n<p><strong>注意:删除后的列表不能再次使用</strong></p>\n<h1 id=\"Python-list列表添加元素的3种方法\"><a href=\"#Python-list列表添加元素的3种方法\" class=\"headerlink\" title=\"Python list列表添加元素的3种方法\"></a>Python list列表添加元素的3种方法</h1><h2 id=\"Python-append-方法添加元素\"><a href=\"#Python-append-方法添加元素\" class=\"headerlink\" title=\"Python append()方法添加元素\"></a>Python append()方法添加元素</h2><p><code>append()</code>方法在列表的末尾追加元素。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listname.append(obj)</span><br></pre></td></tr></table></figure>\n<p>listname代表要添加元素的列表;obj代表要添加到列表末尾的数据。</p>\n<p>obj可以是单个元素，也可以是其他序列。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 追加单个元素</span><br><span class=\"line\">list1 = [0,1,2,3]</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\">list1.append(4)</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\"># 追加一个列表</span><br><span class=\"line\">list2 = [5,6,7,8]</span><br><span class=\"line\">print(list2)</span><br><span class=\"line\">list1.append(list2)</span><br><span class=\"line\">print(list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0, 1, 2, 3]</span><br><span class=\"line\">[0, 1, 2, 3, 4]</span><br><span class=\"line\">[5, 6, 7, 8]</span><br><span class=\"line\">[0, 1, 2, 3, 4, [5, 6, 7, 8]]</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意:使用append()函数时，如果是传递的单个数据，将会直接追加到列表后，但是如果传入的是个列表（序列），那么则会追加一个列表形式的元素。</strong></p>\n<p>想要访问刚刚追加的列表元素的其中一个可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [0,1,2]</span><br><span class=\"line\">list2 = [3,4,5]</span><br><span class=\"line\">list1.append(list2)</span><br><span class=\"line\">print(list1[3][2])</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>5</code></p>\n<h2 id=\"Python-extend-方法添加元素\"><a href=\"#Python-extend-方法添加元素\" class=\"headerlink\" title=\"Python extend()方法添加元素\"></a>Python extend()方法添加元素</h2><p>刚刚我们使用<code>append()</code>函数追加了个列表元素，但是并没有像添加单个字符一样作为一个整体添加，而我们只需要使用<code>extend()</code>方法就可以将列表以整体的方式添加进去。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [0,1,2,3]</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\">list2 = [5,6,7,8]</span><br><span class=\"line\">print(list2)</span><br><span class=\"line\">list1.extend(list2)</span><br><span class=\"line\">print(list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0, 1, 2, 3]</span><br><span class=\"line\">[5, 6, 7, 8]</span><br><span class=\"line\">[0, 1, 2, 3, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-insert-方法插入元素\"><a href=\"#Python-insert-方法插入元素\" class=\"headerlink\" title=\"Python insert()方法插入元素\"></a>Python insert()方法插入元素</h2><p>需要指定插入列表元素的位置时，可以使用insert()方法。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listname.insert(index,obj)</span><br></pre></td></tr></table></figure>\n<p>index: 将obj插入到listname列表的索引</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list1 = list(range(1,11))</span><br><span class=\"line\">print(test_list1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(len(test_list1))</span><br><span class=\"line\">test_list1.insert(len(test_list1),11)</span><br><span class=\"line\">print(test_list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">10</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Pyhton-list列表删除元素-3种方法\"><a href=\"#Pyhton-list列表删除元素-3种方法\" class=\"headerlink\" title=\"Pyhton list列表删除元素(3种方法)\"></a>Pyhton list列表删除元素(3种方法)</h2><blockquote>\n<p>del删除</p>\n</blockquote>\n<p><strong>del语句在Python中可以删除变量、列表的元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1, 11))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">del test_list[1::2]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>根据元素值进行删除</p>\n</blockquote>\n<p>可以使用remove()方法来删除列表元素。</p>\n<p>删除第一个被查找到的元素。</p>\n<p><strong>注意:remove()方法不是根据索引来删除元素的，而是查找元素本身，再进行删除，所以如果找不到元素，则会报错</strong></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]</span><br><span class=\"line\">test_list.remove(&apos;test&apos;)</span><br><span class=\"line\">test_list.remove(30)</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;test2&apos;, 10, 30]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>删除列表所有元素</p>\n</blockquote>\n<p>使用clear()方法可以删除列表的所有元素。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]</span><br><span class=\"line\">test_list.clear()</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-list列表修改元素\"><a href=\"#Python-list列表修改元素\" class=\"headerlink\" title=\"Python list列表修改元素\"></a>Python list列表修改元素</h1><p>修改列表元素，可以通过列表索引获取元素进行赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testlist = list(range(1,10))</span><br><span class=\"line\">print(testlist)</span><br><span class=\"line\">testlist[len(testlist)-1] = 100</span><br><span class=\"line\">print(testlist)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 100]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>使用slice语法对列表部分进行赋值。</p>\n<p>slice语法，不要求新赋值的元素个数与原来的元素个数相等。也就是说使用slice剩余法既可以为列表增加元素，也可以为列表删除元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b_list = list(range(1,5))</span><br><span class=\"line\">print(b_list)</span><br><span class=\"line\"></span><br><span class=\"line\">b_list[1:3] = [&apos;a&apos;,&apos;b&apos;]</span><br><span class=\"line\">print(b_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\">[1, &apos;a&apos;, &apos;b&apos;, 4]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Pyhthon-list常用方法-count、index、pop、reverse和sort-快速攻略\"><a href=\"#Pyhthon-list常用方法-count、index、pop、reverse和sort-快速攻略\" class=\"headerlink\" title=\"Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略\"></a>Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略</h1><p>Pyhton为list提供了一些常用的方法。</p>\n<p>我们使用dir(list)方法可以看到列表包含的所有方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(dir(list))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 _&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;,</span><br><span class=\"line\">5 &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setat</span><br><span class=\"line\">4 tr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;c</span><br><span class=\"line\">3 lear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;</span><br><span class=\"line\">2 , &apos;sort&apos;]</span><br></pre></td></tr></table></figure>\n<p><strong>注意，方法名包含双下划线的不推荐使用</strong> </p>\n<h2 id=\"count-方法\"><a href=\"#count-方法\" class=\"headerlink\" title=\"count()方法\"></a>count()方法</h2><p>count()方法用于统计列表中某个元素出现的次数</p>\n<p>语法格式</p>\n<p><code>listname.count(obj)</code> </p>\n<p>listname:列表名称</p>\n<p>obj:表示判断是否存在的元素</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_list = [2]*5</span><br><span class=\"line\">print(a_list)</span><br><span class=\"line\">print(&quot;2出现%d次&quot; % a_list.count(2))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2, 2, 2, 2, 2]</span><br><span class=\"line\">2出现5次</span><br></pre></td></tr></table></figure>\n<h2 id=\"index-用法\"><a href=\"#index-用法\" class=\"headerlink\" title=\"index()用法\"></a>index()用法</h2><p>index()方法用于定位某元素在列表的索引位置，如果该元素没有出现，则会引发ValueError错误。 </p>\n<p>语法格式:</p>\n<p><code>listname.index(obj,start,end)</code></p>\n<p>index()方法可以传入start,end参数，用于指定在列表的某范围内搜索元素</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,10))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">print(test_list.index(9))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<h2 id=\"pop用法\"><a href=\"#pop用法\" class=\"headerlink\" title=\"pop用法\"></a>pop用法</h2><p>pop()方法会溢出列表中指定索引处的元素，如果没有传入参数，则会移除列表中最后一个元素。</p>\n<p>语法格式:</p>\n<p><code>listname.pop(index)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,10))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\"># 默认移除最后一个元素</span><br><span class=\"line\">test_list.pop()</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\"># 移除第一次元素</span><br><span class=\"line\">print(test_list.pop(0))</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class=\"line\">1</span><br><span class=\"line\">[2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>\n<h2 id=\"reverse-方法\"><a href=\"#reverse-方法\" class=\"headerlink\" title=\"reverse()方法\"></a>reverse()方法</h2><p>reverse()方法会将列表中所有元素反向存放。</p>\n<p>语法格式;</p>\n<p><code>listname.reverse()</code></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,11))</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">test_list.reverse()</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>\n<h2 id=\"sort-用法\"><a href=\"#sort-用法\" class=\"headerlink\" title=\"sort()用法\"></a>sort()用法</h2><p>sort()方法用于对列表元素进行排序。</p>\n<p>语法格式:</p>\n<p><code>listname.sort(key=None,reserse=Fale)</code></p>\n<ul>\n<li><p>key参数用于指定从每个元素中提取一个用于比较的键。</p>\n</li>\n<li><p>reverse参数用于设置是否需要逆序，默认为False也就是从小打到排序，否则反之。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_list = [123,213,1,325,1,51,213,5132,4156]</span><br><span class=\"line\">print(a_list)</span><br><span class=\"line\"># 对列表进行排序</span><br><span class=\"line\">a_list.sort()</span><br><span class=\"line\">print(a_list)</span><br><span class=\"line\"># 逆序排序</span><br><span class=\"line\">a_list.sort(reverse=True)</span><br><span class=\"line\">print(a_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[123, 213, 1, 325, 1, 51, 213, 5132, 4156]</span><br><span class=\"line\">[1, 1, 51, 123, 213, 213, 325, 4156, 5132]</span><br><span class=\"line\">[5132, 4156, 325, 213, 213, 123, 51, 1, 1]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-range-快速初始化数字列表\"><a href=\"#Python-range-快速初始化数字列表\" class=\"headerlink\" title=\"Python range()快速初始化数字列表\"></a>Python range()快速初始化数字列表</h1><p>Python的range()函数能够生成一系列的数字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for value in range(1,5):</span><br><span class=\"line\">  print(value)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<p>range()方法是指定从第一个值开始，生成连续的数字，直到指定的第二值为止(不包括第二个值)</p>\n<p>range()方法可以指定步长，也就是说，每次连续增加时所增加的数值。</p>\n<h1 id=\"Python-tuple元组详解\"><a href=\"#Python-tuple元组详解\" class=\"headerlink\" title=\"Python tuple元组详解\"></a>Python tuple元组详解</h1><p>与列表类似，元组也可以存储任何Python的数据类型，但元组是不可变的，一旦赋值则不可修改。</p>\n<p>Python中，使用<code>()</code>小括号包住的一列数据，被称为元组，而各数据之间又由<code>,</code>逗号隔开。</p>\n<p>元组的数据类型是:<code>tuple</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_tuple = tuple(range(1,11))</span><br><span class=\"line\">print(type(test_tuple))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python创建元组\"><a href=\"#Python创建元组\" class=\"headerlink\" title=\"Python创建元组\"></a>Python创建元组</h2><h3 id=\"运算符直接创建元组\"><a href=\"#运算符直接创建元组\" class=\"headerlink\" title=\"= 运算符直接创建元组\"></a>= 运算符直接创建元组</h3><p>可以使用赋值运算符<code>=</code>将一个元组赋值给变量。</p>\n<p>语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tuplename = (element1,element2...elementn)</span><br></pre></td></tr></table></figure>\n<p>其中tuplename表示要创建的元组名,element代表元素。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_tuple = tuple(range(1,11))</span><br><span class=\"line\">str_tuple = (&quot;Just A Test&quot;,)</span><br><span class=\"line\">object_tuple = (&quot;a&quot;,1,2.22,num_tuple,list(range(1,5)))</span><br><span class=\"line\"></span><br><span class=\"line\">print(num_tuple)</span><br><span class=\"line\">print(str_tuple)</span><br><span class=\"line\">print(object_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class=\"line\">Just A Test</span><br><span class=\"line\">(&apos;a&apos;, 1, 2.22, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), [1, 2, 3, 4])</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong> :创建元组时，如果元组内只有一个元素，那么必须要在元素后加上一个逗号，否则Python解释器将会一位是字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_str = (&quot;Just a Test&quot;)</span><br><span class=\"line\">str_tuple = (&quot;Jest a Test&quot;,)</span><br><span class=\"line\">print(type(test_str))</span><br><span class=\"line\">print(type(str_tuple))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用tuple-函数创建元组\"><a href=\"#使用tuple-函数创建元组\" class=\"headerlink\" title=\"使用tuple()函数创建元组\"></a>使用tuple()函数创建元组</h3><p>Python提供了tuple()函数创建元组，我们可以将一些常见的对象，转化成元组。</p>\n<p>语法格式:</p>\n<p><code>tuple(iterable: Iterable[_T_co]=...)</code></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = list(range(1,21,2))</span><br><span class=\"line\">test_tuple = tuple(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\">print(type(test_list))</span><br><span class=\"line\">print(type(test_tuple))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;list&apos;&gt;</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python访问元组元素\"><a href=\"#Python访问元组元素\" class=\"headerlink\" title=\"Python访问元组元素\"></a>Python访问元组元素</h2><p>可以通过元素的下标获取或通过切片操作获取。</p>\n<h2 id=\"Python修改元组元素\"><a href=\"#Python修改元组元素\" class=\"headerlink\" title=\"Python修改元组元素\"></a>Python修改元组元素</h2><p>虽然前面提到元组是不可变序列，但还是可以通过一些手段进行修改元组内的数据。</p>\n<h3 id=\"重新赋值\"><a href=\"#重新赋值\" class=\"headerlink\" title=\"重新赋值\"></a>重新赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_tuple = tuple(range(1,6))</span><br><span class=\"line\">print(test_tuple)</span><br><span class=\"line\">test_tuple = tuple(range(1,20))</span><br><span class=\"line\">print(test_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1, 2, 3, 4, 5)</span><br><span class=\"line\">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接多个元组\"><a href=\"#连接多个元组\" class=\"headerlink\" title=\"连接多个元组\"></a>连接多个元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_tuple = tuple(range(1,6))</span><br><span class=\"line\">print(test_tuple)</span><br><span class=\"line\">test_tuple2 = tuple(range(6,11))</span><br><span class=\"line\">test_tuple += test_tuple2</span><br><span class=\"line\">print(test_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1, 2, 3, 4, 5)</span><br><span class=\"line\">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python删除元组\"><a href=\"#Python删除元组\" class=\"headerlink\" title=\"Python删除元组\"></a>Python删除元组</h2><p>若创建的元组不再使用可以使用<code>del</code>语句将其删除。</p>\n<h1 id=\"Python元组和列表的区别\"><a href=\"#Python元组和列表的区别\" class=\"headerlink\" title=\"Python元组和列表的区别\"></a>Python元组和列表的区别</h1><p>本节讨论元组和列表的区别:</p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>元组</th>\n<th>列表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>元素是否允许任意修改</td>\n<td>❌</td>\n<td>⭕</td>\n</tr>\n<tr>\n<td>是否能作为map的key</td>\n<td>⭕</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>内存占用小</td>\n<td>⭕</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Python列表和元组的底层实现\"><a href=\"#Python列表和元组的底层实现\" class=\"headerlink\" title=\"Python列表和元组的底层实现\"></a>Python列表和元组的底层实现</h1><p>这里就不记录笔记了，总的来说就是列表是一个长度可变且连续的内存空间，当列表的元素满了后，将会申请更多的内存空间，再将原本的内存空间拷贝过去。而元组则是一个空间带下固定且连续的内存空间。Python对元组进行了优化，例如为了避免系统老是释放和申请内存空间这一繁琐且耗时的操作，所以每次释放元组时其实是将其放入一个缓存中，如果下次还需要申请相同数据的元组，则可以直接从缓存中拿到。</p>\n<p>具体介绍看这里<a href=\"http://c.biancheng.net/view/5360.html\" target=\"_blank\" rel=\"noopener\">💿Python列表和元组的底层实现</a> </p>\n<h1 id=\"Python-dict字典\"><a href=\"#Python-dict字典\" class=\"headerlink\" title=\"Python dict字典\"></a>Python dict字典</h1><p>dict字典属于可变序列，但是无序的序列，其内容是键值对的形式保存的。</p>\n<p>键值对也可以称为映射，所以字典的值与键是互相对应的关系。</p>\n<p>Python字典特征</p>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通过键读取元素</td>\n<td>通过字典中的键来获取指定项，而不是通过索引获取</td>\n</tr>\n<tr>\n<td>字典是任意数据类型的无序集合</td>\n<td>和列表、元组不同，索引值可以通过数字获取对应的元素，而字典中的元素是无序的。</td>\n</tr>\n<tr>\n<td>字典是可变的，并且可以任意嵌套</td>\n<td>字典可以在原处增长或缩短，并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其他字典</td>\n</tr>\n<tr>\n<td>字典中的键必须是唯一的</td>\n<td>字典中不允许出现相同的键，否则只会保留最后一个键值对</td>\n</tr>\n<tr>\n<td>字典中的键必须是不可变的</td>\n<td>字典中的值是不可变的，所以只能使用数字、或元组、字符串等，不能使用可变，例如可变序列：列表</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Python中字典的数据类型为<code>dict</code></strong> </p>\n<h2 id=\"Python创建字典\"><a href=\"#Python创建字典\" class=\"headerlink\" title=\"Python创建字典\"></a>Python创建字典</h2><h3 id=\"花括号语法创建字典\"><a href=\"#花括号语法创建字典\" class=\"headerlink\" title=\"花括号语法创建字典\"></a>花括号语法创建字典</h3><p>字典中每个元素都包含两个部分，分别是键和值。因此在创建字典元素时，需要在键和值之间以冒号<code>:</code>分隔，相邻元素之间使用逗号分隔，所有元素放下大括号<code>{}</code>间。</p>\n<p>语法格式:</p>\n<p><code>dictname = {&#39;key1&#39;:&#39;value&#39;,&quot;key2&quot;:&quot;value&quot;}</code></p>\n<p>其中<code>dictname</code> 代表字典名，<code>key:value</code> 表示各个元素的键值对。</p>\n<p>使用花括号创建字典例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&quot;语文&quot;:80,&quot;数学&quot;:12&#125;</span><br><span class=\"line\">print(test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<p><code>{&#39;语文&#39;: 80, &#39;数学&#39;: 12}</code></p>\n<h3 id=\"通过fromkey-方法创建字典\"><a href=\"#通过fromkey-方法创建字典\" class=\"headerlink\" title=\"通过fromkey()方法创建字典\"></a>通过fromkey()方法创建字典</h3><p>Python中使用dict字典类型提供的fromkeys()方法创建所有键值为空的字典。</p>\n<p>语法格式</p>\n<p><code>dictname=dict.fromkeys(list,value=None)</code> </p>\n<p>list参数表示字典中键的列表，value参数默认为None，表示所有键对应的值。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">knowledge = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">scores = dict.fromkeys(knowledge,100)</span><br><span class=\"line\">print(scores)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;语文&apos;: 100, &apos;英语&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过dict-映射函数创建字典\"><a href=\"#通过dict-映射函数创建字典\" class=\"headerlink\" title=\"通过dict()映射函数创建字典\"></a>通过dict()映射函数创建字典</h3><p>dict()函数常用创建字典方法</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/dict(\" alt=\"dict()函数创建字典\">函数创建字典.png)</p>\n<h2 id=\"Pyton访问字典\"><a href=\"#Pyton访问字典\" class=\"headerlink\" title=\"Pyton访问字典\"></a>Pyton访问字典</h2><p>dict()通过元素的键进行访问值，不能像列表或元组通过下标或切片的形式来访问。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">print(type(test_dict))</span><br><span class=\"line\">print(test_dict[&apos;姓名&apos;])</span><br><span class=\"line\">print(test_dict.get(&quot;性别&quot;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python删除字典\"><a href=\"#Python删除字典\" class=\"headerlink\" title=\"Python删除字典\"></a>Python删除字典</h2><p>如需手动删除，可以使用del语句。</p>\n<h1 id=\"Pythton-dict字典基本操作-包括添加、修改、删除键值对\"><a href=\"#Pythton-dict字典基本操作-包括添加、修改、删除键值对\" class=\"headerlink\" title=\"Pythton dict字典基本操作(包括添加、修改、删除键值对)\"></a>Pythton dict字典基本操作(包括添加、修改、删除键值对)</h1><p>本小节对字典实现常见的操作:</p>\n<ul>\n<li><p>向字典中添加新的键值对</p>\n</li>\n<li><p>修改字典中的键值对</p>\n</li>\n<li><p>从字典中删除指定的键值对</p>\n</li>\n<li><p>判断字典中是否存在指定的键值对</p>\n</li>\n</ul>\n<h2 id=\"Python字典添加键值对\"><a href=\"#Python字典添加键值对\" class=\"headerlink\" title=\"Python字典添加键值对\"></a>Python字典添加键值对</h2><p>为字典中添加新的键值对只需要为不存在的<code>key</code>赋值。</p>\n<p>语法格式:</p>\n<p><code>dict[key]= value</code> </p>\n<p><code>dict</code>表示字典名称,<code>key</code>代表新建键值对的键,<code>value</code>代表新建键值对的值</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 502</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>502</code> </p>\n<h2 id=\"Python字典修改键值对\"><a href=\"#Python字典修改键值对\" class=\"headerlink\" title=\"Python字典修改键值对\"></a>Python字典修改键值对</h2><p>这里的修改是指:修改键值对的值。</p>\n<p><strong>Python中如果新添加的键值对的键存在，那么则会覆盖原本的键值对的值</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 502</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 999</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">502</span><br><span class=\"line\">999</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python字典删除键值对\"><a href=\"#Python字典删除键值对\" class=\"headerlink\" title=\"Python字典删除键值对\"></a>Python字典删除键值对</h2><p>如果要删除字典中的键值对，则可以使用<code>del</code>语句，指定要删除的键值对的键。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">test_dict[&apos;班级&apos;] = 502</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br><span class=\"line\">del test_dict[&apos;班级&apos;]</span><br><span class=\"line\">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">502</span><br><span class=\"line\">None</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断字典中是否存在指定键值对\"><a href=\"#判断字典中是否存在指定键值对\" class=\"headerlink\" title=\"判断字典中是否存在指定键值对\"></a>判断字典中是否存在指定键值对</h2><p>如果需要判断字典是否存在指定键值对的键，可以使用<code>in</code>或<code>not in</code>运算符。</p>\n<p><strong>注意:这里的<code>in</code>或<code>not in</code>运算符都是基于<code>key</code>来判断字典中某个键值对是否存在的.</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class=\"line\">test_dict = dict(test_dict)</span><br><span class=\"line\">del test_dict[&apos;姓名&apos;]</span><br><span class=\"line\">print(test_dict.get(&quot;姓名&quot;))</span><br><span class=\"line\">print(&apos;姓名&apos; in test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">None</span><br><span class=\"line\">False</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-dict字典方法完全攻略-全\"><a href=\"#Python-dict字典方法完全攻略-全\" class=\"headerlink\" title=\"Python dict字典方法完全攻略(全)\"></a>Python dict字典方法完全攻略(全)</h1><p>想查看<code>dict</code>该类包包含哪些方法，可以使用<code>dir()</code>方法进行查看。</p>\n<h2 id=\"Python-keys-values-和items-方法\"><a href=\"#Python-keys-values-和items-方法\" class=\"headerlink\" title=\"Python keys(),values()和items()方法\"></a>Python keys(),values()和items()方法</h2><p>这三个方法可以获取字典中特定的数据.</p>\n<p><code>keys()</code>方法用于返回字典中的所有键;</p>\n<p><code>values()</code>用于返回字典中所有键对应的值;</p>\n<p><code>items()</code>用于返回字典中所有的键值对;</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">print(test_dict.keys())</span><br><span class=\"line\">print(test_dict.values())</span><br><span class=\"line\">print(test_dict.items())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict_keys([&apos;英语&apos;, &apos;语文&apos;, &apos;数学&apos;])</span><br><span class=\"line\">dict_values([100, 100, 100])</span><br><span class=\"line\">dict_items([(&apos;英语&apos;, 100), (&apos;语文&apos;, 100), (&apos;数学&apos;, 100)])</span><br></pre></td></tr></table></figure>\n<p><strong>注意:<code>Python2.x</code>中，上面提到的方法的返回值是列表类型。但在<code>Python3.x</code>中，以上方法返回的类型不是序列类型。</strong> </p>\n<h2 id=\"Python-copy-方法\"><a href=\"#Python-copy-方法\" class=\"headerlink\" title=\"Python copy()方法\"></a>Python copy()方法</h2><p><code>copy()</code>方法用于返回一个具有相同键值对的新字典:</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">test_dict2 = test_dict.copy()</span><br><span class=\"line\">print(test_dict,&quot;\\n&quot;,test_dict2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意Python的copy()方法涉及到<code>深拷贝</code>与<code>浅拷贝</code>的关系，当字典A拷贝键值对给字典B后，那么拷贝的数据(字典B内)将会在字典A对键值对进行修改时发生变化，而字典A添加新的键值对，字典B不收影响。</strong> </p>\n<h2 id=\"Python-update-方法\"><a href=\"#Python-update-方法\" class=\"headerlink\" title=\"Python update()方法\"></a>Python update()方法</h2><p>updae()方法可以使用一个字典所包含的键值对来更新已有的字典。</p>\n<p>如果被更新的字典中已存在对应的键值对，那么原键值对值将会被覆盖，否则将会被添加。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">test_dict2 = test_dict.copy()</span><br><span class=\"line\">print(type(test_dict))</span><br><span class=\"line\">test_dict[&apos;语文&apos;]=100</span><br><span class=\"line\">test_dict2[&apos;物理&apos;]=200</span><br><span class=\"line\">test_dict2.update(test_dict)</span><br><span class=\"line\">print(test_dict,&quot;\\n&quot;,test_dict2)</span><br><span class=\"line\">print(test_dict,&quot;\\n&quot;,test_dict2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-pop方法\"><a href=\"#Python-pop方法\" class=\"headerlink\" title=\"Python pop方法\"></a>Python pop方法</h2><p>pop()方法可以获取指定key的value，并删除。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">print(test_dict.pop(&apos;语文&apos;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-popitem-方法\"><a href=\"#Python-popitem-方法\" class=\"headerlink\" title=\"Python popitem()方法\"></a>Python popitem()方法</h2><p>popitem()方法用于弹出字典中最后一个键值对(这里的最后一个其实是随机的，因为字典是无序序列，所以并不能说的某个键值对的位置取向).</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\">print(test_dict.popitem())</span><br><span class=\"line\">print(test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&apos;数学&apos;, 100)</span><br><span class=\"line\">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-setdefault-方法\"><a href=\"#Python-setdefault-方法\" class=\"headerlink\" title=\"Python setdefault()方法\"></a>Python setdefault()方法</h2><p>setdefault()方法用于根据key来获取value，但有两种场景，第一种是，如果获取的键值对的key存在字典中，则会直接获取改键值对的value，不存在则会为该key先将value设置为默认的value，然后再返回该key对应的value。</p>\n<p><strong>特点:setdefault方法总能返回指定key对应的value;</strong></p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class=\"line\">test_dict = dict.fromkeys(test_dict,100)</span><br><span class=\"line\"># 要设置的键值对的key不存在.</span><br><span class=\"line\">test_dict.setdefault(&apos;物理&apos;,120)</span><br><span class=\"line\">print(test_dict)</span><br><span class=\"line\"># 要设置的键值对的key存在.</span><br><span class=\"line\">test_dict.setdefault(&apos;语文&apos;,200)</span><br><span class=\"line\">print(test_dict)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;</span><br><span class=\"line\">&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python使用字典格式化字符串\"><a href=\"#Python使用字典格式化字符串\" class=\"headerlink\" title=\"Python使用字典格式化字符串\"></a>Python使用字典格式化字符串</h1><p>我们知道，在格式化字符串时，如果格式化字符串模板中包含多个变量时，则后面月必须按顺序加上相同个数的变量，如果变量过多，则会十分麻烦，Python提供了用字典格式化字符串的方式来解决。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student = &apos;姓名:%(name)s\\t班级:%(class)d\\t综合成绩:%(score)f&apos;</span><br><span class=\"line\">student_info = &#123;&apos;name&apos;:&apos;LTy&apos;,&apos;class&apos;:604,&apos;score&apos;:99.5&#125;</span><br><span class=\"line\">print(student % student_info)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">姓名:LTy        班级:604        综合成绩:99.500000</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-set集合详解\"><a href=\"#Python-set集合详解\" class=\"headerlink\" title=\"Python set集合详解\"></a>Python set集合详解</h1><p>set集合的特点:</p>\n<ul>\n<li><p>数据唯一性(必须保证集合中每种数据元素是唯一的)</p>\n</li>\n<li><p>数据不可变(只允许存储不可变的数据类型，例如列表、字典、集合则是不允许存储在集合中的)</p>\n</li>\n<li><p>集合是无序的，所以每次输出元素时，排序顺序可能都不同。</p>\n</li>\n</ul>\n<h2 id=\"Python创建set集合\"><a href=\"#Python创建set集合\" class=\"headerlink\" title=\"Python创建set集合\"></a>Python创建set集合</h2><p>有两种创建<code>set</code>集合的方法，分别是使用{}创建和使用set()函数将列表、元组等数据类型转化为集合。</p>\n<h3 id=\"使用-创建\"><a href=\"#使用-创建\" class=\"headerlink\" title=\"使用{}创建\"></a>使用{}创建</h3><p>语法格式:</p>\n<p><code>setname = {element1,element2...elementn}</code></p>\n<p>setname代表集合的名称。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_set = &#123;1,2,3,4&#125;</span><br><span class=\"line\">print(test_set)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用set-函数创建集合\"><a href=\"#使用set-函数创建集合\" class=\"headerlink\" title=\"使用set()函数创建集合\"></a>使用set()函数创建集合</h3><p>set()函数为Python的内置函数，其可以将字符串、列表、元组以及range对象等可迭代的对象转换成集合。</p>\n<p>语法格式:</p>\n<p><code>setname = set(iteration)</code> </p>\n<p>iteration就表示可迭代的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = set(&quot;I Love China&quot;)</span><br><span class=\"line\">set2 = set(list(range(1,6)))</span><br><span class=\"line\">set3 = set(tuple(range(1,6)))</span><br><span class=\"line\">set4 = set(range(1,6))</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">print(set2)</span><br><span class=\"line\">print(set3)</span><br><span class=\"line\">print(set4)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从输出结果看，字符串被打乱了</span><br><span class=\"line\">&#123;&apos;a&apos;, &apos;L&apos;, &apos;h&apos;, &apos; &apos;, &apos;C&apos;, &apos;e&apos;, &apos;n&apos;, &apos;i&apos;, &apos;I&apos;, &apos;v&apos;, &apos;o&apos;&#125;</span><br><span class=\"line\">&#123;1, 2, 3, 4, 5&#125;</span><br><span class=\"line\">&#123;1, 2, 3, 4, 5&#125;</span><br><span class=\"line\">&#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意:如果想要创建空集合，必须使用<code>set()</code>函数实现，因为如果只给一对<code>{}</code>，Python解释器会将其视为一个空字典。</strong></p>\n<h2 id=\"Python访问set集合元素\"><a href=\"#Python访问set集合元素\" class=\"headerlink\" title=\"Python访问set集合元素\"></a>Python访问set集合元素</h2><p>由于<code>set</code>集合是无序的，所以无法通过下标索引进行访问，但是我们可通过遍历<code>set</code>集合访问元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = set(&quot;I Love China&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">for ele in set1:</span><br><span class=\"line\">    print(ele,end=&apos;&apos;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oCenaL Ihvi</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python删除set集合\"><a href=\"#Python删除set集合\" class=\"headerlink\" title=\"Python删除set集合\"></a>Python删除set集合</h2><p>想要手动删除<code>set</code>集合可以使用<code>del()</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = set(&quot;I Love China&quot;)</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">del(set1)</span><br><span class=\"line\">print(set1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;a&apos;, &apos;i&apos;, &apos;e&apos;, &apos; &apos;, &apos;L&apos;, &apos;C&apos;, &apos;o&apos;, &apos;h&apos;, &apos;I&apos;, &apos;n&apos;, &apos;v&apos;&#125;</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 4, in &lt;module&gt;</span><br><span class=\"line\">  │ print(set1)</span><br><span class=\"line\">NameError: name &apos;set1&apos; is not defined</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-set集合基本操作-添加、删除、交集、并集、差集\"><a href=\"#Python-set集合基本操作-添加、删除、交集、并集、差集\" class=\"headerlink\" title=\"Python set集合基本操作(添加、删除、交集、并集、差集)\"></a>Python set集合基本操作(添加、删除、交集、并集、差集)</h1><p><code>set</code>集合最常用的场景是添加、删除元素以及在多个集合之间做交集、并集、差集等运算。 </p>\n<h2 id=\"向set集合中添加元素\"><a href=\"#向set集合中添加元素\" class=\"headerlink\" title=\"向set集合中添加元素\"></a>向set集合中添加元素</h2><p>Python为<code>set</code>集合提供了<code>add()</code>方法，其可以向<code>set</code>集合添加元素。</p>\n<p>语法格式:</p>\n<p><code>setname.add(element)</code> </p>\n<p>setname表示要添加元素的集合，element代表添加的元素。</p>\n<p><strong>注意:element不可为可变数据类型</strong> </p>\n<h2 id=\"从set集合中删除元素\"><a href=\"#从set集合中删除元素\" class=\"headerlink\" title=\"从set集合中删除元素\"></a>从set集合中删除元素</h2><p>想要从集合中删除某个元素可以使用<code>remove()</code>方法</p>\n<p>语法格式:</p>\n<p><code>setname.remove(element)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;1,2,3,4&#125;</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.remove(1)</span><br><span class=\"line\">print(set1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br><span class=\"line\">&#123;2, 3, 4&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意:如果要删除的元素已经被删除，再次删除则会引发<code>KeyError</code>错误</strong></p>\n<p>如果想要在删除失败时不抛出异常，我们可以使用<code>discard()</code>方法。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;1,2,3,4&#125;</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.remove(1)</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.discard(1)</span><br><span class=\"line\">print(set1)</span><br><span class=\"line\">set1.remove(1)</span><br><span class=\"line\">print(set1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br><span class=\"line\">&#123;2, 3, 4&#125;</span><br><span class=\"line\">&#123;2, 3, 4&#125;</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">  │ set1.remove(1)</span><br><span class=\"line\">KeyError: 1</span><br></pre></td></tr></table></figure>\n<p><code>discard()</code>方法与<code>remove()</code>方法的唯一区别在于:<strong>删除失败时是否抛出异常</strong> o</p>\n<h2 id=\"Python-set集合做交集、并集、差集运算\"><a href=\"#Python-set集合做交集、并集、差集运算\" class=\"headerlink\" title=\"Python set集合做交集、并集、差集运算\"></a>Python set集合做交集、并集、差集运算</h2><p><code>set</code>集合最常用的操作也就是进行交集、并集、差集以及对称差集运算了，首先看这张图:</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合示意图.png\" alt=\"集合示意图\"> </p>\n<p>图中有两个集合，分别是:</p>\n<ul>\n<li><p><code>set1={1,2,3}</code></p>\n</li>\n<li><p><code>set2={3,4,5}</code></p>\n</li>\n</ul>\n<p>下面的表格展示了不同的运算，得到的不同的结果。</p>\n<p><img src=\"/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合运算.png\" alt=\"集合运算图\"> </p>\n<h1 id=\"Python-set集合方法详解-全\"><a href=\"#Python-set集合方法详解-全\" class=\"headerlink\" title=\"Python set集合方法详解(全)\"></a>Python set集合方法详解(全)</h1><p>如果想要看<code>set</code>集合所有的方法，可以使用<code>dir(set)</code>进行查看。</p>\n<p>Python set方法</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>语法格式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add()</td>\n<td>set1.add()</td>\n<td>向set1集合中添加非可变元素</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td>set1.clear()</td>\n<td>清空set1集合中所有的元素</td>\n</tr>\n<tr>\n<td>copy()</td>\n<td>set2=set1.copy()</td>\n<td>拷贝set1集合中的元素给set2</td>\n</tr>\n<tr>\n<td>difference()</td>\n<td>set3=set1.difference(set2)</td>\n<td>将set1中有而set2中没有的元素给set3</td>\n</tr>\n<tr>\n<td>difference_update()</td>\n<td>set1.difference_update(set2)</td>\n<td>从set1中删除与set2相同的元素</td>\n</tr>\n<tr>\n<td>discard()</td>\n<td>set1.discard(element)</td>\n<td>删除set1中的element元素</td>\n</tr>\n<tr>\n<td>intersection()</td>\n<td>set3=set1.intersection(set2)</td>\n<td>取set1和set2的交集赋值给set3</td>\n</tr>\n<tr>\n<td>intersection_update()</td>\n<td>set1.intersection_update(set2)</td>\n<td>取set1和set2的交集并且将值赋值给set1(更新set1的值为set1与set2的交集)</td>\n</tr>\n<tr>\n<td>isdisjoint()</td>\n<td>set1.isdisjoint(set2)</td>\n<td>判断set1和set2是否没有交集，有交集返回False;没有则返回True</td>\n</tr>\n<tr>\n<td>issubset()</td>\n<td>set1.issubset(set2)</td>\n<td>判断set1是否是set2的子集</td>\n</tr>\n<tr>\n<td>issuperset()</td>\n<td>set1.issuperset(set2)</td>\n<td>判断set2是否是set1的子集</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>a = set1.pop()</td>\n<td>取出set1中一个元素并赋值给a</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>set1.remove(element)</td>\n<td>移除set1中的element元素</td>\n</tr>\n<tr>\n<td>symmetric_difference()</td>\n<td>set3=set1.symmetric_difference(set2)</td>\n<td>取set1和set2中互不相同的元素给set3</td>\n</tr>\n<tr>\n<td>symmetric_difference_update()</td>\n<td>set1.symmetric_difference_update(set2)</td>\n<td>取set1和set2中互不相同的元素并更新set1的值</td>\n</tr>\n<tr>\n<td>union()</td>\n<td>set3=set1.union(set2)</td>\n<td>取set1和set2的并集，赋值给set3</td>\n</tr>\n<tr>\n<td>update()</td>\n<td>set1.update(element)</td>\n<td>添加列表或集合中的元素到set1</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Python-frozenset-set集合的不可变版本\"><a href=\"#Python-frozenset-set集合的不可变版本\" class=\"headerlink\" title=\"Python frozenset(set集合的不可变版本)\"></a>Python frozenset(set集合的不可变版本)</h1><p>前面我们所学习的<code>set</code>集合是可变的，而frozenset则是<code>set</code>集合的不可变版本，它不具备<code>set</code>集合的所有能改变集合本身的方法。</p>\n<p>frozenset的主要使用场景:</p>\n<ul>\n<li><p>当集合元素不需要改变的时候，使用frozenset替代set将会更加安全。</p>\n</li>\n<li><p>当某些API需要不可变对象作为参数时，必须用到frozenset替代set。</p>\n</li>\n</ul>\n<h1 id=\"深入底层了解Python字典和集合、一眼看穿他们的本质\"><a href=\"#深入底层了解Python字典和集合、一眼看穿他们的本质\" class=\"headerlink\" title=\"深入底层了解Python字典和集合、一眼看穿他们的本质\"></a>深入底层了解Python字典和集合、一眼看穿他们的本质</h1><p>本小节涉及到未知的知识，推荐去原文看**<a href=\"http://c.biancheng.net/view/5302.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python深拷贝和浅拷贝详解\"><a href=\"#Python深拷贝和浅拷贝详解\" class=\"headerlink\" title=\"Python深拷贝和浅拷贝详解\"></a>Python深拷贝和浅拷贝详解</h1><p>本小节涉及到未知的知识，推荐去原文看<a href=\"http://c.biancheng.net/view/5358.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>"},{"title":"[Python-07]Python函数和Lambda表达式","copyright":true,"date":"2019-10-09T07:34:55.000Z","_content":"\nPython系列第七章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/str_method/)\n\n<!--more-->\n\n本章记录定义函数、调用函数以及大量有关Python的高级内容。\n\n还会记录Lambda表达式，学习完Lambda表达式后可以让源代码更加简洁。\n\n# Python函数（函数定义、函数调用）用法详解\n\n我们之前以及用到过很多的函数，例如:`print() range() len()` 等等，不过这些都是Python的内置函数，Python还允许我们自定义函数，也就是将一段代码定义成函数，从而达到`一次编写、多次调用的目的` 。\n\n## Python函数的定义\n\n想要定义函数需要使用def关键字实现，语法格式如下:\n\n```\ndef function_name([params]):\n    code_space\n    [return [value]]\n```\n\n其中由`[]` 括起来的为可选部分。\n\n语法格式解释:\n\n- function_name: 函数名，需要符合合法的标识符。\n\n- params: 形式参数列表，也就是定义该函数可以接受的参数。可以有多个，多个之间使用英文逗号(`,` )隔开。\n\n- code_space: 代码块，也就是调用函数时需要执行的代码，记得缩进。\n\n**注意: 在创建函数时，即使函数不需要参数，也必须保留括号。** \n\n例子:\n\n```\n# 求最大值\ndef my_max(x,y):\n    return  x if x > y else y\n```\n\n## Python函数的调用\n\n调用函数也就是执行定义过的函数。\n\n函数调用语法格式:\n\n`function_name([params])`\n\n**注意:函数定义时有多少个参数，我们调用时就必须传入相同数量的参数个数。并且如果调用的函数原型没有参数，调用时也不能省略括号。** \n\n例子:\n\n```\nprint(my_max(10,20))\n```\n\n运行过程:\n\n```\n20\n\n[Process exited 0]\n```\n\n## 为函数提供说明文档\n\n前目提到过可以使用`help()` 命令查看指定函数的帮助文档。\n\n想要为函数添加说明文档可以在函数声明后，代码块之前插入字符串以作为函数的说明文档。\n\n例子:\n\n```\ndef say_helloworld():\n    \"输出HelloWorld\"\n    print(\"HelloWorld\")\n\nprint(help(say_helloworld))\nprint(say_helloworld.__doc__)\n```\n\n运行过程:\n\n```\nHelp on function say_helloworld in module __main__:\n\nsay_helloworld()\n    输出HelloWorld\n(END)\n\nNone\n输出HelloWorld\n\n[Process exited 0]\n```\n\n# Python函数值传递和引用传递(包括形式参数和实际参数的区别)\n\n## 形参实参的区别\n\n形参又被称为形式参数，也就是指：在定义函数时，函数列表中的参数，叫做形参。\n\n实参又被称作实际参数，也就是指：在调用函数时，向函数列表中传递的参数，叫做实际参数。\n\n## 值传递与引用传递\n\n值传递使用场景: 不可变类型(字符串，数字，元组)\n引用传递: 可变类型（列表、字典）\n\n两者区别: **值传递的时候，实参传递给形参后，如果形参被修改，实参不收影响。引用传递时，则会改变。** \n\n例子:\n\n```\ndef change_param(x):\n    x+=[4] if isinstance(x,list) else 1\n    print(x)\na = 10\nchange_param(a)\nprint(a)\nb = [1,2,3]\nchange_param(b)\nprint(b)\n```\n\n运行过程:\n\n```\n11\n10\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n\n[Process exited 0]\n```\n\n# Python函数参数传递机制(超级详细)\n\n本笔记不讨论，想要了解[查看原文](http://c.biancheng.net/view/2258.html) \n\n# Python位置参数\n\n一句话解释:`调用函数时传入的实参的数量和位置必须和定义函数时的形参保持一致` \n\n# Python关键字参数\n\n如果不想要记住参数的位置，我们可以使用关键字参数特性，在调用函数时为实际参数指定一个参数名。\n\n例子:\n\n```\ndef test(x,y,z):\n    return x*y+z\nprint(test(10,20,10))\nprint(test(z=10,y=20,x=10))\n```\n\n运行结果:\n\n```\n210\n210\n\n[Process exited 0]\n```\n\n**注意:如果要在传递实参时混用关键字参数与位置参数，必须确保关键字参数置于位置参数之前。**\n\n# Python默认参数\n\n我们可以给形参指定默认参数，这样在调用时，可以省略传入实参。\n\n例子:\n\n```\ndef user_name(name=\"未命名\"):\n    print(\"你的姓名:\",name)\n\nuser_name()\nuser_name(\"EvanMeek\")\n```\n\n输出结果:\n\n```\n你的姓名: 未命名\n你的姓名: EvanMeek\n\n[Process exited 0]\n```\n\n# Python 函数可变参数\n\n如果在编写函数时，不确定需要使用多少个参数，我们就可以使用可变参数这个特性。\n\n可变参数有两种形式，分别是在形参之前添加个**一**`*` 与在形参之前添加个**两**`*` 。\n\n# 可变参数:形参前添加一个`*`\n\n例子:\n\n```\n# 忽略这个反斜杠，因为markdown的缘故\ndef test(x,\\*y):\n    print(type(x),\"\\n\",x)\n    print(type(y),\"\\n\",y)\ntest(10,\"你好\",\"世界\",9.09,0xa)\n```\n\n输出结果:\n\n```\n<class 'int'>\n 10\n<class 'tuple'>\n ('你好', '世界', 9.09, 10)\n\n[Process exited 0]\n```\n\n可以看到，实际上可变参数是将多个参数包含在一个元组内，然后将其输出。\n\n## 可变参数:形参前添加两个`*` \n\n前面的第一种可变参数形式，是往形参前添加一个\\*，并且我们知道它其实就是个元组，那么第二种形式提前透露一下，它其实就是个字典\n\n例子:\n\n```\ndef test(x,**y):\n    print(type(x),\"\\n\",x)\n    print(type(y),\"\\n\",y)\ntest(10,语文=100,数学=9.99,英语=8.88)\n```\n\n输出结果:\n\n```\n<class 'int'>\n 10\n<class 'dict'>\n {'语文': 100, '数学': 9.99, '英语': 8.88}\n\n[Process exited 0]\n```\n\n## 可变参数：形参前添加两个`*`  \n\n语法格式如下:\n\n`**kwargs` \n\n- \\*kw表示创建一个名为kwargs的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。\n\n例子:\n\n```\ndef test(x,**y):\n    print(type(x),\"\\n\",x)\n    print(type(y),\"\\n\",y)\ntest(10,语文=100,数学=9.99,英语=8.88)\n```\n\n运行结果:\n\n```\n<class 'int'>\n 10\n<class 'dict'>\n {'语文': 100, '数学': 9.99, '英语': 8.88}\n\n[Process exited 0]\n```\n\n# Python逆向参数收集详解\n\n逆向参数也就是说将程序中定义的列表、元组、字典等对象的元素拆开后传递给函数的参数。\n\n**逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号** \n\n例子:\n\n```\ndef get_sum(*x):\n    sum = 0\n    for ele in x:\n        sum += ele\n    return sum\n\nnum_list = range(1,101)\n\nprint(get_sum(*num_list))\n```\n\n运行结果:\n\n```\n5050\n\n[Process exited 0]\n\n```\n\n字典也支持逆向收集，字典会以关键字参数的形式传入。\n\n例子:\n\n```\ndef get_student(stu_id,stu_name,**x):\n    print(\"学号:\"+str(stu_id))\n    print(\"姓名:\"+str(stu_name))\n    print(\"其他:\"+str(x))\n\nstu_info = {\"stu_id\":0,\"stu_name\":\"张三\",\"stu_age\":18,\"stu_address\":\"广州市\"}\nget_student(**stu_info)\n```\n\n输出结果:\n\n```\n学号:0\n姓名:张三\n其他:{'stu_age': 18, 'stu_address': '广州市'}\n\n[Process exited 0]\n```\n\n# Python None(空值)及用法\n\nPython中有一个特殊的常量`None`，其表示为空值，它不等于空列表，也不等于空字符串。\n\n`None` 具有自己的数据类型，通过`type()` 可以查看它的类型。\n\n```\n<class 'NoneType'>\n\n[Process exited 0]\n\n```\n\n`None` 为`NoneType` 数据类型的唯一值，不能创建其他NoneType类型的变量，但是可以为任何变量赋值为`None` 。\n\n\n`None` 常用场景是:**assert断言，判断，以及函数无返回值。** \n\n# Python return函数返回值详解\n\n语法格式:\n\n`return [返回值]` \n\nreturn 语句是用于给函数的调用处返回一个值。\n\n**return 语句可以在同一函数中出现多次，但只要有一个得到执行，就会结束函数的执行。** \n\n例子:\n\n```\ndef sum(x,y):\n    return x+y\n\nprint(sum(10,20))\n```\n\n输出结果:\n\n```\n30\n\n[Process exited 0]\n```\n\n**return 的返回值可以为任意类型。** \n\n# Python函数返回多个值的方法\n\nPython允许函数同时返回多个值，它会将多个返回值封装成元组。\n\n例子:\n\n```\ndef multi_return():\n    return 10,20,30,40\n# 序列解包\na,b,c,d = multi_return()\n# 序列解包\ntest_list = multi_return()\nprint(a,b,c,d)\nprint(test_list)\nprint(multi_return())\n```\n\n输出结果:\n\n```\n10 20 30 40\n(10, 20, 30, 40)\n(10, 20, 30, 40)\n\n[Process exited 0]\n```\n\n# Python partial偏函数及用法\n\n[见原文](http://c.biancheng.net/view/5674.html) \n\n# Python函数递归\n\n当一个函数体内调用自身，就被称为`函数递归` 。\n\n我们可以使用函数递归来模式循环，但这种循环不需要使用循环控制。\n\n下面我们做一个数学题: `f(0)=1,f(1)=4,f(n+2)=2*f(n+1)+f(n)`，其中n是大于0的整数，求f(10)的值。我们将会使用循环和递归两种不同的方式来求当f(10)的值。\n\n递归例子:\n\n```\ndef fn(n):\n    if n==0:\n        return 1\n    elif n==1:\n        return 4\n    else :\n        return 2 * fn(n-1)+fn(n-2)\n\nprint(fn(10))\n```\n\n可以看到，我们在函数体内调用了自身，这样当我们执行到调用自身时，那么这就是递归，而对于来`fn(10)`说，也等于式子`2*fn(9)+fn(8)` ，而其中`fn(9)` 又等于`2*fn(8)+fn(7)` ，以此类推，最终当计算到`fn(2)` 等于`2*fn(1)+fn(0)` 时，那么就会开始返回，这个递归也就具有了结束的时候，最终得到fn(10)的值。\n\n**注意:递归类似于循环，必须在某个时刻函数的返回值是确定的，也就是不再调用自身，否则递归将会变成无穷递归，也就是死循环。** \n\n# Python变量作用于(全局变量和局部变量)\n\n变量有作用的范围，这个范围被称为`作用域`。\n**\n**作用域是值，代码能够访问该变量的区域，如果超出该区域将不可访问。**\n\n变量的范围分为两种`局部变量` 和`全局变量` 。\n\n## Python局部变量\n\n**局部变量是指在函数内部定义并使用的变量，它只在函数内部有效** 。\n\n例如:\n\n```\ndef text():\n    demo = \"HelloWorld\"\n    print(demo)\ntext()\n\n# 获取局部变量demo\nprint(demo)\n```\n\n输出结果:\n\n```\nHelloWorld\nTraceback (most recent call last):\n  File \"test.py\", line 7, in <module>\n    print(demo)\nNameError: name 'demo' is not defined\n\n[Process exited 1]\n```\n\n可以看到程序报错了，那是因为后面的print(demo)语句访问了在当前作用于不存在的变量，所以就会报错。\n\n局部变量:每个函数执行时，系统都会为该函数分配一块`临时内存空间` ，所有局部变量都被保存在这块空间内。而当函数执行完后，系统将会将这块内存空间释放，从而局部变量也就失效了，因此当我们再次访问以为存在的局部变量时，解释器就会抛出错误NameError，因为根本不存在。\n\n## Python全局变量\n\n全局变量与局部变量相反，全局变量是指**能够作用于函数内外的变量，也就是说全局变量可以在任何地方使用。** \n\n定义全局变量有两种方法:\n\n1. 在函数体外定义变量，一定是全局变量:\n\n```\ndemo = \"HelloWorld\"\n\ndef text():\n    print(demo)\ntext()\n\nprint(demo)\n```\n\n输出结果:\n\n```\nHelloWorld\nHelloWorld\n\n[Process exited 0]\n```\n\n2. 在函数体内定义全局变量。即使用`global` 关键字对变量进行修饰后，该变量就会变成为全局变量。\n\n```\ndef text():\n    global demo\n    demo = \"HelloWorld\"\n    print(demo)\ntext()\n\nprint(demo)\n```\n\n输出结果:\n\n```\nHelloWorld\nHelloWorld\n\n[Process exited 0]\n```\n\n**注意:在使用global修饰变量时不可以直接给变量赋值。** \n\n## 获取指定作用于范围中的变量\n\nPython提供了三个函数用于访问指定作用于中的变量。\n\n我们可以把变量与值理解为一个个字典，把key理解为变量名或变量的内存地址，把值理解为value。\n\n而下面这三个方法就可以访问某个作用于下的所有字典。\n\n- globals() 该函数返回全局范围内所有变量组成的变量字典。\n\n- locals() 该函数返回当前作用域范围下所有变量组成的变量字典。\n\n- vars(object) 获取object所在作用域范围下所有变量组成的变量字典，若不给参数，则与`locals()` 无区别。\n\n例子:\n\n```\ndef global_test():\n  global name\n  global name2\n  global name3\n  name = \"Evan\"\n  name2 = \"Chen\"\n  name3 = \"Li\"\n\nglobal_test()\n\nprint(\"全局作用于下所有变量字典:\",globals())\nprint(\"指定访问全局作用域下key为name2的变量字典:\",globals()['name2'])\n\n\ndef local_test():\n    age=age1=age2=age3= 20\n    print(\"age:\",age)\n    print(\"age作用域下所有变量字典:\",locals())\n    print(\"指定访问当前作用于下key为age的变量字典:\",locals()['age'])\nlocal_test()\n```\n\n\n","source":"_posts/Python-07-Python函数和Lambda表达式.md","raw":"---\ntitle: '[Python-07]Python函数和Lambda表达式'\ncopyright: true\ndate: 2019-10-09 15:34:55\ncategories: Python\ntags:\n  - Python系列\n---\n\nPython系列第七章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/str_method/)\n\n<!--more-->\n\n本章记录定义函数、调用函数以及大量有关Python的高级内容。\n\n还会记录Lambda表达式，学习完Lambda表达式后可以让源代码更加简洁。\n\n# Python函数（函数定义、函数调用）用法详解\n\n我们之前以及用到过很多的函数，例如:`print() range() len()` 等等，不过这些都是Python的内置函数，Python还允许我们自定义函数，也就是将一段代码定义成函数，从而达到`一次编写、多次调用的目的` 。\n\n## Python函数的定义\n\n想要定义函数需要使用def关键字实现，语法格式如下:\n\n```\ndef function_name([params]):\n    code_space\n    [return [value]]\n```\n\n其中由`[]` 括起来的为可选部分。\n\n语法格式解释:\n\n- function_name: 函数名，需要符合合法的标识符。\n\n- params: 形式参数列表，也就是定义该函数可以接受的参数。可以有多个，多个之间使用英文逗号(`,` )隔开。\n\n- code_space: 代码块，也就是调用函数时需要执行的代码，记得缩进。\n\n**注意: 在创建函数时，即使函数不需要参数，也必须保留括号。** \n\n例子:\n\n```\n# 求最大值\ndef my_max(x,y):\n    return  x if x > y else y\n```\n\n## Python函数的调用\n\n调用函数也就是执行定义过的函数。\n\n函数调用语法格式:\n\n`function_name([params])`\n\n**注意:函数定义时有多少个参数，我们调用时就必须传入相同数量的参数个数。并且如果调用的函数原型没有参数，调用时也不能省略括号。** \n\n例子:\n\n```\nprint(my_max(10,20))\n```\n\n运行过程:\n\n```\n20\n\n[Process exited 0]\n```\n\n## 为函数提供说明文档\n\n前目提到过可以使用`help()` 命令查看指定函数的帮助文档。\n\n想要为函数添加说明文档可以在函数声明后，代码块之前插入字符串以作为函数的说明文档。\n\n例子:\n\n```\ndef say_helloworld():\n    \"输出HelloWorld\"\n    print(\"HelloWorld\")\n\nprint(help(say_helloworld))\nprint(say_helloworld.__doc__)\n```\n\n运行过程:\n\n```\nHelp on function say_helloworld in module __main__:\n\nsay_helloworld()\n    输出HelloWorld\n(END)\n\nNone\n输出HelloWorld\n\n[Process exited 0]\n```\n\n# Python函数值传递和引用传递(包括形式参数和实际参数的区别)\n\n## 形参实参的区别\n\n形参又被称为形式参数，也就是指：在定义函数时，函数列表中的参数，叫做形参。\n\n实参又被称作实际参数，也就是指：在调用函数时，向函数列表中传递的参数，叫做实际参数。\n\n## 值传递与引用传递\n\n值传递使用场景: 不可变类型(字符串，数字，元组)\n引用传递: 可变类型（列表、字典）\n\n两者区别: **值传递的时候，实参传递给形参后，如果形参被修改，实参不收影响。引用传递时，则会改变。** \n\n例子:\n\n```\ndef change_param(x):\n    x+=[4] if isinstance(x,list) else 1\n    print(x)\na = 10\nchange_param(a)\nprint(a)\nb = [1,2,3]\nchange_param(b)\nprint(b)\n```\n\n运行过程:\n\n```\n11\n10\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n\n[Process exited 0]\n```\n\n# Python函数参数传递机制(超级详细)\n\n本笔记不讨论，想要了解[查看原文](http://c.biancheng.net/view/2258.html) \n\n# Python位置参数\n\n一句话解释:`调用函数时传入的实参的数量和位置必须和定义函数时的形参保持一致` \n\n# Python关键字参数\n\n如果不想要记住参数的位置，我们可以使用关键字参数特性，在调用函数时为实际参数指定一个参数名。\n\n例子:\n\n```\ndef test(x,y,z):\n    return x*y+z\nprint(test(10,20,10))\nprint(test(z=10,y=20,x=10))\n```\n\n运行结果:\n\n```\n210\n210\n\n[Process exited 0]\n```\n\n**注意:如果要在传递实参时混用关键字参数与位置参数，必须确保关键字参数置于位置参数之前。**\n\n# Python默认参数\n\n我们可以给形参指定默认参数，这样在调用时，可以省略传入实参。\n\n例子:\n\n```\ndef user_name(name=\"未命名\"):\n    print(\"你的姓名:\",name)\n\nuser_name()\nuser_name(\"EvanMeek\")\n```\n\n输出结果:\n\n```\n你的姓名: 未命名\n你的姓名: EvanMeek\n\n[Process exited 0]\n```\n\n# Python 函数可变参数\n\n如果在编写函数时，不确定需要使用多少个参数，我们就可以使用可变参数这个特性。\n\n可变参数有两种形式，分别是在形参之前添加个**一**`*` 与在形参之前添加个**两**`*` 。\n\n# 可变参数:形参前添加一个`*`\n\n例子:\n\n```\n# 忽略这个反斜杠，因为markdown的缘故\ndef test(x,\\*y):\n    print(type(x),\"\\n\",x)\n    print(type(y),\"\\n\",y)\ntest(10,\"你好\",\"世界\",9.09,0xa)\n```\n\n输出结果:\n\n```\n<class 'int'>\n 10\n<class 'tuple'>\n ('你好', '世界', 9.09, 10)\n\n[Process exited 0]\n```\n\n可以看到，实际上可变参数是将多个参数包含在一个元组内，然后将其输出。\n\n## 可变参数:形参前添加两个`*` \n\n前面的第一种可变参数形式，是往形参前添加一个\\*，并且我们知道它其实就是个元组，那么第二种形式提前透露一下，它其实就是个字典\n\n例子:\n\n```\ndef test(x,**y):\n    print(type(x),\"\\n\",x)\n    print(type(y),\"\\n\",y)\ntest(10,语文=100,数学=9.99,英语=8.88)\n```\n\n输出结果:\n\n```\n<class 'int'>\n 10\n<class 'dict'>\n {'语文': 100, '数学': 9.99, '英语': 8.88}\n\n[Process exited 0]\n```\n\n## 可变参数：形参前添加两个`*`  \n\n语法格式如下:\n\n`**kwargs` \n\n- \\*kw表示创建一个名为kwargs的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。\n\n例子:\n\n```\ndef test(x,**y):\n    print(type(x),\"\\n\",x)\n    print(type(y),\"\\n\",y)\ntest(10,语文=100,数学=9.99,英语=8.88)\n```\n\n运行结果:\n\n```\n<class 'int'>\n 10\n<class 'dict'>\n {'语文': 100, '数学': 9.99, '英语': 8.88}\n\n[Process exited 0]\n```\n\n# Python逆向参数收集详解\n\n逆向参数也就是说将程序中定义的列表、元组、字典等对象的元素拆开后传递给函数的参数。\n\n**逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号** \n\n例子:\n\n```\ndef get_sum(*x):\n    sum = 0\n    for ele in x:\n        sum += ele\n    return sum\n\nnum_list = range(1,101)\n\nprint(get_sum(*num_list))\n```\n\n运行结果:\n\n```\n5050\n\n[Process exited 0]\n\n```\n\n字典也支持逆向收集，字典会以关键字参数的形式传入。\n\n例子:\n\n```\ndef get_student(stu_id,stu_name,**x):\n    print(\"学号:\"+str(stu_id))\n    print(\"姓名:\"+str(stu_name))\n    print(\"其他:\"+str(x))\n\nstu_info = {\"stu_id\":0,\"stu_name\":\"张三\",\"stu_age\":18,\"stu_address\":\"广州市\"}\nget_student(**stu_info)\n```\n\n输出结果:\n\n```\n学号:0\n姓名:张三\n其他:{'stu_age': 18, 'stu_address': '广州市'}\n\n[Process exited 0]\n```\n\n# Python None(空值)及用法\n\nPython中有一个特殊的常量`None`，其表示为空值，它不等于空列表，也不等于空字符串。\n\n`None` 具有自己的数据类型，通过`type()` 可以查看它的类型。\n\n```\n<class 'NoneType'>\n\n[Process exited 0]\n\n```\n\n`None` 为`NoneType` 数据类型的唯一值，不能创建其他NoneType类型的变量，但是可以为任何变量赋值为`None` 。\n\n\n`None` 常用场景是:**assert断言，判断，以及函数无返回值。** \n\n# Python return函数返回值详解\n\n语法格式:\n\n`return [返回值]` \n\nreturn 语句是用于给函数的调用处返回一个值。\n\n**return 语句可以在同一函数中出现多次，但只要有一个得到执行，就会结束函数的执行。** \n\n例子:\n\n```\ndef sum(x,y):\n    return x+y\n\nprint(sum(10,20))\n```\n\n输出结果:\n\n```\n30\n\n[Process exited 0]\n```\n\n**return 的返回值可以为任意类型。** \n\n# Python函数返回多个值的方法\n\nPython允许函数同时返回多个值，它会将多个返回值封装成元组。\n\n例子:\n\n```\ndef multi_return():\n    return 10,20,30,40\n# 序列解包\na,b,c,d = multi_return()\n# 序列解包\ntest_list = multi_return()\nprint(a,b,c,d)\nprint(test_list)\nprint(multi_return())\n```\n\n输出结果:\n\n```\n10 20 30 40\n(10, 20, 30, 40)\n(10, 20, 30, 40)\n\n[Process exited 0]\n```\n\n# Python partial偏函数及用法\n\n[见原文](http://c.biancheng.net/view/5674.html) \n\n# Python函数递归\n\n当一个函数体内调用自身，就被称为`函数递归` 。\n\n我们可以使用函数递归来模式循环，但这种循环不需要使用循环控制。\n\n下面我们做一个数学题: `f(0)=1,f(1)=4,f(n+2)=2*f(n+1)+f(n)`，其中n是大于0的整数，求f(10)的值。我们将会使用循环和递归两种不同的方式来求当f(10)的值。\n\n递归例子:\n\n```\ndef fn(n):\n    if n==0:\n        return 1\n    elif n==1:\n        return 4\n    else :\n        return 2 * fn(n-1)+fn(n-2)\n\nprint(fn(10))\n```\n\n可以看到，我们在函数体内调用了自身，这样当我们执行到调用自身时，那么这就是递归，而对于来`fn(10)`说，也等于式子`2*fn(9)+fn(8)` ，而其中`fn(9)` 又等于`2*fn(8)+fn(7)` ，以此类推，最终当计算到`fn(2)` 等于`2*fn(1)+fn(0)` 时，那么就会开始返回，这个递归也就具有了结束的时候，最终得到fn(10)的值。\n\n**注意:递归类似于循环，必须在某个时刻函数的返回值是确定的，也就是不再调用自身，否则递归将会变成无穷递归，也就是死循环。** \n\n# Python变量作用于(全局变量和局部变量)\n\n变量有作用的范围，这个范围被称为`作用域`。\n**\n**作用域是值，代码能够访问该变量的区域，如果超出该区域将不可访问。**\n\n变量的范围分为两种`局部变量` 和`全局变量` 。\n\n## Python局部变量\n\n**局部变量是指在函数内部定义并使用的变量，它只在函数内部有效** 。\n\n例如:\n\n```\ndef text():\n    demo = \"HelloWorld\"\n    print(demo)\ntext()\n\n# 获取局部变量demo\nprint(demo)\n```\n\n输出结果:\n\n```\nHelloWorld\nTraceback (most recent call last):\n  File \"test.py\", line 7, in <module>\n    print(demo)\nNameError: name 'demo' is not defined\n\n[Process exited 1]\n```\n\n可以看到程序报错了，那是因为后面的print(demo)语句访问了在当前作用于不存在的变量，所以就会报错。\n\n局部变量:每个函数执行时，系统都会为该函数分配一块`临时内存空间` ，所有局部变量都被保存在这块空间内。而当函数执行完后，系统将会将这块内存空间释放，从而局部变量也就失效了，因此当我们再次访问以为存在的局部变量时，解释器就会抛出错误NameError，因为根本不存在。\n\n## Python全局变量\n\n全局变量与局部变量相反，全局变量是指**能够作用于函数内外的变量，也就是说全局变量可以在任何地方使用。** \n\n定义全局变量有两种方法:\n\n1. 在函数体外定义变量，一定是全局变量:\n\n```\ndemo = \"HelloWorld\"\n\ndef text():\n    print(demo)\ntext()\n\nprint(demo)\n```\n\n输出结果:\n\n```\nHelloWorld\nHelloWorld\n\n[Process exited 0]\n```\n\n2. 在函数体内定义全局变量。即使用`global` 关键字对变量进行修饰后，该变量就会变成为全局变量。\n\n```\ndef text():\n    global demo\n    demo = \"HelloWorld\"\n    print(demo)\ntext()\n\nprint(demo)\n```\n\n输出结果:\n\n```\nHelloWorld\nHelloWorld\n\n[Process exited 0]\n```\n\n**注意:在使用global修饰变量时不可以直接给变量赋值。** \n\n## 获取指定作用于范围中的变量\n\nPython提供了三个函数用于访问指定作用于中的变量。\n\n我们可以把变量与值理解为一个个字典，把key理解为变量名或变量的内存地址，把值理解为value。\n\n而下面这三个方法就可以访问某个作用于下的所有字典。\n\n- globals() 该函数返回全局范围内所有变量组成的变量字典。\n\n- locals() 该函数返回当前作用域范围下所有变量组成的变量字典。\n\n- vars(object) 获取object所在作用域范围下所有变量组成的变量字典，若不给参数，则与`locals()` 无区别。\n\n例子:\n\n```\ndef global_test():\n  global name\n  global name2\n  global name3\n  name = \"Evan\"\n  name2 = \"Chen\"\n  name3 = \"Li\"\n\nglobal_test()\n\nprint(\"全局作用于下所有变量字典:\",globals())\nprint(\"指定访问全局作用域下key为name2的变量字典:\",globals()['name2'])\n\n\ndef local_test():\n    age=age1=age2=age3= 20\n    print(\"age:\",age)\n    print(\"age作用域下所有变量字典:\",locals())\n    print(\"指定访问当前作用于下key为age的变量字典:\",locals()['age'])\nlocal_test()\n```\n\n\n","slug":"Python-07-Python函数和Lambda表达式","published":1,"updated":"2020-01-19T03:49:51.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocq0043omoohb34cisw","content":"<p>Python系列第七章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/str_method/\" target=\"_blank\" rel=\"noopener\">💿</a></p>\n<a id=\"more\"></a>\n<p>本章记录定义函数、调用函数以及大量有关Python的高级内容。</p>\n<p>还会记录Lambda表达式，学习完Lambda表达式后可以让源代码更加简洁。</p>\n<h1 id=\"Python函数（函数定义、函数调用）用法详解\"><a href=\"#Python函数（函数定义、函数调用）用法详解\" class=\"headerlink\" title=\"Python函数（函数定义、函数调用）用法详解\"></a>Python函数（函数定义、函数调用）用法详解</h1><p>我们之前以及用到过很多的函数，例如:<code>print() range() len()</code> 等等，不过这些都是Python的内置函数，Python还允许我们自定义函数，也就是将一段代码定义成函数，从而达到<code>一次编写、多次调用的目的</code> 。</p>\n<h2 id=\"Python函数的定义\"><a href=\"#Python函数的定义\" class=\"headerlink\" title=\"Python函数的定义\"></a>Python函数的定义</h2><p>想要定义函数需要使用def关键字实现，语法格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def function_name([params]):</span><br><span class=\"line\">    code_space</span><br><span class=\"line\">    [return [value]]</span><br></pre></td></tr></table></figure>\n<p>其中由<code>[]</code> 括起来的为可选部分。</p>\n<p>语法格式解释:</p>\n<ul>\n<li><p>function_name: 函数名，需要符合合法的标识符。</p>\n</li>\n<li><p>params: 形式参数列表，也就是定义该函数可以接受的参数。可以有多个，多个之间使用英文逗号(<code>,</code> )隔开。</p>\n</li>\n<li><p>code_space: 代码块，也就是调用函数时需要执行的代码，记得缩进。</p>\n</li>\n</ul>\n<p><strong>注意: 在创建函数时，即使函数不需要参数，也必须保留括号。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 求最大值</span><br><span class=\"line\">def my_max(x,y):</span><br><span class=\"line\">    return  x if x &gt; y else y</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python函数的调用\"><a href=\"#Python函数的调用\" class=\"headerlink\" title=\"Python函数的调用\"></a>Python函数的调用</h2><p>调用函数也就是执行定义过的函数。</p>\n<p>函数调用语法格式:</p>\n<p><code>function_name([params])</code></p>\n<p><strong>注意:函数定义时有多少个参数，我们调用时就必须传入相同数量的参数个数。并且如果调用的函数原型没有参数，调用时也不能省略括号。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(my_max(10,20))</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"为函数提供说明文档\"><a href=\"#为函数提供说明文档\" class=\"headerlink\" title=\"为函数提供说明文档\"></a>为函数提供说明文档</h2><p>前目提到过可以使用<code>help()</code> 命令查看指定函数的帮助文档。</p>\n<p>想要为函数添加说明文档可以在函数声明后，代码块之前插入字符串以作为函数的说明文档。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def say_helloworld():</span><br><span class=\"line\">    &quot;输出HelloWorld&quot;</span><br><span class=\"line\">    print(&quot;HelloWorld&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">print(help(say_helloworld))</span><br><span class=\"line\">print(say_helloworld.__doc__)</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Help on function say_helloworld in module __main__:</span><br><span class=\"line\"></span><br><span class=\"line\">say_helloworld()</span><br><span class=\"line\">    输出HelloWorld</span><br><span class=\"line\">(END)</span><br><span class=\"line\"></span><br><span class=\"line\">None</span><br><span class=\"line\">输出HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python函数值传递和引用传递-包括形式参数和实际参数的区别\"><a href=\"#Python函数值传递和引用传递-包括形式参数和实际参数的区别\" class=\"headerlink\" title=\"Python函数值传递和引用传递(包括形式参数和实际参数的区别)\"></a>Python函数值传递和引用传递(包括形式参数和实际参数的区别)</h1><h2 id=\"形参实参的区别\"><a href=\"#形参实参的区别\" class=\"headerlink\" title=\"形参实参的区别\"></a>形参实参的区别</h2><p>形参又被称为形式参数，也就是指：在定义函数时，函数列表中的参数，叫做形参。</p>\n<p>实参又被称作实际参数，也就是指：在调用函数时，向函数列表中传递的参数，叫做实际参数。</p>\n<h2 id=\"值传递与引用传递\"><a href=\"#值传递与引用传递\" class=\"headerlink\" title=\"值传递与引用传递\"></a>值传递与引用传递</h2><p>值传递使用场景: 不可变类型(字符串，数字，元组)<br>引用传递: 可变类型（列表、字典）</p>\n<p>两者区别: <strong>值传递的时候，实参传递给形参后，如果形参被修改，实参不收影响。引用传递时，则会改变。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def change_param(x):</span><br><span class=\"line\">    x+=[4] if isinstance(x,list) else 1</span><br><span class=\"line\">    print(x)</span><br><span class=\"line\">a = 10</span><br><span class=\"line\">change_param(a)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">b = [1,2,3]</span><br><span class=\"line\">change_param(b)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11</span><br><span class=\"line\">10</span><br><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python函数参数传递机制-超级详细\"><a href=\"#Python函数参数传递机制-超级详细\" class=\"headerlink\" title=\"Python函数参数传递机制(超级详细)\"></a>Python函数参数传递机制(超级详细)</h1><p>本笔记不讨论，想要了解<a href=\"http://c.biancheng.net/view/2258.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python位置参数\"><a href=\"#Python位置参数\" class=\"headerlink\" title=\"Python位置参数\"></a>Python位置参数</h1><p>一句话解释:<code>调用函数时传入的实参的数量和位置必须和定义函数时的形参保持一致</code> </p>\n<h1 id=\"Python关键字参数\"><a href=\"#Python关键字参数\" class=\"headerlink\" title=\"Python关键字参数\"></a>Python关键字参数</h1><p>如果不想要记住参数的位置，我们可以使用关键字参数特性，在调用函数时为实际参数指定一个参数名。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def test(x,y,z):</span><br><span class=\"line\">    return x*y+z</span><br><span class=\"line\">print(test(10,20,10))</span><br><span class=\"line\">print(test(z=10,y=20,x=10))</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">210</span><br><span class=\"line\">210</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><strong>注意:如果要在传递实参时混用关键字参数与位置参数，必须确保关键字参数置于位置参数之前。</strong></p>\n<h1 id=\"Python默认参数\"><a href=\"#Python默认参数\" class=\"headerlink\" title=\"Python默认参数\"></a>Python默认参数</h1><p>我们可以给形参指定默认参数，这样在调用时，可以省略传入实参。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def user_name(name=&quot;未命名&quot;):</span><br><span class=\"line\">    print(&quot;你的姓名:&quot;,name)</span><br><span class=\"line\"></span><br><span class=\"line\">user_name()</span><br><span class=\"line\">user_name(&quot;EvanMeek&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你的姓名: 未命名</span><br><span class=\"line\">你的姓名: EvanMeek</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-函数可变参数\"><a href=\"#Python-函数可变参数\" class=\"headerlink\" title=\"Python 函数可变参数\"></a>Python 函数可变参数</h1><p>如果在编写函数时，不确定需要使用多少个参数，我们就可以使用可变参数这个特性。</p>\n<p>可变参数有两种形式，分别是在形参之前添加个<strong>一</strong><code>*</code> 与在形参之前添加个<strong>两</strong><code>*</code> 。</p>\n<h1 id=\"可变参数-形参前添加一个\"><a href=\"#可变参数-形参前添加一个\" class=\"headerlink\" title=\"可变参数:形参前添加一个*\"></a>可变参数:形参前添加一个<code>*</code></h1><p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 忽略这个反斜杠，因为markdown的缘故</span><br><span class=\"line\">def test(x,\\*y):</span><br><span class=\"line\">    print(type(x),&quot;\\n&quot;,x)</span><br><span class=\"line\">    print(type(y),&quot;\\n&quot;,y)</span><br><span class=\"line\">test(10,&quot;你好&quot;,&quot;世界&quot;,9.09,0xa)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> 10</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br><span class=\"line\"> (&apos;你好&apos;, &apos;世界&apos;, 9.09, 10)</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，实际上可变参数是将多个参数包含在一个元组内，然后将其输出。</p>\n<h2 id=\"可变参数-形参前添加两个\"><a href=\"#可变参数-形参前添加两个\" class=\"headerlink\" title=\"可变参数:形参前添加两个*\"></a>可变参数:形参前添加两个<code>*</code></h2><p>前面的第一种可变参数形式，是往形参前添加一个*，并且我们知道它其实就是个元组，那么第二种形式提前透露一下，它其实就是个字典</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def test(x,**y):</span><br><span class=\"line\">    print(type(x),&quot;\\n&quot;,x)</span><br><span class=\"line\">    print(type(y),&quot;\\n&quot;,y)</span><br><span class=\"line\">test(10,语文=100,数学=9.99,英语=8.88)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> 10</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br><span class=\"line\"> &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"可变参数：形参前添加两个\"><a href=\"#可变参数：形参前添加两个\" class=\"headerlink\" title=\"可变参数：形参前添加两个*\"></a>可变参数：形参前添加两个<code>*</code></h2><p>语法格式如下:</p>\n<p><code>**kwargs</code> </p>\n<ul>\n<li>*kw表示创建一个名为kwargs的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def test(x,**y):</span><br><span class=\"line\">    print(type(x),&quot;\\n&quot;,x)</span><br><span class=\"line\">    print(type(y),&quot;\\n&quot;,y)</span><br><span class=\"line\">test(10,语文=100,数学=9.99,英语=8.88)</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> 10</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br><span class=\"line\"> &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python逆向参数收集详解\"><a href=\"#Python逆向参数收集详解\" class=\"headerlink\" title=\"Python逆向参数收集详解\"></a>Python逆向参数收集详解</h1><p>逆向参数也就是说将程序中定义的列表、元组、字典等对象的元素拆开后传递给函数的参数。</p>\n<p><strong>逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_sum(*x):</span><br><span class=\"line\">    sum = 0</span><br><span class=\"line\">    for ele in x:</span><br><span class=\"line\">        sum += ele</span><br><span class=\"line\">    return sum</span><br><span class=\"line\"></span><br><span class=\"line\">num_list = range(1,101)</span><br><span class=\"line\"></span><br><span class=\"line\">print(get_sum(*num_list))</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5050</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>字典也支持逆向收集，字典会以关键字参数的形式传入。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_student(stu_id,stu_name,**x):</span><br><span class=\"line\">    print(&quot;学号:&quot;+str(stu_id))</span><br><span class=\"line\">    print(&quot;姓名:&quot;+str(stu_name))</span><br><span class=\"line\">    print(&quot;其他:&quot;+str(x))</span><br><span class=\"line\"></span><br><span class=\"line\">stu_info = &#123;&quot;stu_id&quot;:0,&quot;stu_name&quot;:&quot;张三&quot;,&quot;stu_age&quot;:18,&quot;stu_address&quot;:&quot;广州市&quot;&#125;</span><br><span class=\"line\">get_student(**stu_info)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学号:0</span><br><span class=\"line\">姓名:张三</span><br><span class=\"line\">其他:&#123;&apos;stu_age&apos;: 18, &apos;stu_address&apos;: &apos;广州市&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-None-空值-及用法\"><a href=\"#Python-None-空值-及用法\" class=\"headerlink\" title=\"Python None(空值)及用法\"></a>Python None(空值)及用法</h1><p>Python中有一个特殊的常量<code>None</code>，其表示为空值，它不等于空列表，也不等于空字符串。</p>\n<p><code>None</code> 具有自己的数据类型，通过<code>type()</code> 可以查看它的类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;NoneType&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><code>None</code> 为<code>NoneType</code> 数据类型的唯一值，不能创建其他NoneType类型的变量，但是可以为任何变量赋值为<code>None</code> 。</p>\n<p><code>None</code> 常用场景是:<strong>assert断言，判断，以及函数无返回值。</strong> </p>\n<h1 id=\"Python-return函数返回值详解\"><a href=\"#Python-return函数返回值详解\" class=\"headerlink\" title=\"Python return函数返回值详解\"></a>Python return函数返回值详解</h1><p>语法格式:</p>\n<p><code>return [返回值]</code> </p>\n<p>return 语句是用于给函数的调用处返回一个值。</p>\n<p><strong>return 语句可以在同一函数中出现多次，但只要有一个得到执行，就会结束函数的执行。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def sum(x,y):</span><br><span class=\"line\">    return x+y</span><br><span class=\"line\"></span><br><span class=\"line\">print(sum(10,20))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><strong>return 的返回值可以为任意类型。</strong> </p>\n<h1 id=\"Python函数返回多个值的方法\"><a href=\"#Python函数返回多个值的方法\" class=\"headerlink\" title=\"Python函数返回多个值的方法\"></a>Python函数返回多个值的方法</h1><p>Python允许函数同时返回多个值，它会将多个返回值封装成元组。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def multi_return():</span><br><span class=\"line\">    return 10,20,30,40</span><br><span class=\"line\"># 序列解包</span><br><span class=\"line\">a,b,c,d = multi_return()</span><br><span class=\"line\"># 序列解包</span><br><span class=\"line\">test_list = multi_return()</span><br><span class=\"line\">print(a,b,c,d)</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">print(multi_return())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 20 30 40</span><br><span class=\"line\">(10, 20, 30, 40)</span><br><span class=\"line\">(10, 20, 30, 40)</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-partial偏函数及用法\"><a href=\"#Python-partial偏函数及用法\" class=\"headerlink\" title=\"Python partial偏函数及用法\"></a>Python partial偏函数及用法</h1><p><a href=\"http://c.biancheng.net/view/5674.html\" target=\"_blank\" rel=\"noopener\">见原文</a> </p>\n<h1 id=\"Python函数递归\"><a href=\"#Python函数递归\" class=\"headerlink\" title=\"Python函数递归\"></a>Python函数递归</h1><p>当一个函数体内调用自身，就被称为<code>函数递归</code> 。</p>\n<p>我们可以使用函数递归来模式循环，但这种循环不需要使用循环控制。</p>\n<p>下面我们做一个数学题: <code>f(0)=1,f(1)=4,f(n+2)=2*f(n+1)+f(n)</code>，其中n是大于0的整数，求f(10)的值。我们将会使用循环和递归两种不同的方式来求当f(10)的值。</p>\n<p>递归例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fn(n):</span><br><span class=\"line\">    if n==0:</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    elif n==1:</span><br><span class=\"line\">        return 4</span><br><span class=\"line\">    else :</span><br><span class=\"line\">        return 2 * fn(n-1)+fn(n-2)</span><br><span class=\"line\"></span><br><span class=\"line\">print(fn(10))</span><br></pre></td></tr></table></figure>\n<p>可以看到，我们在函数体内调用了自身，这样当我们执行到调用自身时，那么这就是递归，而对于来<code>fn(10)</code>说，也等于式子<code>2*fn(9)+fn(8)</code> ，而其中<code>fn(9)</code> 又等于<code>2*fn(8)+fn(7)</code> ，以此类推，最终当计算到<code>fn(2)</code> 等于<code>2*fn(1)+fn(0)</code> 时，那么就会开始返回，这个递归也就具有了结束的时候，最终得到fn(10)的值。</p>\n<p><strong>注意:递归类似于循环，必须在某个时刻函数的返回值是确定的，也就是不再调用自身，否则递归将会变成无穷递归，也就是死循环。</strong> </p>\n<h1 id=\"Python变量作用于-全局变量和局部变量\"><a href=\"#Python变量作用于-全局变量和局部变量\" class=\"headerlink\" title=\"Python变量作用于(全局变量和局部变量)\"></a>Python变量作用于(全局变量和局部变量)</h1><p>变量有作用的范围，这个范围被称为<code>作用域</code>。<br><strong>\n</strong>作用域是值，代码能够访问该变量的区域，如果超出该区域将不可访问。**</p>\n<p>变量的范围分为两种<code>局部变量</code> 和<code>全局变量</code> 。</p>\n<h2 id=\"Python局部变量\"><a href=\"#Python局部变量\" class=\"headerlink\" title=\"Python局部变量\"></a>Python局部变量</h2><p><strong>局部变量是指在函数内部定义并使用的变量，它只在函数内部有效</strong> 。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def text():</span><br><span class=\"line\">    demo = &quot;HelloWorld&quot;</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">text()</span><br><span class=\"line\"></span><br><span class=\"line\"># 获取局部变量demo</span><br><span class=\"line\">print(demo)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">NameError: name &apos;demo&apos; is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>可以看到程序报错了，那是因为后面的print(demo)语句访问了在当前作用于不存在的变量，所以就会报错。</p>\n<p>局部变量:每个函数执行时，系统都会为该函数分配一块<code>临时内存空间</code> ，所有局部变量都被保存在这块空间内。而当函数执行完后，系统将会将这块内存空间释放，从而局部变量也就失效了，因此当我们再次访问以为存在的局部变量时，解释器就会抛出错误NameError，因为根本不存在。</p>\n<h2 id=\"Python全局变量\"><a href=\"#Python全局变量\" class=\"headerlink\" title=\"Python全局变量\"></a>Python全局变量</h2><p>全局变量与局部变量相反，全局变量是指<strong>能够作用于函数内外的变量，也就是说全局变量可以在任何地方使用。</strong> </p>\n<p>定义全局变量有两种方法:</p>\n<ol>\n<li>在函数体外定义变量，一定是全局变量:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo = &quot;HelloWorld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">def text():</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">text()</span><br><span class=\"line\"></span><br><span class=\"line\">print(demo)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld</span><br><span class=\"line\">HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在函数体内定义全局变量。即使用<code>global</code> 关键字对变量进行修饰后，该变量就会变成为全局变量。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def text():</span><br><span class=\"line\">    global demo</span><br><span class=\"line\">    demo = &quot;HelloWorld&quot;</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">text()</span><br><span class=\"line\"></span><br><span class=\"line\">print(demo)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld</span><br><span class=\"line\">HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><strong>注意:在使用global修饰变量时不可以直接给变量赋值。</strong> </p>\n<h2 id=\"获取指定作用于范围中的变量\"><a href=\"#获取指定作用于范围中的变量\" class=\"headerlink\" title=\"获取指定作用于范围中的变量\"></a>获取指定作用于范围中的变量</h2><p>Python提供了三个函数用于访问指定作用于中的变量。</p>\n<p>我们可以把变量与值理解为一个个字典，把key理解为变量名或变量的内存地址，把值理解为value。</p>\n<p>而下面这三个方法就可以访问某个作用于下的所有字典。</p>\n<ul>\n<li><p>globals() 该函数返回全局范围内所有变量组成的变量字典。</p>\n</li>\n<li><p>locals() 该函数返回当前作用域范围下所有变量组成的变量字典。</p>\n</li>\n<li><p>vars(object) 获取object所在作用域范围下所有变量组成的变量字典，若不给参数，则与<code>locals()</code> 无区别。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def global_test():</span><br><span class=\"line\">  global name</span><br><span class=\"line\">  global name2</span><br><span class=\"line\">  global name3</span><br><span class=\"line\">  name = &quot;Evan&quot;</span><br><span class=\"line\">  name2 = &quot;Chen&quot;</span><br><span class=\"line\">  name3 = &quot;Li&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">global_test()</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;全局作用于下所有变量字典:&quot;,globals())</span><br><span class=\"line\">print(&quot;指定访问全局作用域下key为name2的变量字典:&quot;,globals()[&apos;name2&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def local_test():</span><br><span class=\"line\">    age=age1=age2=age3= 20</span><br><span class=\"line\">    print(&quot;age:&quot;,age)</span><br><span class=\"line\">    print(&quot;age作用域下所有变量字典:&quot;,locals())</span><br><span class=\"line\">    print(&quot;指定访问当前作用于下key为age的变量字典:&quot;,locals()[&apos;age&apos;])</span><br><span class=\"line\">local_test()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Python系列第七章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/str_method/\" target=\"_blank\" rel=\"noopener\">💿</a></p>","more":"<p>本章记录定义函数、调用函数以及大量有关Python的高级内容。</p>\n<p>还会记录Lambda表达式，学习完Lambda表达式后可以让源代码更加简洁。</p>\n<h1 id=\"Python函数（函数定义、函数调用）用法详解\"><a href=\"#Python函数（函数定义、函数调用）用法详解\" class=\"headerlink\" title=\"Python函数（函数定义、函数调用）用法详解\"></a>Python函数（函数定义、函数调用）用法详解</h1><p>我们之前以及用到过很多的函数，例如:<code>print() range() len()</code> 等等，不过这些都是Python的内置函数，Python还允许我们自定义函数，也就是将一段代码定义成函数，从而达到<code>一次编写、多次调用的目的</code> 。</p>\n<h2 id=\"Python函数的定义\"><a href=\"#Python函数的定义\" class=\"headerlink\" title=\"Python函数的定义\"></a>Python函数的定义</h2><p>想要定义函数需要使用def关键字实现，语法格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def function_name([params]):</span><br><span class=\"line\">    code_space</span><br><span class=\"line\">    [return [value]]</span><br></pre></td></tr></table></figure>\n<p>其中由<code>[]</code> 括起来的为可选部分。</p>\n<p>语法格式解释:</p>\n<ul>\n<li><p>function_name: 函数名，需要符合合法的标识符。</p>\n</li>\n<li><p>params: 形式参数列表，也就是定义该函数可以接受的参数。可以有多个，多个之间使用英文逗号(<code>,</code> )隔开。</p>\n</li>\n<li><p>code_space: 代码块，也就是调用函数时需要执行的代码，记得缩进。</p>\n</li>\n</ul>\n<p><strong>注意: 在创建函数时，即使函数不需要参数，也必须保留括号。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 求最大值</span><br><span class=\"line\">def my_max(x,y):</span><br><span class=\"line\">    return  x if x &gt; y else y</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python函数的调用\"><a href=\"#Python函数的调用\" class=\"headerlink\" title=\"Python函数的调用\"></a>Python函数的调用</h2><p>调用函数也就是执行定义过的函数。</p>\n<p>函数调用语法格式:</p>\n<p><code>function_name([params])</code></p>\n<p><strong>注意:函数定义时有多少个参数，我们调用时就必须传入相同数量的参数个数。并且如果调用的函数原型没有参数，调用时也不能省略括号。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(my_max(10,20))</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"为函数提供说明文档\"><a href=\"#为函数提供说明文档\" class=\"headerlink\" title=\"为函数提供说明文档\"></a>为函数提供说明文档</h2><p>前目提到过可以使用<code>help()</code> 命令查看指定函数的帮助文档。</p>\n<p>想要为函数添加说明文档可以在函数声明后，代码块之前插入字符串以作为函数的说明文档。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def say_helloworld():</span><br><span class=\"line\">    &quot;输出HelloWorld&quot;</span><br><span class=\"line\">    print(&quot;HelloWorld&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">print(help(say_helloworld))</span><br><span class=\"line\">print(say_helloworld.__doc__)</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Help on function say_helloworld in module __main__:</span><br><span class=\"line\"></span><br><span class=\"line\">say_helloworld()</span><br><span class=\"line\">    输出HelloWorld</span><br><span class=\"line\">(END)</span><br><span class=\"line\"></span><br><span class=\"line\">None</span><br><span class=\"line\">输出HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python函数值传递和引用传递-包括形式参数和实际参数的区别\"><a href=\"#Python函数值传递和引用传递-包括形式参数和实际参数的区别\" class=\"headerlink\" title=\"Python函数值传递和引用传递(包括形式参数和实际参数的区别)\"></a>Python函数值传递和引用传递(包括形式参数和实际参数的区别)</h1><h2 id=\"形参实参的区别\"><a href=\"#形参实参的区别\" class=\"headerlink\" title=\"形参实参的区别\"></a>形参实参的区别</h2><p>形参又被称为形式参数，也就是指：在定义函数时，函数列表中的参数，叫做形参。</p>\n<p>实参又被称作实际参数，也就是指：在调用函数时，向函数列表中传递的参数，叫做实际参数。</p>\n<h2 id=\"值传递与引用传递\"><a href=\"#值传递与引用传递\" class=\"headerlink\" title=\"值传递与引用传递\"></a>值传递与引用传递</h2><p>值传递使用场景: 不可变类型(字符串，数字，元组)<br>引用传递: 可变类型（列表、字典）</p>\n<p>两者区别: <strong>值传递的时候，实参传递给形参后，如果形参被修改，实参不收影响。引用传递时，则会改变。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def change_param(x):</span><br><span class=\"line\">    x+=[4] if isinstance(x,list) else 1</span><br><span class=\"line\">    print(x)</span><br><span class=\"line\">a = 10</span><br><span class=\"line\">change_param(a)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">b = [1,2,3]</span><br><span class=\"line\">change_param(b)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11</span><br><span class=\"line\">10</span><br><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python函数参数传递机制-超级详细\"><a href=\"#Python函数参数传递机制-超级详细\" class=\"headerlink\" title=\"Python函数参数传递机制(超级详细)\"></a>Python函数参数传递机制(超级详细)</h1><p>本笔记不讨论，想要了解<a href=\"http://c.biancheng.net/view/2258.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python位置参数\"><a href=\"#Python位置参数\" class=\"headerlink\" title=\"Python位置参数\"></a>Python位置参数</h1><p>一句话解释:<code>调用函数时传入的实参的数量和位置必须和定义函数时的形参保持一致</code> </p>\n<h1 id=\"Python关键字参数\"><a href=\"#Python关键字参数\" class=\"headerlink\" title=\"Python关键字参数\"></a>Python关键字参数</h1><p>如果不想要记住参数的位置，我们可以使用关键字参数特性，在调用函数时为实际参数指定一个参数名。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def test(x,y,z):</span><br><span class=\"line\">    return x*y+z</span><br><span class=\"line\">print(test(10,20,10))</span><br><span class=\"line\">print(test(z=10,y=20,x=10))</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">210</span><br><span class=\"line\">210</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><strong>注意:如果要在传递实参时混用关键字参数与位置参数，必须确保关键字参数置于位置参数之前。</strong></p>\n<h1 id=\"Python默认参数\"><a href=\"#Python默认参数\" class=\"headerlink\" title=\"Python默认参数\"></a>Python默认参数</h1><p>我们可以给形参指定默认参数，这样在调用时，可以省略传入实参。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def user_name(name=&quot;未命名&quot;):</span><br><span class=\"line\">    print(&quot;你的姓名:&quot;,name)</span><br><span class=\"line\"></span><br><span class=\"line\">user_name()</span><br><span class=\"line\">user_name(&quot;EvanMeek&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你的姓名: 未命名</span><br><span class=\"line\">你的姓名: EvanMeek</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-函数可变参数\"><a href=\"#Python-函数可变参数\" class=\"headerlink\" title=\"Python 函数可变参数\"></a>Python 函数可变参数</h1><p>如果在编写函数时，不确定需要使用多少个参数，我们就可以使用可变参数这个特性。</p>\n<p>可变参数有两种形式，分别是在形参之前添加个<strong>一</strong><code>*</code> 与在形参之前添加个<strong>两</strong><code>*</code> 。</p>\n<h1 id=\"可变参数-形参前添加一个\"><a href=\"#可变参数-形参前添加一个\" class=\"headerlink\" title=\"可变参数:形参前添加一个*\"></a>可变参数:形参前添加一个<code>*</code></h1><p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 忽略这个反斜杠，因为markdown的缘故</span><br><span class=\"line\">def test(x,\\*y):</span><br><span class=\"line\">    print(type(x),&quot;\\n&quot;,x)</span><br><span class=\"line\">    print(type(y),&quot;\\n&quot;,y)</span><br><span class=\"line\">test(10,&quot;你好&quot;,&quot;世界&quot;,9.09,0xa)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> 10</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br><span class=\"line\"> (&apos;你好&apos;, &apos;世界&apos;, 9.09, 10)</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，实际上可变参数是将多个参数包含在一个元组内，然后将其输出。</p>\n<h2 id=\"可变参数-形参前添加两个\"><a href=\"#可变参数-形参前添加两个\" class=\"headerlink\" title=\"可变参数:形参前添加两个*\"></a>可变参数:形参前添加两个<code>*</code></h2><p>前面的第一种可变参数形式，是往形参前添加一个*，并且我们知道它其实就是个元组，那么第二种形式提前透露一下，它其实就是个字典</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def test(x,**y):</span><br><span class=\"line\">    print(type(x),&quot;\\n&quot;,x)</span><br><span class=\"line\">    print(type(y),&quot;\\n&quot;,y)</span><br><span class=\"line\">test(10,语文=100,数学=9.99,英语=8.88)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> 10</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br><span class=\"line\"> &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"可变参数：形参前添加两个\"><a href=\"#可变参数：形参前添加两个\" class=\"headerlink\" title=\"可变参数：形参前添加两个*\"></a>可变参数：形参前添加两个<code>*</code></h2><p>语法格式如下:</p>\n<p><code>**kwargs</code> </p>\n<ul>\n<li>*kw表示创建一个名为kwargs的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def test(x,**y):</span><br><span class=\"line\">    print(type(x),&quot;\\n&quot;,x)</span><br><span class=\"line\">    print(type(y),&quot;\\n&quot;,y)</span><br><span class=\"line\">test(10,语文=100,数学=9.99,英语=8.88)</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> 10</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br><span class=\"line\"> &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python逆向参数收集详解\"><a href=\"#Python逆向参数收集详解\" class=\"headerlink\" title=\"Python逆向参数收集详解\"></a>Python逆向参数收集详解</h1><p>逆向参数也就是说将程序中定义的列表、元组、字典等对象的元素拆开后传递给函数的参数。</p>\n<p><strong>逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_sum(*x):</span><br><span class=\"line\">    sum = 0</span><br><span class=\"line\">    for ele in x:</span><br><span class=\"line\">        sum += ele</span><br><span class=\"line\">    return sum</span><br><span class=\"line\"></span><br><span class=\"line\">num_list = range(1,101)</span><br><span class=\"line\"></span><br><span class=\"line\">print(get_sum(*num_list))</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5050</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>字典也支持逆向收集，字典会以关键字参数的形式传入。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_student(stu_id,stu_name,**x):</span><br><span class=\"line\">    print(&quot;学号:&quot;+str(stu_id))</span><br><span class=\"line\">    print(&quot;姓名:&quot;+str(stu_name))</span><br><span class=\"line\">    print(&quot;其他:&quot;+str(x))</span><br><span class=\"line\"></span><br><span class=\"line\">stu_info = &#123;&quot;stu_id&quot;:0,&quot;stu_name&quot;:&quot;张三&quot;,&quot;stu_age&quot;:18,&quot;stu_address&quot;:&quot;广州市&quot;&#125;</span><br><span class=\"line\">get_student(**stu_info)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学号:0</span><br><span class=\"line\">姓名:张三</span><br><span class=\"line\">其他:&#123;&apos;stu_age&apos;: 18, &apos;stu_address&apos;: &apos;广州市&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-None-空值-及用法\"><a href=\"#Python-None-空值-及用法\" class=\"headerlink\" title=\"Python None(空值)及用法\"></a>Python None(空值)及用法</h1><p>Python中有一个特殊的常量<code>None</code>，其表示为空值，它不等于空列表，也不等于空字符串。</p>\n<p><code>None</code> 具有自己的数据类型，通过<code>type()</code> 可以查看它的类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &apos;NoneType&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><code>None</code> 为<code>NoneType</code> 数据类型的唯一值，不能创建其他NoneType类型的变量，但是可以为任何变量赋值为<code>None</code> 。</p>\n<p><code>None</code> 常用场景是:<strong>assert断言，判断，以及函数无返回值。</strong> </p>\n<h1 id=\"Python-return函数返回值详解\"><a href=\"#Python-return函数返回值详解\" class=\"headerlink\" title=\"Python return函数返回值详解\"></a>Python return函数返回值详解</h1><p>语法格式:</p>\n<p><code>return [返回值]</code> </p>\n<p>return 语句是用于给函数的调用处返回一个值。</p>\n<p><strong>return 语句可以在同一函数中出现多次，但只要有一个得到执行，就会结束函数的执行。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def sum(x,y):</span><br><span class=\"line\">    return x+y</span><br><span class=\"line\"></span><br><span class=\"line\">print(sum(10,20))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><strong>return 的返回值可以为任意类型。</strong> </p>\n<h1 id=\"Python函数返回多个值的方法\"><a href=\"#Python函数返回多个值的方法\" class=\"headerlink\" title=\"Python函数返回多个值的方法\"></a>Python函数返回多个值的方法</h1><p>Python允许函数同时返回多个值，它会将多个返回值封装成元组。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def multi_return():</span><br><span class=\"line\">    return 10,20,30,40</span><br><span class=\"line\"># 序列解包</span><br><span class=\"line\">a,b,c,d = multi_return()</span><br><span class=\"line\"># 序列解包</span><br><span class=\"line\">test_list = multi_return()</span><br><span class=\"line\">print(a,b,c,d)</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">print(multi_return())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 20 30 40</span><br><span class=\"line\">(10, 20, 30, 40)</span><br><span class=\"line\">(10, 20, 30, 40)</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-partial偏函数及用法\"><a href=\"#Python-partial偏函数及用法\" class=\"headerlink\" title=\"Python partial偏函数及用法\"></a>Python partial偏函数及用法</h1><p><a href=\"http://c.biancheng.net/view/5674.html\" target=\"_blank\" rel=\"noopener\">见原文</a> </p>\n<h1 id=\"Python函数递归\"><a href=\"#Python函数递归\" class=\"headerlink\" title=\"Python函数递归\"></a>Python函数递归</h1><p>当一个函数体内调用自身，就被称为<code>函数递归</code> 。</p>\n<p>我们可以使用函数递归来模式循环，但这种循环不需要使用循环控制。</p>\n<p>下面我们做一个数学题: <code>f(0)=1,f(1)=4,f(n+2)=2*f(n+1)+f(n)</code>，其中n是大于0的整数，求f(10)的值。我们将会使用循环和递归两种不同的方式来求当f(10)的值。</p>\n<p>递归例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fn(n):</span><br><span class=\"line\">    if n==0:</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    elif n==1:</span><br><span class=\"line\">        return 4</span><br><span class=\"line\">    else :</span><br><span class=\"line\">        return 2 * fn(n-1)+fn(n-2)</span><br><span class=\"line\"></span><br><span class=\"line\">print(fn(10))</span><br></pre></td></tr></table></figure>\n<p>可以看到，我们在函数体内调用了自身，这样当我们执行到调用自身时，那么这就是递归，而对于来<code>fn(10)</code>说，也等于式子<code>2*fn(9)+fn(8)</code> ，而其中<code>fn(9)</code> 又等于<code>2*fn(8)+fn(7)</code> ，以此类推，最终当计算到<code>fn(2)</code> 等于<code>2*fn(1)+fn(0)</code> 时，那么就会开始返回，这个递归也就具有了结束的时候，最终得到fn(10)的值。</p>\n<p><strong>注意:递归类似于循环，必须在某个时刻函数的返回值是确定的，也就是不再调用自身，否则递归将会变成无穷递归，也就是死循环。</strong> </p>\n<h1 id=\"Python变量作用于-全局变量和局部变量\"><a href=\"#Python变量作用于-全局变量和局部变量\" class=\"headerlink\" title=\"Python变量作用于(全局变量和局部变量)\"></a>Python变量作用于(全局变量和局部变量)</h1><p>变量有作用的范围，这个范围被称为<code>作用域</code>。<br><strong>\n</strong>作用域是值，代码能够访问该变量的区域，如果超出该区域将不可访问。**</p>\n<p>变量的范围分为两种<code>局部变量</code> 和<code>全局变量</code> 。</p>\n<h2 id=\"Python局部变量\"><a href=\"#Python局部变量\" class=\"headerlink\" title=\"Python局部变量\"></a>Python局部变量</h2><p><strong>局部变量是指在函数内部定义并使用的变量，它只在函数内部有效</strong> 。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def text():</span><br><span class=\"line\">    demo = &quot;HelloWorld&quot;</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">text()</span><br><span class=\"line\"></span><br><span class=\"line\"># 获取局部变量demo</span><br><span class=\"line\">print(demo)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">NameError: name &apos;demo&apos; is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>可以看到程序报错了，那是因为后面的print(demo)语句访问了在当前作用于不存在的变量，所以就会报错。</p>\n<p>局部变量:每个函数执行时，系统都会为该函数分配一块<code>临时内存空间</code> ，所有局部变量都被保存在这块空间内。而当函数执行完后，系统将会将这块内存空间释放，从而局部变量也就失效了，因此当我们再次访问以为存在的局部变量时，解释器就会抛出错误NameError，因为根本不存在。</p>\n<h2 id=\"Python全局变量\"><a href=\"#Python全局变量\" class=\"headerlink\" title=\"Python全局变量\"></a>Python全局变量</h2><p>全局变量与局部变量相反，全局变量是指<strong>能够作用于函数内外的变量，也就是说全局变量可以在任何地方使用。</strong> </p>\n<p>定义全局变量有两种方法:</p>\n<ol>\n<li>在函数体外定义变量，一定是全局变量:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo = &quot;HelloWorld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">def text():</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">text()</span><br><span class=\"line\"></span><br><span class=\"line\">print(demo)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld</span><br><span class=\"line\">HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在函数体内定义全局变量。即使用<code>global</code> 关键字对变量进行修饰后，该变量就会变成为全局变量。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def text():</span><br><span class=\"line\">    global demo</span><br><span class=\"line\">    demo = &quot;HelloWorld&quot;</span><br><span class=\"line\">    print(demo)</span><br><span class=\"line\">text()</span><br><span class=\"line\"></span><br><span class=\"line\">print(demo)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld</span><br><span class=\"line\">HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p><strong>注意:在使用global修饰变量时不可以直接给变量赋值。</strong> </p>\n<h2 id=\"获取指定作用于范围中的变量\"><a href=\"#获取指定作用于范围中的变量\" class=\"headerlink\" title=\"获取指定作用于范围中的变量\"></a>获取指定作用于范围中的变量</h2><p>Python提供了三个函数用于访问指定作用于中的变量。</p>\n<p>我们可以把变量与值理解为一个个字典，把key理解为变量名或变量的内存地址，把值理解为value。</p>\n<p>而下面这三个方法就可以访问某个作用于下的所有字典。</p>\n<ul>\n<li><p>globals() 该函数返回全局范围内所有变量组成的变量字典。</p>\n</li>\n<li><p>locals() 该函数返回当前作用域范围下所有变量组成的变量字典。</p>\n</li>\n<li><p>vars(object) 获取object所在作用域范围下所有变量组成的变量字典，若不给参数，则与<code>locals()</code> 无区别。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def global_test():</span><br><span class=\"line\">  global name</span><br><span class=\"line\">  global name2</span><br><span class=\"line\">  global name3</span><br><span class=\"line\">  name = &quot;Evan&quot;</span><br><span class=\"line\">  name2 = &quot;Chen&quot;</span><br><span class=\"line\">  name3 = &quot;Li&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">global_test()</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;全局作用于下所有变量字典:&quot;,globals())</span><br><span class=\"line\">print(&quot;指定访问全局作用域下key为name2的变量字典:&quot;,globals()[&apos;name2&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def local_test():</span><br><span class=\"line\">    age=age1=age2=age3= 20</span><br><span class=\"line\">    print(&quot;age:&quot;,age)</span><br><span class=\"line\">    print(&quot;age作用域下所有变量字典:&quot;,locals())</span><br><span class=\"line\">    print(&quot;指定访问当前作用于下key为age的变量字典:&quot;,locals()[&apos;age&apos;])</span><br><span class=\"line\">local_test()</span><br></pre></td></tr></table></figure>"},{"title":"[Python-05]Python字符串常用方法详解","copyright":true,"date":"2019-09-23T11:40:09.000Z","_content":"\nPython系列第五章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/str_method/)\n\n<!--more-->\n\n# Python字符串拼接(包含字符串拼接数字)\n\n先说一个Python中书写字符串的一种特殊方式，如果我们将两个字符串紧挨着写，那么Python则会自动拼接它们。\n\n```\nstr1 = \"Hello\"',World'\nprint(str1)\n```\n\n输出结果:`Hello,World` \n\n**Python字符串拼接数字** \n\n某些场景下，我们需要将字符串与其他数据类型进行拼接，例如数字，但Python是不支持直接将数字与字符串拼接的，所以我们得先将数字转换成字符串，再进行拼接。\n\n```\nstr1 = \"This number is:\"\nnumber = 1.1001\n# 使用str()方法将数值类型的变量转化成字符串\nprint(str1+str(number))\n# 使用repr()方法将数值类型的变量转化成字符串\nprint(str1+repr(number))\n# 直接将字符串类型与数值类型进行拼接\nprint(str1+number)\n```\n\n输出结果:\n\n```\nThis number is:1.1001\nThis number is:1.1001\nTraceback (most recent call last):\n  File \"test.py\", line 8, in <module>\n  │ print(str1+number)\nTypeError: can only concatenate str (not \"float\") to str\n```\n\n可以看到，我们必须先将数值类型的变量转换成字符串类型才能进行拼接，否则将会引发`TypeError`的错误。\n\n**str()与repr()的区别** \n\nstr()与repr()都可以将数值转换成字符串，但其中**str是Python内置的类型，和int、float一样** ，然而repr()则只是一个函数。\n\nrepr()方法还可以以Python表达式的形式来表示值:\n\n```\nstr1 = \"This number is:\"\nprint(str1)\nprint(repr(str1))\n```\n\n输出结果:\n\n```\nThis number is:\n'This number is:'\n```\n\n# Python截取字符串(字符串切片)方法详解\n\nPython的字符串实际上是由多个字符组成的，并且允许通过索引访问字符串的某个字符，其语法格式为:\n\n`str[index]` \n\nstr代表要获取的字符串，index代表字符串的某个下标。\n\nPython中字符串的第一个字符默认从0开始访问，依次推进则是0,1,2,n...，并且Python还允许使用负数作为索引下标，负数从-1开始，依次推进。\n\n例子:\n\n```\nstr1 = \"HelloWorld\"\n# 获取'H'\nprint(str1[0])\n# 获取'o'\nprint(str1[-6])\n```\n\n输出结果:\n\n```\nH\no\n```\n\n除了通过索引单次获取单个字符外，Python还可以使用中括号对字符串以范围的方式获取，被获取的字符串称为\"子串\"，其语法格式为:\n\n`string[start:end:step]` \n\n- string代表要截取的字符串\n- start代表要截取子串的开始位置\n- end代表要截取子串的结束位置(不包括该字符)\n- step代表从start开始，每step个距离获取一个字符。默认为1，可忽略该值。\n\n例子:\n\n```\nstr1 = \"HelloWorld\"\n# 截取'Hello'\nprint(str1[0:6])\n# 截取'Hold'\nprint(str1[0:len(str1):3])\n```\n\n输出结果:\n\n```\nHelloW\nHlod\n```\n\nPython还支持使用`in`运算符判断是否包含某个子串.\n\n例子:\n\n```\nstr1=\"HelloWorld\"\nprint('Hello' in str1)\nprint(\"World\" in str1)\nprint(\"Test\" in str1)\n```\n\n输出结果:\n\n```\nTrue\nTrue\nFalse\n```\n\n# Python len()函数详解:获取字符串长度或字节数\n\nlen()函数用于获取字符串的长度，或字符串占用的字节。\n\n例子:\n\n```\nstr1=\"HelloWorld\"\nprint(len(str1))\n```\n\n输出结果:`10` \n\n如果想知道字符串所占用的字节数，可以先将字符串编码后，再获取。\n\n例子:\n\n```\nstr1=\"你好世界\"\nprint(len(str1))\nprint(len(str1.encode()))\n```\n\n输出结果:\n\n```\n4\n10\n```\n\n`encode()`方法可以将字符串转换成不同编码格式的字符。\n\n例如:\n\n```\nstr1=\"你好世界\"\nprint(len(str1.encode()))\n# 将字符串转换成gbk编码格式\nprint(len(str1.encode('gbk')))\n```\n\n输出结果:\n\n```\n8\n12\n```\n\n# Python split()方法详解: 分割字符串\n\n\nsplit()方法可以实现将一个字符串按照指定的分隔符分成多个子串，这些子串会被保存至列表中，其语法格式为:\n\n`string.split(sep,maxsplit)` \n\n- string代表要分割的字符串\n\n- sep代表指定的分隔符，默认为None，也就是任何空字符，例如空格，\\n，\\t等\n\n- maxsplit代表最大分割次数，如果不指定或者指定为-1，则表示分割次数无限制。\n\n**如果不指定sep，那么maxsplit也不能指定** \n\n例子:\n\n``` \nstr1 = \"192.168.0.0.1\"\n# 指定分隔符为'.'，最大分割数为3次\nlist1 = str1.split('.',3)\nprint(list1)\n# 指定分割符为'0.'，最大分割数为-1\nlist1 = str1.split('0.',-1)\nprint(list1)\n# 不指定split()参数\nlist1 = str1.split()\nprint(list1)\n```\n\n输出结果:\n\n```\n['192', '168', '0', '0.1']\n['192.168.', '', '1']\n['192.168.0.0.1']\n```\n\n# Python join()方法: 合并字符串\n\njoin()方法算是split()方法的逆方法，它可以将列表(或元素)中多个字符串元素采用固定的连接负连接在一起，其语法格式为:\n\n`newstr = str.join(iterable)` \n\n- newstr代表合并后产生的新字符串.\n\n- str代表连接符\n\n- iterable代表合并操作的源字符串数据。\n\n例子:\n\n```\npath = ['usr','bin','python3.7']\nstr1 = '/'.join(path)\nprint(str1)\n```\n\n输出结果:\n\n```\n/usr/bin/python3.7\n```\n\n# Python count()方法，统计字符串出现的次数\n\ncount()方法用于统计字符串在另一个字符串出现的次数，若不存在则返回0，否则返回统计的次数，其语法格式如下:\n\n`string.count(sub[,start[,end]])` \n\n- string代表字符串源\n\n- sub代表要检索的字符串\n\n- start代表检索字符串的起始位置，若不指定则默认为0开始\n\n- end指定检索的终止位置，若不指定则默认为字符串长度\n\n例子:\n\n```\nstr1 = \"叽里呱啦，嘻嘻哈哈，高高兴兴\"\nprint(str1.count('嘻嘻哈哈',0,len(str1)))\n```\n\n# Python find()方法：检测字符串中是否包含某个子串\n\nfind()方法用于检索字符串中是否包含目标字符串，若包含则返回第一次出现该字符串的索引，否则返回-1。其语法格式为:\n\n`string.find(sub,start,end)` \n\n- string要检索的字符串源\n\n- sub要检索的子串\n\n- start检索的起始位置\n\n- end检索的终止位置\n\n例子:\n\n```\nstr1 = \"叽里呱啦，嘻嘻哈哈，高高兴兴\"\nprint(str1.find(\"嘻嘻哈哈\"))\nprint(str1.find(\"嘻嘻哈哈\",6,len(str1)))\n```\n\n输出结果:\n\n```\n5\n-1\n```\n\n**Python还提供了rfind()方法，与find()方法不同的是，其实从字符串的右侧开始检索**\n\n# Python index()方法: 检测字符串中是否包含某个字符串\n\nindex()方法与find()方法类似，唯一不同的是，index()方法检索子串若没找到，则会抛出异常。\n\n同理，Python也提供了个rindex()方法，作用于rfind()方法类似。\n\n# Python字符串对齐方法ljust()、rjust()和center()详解\n\nPython 的`str`类提供了3种可以用来进行文本对齐的方法，分别是ljust()，rjust()，center()\n\n## Python ljust()方法\n\nljust()是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。语法格式如下:\n\n```\nstring.ljust(width,fillchar)\n```\n\n- string 表示被填充的字符串\n- width 表示包括string长度在内，字符串要占的总长度\n- fillchar 表示填充时占位的字符，默认为空格\n\n例子:\n\n```\nstring = 'HelloWorld'\nstring2 = \"你好世界\"\nprint(string.ljust(15,'*'),string2)\n```\n\n输出结果:\n\n```\nHelloWorld***** 你好世界\n```\n\n## Python rjust()方法\n\nrjust()方法与ljust()方法类似，唯一不同的是rjust()方法是向字符串左侧填充字符以右对齐的目的。语法格式:\n\n`str.rjust(width,fillchar)` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.rjust(15,'*'))\n```\n\n输出结果:\n\n```\n*****HelloWorld\n```\n\n## Python center()方法\n\ncenter()方法与rjust()、ljust()方法类似，其作用是在字符串两边填充字符以进行居中对齐。语法格式:\n\n`str.center(width,fillchar)` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.center(20,'*'))\n```\n\n输出结果:\n\n`*****HelloWorld*****` \n\n# Python startswith()和endswith()方法\n\nstartswith()方法与endswith()方法都是用来检索指定字符串是否为字符串源的开头或结尾。\n\n## startswith()方法\n\nstartswith()方法用于检索指定字符串是否为字符串源的开头。如果是返回True，否则反之。语法格式:\n\n`str.startswith(sub,start,end)` \n\n- str: 字符串源\n\n- sub: 指定的字符串（子串)\n\n- start: 指定开始检索的索引位置，可选参数，默认为开头。\n\n- end: 指定结束检索的索引位置，可选参数，默认为字符串源结尾。\n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.startswith(\"He\",2))\nprint(string.startswith(\"Wo\",5))\n```\n\n输出结果:\n\n```\nFalse\nTrue\n```\n\n## endswith()方法\n\nendswith()方法用于检索字符串是否以指定字符串结尾\n\n语法格式:\n\n`str.endswith(sub,start,end)` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.endswith('ld'))\nprint(string.endswith('rl',0,len(string)-1))\n```\n\n输出结果:\n\n```\nTrue\nTrue\n```\n\n# Pyhton大小写转换(3种)函数及用法\n\nPython提供了三种函数，方便用于转换字符串大小写，分别是title(),lower(),upper().\n\n## title()方法\n\ntitle()方法用于将字符串的字符转换为大写，其他字符转换为小写，并返回。\n\n**若不需要进行转换，则会直接返回** \n\n语法格式:\n\n`str.title()` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.title())\n```\n\n输出结果:\n\n```\nHelloworld\n```\n\n## lower()方法\n\nlower()方法用于将字符串中大写的字符转换为小写字符，并返回。\n\n语法格式:\n\n`str.lower()` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.lower())\n```\n\n输出结果:`helloworld` \n\n## upper()方法\n\nupper()方法用于将字符串中小写的字符转换为大写字符，并返回。\n\n语法格式:\n\n`str.upper()` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.upper())\n```\n\n输出结果:\n\n`HELLOWORLD` \n\n# Python去除字符串中空格\n\nPython提供了三种方法，用于去除字符串中的特殊符号或指定字符，例如**换行符(\\n)，回车符(\\r)，制表符(\\t)**，它们分别是strip(),ltrip(),rtrip().\n\n## strip()方法\n\nstrip()用于去除字符串前后(左右侧)的特殊符号或指定字符。\n\n语法格式:\n\n`str.strip(char)` \n\n- str: 字符串源\n\n- char: 指定删除的字符，可选参数，默认为空格、换行符、回车符、制表符\n\n例子:\n\n```\nstring = \"\\r   排山倒海\\t\\n\\r\"\nprint(repr(string))\nprint(repr(string.strip()))\nprint(repr(string.strip('\\r')))\n```\n\n输出结果:\n\n```\n'\\r   排山倒海\\t\\n\\r'\n'排山倒海'\n'   排山倒海\\t\\n'\n```\n\n## lstrip()方法\n\nlstrip方法用于去除字符串前(左侧)的特殊符号或指定字符。\n\n语法格式:\n\n`str.lstrip(char)` \n\n例子:\n\n```\nstring = \"\\t\\n\\r排山倒海\"\nprint(repr(string))\nprint(repr(string.lstrip()))\n```\n\n输出结果:\n\n```\n'\\t\\n\\r排山倒海'\n'排山倒海'\n```\n\n## rstrip()方法\n\nrstrip()方法与lstrip()方法以及strip()方法很类似，只不过其作用是去除字符串后(右侧)的特殊符号或指定字符。\n\n语法格式:\n\n`str.rstrip(char)` \n\n例子:\n\n```\nstring = \"排山倒海\\t\\n\\r\"\nprint(repr(string))\nprint(repr(string.rstrip()))\n```\n\n输出结果:\n\n```\n'排山倒海\\t\\n\\r'\n'排山倒海'\n```\n\n# Python format()方法格式化输出方法详解\n\n语法格式:\n\n`str.format(args)` \n\n- str: 字符串源\n\n- args: 参数列表，使用逗号进行分割\n\nformat()方法的重点在于搞清楚str显示样式的格式。在差UN感觉爱你显示样式模板时，需要使用`{}`和`:`来指定占位符，其完整的语法格式为:\n\n`{[index][:[[fill] align] [sign] [#] [width] [.precision] [type]]}` \n\n**注意,语法格式中的`[]`括起来的都是可选参数** \n\n参数含义如下:\n\n- index : 指定后面设置的格式要作用到args中第n个数据，数据的索引值从0开始，默认值为args中数据的先后顺序自动分配排列。\n\n- fill : 指定空白处填充的字符。注意，当填充字符为逗号`,`切作用于整数或浮点数时，该整数(或浮点数)会以逗号分隔的形式输出，例如(1000会输出1,000)。\n\n- align : 指定数据的对齐方式\n\nalign 参数及含义\n\n| align | 含义                                                                  |\n|-------|-----------------------------------------------------------------------|\n| <     | 数据左对齐                                                            |\n| >     | 数据右对齐                                                            |\n| =     | 数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对 数据类型有效 |\n| ^     | 数据居中，此选项续和width参数一起使用                                 |\n\n- sign : 指定有无符号数\n\n| sign | 含义                                                 |\n|------|------------------------------------------------------|\n| +    | 正数加正号，负数加负号                               |\n| -    | 正数不加正好，负数加负号                             |\n| 空格 | 正数前加空格，负数前加负号                           |\n| #    | 对于二、八、十六进制数，使用此参数，会显示对应的前缀 |\n\n- width : 指定输出数据时所占的宽度。\n\n- .precision : 指定保留的小数位数。\n\n- type : 指定输出数据的具体类型\n\n| type类型值 | 含义                                           |\n|------------|------------------------------------------------|\n| s          | 对字符串类型格式化                             |\n| d          | 十进制整数                                     |\n| c          | 将十进制整数自动转换成对应的 Unicode字符       |\n| e或者E     | 转换成科计数法后，再格式化输出                 |\n| g或G       | 自动在e和f中切换                               |\n| b          | 将十进制数自动转换成二进制表示，再格式化       |\n| o          | 将十进制数自动转换成八进制表示，再格式化       |\n| x或X       | 将十进制数自动转换成十六进制表示，再格式化     |\n| f或F       | 转换为浮点数(默认小数点后保留6位),再格式化输出 |\n| %          | 显示百分比(默认显示小数点后6位)                |\n\n例子:\n\n```\nstring = \"姓名:{:>5s}\\n工资:{:>10.2F}\\n\"\nprint(string.format(\"张三\",1001.223))\n```\n\n输出结果:\n\n```\n\n姓名:   张三\n工资:   1001.22\n```\n\n例子2:\n\n```\n# 货币形式显示\nprint(\"$:{:,d}\".format(1000009922399))\n\n# 科学计数法显示\nprint(\"科学计数法:{:e}\".format(1000.123))\n\n# 十六进制显示\nprint(\"1016的十六进制:{:x}\".format(1016))\n\n# 百分比形式显示\nprint(\"百分比显示:{:.0%}\".format(0.99))\n```\n\n输出结果:\n\n```\n$:1,000,009,922,399\n科学计数法:1.000123e+03\n1016的十六进制:3f8\n百分比显示:99%\n```\n\n# Python encode()和decode()方法: 字符串编码转换\n\n前言: 世界最早的字符编码时ASCII编码，它最多表示256个符号，每个符号占用1个字节，随着技术的发展，多国的文字都需要进行编码，所以出现了很多种编码格式，例如UTF-8也就是最通用的编码格式，Python3.x默认也是使用UTF-8编码格式。\n\nPython中有两种常用的字符串类型: `str`与`bytes`类型，`str`用来表示Unicode字符,`bytes`用来表示二进制数据。\n\n所以我们就需要使用`encode()`和`decode()`方法进行转换。\n\n## Phthon encode()方法\n\nencode()方法是str提供的功法，其作用是将str类型转换成bytes类型，这个操作也被称为编码。\n\n语法格式如下:\n\n`str.encode([encode=\"utf-8\"],[errors=\"strict\"])` \n\n- encoding : 指定在编码时采用的字符编码，默认采用utf-8。当只有这个参数时，可以省略`=`直接写`str.encode(\"UTF-8\")`\n\n- errors : 指定错误处理方式，默认为strict，其可选项有:\n\n| errors            | 含义                   |\n|-------------------|------------------------|\n| strict            | 遇到非法字符就抛出异常 |\n| ignore            | 忽略非法字符           |\n| replace           | 用`?`替代非法字符      |\n| xmlcharrefreplace | 使用xml的字符引用      |\n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.encode())\n```\n\n输出结果:\n\n`b'HelloWorld'` \n\n## Python decode()方法\n\ndecode()可以将bytes类型的二进制数据转换成str类型，这个过程被称为解码\n\n语法格式:\n\n`bytes.decode([encoding=\"utf-8\"],[errors=\"strict\"])` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.encode())\nprint(bytes.decode(string.encode()))\n```\n\n输出结果:\n\n```\nb'HelloWorld'\nHelloWorld\n```\n\n**注意:解码时必须使用与编码时相同的编码格式，否则将会抛出异常** \n\n# Python dir()和help()帮助函数\n\nPython提供了两个函数，用于帮助程序员查询文档，掌握这两个函数则可以查看所有函数(方法)的用法及功能.\n\n**dir()** 列出指定类或模块包含的全部内容，包括函数、方法、类、变量etc.\n\n**help()** 查看某个函数或方法的帮助文档。\n\n例子:\n\n查看字符串能调用的全部内容\n\n```\nprint(dir(str))\n```\n\n输出结果:\n\n```\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '_\n_eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs\n__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__'\n, '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__',\n'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__'\n, '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'e\nncode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isal\nnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', '\nisnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lo\nwer', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust',\n 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',\n 'swapcase', 'title', 'translate', 'upper', 'zfill']\n```\n\n**注意:其中以`_`结尾的方法为私有方法，不希望被外界直接调用。** \n\n\n**help()** \n\n想要查看某个方法或函数的帮助文档，就使用help()函数\n\n`print(help(str.format))` \n\n输出结果:\n\n```\nHelp on method_descriptor:\n\nformat(...)\n    S.format(*args, **kwargs) -> str\n\n    Return a formatted version of S, using substitutions from args and kwargs.\n    The substitutions are identified by braces ('{' and '}').\n(END)\n```\n\n\n","source":"_posts/Python-05-Python字符串常用方法详解.md","raw":"---\ntitle: '[Python-05]Python字符串常用方法详解'\ncopyright: true\ndate: 2019-09-23 19:40:09\ncategories: Python\ntags:\n  - Python系列\n---\n\nPython系列第五章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/str_method/)\n\n<!--more-->\n\n# Python字符串拼接(包含字符串拼接数字)\n\n先说一个Python中书写字符串的一种特殊方式，如果我们将两个字符串紧挨着写，那么Python则会自动拼接它们。\n\n```\nstr1 = \"Hello\"',World'\nprint(str1)\n```\n\n输出结果:`Hello,World` \n\n**Python字符串拼接数字** \n\n某些场景下，我们需要将字符串与其他数据类型进行拼接，例如数字，但Python是不支持直接将数字与字符串拼接的，所以我们得先将数字转换成字符串，再进行拼接。\n\n```\nstr1 = \"This number is:\"\nnumber = 1.1001\n# 使用str()方法将数值类型的变量转化成字符串\nprint(str1+str(number))\n# 使用repr()方法将数值类型的变量转化成字符串\nprint(str1+repr(number))\n# 直接将字符串类型与数值类型进行拼接\nprint(str1+number)\n```\n\n输出结果:\n\n```\nThis number is:1.1001\nThis number is:1.1001\nTraceback (most recent call last):\n  File \"test.py\", line 8, in <module>\n  │ print(str1+number)\nTypeError: can only concatenate str (not \"float\") to str\n```\n\n可以看到，我们必须先将数值类型的变量转换成字符串类型才能进行拼接，否则将会引发`TypeError`的错误。\n\n**str()与repr()的区别** \n\nstr()与repr()都可以将数值转换成字符串，但其中**str是Python内置的类型，和int、float一样** ，然而repr()则只是一个函数。\n\nrepr()方法还可以以Python表达式的形式来表示值:\n\n```\nstr1 = \"This number is:\"\nprint(str1)\nprint(repr(str1))\n```\n\n输出结果:\n\n```\nThis number is:\n'This number is:'\n```\n\n# Python截取字符串(字符串切片)方法详解\n\nPython的字符串实际上是由多个字符组成的，并且允许通过索引访问字符串的某个字符，其语法格式为:\n\n`str[index]` \n\nstr代表要获取的字符串，index代表字符串的某个下标。\n\nPython中字符串的第一个字符默认从0开始访问，依次推进则是0,1,2,n...，并且Python还允许使用负数作为索引下标，负数从-1开始，依次推进。\n\n例子:\n\n```\nstr1 = \"HelloWorld\"\n# 获取'H'\nprint(str1[0])\n# 获取'o'\nprint(str1[-6])\n```\n\n输出结果:\n\n```\nH\no\n```\n\n除了通过索引单次获取单个字符外，Python还可以使用中括号对字符串以范围的方式获取，被获取的字符串称为\"子串\"，其语法格式为:\n\n`string[start:end:step]` \n\n- string代表要截取的字符串\n- start代表要截取子串的开始位置\n- end代表要截取子串的结束位置(不包括该字符)\n- step代表从start开始，每step个距离获取一个字符。默认为1，可忽略该值。\n\n例子:\n\n```\nstr1 = \"HelloWorld\"\n# 截取'Hello'\nprint(str1[0:6])\n# 截取'Hold'\nprint(str1[0:len(str1):3])\n```\n\n输出结果:\n\n```\nHelloW\nHlod\n```\n\nPython还支持使用`in`运算符判断是否包含某个子串.\n\n例子:\n\n```\nstr1=\"HelloWorld\"\nprint('Hello' in str1)\nprint(\"World\" in str1)\nprint(\"Test\" in str1)\n```\n\n输出结果:\n\n```\nTrue\nTrue\nFalse\n```\n\n# Python len()函数详解:获取字符串长度或字节数\n\nlen()函数用于获取字符串的长度，或字符串占用的字节。\n\n例子:\n\n```\nstr1=\"HelloWorld\"\nprint(len(str1))\n```\n\n输出结果:`10` \n\n如果想知道字符串所占用的字节数，可以先将字符串编码后，再获取。\n\n例子:\n\n```\nstr1=\"你好世界\"\nprint(len(str1))\nprint(len(str1.encode()))\n```\n\n输出结果:\n\n```\n4\n10\n```\n\n`encode()`方法可以将字符串转换成不同编码格式的字符。\n\n例如:\n\n```\nstr1=\"你好世界\"\nprint(len(str1.encode()))\n# 将字符串转换成gbk编码格式\nprint(len(str1.encode('gbk')))\n```\n\n输出结果:\n\n```\n8\n12\n```\n\n# Python split()方法详解: 分割字符串\n\n\nsplit()方法可以实现将一个字符串按照指定的分隔符分成多个子串，这些子串会被保存至列表中，其语法格式为:\n\n`string.split(sep,maxsplit)` \n\n- string代表要分割的字符串\n\n- sep代表指定的分隔符，默认为None，也就是任何空字符，例如空格，\\n，\\t等\n\n- maxsplit代表最大分割次数，如果不指定或者指定为-1，则表示分割次数无限制。\n\n**如果不指定sep，那么maxsplit也不能指定** \n\n例子:\n\n``` \nstr1 = \"192.168.0.0.1\"\n# 指定分隔符为'.'，最大分割数为3次\nlist1 = str1.split('.',3)\nprint(list1)\n# 指定分割符为'0.'，最大分割数为-1\nlist1 = str1.split('0.',-1)\nprint(list1)\n# 不指定split()参数\nlist1 = str1.split()\nprint(list1)\n```\n\n输出结果:\n\n```\n['192', '168', '0', '0.1']\n['192.168.', '', '1']\n['192.168.0.0.1']\n```\n\n# Python join()方法: 合并字符串\n\njoin()方法算是split()方法的逆方法，它可以将列表(或元素)中多个字符串元素采用固定的连接负连接在一起，其语法格式为:\n\n`newstr = str.join(iterable)` \n\n- newstr代表合并后产生的新字符串.\n\n- str代表连接符\n\n- iterable代表合并操作的源字符串数据。\n\n例子:\n\n```\npath = ['usr','bin','python3.7']\nstr1 = '/'.join(path)\nprint(str1)\n```\n\n输出结果:\n\n```\n/usr/bin/python3.7\n```\n\n# Python count()方法，统计字符串出现的次数\n\ncount()方法用于统计字符串在另一个字符串出现的次数，若不存在则返回0，否则返回统计的次数，其语法格式如下:\n\n`string.count(sub[,start[,end]])` \n\n- string代表字符串源\n\n- sub代表要检索的字符串\n\n- start代表检索字符串的起始位置，若不指定则默认为0开始\n\n- end指定检索的终止位置，若不指定则默认为字符串长度\n\n例子:\n\n```\nstr1 = \"叽里呱啦，嘻嘻哈哈，高高兴兴\"\nprint(str1.count('嘻嘻哈哈',0,len(str1)))\n```\n\n# Python find()方法：检测字符串中是否包含某个子串\n\nfind()方法用于检索字符串中是否包含目标字符串，若包含则返回第一次出现该字符串的索引，否则返回-1。其语法格式为:\n\n`string.find(sub,start,end)` \n\n- string要检索的字符串源\n\n- sub要检索的子串\n\n- start检索的起始位置\n\n- end检索的终止位置\n\n例子:\n\n```\nstr1 = \"叽里呱啦，嘻嘻哈哈，高高兴兴\"\nprint(str1.find(\"嘻嘻哈哈\"))\nprint(str1.find(\"嘻嘻哈哈\",6,len(str1)))\n```\n\n输出结果:\n\n```\n5\n-1\n```\n\n**Python还提供了rfind()方法，与find()方法不同的是，其实从字符串的右侧开始检索**\n\n# Python index()方法: 检测字符串中是否包含某个字符串\n\nindex()方法与find()方法类似，唯一不同的是，index()方法检索子串若没找到，则会抛出异常。\n\n同理，Python也提供了个rindex()方法，作用于rfind()方法类似。\n\n# Python字符串对齐方法ljust()、rjust()和center()详解\n\nPython 的`str`类提供了3种可以用来进行文本对齐的方法，分别是ljust()，rjust()，center()\n\n## Python ljust()方法\n\nljust()是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。语法格式如下:\n\n```\nstring.ljust(width,fillchar)\n```\n\n- string 表示被填充的字符串\n- width 表示包括string长度在内，字符串要占的总长度\n- fillchar 表示填充时占位的字符，默认为空格\n\n例子:\n\n```\nstring = 'HelloWorld'\nstring2 = \"你好世界\"\nprint(string.ljust(15,'*'),string2)\n```\n\n输出结果:\n\n```\nHelloWorld***** 你好世界\n```\n\n## Python rjust()方法\n\nrjust()方法与ljust()方法类似，唯一不同的是rjust()方法是向字符串左侧填充字符以右对齐的目的。语法格式:\n\n`str.rjust(width,fillchar)` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.rjust(15,'*'))\n```\n\n输出结果:\n\n```\n*****HelloWorld\n```\n\n## Python center()方法\n\ncenter()方法与rjust()、ljust()方法类似，其作用是在字符串两边填充字符以进行居中对齐。语法格式:\n\n`str.center(width,fillchar)` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.center(20,'*'))\n```\n\n输出结果:\n\n`*****HelloWorld*****` \n\n# Python startswith()和endswith()方法\n\nstartswith()方法与endswith()方法都是用来检索指定字符串是否为字符串源的开头或结尾。\n\n## startswith()方法\n\nstartswith()方法用于检索指定字符串是否为字符串源的开头。如果是返回True，否则反之。语法格式:\n\n`str.startswith(sub,start,end)` \n\n- str: 字符串源\n\n- sub: 指定的字符串（子串)\n\n- start: 指定开始检索的索引位置，可选参数，默认为开头。\n\n- end: 指定结束检索的索引位置，可选参数，默认为字符串源结尾。\n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.startswith(\"He\",2))\nprint(string.startswith(\"Wo\",5))\n```\n\n输出结果:\n\n```\nFalse\nTrue\n```\n\n## endswith()方法\n\nendswith()方法用于检索字符串是否以指定字符串结尾\n\n语法格式:\n\n`str.endswith(sub,start,end)` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.endswith('ld'))\nprint(string.endswith('rl',0,len(string)-1))\n```\n\n输出结果:\n\n```\nTrue\nTrue\n```\n\n# Pyhton大小写转换(3种)函数及用法\n\nPython提供了三种函数，方便用于转换字符串大小写，分别是title(),lower(),upper().\n\n## title()方法\n\ntitle()方法用于将字符串的字符转换为大写，其他字符转换为小写，并返回。\n\n**若不需要进行转换，则会直接返回** \n\n语法格式:\n\n`str.title()` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.title())\n```\n\n输出结果:\n\n```\nHelloworld\n```\n\n## lower()方法\n\nlower()方法用于将字符串中大写的字符转换为小写字符，并返回。\n\n语法格式:\n\n`str.lower()` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.lower())\n```\n\n输出结果:`helloworld` \n\n## upper()方法\n\nupper()方法用于将字符串中小写的字符转换为大写字符，并返回。\n\n语法格式:\n\n`str.upper()` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.upper())\n```\n\n输出结果:\n\n`HELLOWORLD` \n\n# Python去除字符串中空格\n\nPython提供了三种方法，用于去除字符串中的特殊符号或指定字符，例如**换行符(\\n)，回车符(\\r)，制表符(\\t)**，它们分别是strip(),ltrip(),rtrip().\n\n## strip()方法\n\nstrip()用于去除字符串前后(左右侧)的特殊符号或指定字符。\n\n语法格式:\n\n`str.strip(char)` \n\n- str: 字符串源\n\n- char: 指定删除的字符，可选参数，默认为空格、换行符、回车符、制表符\n\n例子:\n\n```\nstring = \"\\r   排山倒海\\t\\n\\r\"\nprint(repr(string))\nprint(repr(string.strip()))\nprint(repr(string.strip('\\r')))\n```\n\n输出结果:\n\n```\n'\\r   排山倒海\\t\\n\\r'\n'排山倒海'\n'   排山倒海\\t\\n'\n```\n\n## lstrip()方法\n\nlstrip方法用于去除字符串前(左侧)的特殊符号或指定字符。\n\n语法格式:\n\n`str.lstrip(char)` \n\n例子:\n\n```\nstring = \"\\t\\n\\r排山倒海\"\nprint(repr(string))\nprint(repr(string.lstrip()))\n```\n\n输出结果:\n\n```\n'\\t\\n\\r排山倒海'\n'排山倒海'\n```\n\n## rstrip()方法\n\nrstrip()方法与lstrip()方法以及strip()方法很类似，只不过其作用是去除字符串后(右侧)的特殊符号或指定字符。\n\n语法格式:\n\n`str.rstrip(char)` \n\n例子:\n\n```\nstring = \"排山倒海\\t\\n\\r\"\nprint(repr(string))\nprint(repr(string.rstrip()))\n```\n\n输出结果:\n\n```\n'排山倒海\\t\\n\\r'\n'排山倒海'\n```\n\n# Python format()方法格式化输出方法详解\n\n语法格式:\n\n`str.format(args)` \n\n- str: 字符串源\n\n- args: 参数列表，使用逗号进行分割\n\nformat()方法的重点在于搞清楚str显示样式的格式。在差UN感觉爱你显示样式模板时，需要使用`{}`和`:`来指定占位符，其完整的语法格式为:\n\n`{[index][:[[fill] align] [sign] [#] [width] [.precision] [type]]}` \n\n**注意,语法格式中的`[]`括起来的都是可选参数** \n\n参数含义如下:\n\n- index : 指定后面设置的格式要作用到args中第n个数据，数据的索引值从0开始，默认值为args中数据的先后顺序自动分配排列。\n\n- fill : 指定空白处填充的字符。注意，当填充字符为逗号`,`切作用于整数或浮点数时，该整数(或浮点数)会以逗号分隔的形式输出，例如(1000会输出1,000)。\n\n- align : 指定数据的对齐方式\n\nalign 参数及含义\n\n| align | 含义                                                                  |\n|-------|-----------------------------------------------------------------------|\n| <     | 数据左对齐                                                            |\n| >     | 数据右对齐                                                            |\n| =     | 数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对 数据类型有效 |\n| ^     | 数据居中，此选项续和width参数一起使用                                 |\n\n- sign : 指定有无符号数\n\n| sign | 含义                                                 |\n|------|------------------------------------------------------|\n| +    | 正数加正号，负数加负号                               |\n| -    | 正数不加正好，负数加负号                             |\n| 空格 | 正数前加空格，负数前加负号                           |\n| #    | 对于二、八、十六进制数，使用此参数，会显示对应的前缀 |\n\n- width : 指定输出数据时所占的宽度。\n\n- .precision : 指定保留的小数位数。\n\n- type : 指定输出数据的具体类型\n\n| type类型值 | 含义                                           |\n|------------|------------------------------------------------|\n| s          | 对字符串类型格式化                             |\n| d          | 十进制整数                                     |\n| c          | 将十进制整数自动转换成对应的 Unicode字符       |\n| e或者E     | 转换成科计数法后，再格式化输出                 |\n| g或G       | 自动在e和f中切换                               |\n| b          | 将十进制数自动转换成二进制表示，再格式化       |\n| o          | 将十进制数自动转换成八进制表示，再格式化       |\n| x或X       | 将十进制数自动转换成十六进制表示，再格式化     |\n| f或F       | 转换为浮点数(默认小数点后保留6位),再格式化输出 |\n| %          | 显示百分比(默认显示小数点后6位)                |\n\n例子:\n\n```\nstring = \"姓名:{:>5s}\\n工资:{:>10.2F}\\n\"\nprint(string.format(\"张三\",1001.223))\n```\n\n输出结果:\n\n```\n\n姓名:   张三\n工资:   1001.22\n```\n\n例子2:\n\n```\n# 货币形式显示\nprint(\"$:{:,d}\".format(1000009922399))\n\n# 科学计数法显示\nprint(\"科学计数法:{:e}\".format(1000.123))\n\n# 十六进制显示\nprint(\"1016的十六进制:{:x}\".format(1016))\n\n# 百分比形式显示\nprint(\"百分比显示:{:.0%}\".format(0.99))\n```\n\n输出结果:\n\n```\n$:1,000,009,922,399\n科学计数法:1.000123e+03\n1016的十六进制:3f8\n百分比显示:99%\n```\n\n# Python encode()和decode()方法: 字符串编码转换\n\n前言: 世界最早的字符编码时ASCII编码，它最多表示256个符号，每个符号占用1个字节，随着技术的发展，多国的文字都需要进行编码，所以出现了很多种编码格式，例如UTF-8也就是最通用的编码格式，Python3.x默认也是使用UTF-8编码格式。\n\nPython中有两种常用的字符串类型: `str`与`bytes`类型，`str`用来表示Unicode字符,`bytes`用来表示二进制数据。\n\n所以我们就需要使用`encode()`和`decode()`方法进行转换。\n\n## Phthon encode()方法\n\nencode()方法是str提供的功法，其作用是将str类型转换成bytes类型，这个操作也被称为编码。\n\n语法格式如下:\n\n`str.encode([encode=\"utf-8\"],[errors=\"strict\"])` \n\n- encoding : 指定在编码时采用的字符编码，默认采用utf-8。当只有这个参数时，可以省略`=`直接写`str.encode(\"UTF-8\")`\n\n- errors : 指定错误处理方式，默认为strict，其可选项有:\n\n| errors            | 含义                   |\n|-------------------|------------------------|\n| strict            | 遇到非法字符就抛出异常 |\n| ignore            | 忽略非法字符           |\n| replace           | 用`?`替代非法字符      |\n| xmlcharrefreplace | 使用xml的字符引用      |\n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.encode())\n```\n\n输出结果:\n\n`b'HelloWorld'` \n\n## Python decode()方法\n\ndecode()可以将bytes类型的二进制数据转换成str类型，这个过程被称为解码\n\n语法格式:\n\n`bytes.decode([encoding=\"utf-8\"],[errors=\"strict\"])` \n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint(string.encode())\nprint(bytes.decode(string.encode()))\n```\n\n输出结果:\n\n```\nb'HelloWorld'\nHelloWorld\n```\n\n**注意:解码时必须使用与编码时相同的编码格式，否则将会抛出异常** \n\n# Python dir()和help()帮助函数\n\nPython提供了两个函数，用于帮助程序员查询文档，掌握这两个函数则可以查看所有函数(方法)的用法及功能.\n\n**dir()** 列出指定类或模块包含的全部内容，包括函数、方法、类、变量etc.\n\n**help()** 查看某个函数或方法的帮助文档。\n\n例子:\n\n查看字符串能调用的全部内容\n\n```\nprint(dir(str))\n```\n\n输出结果:\n\n```\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '_\n_eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs\n__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__'\n, '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__',\n'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__'\n, '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'e\nncode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isal\nnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', '\nisnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lo\nwer', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust',\n 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',\n 'swapcase', 'title', 'translate', 'upper', 'zfill']\n```\n\n**注意:其中以`_`结尾的方法为私有方法，不希望被外界直接调用。** \n\n\n**help()** \n\n想要查看某个方法或函数的帮助文档，就使用help()函数\n\n`print(help(str.format))` \n\n输出结果:\n\n```\nHelp on method_descriptor:\n\nformat(...)\n    S.format(*args, **kwargs) -> str\n\n    Return a formatted version of S, using substitutions from args and kwargs.\n    The substitutions are identified by braces ('{' and '}').\n(END)\n```\n\n\n","slug":"Python-05-Python字符串常用方法详解","published":1,"updated":"2020-01-19T03:49:51.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocr0047omoowsl2xkbs","content":"<p>Python系列第五章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/str_method/\" target=\"_blank\" rel=\"noopener\">💿</a></p>\n<a id=\"more\"></a>\n<h1 id=\"Python字符串拼接-包含字符串拼接数字\"><a href=\"#Python字符串拼接-包含字符串拼接数字\" class=\"headerlink\" title=\"Python字符串拼接(包含字符串拼接数字)\"></a>Python字符串拼接(包含字符串拼接数字)</h1><p>先说一个Python中书写字符串的一种特殊方式，如果我们将两个字符串紧挨着写，那么Python则会自动拼接它们。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;Hello&quot;&apos;,World&apos;</span><br><span class=\"line\">print(str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>Hello,World</code> </p>\n<p><strong>Python字符串拼接数字</strong> </p>\n<p>某些场景下，我们需要将字符串与其他数据类型进行拼接，例如数字，但Python是不支持直接将数字与字符串拼接的，所以我们得先将数字转换成字符串，再进行拼接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;This number is:&quot;</span><br><span class=\"line\">number = 1.1001</span><br><span class=\"line\"># 使用str()方法将数值类型的变量转化成字符串</span><br><span class=\"line\">print(str1+str(number))</span><br><span class=\"line\"># 使用repr()方法将数值类型的变量转化成字符串</span><br><span class=\"line\">print(str1+repr(number))</span><br><span class=\"line\"># 直接将字符串类型与数值类型进行拼接</span><br><span class=\"line\">print(str1+number)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This number is:1.1001</span><br><span class=\"line\">This number is:1.1001</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class=\"line\">  │ print(str1+number)</span><br><span class=\"line\">TypeError: can only concatenate str (not &quot;float&quot;) to str</span><br></pre></td></tr></table></figure>\n<p>可以看到，我们必须先将数值类型的变量转换成字符串类型才能进行拼接，否则将会引发<code>TypeError</code>的错误。</p>\n<p><strong>str()与repr()的区别</strong> </p>\n<p>str()与repr()都可以将数值转换成字符串，但其中<strong>str是Python内置的类型，和int、float一样</strong> ，然而repr()则只是一个函数。</p>\n<p>repr()方法还可以以Python表达式的形式来表示值:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;This number is:&quot;</span><br><span class=\"line\">print(str1)</span><br><span class=\"line\">print(repr(str1))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This number is:</span><br><span class=\"line\">&apos;This number is:&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python截取字符串-字符串切片-方法详解\"><a href=\"#Python截取字符串-字符串切片-方法详解\" class=\"headerlink\" title=\"Python截取字符串(字符串切片)方法详解\"></a>Python截取字符串(字符串切片)方法详解</h1><p>Python的字符串实际上是由多个字符组成的，并且允许通过索引访问字符串的某个字符，其语法格式为:</p>\n<p><code>str[index]</code> </p>\n<p>str代表要获取的字符串，index代表字符串的某个下标。</p>\n<p>Python中字符串的第一个字符默认从0开始访问，依次推进则是0,1,2,n…，并且Python还允许使用负数作为索引下标，负数从-1开始，依次推进。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;HelloWorld&quot;</span><br><span class=\"line\"># 获取&apos;H&apos;</span><br><span class=\"line\">print(str1[0])</span><br><span class=\"line\"># 获取&apos;o&apos;</span><br><span class=\"line\">print(str1[-6])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H</span><br><span class=\"line\">o</span><br></pre></td></tr></table></figure>\n<p>除了通过索引单次获取单个字符外，Python还可以使用中括号对字符串以范围的方式获取，被获取的字符串称为”子串”，其语法格式为:</p>\n<p><code>string[start:end:step]</code> </p>\n<ul>\n<li>string代表要截取的字符串</li>\n<li>start代表要截取子串的开始位置</li>\n<li>end代表要截取子串的结束位置(不包括该字符)</li>\n<li>step代表从start开始，每step个距离获取一个字符。默认为1，可忽略该值。</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;HelloWorld&quot;</span><br><span class=\"line\"># 截取&apos;Hello&apos;</span><br><span class=\"line\">print(str1[0:6])</span><br><span class=\"line\"># 截取&apos;Hold&apos;</span><br><span class=\"line\">print(str1[0:len(str1):3])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloW</span><br><span class=\"line\">Hlod</span><br></pre></td></tr></table></figure>\n<p>Python还支持使用<code>in</code>运算符判断是否包含某个子串.</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;HelloWorld&quot;</span><br><span class=\"line\">print(&apos;Hello&apos; in str1)</span><br><span class=\"line\">print(&quot;World&quot; in str1)</span><br><span class=\"line\">print(&quot;Test&quot; in str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">True</span><br><span class=\"line\">True</span><br><span class=\"line\">False</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-len-函数详解-获取字符串长度或字节数\"><a href=\"#Python-len-函数详解-获取字符串长度或字节数\" class=\"headerlink\" title=\"Python len()函数详解:获取字符串长度或字节数\"></a>Python len()函数详解:获取字符串长度或字节数</h1><p>len()函数用于获取字符串的长度，或字符串占用的字节。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;HelloWorld&quot;</span><br><span class=\"line\">print(len(str1))</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>10</code> </p>\n<p>如果想知道字符串所占用的字节数，可以先将字符串编码后，再获取。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;你好世界&quot;</span><br><span class=\"line\">print(len(str1))</span><br><span class=\"line\">print(len(str1.encode()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p><code>encode()</code>方法可以将字符串转换成不同编码格式的字符。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;你好世界&quot;</span><br><span class=\"line\">print(len(str1.encode()))</span><br><span class=\"line\"># 将字符串转换成gbk编码格式</span><br><span class=\"line\">print(len(str1.encode(&apos;gbk&apos;)))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-split-方法详解-分割字符串\"><a href=\"#Python-split-方法详解-分割字符串\" class=\"headerlink\" title=\"Python split()方法详解: 分割字符串\"></a>Python split()方法详解: 分割字符串</h1><p>split()方法可以实现将一个字符串按照指定的分隔符分成多个子串，这些子串会被保存至列表中，其语法格式为:</p>\n<p><code>string.split(sep,maxsplit)</code> </p>\n<ul>\n<li><p>string代表要分割的字符串</p>\n</li>\n<li><p>sep代表指定的分隔符，默认为None，也就是任何空字符，例如空格，\\n，\\t等</p>\n</li>\n<li><p>maxsplit代表最大分割次数，如果不指定或者指定为-1，则表示分割次数无限制。</p>\n</li>\n</ul>\n<p><strong>如果不指定sep，那么maxsplit也不能指定</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;192.168.0.0.1&quot;</span><br><span class=\"line\"># 指定分隔符为&apos;.&apos;，最大分割数为3次</span><br><span class=\"line\">list1 = str1.split(&apos;.&apos;,3)</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\"># 指定分割符为&apos;0.&apos;，最大分割数为-1</span><br><span class=\"line\">list1 = str1.split(&apos;0.&apos;,-1)</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\"># 不指定split()参数</span><br><span class=\"line\">list1 = str1.split()</span><br><span class=\"line\">print(list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;192&apos;, &apos;168&apos;, &apos;0&apos;, &apos;0.1&apos;]</span><br><span class=\"line\">[&apos;192.168.&apos;, &apos;&apos;, &apos;1&apos;]</span><br><span class=\"line\">[&apos;192.168.0.0.1&apos;]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-join-方法-合并字符串\"><a href=\"#Python-join-方法-合并字符串\" class=\"headerlink\" title=\"Python join()方法: 合并字符串\"></a>Python join()方法: 合并字符串</h1><p>join()方法算是split()方法的逆方法，它可以将列表(或元素)中多个字符串元素采用固定的连接负连接在一起，其语法格式为:</p>\n<p><code>newstr = str.join(iterable)</code> </p>\n<ul>\n<li><p>newstr代表合并后产生的新字符串.</p>\n</li>\n<li><p>str代表连接符</p>\n</li>\n<li><p>iterable代表合并操作的源字符串数据。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = [&apos;usr&apos;,&apos;bin&apos;,&apos;python3.7&apos;]</span><br><span class=\"line\">str1 = &apos;/&apos;.join(path)</span><br><span class=\"line\">print(str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/python3.7</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-count-方法，统计字符串出现的次数\"><a href=\"#Python-count-方法，统计字符串出现的次数\" class=\"headerlink\" title=\"Python count()方法，统计字符串出现的次数\"></a>Python count()方法，统计字符串出现的次数</h1><p>count()方法用于统计字符串在另一个字符串出现的次数，若不存在则返回0，否则返回统计的次数，其语法格式如下:</p>\n<p><code>string.count(sub[,start[,end]])</code> </p>\n<ul>\n<li><p>string代表字符串源</p>\n</li>\n<li><p>sub代表要检索的字符串</p>\n</li>\n<li><p>start代表检索字符串的起始位置，若不指定则默认为0开始</p>\n</li>\n<li><p>end指定检索的终止位置，若不指定则默认为字符串长度</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;</span><br><span class=\"line\">print(str1.count(&apos;嘻嘻哈哈&apos;,0,len(str1)))</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-find-方法：检测字符串中是否包含某个子串\"><a href=\"#Python-find-方法：检测字符串中是否包含某个子串\" class=\"headerlink\" title=\"Python find()方法：检测字符串中是否包含某个子串\"></a>Python find()方法：检测字符串中是否包含某个子串</h1><p>find()方法用于检索字符串中是否包含目标字符串，若包含则返回第一次出现该字符串的索引，否则返回-1。其语法格式为:</p>\n<p><code>string.find(sub,start,end)</code> </p>\n<ul>\n<li><p>string要检索的字符串源</p>\n</li>\n<li><p>sub要检索的子串</p>\n</li>\n<li><p>start检索的起始位置</p>\n</li>\n<li><p>end检索的终止位置</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;</span><br><span class=\"line\">print(str1.find(&quot;嘻嘻哈哈&quot;))</span><br><span class=\"line\">print(str1.find(&quot;嘻嘻哈哈&quot;,6,len(str1)))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">-1</span><br></pre></td></tr></table></figure>\n<p><strong>Python还提供了rfind()方法，与find()方法不同的是，其实从字符串的右侧开始检索</strong></p>\n<h1 id=\"Python-index-方法-检测字符串中是否包含某个字符串\"><a href=\"#Python-index-方法-检测字符串中是否包含某个字符串\" class=\"headerlink\" title=\"Python index()方法: 检测字符串中是否包含某个字符串\"></a>Python index()方法: 检测字符串中是否包含某个字符串</h1><p>index()方法与find()方法类似，唯一不同的是，index()方法检索子串若没找到，则会抛出异常。</p>\n<p>同理，Python也提供了个rindex()方法，作用于rfind()方法类似。</p>\n<h1 id=\"Python字符串对齐方法ljust-、rjust-和center-详解\"><a href=\"#Python字符串对齐方法ljust-、rjust-和center-详解\" class=\"headerlink\" title=\"Python字符串对齐方法ljust()、rjust()和center()详解\"></a>Python字符串对齐方法ljust()、rjust()和center()详解</h1><p>Python 的<code>str</code>类提供了3种可以用来进行文本对齐的方法，分别是ljust()，rjust()，center()</p>\n<h2 id=\"Python-ljust-方法\"><a href=\"#Python-ljust-方法\" class=\"headerlink\" title=\"Python ljust()方法\"></a>Python ljust()方法</h2><p>ljust()是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。语法格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string.ljust(width,fillchar)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>string 表示被填充的字符串</li>\n<li>width 表示包括string长度在内，字符串要占的总长度</li>\n<li>fillchar 表示填充时占位的字符，默认为空格</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &apos;HelloWorld&apos;</span><br><span class=\"line\">string2 = &quot;你好世界&quot;</span><br><span class=\"line\">print(string.ljust(15,&apos;*&apos;),string2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld***** 你好世界</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-rjust-方法\"><a href=\"#Python-rjust-方法\" class=\"headerlink\" title=\"Python rjust()方法\"></a>Python rjust()方法</h2><p>rjust()方法与ljust()方法类似，唯一不同的是rjust()方法是向字符串左侧填充字符以右对齐的目的。语法格式:</p>\n<p><code>str.rjust(width,fillchar)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.rjust(15,&apos;*&apos;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****HelloWorld</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-center-方法\"><a href=\"#Python-center-方法\" class=\"headerlink\" title=\"Python center()方法\"></a>Python center()方法</h2><p>center()方法与rjust()、ljust()方法类似，其作用是在字符串两边填充字符以进行居中对齐。语法格式:</p>\n<p><code>str.center(width,fillchar)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.center(20,&apos;*&apos;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>*****HelloWorld*****</code> </p>\n<h1 id=\"Python-startswith-和endswith-方法\"><a href=\"#Python-startswith-和endswith-方法\" class=\"headerlink\" title=\"Python startswith()和endswith()方法\"></a>Python startswith()和endswith()方法</h1><p>startswith()方法与endswith()方法都是用来检索指定字符串是否为字符串源的开头或结尾。</p>\n<h2 id=\"startswith-方法\"><a href=\"#startswith-方法\" class=\"headerlink\" title=\"startswith()方法\"></a>startswith()方法</h2><p>startswith()方法用于检索指定字符串是否为字符串源的开头。如果是返回True，否则反之。语法格式:</p>\n<p><code>str.startswith(sub,start,end)</code> </p>\n<ul>\n<li><p>str: 字符串源</p>\n</li>\n<li><p>sub: 指定的字符串（子串)</p>\n</li>\n<li><p>start: 指定开始检索的索引位置，可选参数，默认为开头。</p>\n</li>\n<li><p>end: 指定结束检索的索引位置，可选参数，默认为字符串源结尾。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.startswith(&quot;He&quot;,2))</span><br><span class=\"line\">print(string.startswith(&quot;Wo&quot;,5))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">False</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<h2 id=\"endswith-方法\"><a href=\"#endswith-方法\" class=\"headerlink\" title=\"endswith()方法\"></a>endswith()方法</h2><p>endswith()方法用于检索字符串是否以指定字符串结尾</p>\n<p>语法格式:</p>\n<p><code>str.endswith(sub,start,end)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.endswith(&apos;ld&apos;))</span><br><span class=\"line\">print(string.endswith(&apos;rl&apos;,0,len(string)-1))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">True</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<h1 id=\"Pyhton大小写转换-3种-函数及用法\"><a href=\"#Pyhton大小写转换-3种-函数及用法\" class=\"headerlink\" title=\"Pyhton大小写转换(3种)函数及用法\"></a>Pyhton大小写转换(3种)函数及用法</h1><p>Python提供了三种函数，方便用于转换字符串大小写，分别是title(),lower(),upper().</p>\n<h2 id=\"title-方法\"><a href=\"#title-方法\" class=\"headerlink\" title=\"title()方法\"></a>title()方法</h2><p>title()方法用于将字符串的字符转换为大写，其他字符转换为小写，并返回。</p>\n<p><strong>若不需要进行转换，则会直接返回</strong> </p>\n<p>语法格式:</p>\n<p><code>str.title()</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.title())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Helloworld</span><br></pre></td></tr></table></figure>\n<h2 id=\"lower-方法\"><a href=\"#lower-方法\" class=\"headerlink\" title=\"lower()方法\"></a>lower()方法</h2><p>lower()方法用于将字符串中大写的字符转换为小写字符，并返回。</p>\n<p>语法格式:</p>\n<p><code>str.lower()</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.lower())</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>helloworld</code> </p>\n<h2 id=\"upper-方法\"><a href=\"#upper-方法\" class=\"headerlink\" title=\"upper()方法\"></a>upper()方法</h2><p>upper()方法用于将字符串中小写的字符转换为大写字符，并返回。</p>\n<p>语法格式:</p>\n<p><code>str.upper()</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.upper())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>HELLOWORLD</code> </p>\n<h1 id=\"Python去除字符串中空格\"><a href=\"#Python去除字符串中空格\" class=\"headerlink\" title=\"Python去除字符串中空格\"></a>Python去除字符串中空格</h1><p>Python提供了三种方法，用于去除字符串中的特殊符号或指定字符，例如<strong>换行符(\\n)，回车符(\\r)，制表符(\\t)</strong>，它们分别是strip(),ltrip(),rtrip().</p>\n<h2 id=\"strip-方法\"><a href=\"#strip-方法\" class=\"headerlink\" title=\"strip()方法\"></a>strip()方法</h2><p>strip()用于去除字符串前后(左右侧)的特殊符号或指定字符。</p>\n<p>语法格式:</p>\n<p><code>str.strip(char)</code> </p>\n<ul>\n<li><p>str: 字符串源</p>\n</li>\n<li><p>char: 指定删除的字符，可选参数，默认为空格、换行符、回车符、制表符</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;\\r   排山倒海\\t\\n\\r&quot;</span><br><span class=\"line\">print(repr(string))</span><br><span class=\"line\">print(repr(string.strip()))</span><br><span class=\"line\">print(repr(string.strip(&apos;\\r&apos;)))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;\\r   排山倒海\\t\\n\\r&apos;</span><br><span class=\"line\">&apos;排山倒海&apos;</span><br><span class=\"line\">&apos;   排山倒海\\t\\n&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"lstrip-方法\"><a href=\"#lstrip-方法\" class=\"headerlink\" title=\"lstrip()方法\"></a>lstrip()方法</h2><p>lstrip方法用于去除字符串前(左侧)的特殊符号或指定字符。</p>\n<p>语法格式:</p>\n<p><code>str.lstrip(char)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;\\t\\n\\r排山倒海&quot;</span><br><span class=\"line\">print(repr(string))</span><br><span class=\"line\">print(repr(string.lstrip()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;\\t\\n\\r排山倒海&apos;</span><br><span class=\"line\">&apos;排山倒海&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"rstrip-方法\"><a href=\"#rstrip-方法\" class=\"headerlink\" title=\"rstrip()方法\"></a>rstrip()方法</h2><p>rstrip()方法与lstrip()方法以及strip()方法很类似，只不过其作用是去除字符串后(右侧)的特殊符号或指定字符。</p>\n<p>语法格式:</p>\n<p><code>str.rstrip(char)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;排山倒海\\t\\n\\r&quot;</span><br><span class=\"line\">print(repr(string))</span><br><span class=\"line\">print(repr(string.rstrip()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;排山倒海\\t\\n\\r&apos;</span><br><span class=\"line\">&apos;排山倒海&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-format-方法格式化输出方法详解\"><a href=\"#Python-format-方法格式化输出方法详解\" class=\"headerlink\" title=\"Python format()方法格式化输出方法详解\"></a>Python format()方法格式化输出方法详解</h1><p>语法格式:</p>\n<p><code>str.format(args)</code> </p>\n<ul>\n<li><p>str: 字符串源</p>\n</li>\n<li><p>args: 参数列表，使用逗号进行分割</p>\n</li>\n</ul>\n<p>format()方法的重点在于搞清楚str显示样式的格式。在差UN感觉爱你显示样式模板时，需要使用<code>{}</code>和<code>:</code>来指定占位符，其完整的语法格式为:</p>\n<p><code>{[index][:[[fill] align] [sign] [#] [width] [.precision] [type]]}</code> </p>\n<p><strong>注意,语法格式中的<code>[]</code>括起来的都是可选参数</strong> </p>\n<p>参数含义如下:</p>\n<ul>\n<li><p>index : 指定后面设置的格式要作用到args中第n个数据，数据的索引值从0开始，默认值为args中数据的先后顺序自动分配排列。</p>\n</li>\n<li><p>fill : 指定空白处填充的字符。注意，当填充字符为逗号<code>,</code>切作用于整数或浮点数时，该整数(或浮点数)会以逗号分隔的形式输出，例如(1000会输出1,000)。</p>\n</li>\n<li><p>align : 指定数据的对齐方式</p>\n</li>\n</ul>\n<p>align 参数及含义</p>\n<table>\n<thead>\n<tr>\n<th>align</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;</td>\n<td>数据左对齐</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>数据右对齐</td>\n</tr>\n<tr>\n<td>=</td>\n<td>数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对 数据类型有效</td>\n</tr>\n<tr>\n<td>^</td>\n<td>数据居中，此选项续和width参数一起使用</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>sign : 指定有无符号数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>sign</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>正数加正号，负数加负号</td>\n</tr>\n<tr>\n<td>-</td>\n<td>正数不加正好，负数加负号</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>正数前加空格，负数前加负号</td>\n</tr>\n<tr>\n<td>#</td>\n<td>对于二、八、十六进制数，使用此参数，会显示对应的前缀</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>width : 指定输出数据时所占的宽度。</p>\n</li>\n<li><p>.precision : 指定保留的小数位数。</p>\n</li>\n<li><p>type : 指定输出数据的具体类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>type类型值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>s</td>\n<td>对字符串类型格式化</td>\n</tr>\n<tr>\n<td>d</td>\n<td>十进制整数</td>\n</tr>\n<tr>\n<td>c</td>\n<td>将十进制整数自动转换成对应的 Unicode字符</td>\n</tr>\n<tr>\n<td>e或者E</td>\n<td>转换成科计数法后，再格式化输出</td>\n</tr>\n<tr>\n<td>g或G</td>\n<td>自动在e和f中切换</td>\n</tr>\n<tr>\n<td>b</td>\n<td>将十进制数自动转换成二进制表示，再格式化</td>\n</tr>\n<tr>\n<td>o</td>\n<td>将十进制数自动转换成八进制表示，再格式化</td>\n</tr>\n<tr>\n<td>x或X</td>\n<td>将十进制数自动转换成十六进制表示，再格式化</td>\n</tr>\n<tr>\n<td>f或F</td>\n<td>转换为浮点数(默认小数点后保留6位),再格式化输出</td>\n</tr>\n<tr>\n<td>%</td>\n<td>显示百分比(默认显示小数点后6位)</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;姓名:&#123;:&gt;5s&#125;\\n工资:&#123;:&gt;10.2F&#125;\\n&quot;</span><br><span class=\"line\">print(string.format(&quot;张三&quot;,1001.223))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">姓名:   张三</span><br><span class=\"line\">工资:   1001.22</span><br></pre></td></tr></table></figure>\n<p>例子2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 货币形式显示</span><br><span class=\"line\">print(&quot;$:&#123;:,d&#125;&quot;.format(1000009922399))</span><br><span class=\"line\"></span><br><span class=\"line\"># 科学计数法显示</span><br><span class=\"line\">print(&quot;科学计数法:&#123;:e&#125;&quot;.format(1000.123))</span><br><span class=\"line\"></span><br><span class=\"line\"># 十六进制显示</span><br><span class=\"line\">print(&quot;1016的十六进制:&#123;:x&#125;&quot;.format(1016))</span><br><span class=\"line\"></span><br><span class=\"line\"># 百分比形式显示</span><br><span class=\"line\">print(&quot;百分比显示:&#123;:.0%&#125;&quot;.format(0.99))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$:1,000,009,922,399</span><br><span class=\"line\">科学计数法:1.000123e+03</span><br><span class=\"line\">1016的十六进制:3f8</span><br><span class=\"line\">百分比显示:99%</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-encode-和decode-方法-字符串编码转换\"><a href=\"#Python-encode-和decode-方法-字符串编码转换\" class=\"headerlink\" title=\"Python encode()和decode()方法: 字符串编码转换\"></a>Python encode()和decode()方法: 字符串编码转换</h1><p>前言: 世界最早的字符编码时ASCII编码，它最多表示256个符号，每个符号占用1个字节，随着技术的发展，多国的文字都需要进行编码，所以出现了很多种编码格式，例如UTF-8也就是最通用的编码格式，Python3.x默认也是使用UTF-8编码格式。</p>\n<p>Python中有两种常用的字符串类型: <code>str</code>与<code>bytes</code>类型，<code>str</code>用来表示Unicode字符,<code>bytes</code>用来表示二进制数据。</p>\n<p>所以我们就需要使用<code>encode()</code>和<code>decode()</code>方法进行转换。</p>\n<h2 id=\"Phthon-encode-方法\"><a href=\"#Phthon-encode-方法\" class=\"headerlink\" title=\"Phthon encode()方法\"></a>Phthon encode()方法</h2><p>encode()方法是str提供的功法，其作用是将str类型转换成bytes类型，这个操作也被称为编码。</p>\n<p>语法格式如下:</p>\n<p><code>str.encode([encode=&quot;utf-8&quot;],[errors=&quot;strict&quot;])</code> </p>\n<ul>\n<li><p>encoding : 指定在编码时采用的字符编码，默认采用utf-8。当只有这个参数时，可以省略<code>=</code>直接写<code>str.encode(&quot;UTF-8&quot;)</code></p>\n</li>\n<li><p>errors : 指定错误处理方式，默认为strict，其可选项有:</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>errors</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>strict</td>\n<td>遇到非法字符就抛出异常</td>\n</tr>\n<tr>\n<td>ignore</td>\n<td>忽略非法字符</td>\n</tr>\n<tr>\n<td>replace</td>\n<td>用<code>?</code>替代非法字符</td>\n</tr>\n<tr>\n<td>xmlcharrefreplace</td>\n<td>使用xml的字符引用</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.encode())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>b&#39;HelloWorld&#39;</code> </p>\n<h2 id=\"Python-decode-方法\"><a href=\"#Python-decode-方法\" class=\"headerlink\" title=\"Python decode()方法\"></a>Python decode()方法</h2><p>decode()可以将bytes类型的二进制数据转换成str类型，这个过程被称为解码</p>\n<p>语法格式:</p>\n<p><code>bytes.decode([encoding=&quot;utf-8&quot;],[errors=&quot;strict&quot;])</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.encode())</span><br><span class=\"line\">print(bytes.decode(string.encode()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b&apos;HelloWorld&apos;</span><br><span class=\"line\">HelloWorld</span><br></pre></td></tr></table></figure>\n<p><strong>注意:解码时必须使用与编码时相同的编码格式，否则将会抛出异常</strong> </p>\n<h1 id=\"Python-dir-和help-帮助函数\"><a href=\"#Python-dir-和help-帮助函数\" class=\"headerlink\" title=\"Python dir()和help()帮助函数\"></a>Python dir()和help()帮助函数</h1><p>Python提供了两个函数，用于帮助程序员查询文档，掌握这两个函数则可以查看所有函数(方法)的用法及功能.</p>\n<p><strong>dir()</strong> 列出指定类或模块包含的全部内容，包括函数、方法、类、变量etc.</p>\n<p><strong>help()</strong> 查看某个函数或方法的帮助文档。</p>\n<p>例子:</p>\n<p>查看字符串能调用的全部内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(dir(str))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;_</span><br><span class=\"line\">_eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs</span><br><span class=\"line\">__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;</span><br><span class=\"line\">, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;,</span><br><span class=\"line\">&apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;</span><br><span class=\"line\">, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;e</span><br><span class=\"line\">ncode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isal</span><br><span class=\"line\">num&apos;, &apos;isalpha&apos;, &apos;isascii&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;</span><br><span class=\"line\">isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lo</span><br><span class=\"line\">wer&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;,</span><br><span class=\"line\"> &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;,</span><br><span class=\"line\"> &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</span><br></pre></td></tr></table></figure>\n<p><strong>注意:其中以<code>_</code>结尾的方法为私有方法，不希望被外界直接调用。</strong> </p>\n<p><strong>help()</strong> </p>\n<p>想要查看某个方法或函数的帮助文档，就使用help()函数</p>\n<p><code>print(help(str.format))</code> </p>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Help on method_descriptor:</span><br><span class=\"line\"></span><br><span class=\"line\">format(...)</span><br><span class=\"line\">    S.format(*args, **kwargs) -&gt; str</span><br><span class=\"line\"></span><br><span class=\"line\">    Return a formatted version of S, using substitutions from args and kwargs.</span><br><span class=\"line\">    The substitutions are identified by braces (&apos;&#123;&apos; and &apos;&#125;&apos;).</span><br><span class=\"line\">(END)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Python系列第五章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/str_method/\" target=\"_blank\" rel=\"noopener\">💿</a></p>","more":"<h1 id=\"Python字符串拼接-包含字符串拼接数字\"><a href=\"#Python字符串拼接-包含字符串拼接数字\" class=\"headerlink\" title=\"Python字符串拼接(包含字符串拼接数字)\"></a>Python字符串拼接(包含字符串拼接数字)</h1><p>先说一个Python中书写字符串的一种特殊方式，如果我们将两个字符串紧挨着写，那么Python则会自动拼接它们。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;Hello&quot;&apos;,World&apos;</span><br><span class=\"line\">print(str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>Hello,World</code> </p>\n<p><strong>Python字符串拼接数字</strong> </p>\n<p>某些场景下，我们需要将字符串与其他数据类型进行拼接，例如数字，但Python是不支持直接将数字与字符串拼接的，所以我们得先将数字转换成字符串，再进行拼接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;This number is:&quot;</span><br><span class=\"line\">number = 1.1001</span><br><span class=\"line\"># 使用str()方法将数值类型的变量转化成字符串</span><br><span class=\"line\">print(str1+str(number))</span><br><span class=\"line\"># 使用repr()方法将数值类型的变量转化成字符串</span><br><span class=\"line\">print(str1+repr(number))</span><br><span class=\"line\"># 直接将字符串类型与数值类型进行拼接</span><br><span class=\"line\">print(str1+number)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This number is:1.1001</span><br><span class=\"line\">This number is:1.1001</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class=\"line\">  │ print(str1+number)</span><br><span class=\"line\">TypeError: can only concatenate str (not &quot;float&quot;) to str</span><br></pre></td></tr></table></figure>\n<p>可以看到，我们必须先将数值类型的变量转换成字符串类型才能进行拼接，否则将会引发<code>TypeError</code>的错误。</p>\n<p><strong>str()与repr()的区别</strong> </p>\n<p>str()与repr()都可以将数值转换成字符串，但其中<strong>str是Python内置的类型，和int、float一样</strong> ，然而repr()则只是一个函数。</p>\n<p>repr()方法还可以以Python表达式的形式来表示值:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;This number is:&quot;</span><br><span class=\"line\">print(str1)</span><br><span class=\"line\">print(repr(str1))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This number is:</span><br><span class=\"line\">&apos;This number is:&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python截取字符串-字符串切片-方法详解\"><a href=\"#Python截取字符串-字符串切片-方法详解\" class=\"headerlink\" title=\"Python截取字符串(字符串切片)方法详解\"></a>Python截取字符串(字符串切片)方法详解</h1><p>Python的字符串实际上是由多个字符组成的，并且允许通过索引访问字符串的某个字符，其语法格式为:</p>\n<p><code>str[index]</code> </p>\n<p>str代表要获取的字符串，index代表字符串的某个下标。</p>\n<p>Python中字符串的第一个字符默认从0开始访问，依次推进则是0,1,2,n…，并且Python还允许使用负数作为索引下标，负数从-1开始，依次推进。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;HelloWorld&quot;</span><br><span class=\"line\"># 获取&apos;H&apos;</span><br><span class=\"line\">print(str1[0])</span><br><span class=\"line\"># 获取&apos;o&apos;</span><br><span class=\"line\">print(str1[-6])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H</span><br><span class=\"line\">o</span><br></pre></td></tr></table></figure>\n<p>除了通过索引单次获取单个字符外，Python还可以使用中括号对字符串以范围的方式获取，被获取的字符串称为”子串”，其语法格式为:</p>\n<p><code>string[start:end:step]</code> </p>\n<ul>\n<li>string代表要截取的字符串</li>\n<li>start代表要截取子串的开始位置</li>\n<li>end代表要截取子串的结束位置(不包括该字符)</li>\n<li>step代表从start开始，每step个距离获取一个字符。默认为1，可忽略该值。</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;HelloWorld&quot;</span><br><span class=\"line\"># 截取&apos;Hello&apos;</span><br><span class=\"line\">print(str1[0:6])</span><br><span class=\"line\"># 截取&apos;Hold&apos;</span><br><span class=\"line\">print(str1[0:len(str1):3])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloW</span><br><span class=\"line\">Hlod</span><br></pre></td></tr></table></figure>\n<p>Python还支持使用<code>in</code>运算符判断是否包含某个子串.</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;HelloWorld&quot;</span><br><span class=\"line\">print(&apos;Hello&apos; in str1)</span><br><span class=\"line\">print(&quot;World&quot; in str1)</span><br><span class=\"line\">print(&quot;Test&quot; in str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">True</span><br><span class=\"line\">True</span><br><span class=\"line\">False</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-len-函数详解-获取字符串长度或字节数\"><a href=\"#Python-len-函数详解-获取字符串长度或字节数\" class=\"headerlink\" title=\"Python len()函数详解:获取字符串长度或字节数\"></a>Python len()函数详解:获取字符串长度或字节数</h1><p>len()函数用于获取字符串的长度，或字符串占用的字节。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;HelloWorld&quot;</span><br><span class=\"line\">print(len(str1))</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>10</code> </p>\n<p>如果想知道字符串所占用的字节数，可以先将字符串编码后，再获取。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;你好世界&quot;</span><br><span class=\"line\">print(len(str1))</span><br><span class=\"line\">print(len(str1.encode()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p><code>encode()</code>方法可以将字符串转换成不同编码格式的字符。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=&quot;你好世界&quot;</span><br><span class=\"line\">print(len(str1.encode()))</span><br><span class=\"line\"># 将字符串转换成gbk编码格式</span><br><span class=\"line\">print(len(str1.encode(&apos;gbk&apos;)))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-split-方法详解-分割字符串\"><a href=\"#Python-split-方法详解-分割字符串\" class=\"headerlink\" title=\"Python split()方法详解: 分割字符串\"></a>Python split()方法详解: 分割字符串</h1><p>split()方法可以实现将一个字符串按照指定的分隔符分成多个子串，这些子串会被保存至列表中，其语法格式为:</p>\n<p><code>string.split(sep,maxsplit)</code> </p>\n<ul>\n<li><p>string代表要分割的字符串</p>\n</li>\n<li><p>sep代表指定的分隔符，默认为None，也就是任何空字符，例如空格，\\n，\\t等</p>\n</li>\n<li><p>maxsplit代表最大分割次数，如果不指定或者指定为-1，则表示分割次数无限制。</p>\n</li>\n</ul>\n<p><strong>如果不指定sep，那么maxsplit也不能指定</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;192.168.0.0.1&quot;</span><br><span class=\"line\"># 指定分隔符为&apos;.&apos;，最大分割数为3次</span><br><span class=\"line\">list1 = str1.split(&apos;.&apos;,3)</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\"># 指定分割符为&apos;0.&apos;，最大分割数为-1</span><br><span class=\"line\">list1 = str1.split(&apos;0.&apos;,-1)</span><br><span class=\"line\">print(list1)</span><br><span class=\"line\"># 不指定split()参数</span><br><span class=\"line\">list1 = str1.split()</span><br><span class=\"line\">print(list1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;192&apos;, &apos;168&apos;, &apos;0&apos;, &apos;0.1&apos;]</span><br><span class=\"line\">[&apos;192.168.&apos;, &apos;&apos;, &apos;1&apos;]</span><br><span class=\"line\">[&apos;192.168.0.0.1&apos;]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-join-方法-合并字符串\"><a href=\"#Python-join-方法-合并字符串\" class=\"headerlink\" title=\"Python join()方法: 合并字符串\"></a>Python join()方法: 合并字符串</h1><p>join()方法算是split()方法的逆方法，它可以将列表(或元素)中多个字符串元素采用固定的连接负连接在一起，其语法格式为:</p>\n<p><code>newstr = str.join(iterable)</code> </p>\n<ul>\n<li><p>newstr代表合并后产生的新字符串.</p>\n</li>\n<li><p>str代表连接符</p>\n</li>\n<li><p>iterable代表合并操作的源字符串数据。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = [&apos;usr&apos;,&apos;bin&apos;,&apos;python3.7&apos;]</span><br><span class=\"line\">str1 = &apos;/&apos;.join(path)</span><br><span class=\"line\">print(str1)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/python3.7</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-count-方法，统计字符串出现的次数\"><a href=\"#Python-count-方法，统计字符串出现的次数\" class=\"headerlink\" title=\"Python count()方法，统计字符串出现的次数\"></a>Python count()方法，统计字符串出现的次数</h1><p>count()方法用于统计字符串在另一个字符串出现的次数，若不存在则返回0，否则返回统计的次数，其语法格式如下:</p>\n<p><code>string.count(sub[,start[,end]])</code> </p>\n<ul>\n<li><p>string代表字符串源</p>\n</li>\n<li><p>sub代表要检索的字符串</p>\n</li>\n<li><p>start代表检索字符串的起始位置，若不指定则默认为0开始</p>\n</li>\n<li><p>end指定检索的终止位置，若不指定则默认为字符串长度</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;</span><br><span class=\"line\">print(str1.count(&apos;嘻嘻哈哈&apos;,0,len(str1)))</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-find-方法：检测字符串中是否包含某个子串\"><a href=\"#Python-find-方法：检测字符串中是否包含某个子串\" class=\"headerlink\" title=\"Python find()方法：检测字符串中是否包含某个子串\"></a>Python find()方法：检测字符串中是否包含某个子串</h1><p>find()方法用于检索字符串中是否包含目标字符串，若包含则返回第一次出现该字符串的索引，否则返回-1。其语法格式为:</p>\n<p><code>string.find(sub,start,end)</code> </p>\n<ul>\n<li><p>string要检索的字符串源</p>\n</li>\n<li><p>sub要检索的子串</p>\n</li>\n<li><p>start检索的起始位置</p>\n</li>\n<li><p>end检索的终止位置</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;</span><br><span class=\"line\">print(str1.find(&quot;嘻嘻哈哈&quot;))</span><br><span class=\"line\">print(str1.find(&quot;嘻嘻哈哈&quot;,6,len(str1)))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">-1</span><br></pre></td></tr></table></figure>\n<p><strong>Python还提供了rfind()方法，与find()方法不同的是，其实从字符串的右侧开始检索</strong></p>\n<h1 id=\"Python-index-方法-检测字符串中是否包含某个字符串\"><a href=\"#Python-index-方法-检测字符串中是否包含某个字符串\" class=\"headerlink\" title=\"Python index()方法: 检测字符串中是否包含某个字符串\"></a>Python index()方法: 检测字符串中是否包含某个字符串</h1><p>index()方法与find()方法类似，唯一不同的是，index()方法检索子串若没找到，则会抛出异常。</p>\n<p>同理，Python也提供了个rindex()方法，作用于rfind()方法类似。</p>\n<h1 id=\"Python字符串对齐方法ljust-、rjust-和center-详解\"><a href=\"#Python字符串对齐方法ljust-、rjust-和center-详解\" class=\"headerlink\" title=\"Python字符串对齐方法ljust()、rjust()和center()详解\"></a>Python字符串对齐方法ljust()、rjust()和center()详解</h1><p>Python 的<code>str</code>类提供了3种可以用来进行文本对齐的方法，分别是ljust()，rjust()，center()</p>\n<h2 id=\"Python-ljust-方法\"><a href=\"#Python-ljust-方法\" class=\"headerlink\" title=\"Python ljust()方法\"></a>Python ljust()方法</h2><p>ljust()是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。语法格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string.ljust(width,fillchar)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>string 表示被填充的字符串</li>\n<li>width 表示包括string长度在内，字符串要占的总长度</li>\n<li>fillchar 表示填充时占位的字符，默认为空格</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &apos;HelloWorld&apos;</span><br><span class=\"line\">string2 = &quot;你好世界&quot;</span><br><span class=\"line\">print(string.ljust(15,&apos;*&apos;),string2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloWorld***** 你好世界</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-rjust-方法\"><a href=\"#Python-rjust-方法\" class=\"headerlink\" title=\"Python rjust()方法\"></a>Python rjust()方法</h2><p>rjust()方法与ljust()方法类似，唯一不同的是rjust()方法是向字符串左侧填充字符以右对齐的目的。语法格式:</p>\n<p><code>str.rjust(width,fillchar)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.rjust(15,&apos;*&apos;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****HelloWorld</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python-center-方法\"><a href=\"#Python-center-方法\" class=\"headerlink\" title=\"Python center()方法\"></a>Python center()方法</h2><p>center()方法与rjust()、ljust()方法类似，其作用是在字符串两边填充字符以进行居中对齐。语法格式:</p>\n<p><code>str.center(width,fillchar)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.center(20,&apos;*&apos;))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>*****HelloWorld*****</code> </p>\n<h1 id=\"Python-startswith-和endswith-方法\"><a href=\"#Python-startswith-和endswith-方法\" class=\"headerlink\" title=\"Python startswith()和endswith()方法\"></a>Python startswith()和endswith()方法</h1><p>startswith()方法与endswith()方法都是用来检索指定字符串是否为字符串源的开头或结尾。</p>\n<h2 id=\"startswith-方法\"><a href=\"#startswith-方法\" class=\"headerlink\" title=\"startswith()方法\"></a>startswith()方法</h2><p>startswith()方法用于检索指定字符串是否为字符串源的开头。如果是返回True，否则反之。语法格式:</p>\n<p><code>str.startswith(sub,start,end)</code> </p>\n<ul>\n<li><p>str: 字符串源</p>\n</li>\n<li><p>sub: 指定的字符串（子串)</p>\n</li>\n<li><p>start: 指定开始检索的索引位置，可选参数，默认为开头。</p>\n</li>\n<li><p>end: 指定结束检索的索引位置，可选参数，默认为字符串源结尾。</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.startswith(&quot;He&quot;,2))</span><br><span class=\"line\">print(string.startswith(&quot;Wo&quot;,5))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">False</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<h2 id=\"endswith-方法\"><a href=\"#endswith-方法\" class=\"headerlink\" title=\"endswith()方法\"></a>endswith()方法</h2><p>endswith()方法用于检索字符串是否以指定字符串结尾</p>\n<p>语法格式:</p>\n<p><code>str.endswith(sub,start,end)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.endswith(&apos;ld&apos;))</span><br><span class=\"line\">print(string.endswith(&apos;rl&apos;,0,len(string)-1))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">True</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<h1 id=\"Pyhton大小写转换-3种-函数及用法\"><a href=\"#Pyhton大小写转换-3种-函数及用法\" class=\"headerlink\" title=\"Pyhton大小写转换(3种)函数及用法\"></a>Pyhton大小写转换(3种)函数及用法</h1><p>Python提供了三种函数，方便用于转换字符串大小写，分别是title(),lower(),upper().</p>\n<h2 id=\"title-方法\"><a href=\"#title-方法\" class=\"headerlink\" title=\"title()方法\"></a>title()方法</h2><p>title()方法用于将字符串的字符转换为大写，其他字符转换为小写，并返回。</p>\n<p><strong>若不需要进行转换，则会直接返回</strong> </p>\n<p>语法格式:</p>\n<p><code>str.title()</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.title())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Helloworld</span><br></pre></td></tr></table></figure>\n<h2 id=\"lower-方法\"><a href=\"#lower-方法\" class=\"headerlink\" title=\"lower()方法\"></a>lower()方法</h2><p>lower()方法用于将字符串中大写的字符转换为小写字符，并返回。</p>\n<p>语法格式:</p>\n<p><code>str.lower()</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.lower())</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>helloworld</code> </p>\n<h2 id=\"upper-方法\"><a href=\"#upper-方法\" class=\"headerlink\" title=\"upper()方法\"></a>upper()方法</h2><p>upper()方法用于将字符串中小写的字符转换为大写字符，并返回。</p>\n<p>语法格式:</p>\n<p><code>str.upper()</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.upper())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>HELLOWORLD</code> </p>\n<h1 id=\"Python去除字符串中空格\"><a href=\"#Python去除字符串中空格\" class=\"headerlink\" title=\"Python去除字符串中空格\"></a>Python去除字符串中空格</h1><p>Python提供了三种方法，用于去除字符串中的特殊符号或指定字符，例如<strong>换行符(\\n)，回车符(\\r)，制表符(\\t)</strong>，它们分别是strip(),ltrip(),rtrip().</p>\n<h2 id=\"strip-方法\"><a href=\"#strip-方法\" class=\"headerlink\" title=\"strip()方法\"></a>strip()方法</h2><p>strip()用于去除字符串前后(左右侧)的特殊符号或指定字符。</p>\n<p>语法格式:</p>\n<p><code>str.strip(char)</code> </p>\n<ul>\n<li><p>str: 字符串源</p>\n</li>\n<li><p>char: 指定删除的字符，可选参数，默认为空格、换行符、回车符、制表符</p>\n</li>\n</ul>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;\\r   排山倒海\\t\\n\\r&quot;</span><br><span class=\"line\">print(repr(string))</span><br><span class=\"line\">print(repr(string.strip()))</span><br><span class=\"line\">print(repr(string.strip(&apos;\\r&apos;)))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;\\r   排山倒海\\t\\n\\r&apos;</span><br><span class=\"line\">&apos;排山倒海&apos;</span><br><span class=\"line\">&apos;   排山倒海\\t\\n&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"lstrip-方法\"><a href=\"#lstrip-方法\" class=\"headerlink\" title=\"lstrip()方法\"></a>lstrip()方法</h2><p>lstrip方法用于去除字符串前(左侧)的特殊符号或指定字符。</p>\n<p>语法格式:</p>\n<p><code>str.lstrip(char)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;\\t\\n\\r排山倒海&quot;</span><br><span class=\"line\">print(repr(string))</span><br><span class=\"line\">print(repr(string.lstrip()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;\\t\\n\\r排山倒海&apos;</span><br><span class=\"line\">&apos;排山倒海&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"rstrip-方法\"><a href=\"#rstrip-方法\" class=\"headerlink\" title=\"rstrip()方法\"></a>rstrip()方法</h2><p>rstrip()方法与lstrip()方法以及strip()方法很类似，只不过其作用是去除字符串后(右侧)的特殊符号或指定字符。</p>\n<p>语法格式:</p>\n<p><code>str.rstrip(char)</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;排山倒海\\t\\n\\r&quot;</span><br><span class=\"line\">print(repr(string))</span><br><span class=\"line\">print(repr(string.rstrip()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;排山倒海\\t\\n\\r&apos;</span><br><span class=\"line\">&apos;排山倒海&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-format-方法格式化输出方法详解\"><a href=\"#Python-format-方法格式化输出方法详解\" class=\"headerlink\" title=\"Python format()方法格式化输出方法详解\"></a>Python format()方法格式化输出方法详解</h1><p>语法格式:</p>\n<p><code>str.format(args)</code> </p>\n<ul>\n<li><p>str: 字符串源</p>\n</li>\n<li><p>args: 参数列表，使用逗号进行分割</p>\n</li>\n</ul>\n<p>format()方法的重点在于搞清楚str显示样式的格式。在差UN感觉爱你显示样式模板时，需要使用<code>{}</code>和<code>:</code>来指定占位符，其完整的语法格式为:</p>\n<p><code>{[index][:[[fill] align] [sign] [#] [width] [.precision] [type]]}</code> </p>\n<p><strong>注意,语法格式中的<code>[]</code>括起来的都是可选参数</strong> </p>\n<p>参数含义如下:</p>\n<ul>\n<li><p>index : 指定后面设置的格式要作用到args中第n个数据，数据的索引值从0开始，默认值为args中数据的先后顺序自动分配排列。</p>\n</li>\n<li><p>fill : 指定空白处填充的字符。注意，当填充字符为逗号<code>,</code>切作用于整数或浮点数时，该整数(或浮点数)会以逗号分隔的形式输出，例如(1000会输出1,000)。</p>\n</li>\n<li><p>align : 指定数据的对齐方式</p>\n</li>\n</ul>\n<p>align 参数及含义</p>\n<table>\n<thead>\n<tr>\n<th>align</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;</td>\n<td>数据左对齐</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>数据右对齐</td>\n</tr>\n<tr>\n<td>=</td>\n<td>数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对 数据类型有效</td>\n</tr>\n<tr>\n<td>^</td>\n<td>数据居中，此选项续和width参数一起使用</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>sign : 指定有无符号数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>sign</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>正数加正号，负数加负号</td>\n</tr>\n<tr>\n<td>-</td>\n<td>正数不加正好，负数加负号</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>正数前加空格，负数前加负号</td>\n</tr>\n<tr>\n<td>#</td>\n<td>对于二、八、十六进制数，使用此参数，会显示对应的前缀</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>width : 指定输出数据时所占的宽度。</p>\n</li>\n<li><p>.precision : 指定保留的小数位数。</p>\n</li>\n<li><p>type : 指定输出数据的具体类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>type类型值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>s</td>\n<td>对字符串类型格式化</td>\n</tr>\n<tr>\n<td>d</td>\n<td>十进制整数</td>\n</tr>\n<tr>\n<td>c</td>\n<td>将十进制整数自动转换成对应的 Unicode字符</td>\n</tr>\n<tr>\n<td>e或者E</td>\n<td>转换成科计数法后，再格式化输出</td>\n</tr>\n<tr>\n<td>g或G</td>\n<td>自动在e和f中切换</td>\n</tr>\n<tr>\n<td>b</td>\n<td>将十进制数自动转换成二进制表示，再格式化</td>\n</tr>\n<tr>\n<td>o</td>\n<td>将十进制数自动转换成八进制表示，再格式化</td>\n</tr>\n<tr>\n<td>x或X</td>\n<td>将十进制数自动转换成十六进制表示，再格式化</td>\n</tr>\n<tr>\n<td>f或F</td>\n<td>转换为浮点数(默认小数点后保留6位),再格式化输出</td>\n</tr>\n<tr>\n<td>%</td>\n<td>显示百分比(默认显示小数点后6位)</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;姓名:&#123;:&gt;5s&#125;\\n工资:&#123;:&gt;10.2F&#125;\\n&quot;</span><br><span class=\"line\">print(string.format(&quot;张三&quot;,1001.223))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">姓名:   张三</span><br><span class=\"line\">工资:   1001.22</span><br></pre></td></tr></table></figure>\n<p>例子2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 货币形式显示</span><br><span class=\"line\">print(&quot;$:&#123;:,d&#125;&quot;.format(1000009922399))</span><br><span class=\"line\"></span><br><span class=\"line\"># 科学计数法显示</span><br><span class=\"line\">print(&quot;科学计数法:&#123;:e&#125;&quot;.format(1000.123))</span><br><span class=\"line\"></span><br><span class=\"line\"># 十六进制显示</span><br><span class=\"line\">print(&quot;1016的十六进制:&#123;:x&#125;&quot;.format(1016))</span><br><span class=\"line\"></span><br><span class=\"line\"># 百分比形式显示</span><br><span class=\"line\">print(&quot;百分比显示:&#123;:.0%&#125;&quot;.format(0.99))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$:1,000,009,922,399</span><br><span class=\"line\">科学计数法:1.000123e+03</span><br><span class=\"line\">1016的十六进制:3f8</span><br><span class=\"line\">百分比显示:99%</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-encode-和decode-方法-字符串编码转换\"><a href=\"#Python-encode-和decode-方法-字符串编码转换\" class=\"headerlink\" title=\"Python encode()和decode()方法: 字符串编码转换\"></a>Python encode()和decode()方法: 字符串编码转换</h1><p>前言: 世界最早的字符编码时ASCII编码，它最多表示256个符号，每个符号占用1个字节，随着技术的发展，多国的文字都需要进行编码，所以出现了很多种编码格式，例如UTF-8也就是最通用的编码格式，Python3.x默认也是使用UTF-8编码格式。</p>\n<p>Python中有两种常用的字符串类型: <code>str</code>与<code>bytes</code>类型，<code>str</code>用来表示Unicode字符,<code>bytes</code>用来表示二进制数据。</p>\n<p>所以我们就需要使用<code>encode()</code>和<code>decode()</code>方法进行转换。</p>\n<h2 id=\"Phthon-encode-方法\"><a href=\"#Phthon-encode-方法\" class=\"headerlink\" title=\"Phthon encode()方法\"></a>Phthon encode()方法</h2><p>encode()方法是str提供的功法，其作用是将str类型转换成bytes类型，这个操作也被称为编码。</p>\n<p>语法格式如下:</p>\n<p><code>str.encode([encode=&quot;utf-8&quot;],[errors=&quot;strict&quot;])</code> </p>\n<ul>\n<li><p>encoding : 指定在编码时采用的字符编码，默认采用utf-8。当只有这个参数时，可以省略<code>=</code>直接写<code>str.encode(&quot;UTF-8&quot;)</code></p>\n</li>\n<li><p>errors : 指定错误处理方式，默认为strict，其可选项有:</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>errors</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>strict</td>\n<td>遇到非法字符就抛出异常</td>\n</tr>\n<tr>\n<td>ignore</td>\n<td>忽略非法字符</td>\n</tr>\n<tr>\n<td>replace</td>\n<td>用<code>?</code>替代非法字符</td>\n</tr>\n<tr>\n<td>xmlcharrefreplace</td>\n<td>使用xml的字符引用</td>\n</tr>\n</tbody>\n</table>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.encode())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>b&#39;HelloWorld&#39;</code> </p>\n<h2 id=\"Python-decode-方法\"><a href=\"#Python-decode-方法\" class=\"headerlink\" title=\"Python decode()方法\"></a>Python decode()方法</h2><p>decode()可以将bytes类型的二进制数据转换成str类型，这个过程被称为解码</p>\n<p>语法格式:</p>\n<p><code>bytes.decode([encoding=&quot;utf-8&quot;],[errors=&quot;strict&quot;])</code> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print(string.encode())</span><br><span class=\"line\">print(bytes.decode(string.encode()))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b&apos;HelloWorld&apos;</span><br><span class=\"line\">HelloWorld</span><br></pre></td></tr></table></figure>\n<p><strong>注意:解码时必须使用与编码时相同的编码格式，否则将会抛出异常</strong> </p>\n<h1 id=\"Python-dir-和help-帮助函数\"><a href=\"#Python-dir-和help-帮助函数\" class=\"headerlink\" title=\"Python dir()和help()帮助函数\"></a>Python dir()和help()帮助函数</h1><p>Python提供了两个函数，用于帮助程序员查询文档，掌握这两个函数则可以查看所有函数(方法)的用法及功能.</p>\n<p><strong>dir()</strong> 列出指定类或模块包含的全部内容，包括函数、方法、类、变量etc.</p>\n<p><strong>help()</strong> 查看某个函数或方法的帮助文档。</p>\n<p>例子:</p>\n<p>查看字符串能调用的全部内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(dir(str))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;_</span><br><span class=\"line\">_eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs</span><br><span class=\"line\">__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;</span><br><span class=\"line\">, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;,</span><br><span class=\"line\">&apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;</span><br><span class=\"line\">, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;e</span><br><span class=\"line\">ncode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isal</span><br><span class=\"line\">num&apos;, &apos;isalpha&apos;, &apos;isascii&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;</span><br><span class=\"line\">isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lo</span><br><span class=\"line\">wer&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;,</span><br><span class=\"line\"> &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;,</span><br><span class=\"line\"> &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</span><br></pre></td></tr></table></figure>\n<p><strong>注意:其中以<code>_</code>结尾的方法为私有方法，不希望被外界直接调用。</strong> </p>\n<p><strong>help()</strong> </p>\n<p>想要查看某个方法或函数的帮助文档，就使用help()函数</p>\n<p><code>print(help(str.format))</code> </p>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Help on method_descriptor:</span><br><span class=\"line\"></span><br><span class=\"line\">format(...)</span><br><span class=\"line\">    S.format(*args, **kwargs) -&gt; str</span><br><span class=\"line\"></span><br><span class=\"line\">    Return a formatted version of S, using substitutions from args and kwargs.</span><br><span class=\"line\">    The substitutions are identified by braces (&apos;&#123;&apos; and &apos;&#125;&apos;).</span><br><span class=\"line\">(END)</span><br></pre></td></tr></table></figure>"},{"title":"Rust-理解所有权","copyright":true,"date":"2019-07-29T19:11:46.000Z","_content":"\n根据Rust中文学习了些Rust的知识，所以记录下Rust中很重要的特性之一:所有权\n<!--more-->\n\n# 认识所有权\n\n所有权是Rust最独特的功能，使得Rust不需要GC即可保证内存安全.\n\n本篇文章介绍所有权及其相关功能：借用、slice，以及Rust如何在内存中布局数据\n\n# 什么是所有权\n\n所有权（ownership)是Rust的核心特性之一，其最大的特点是解决了目前大部分编程语言对内存管理方式的缺陷，例如:一些语言通过GC(垃圾回收机制)进行管理内存，在程序运行时不断的寻找无用的内存，但这种方式会使得程序的效率降低。另一种方式则是内存的分配和释放由程序员进行管理，所以经常会出现遗漏或设计缺陷，从而使得程序问题不断。而Rust的所有权特性则恰好解决了以上两个常见的问题。\n\n在理解所有权之前，让我们先了解一个常用的数据结构:Stack Heap.\n\n## 栈(Stack) 与 堆(Heap)\n\n> 程序是由__算法__和__数据__组成的，`栈堆`这种数据结构则是一种处理数据的算法，而在所有权的概念中，数据是存在栈上还是堆上很大的影响了程序的行为。\n\n`栈`的结构是一种后进先出的方式处理数据的，生活中的羽毛球例子可以清晰的描述这一关系:当我们将羽毛球放入羽毛球桶时，想要拿走时，总是拿走的最后一个放入的羽毛球，我们不能拿走最后一个放入之前的羽毛球。我们把放入羽毛球(增加数据)叫做__入栈__，拿出羽毛球(移出数据)叫做__出栈__。\n\n__'栈'的优点是，速度快。这主要是因为如果要获取数据则总是从栈顶直接获取，而不需要寻找某个特定的位置需要读取数据。第二个原因是:栈中数据所占内存大小都已固定也可知。__\n\n`堆`的结构是一种随机的方式处理数据的，生活中的例子每天吃饭可以清晰的描述这一关系:一日三餐，我们总是会想要吃什么，世界上有那么多美食，此时我们就需要选择想要的菜品才能进食，并且在要选择菜品时，我们还必须考虑是否有足够的金钱付款，而在我们选择菜品时是根据菜名通过服务员才能让厨房处理，最终上菜。我们把为菜品付款称作在__堆上分配内存__，而菜名称作__指针__，我们需要通过通过指针访问在堆上分配的内存.\n\n__`堆`的优点是，不受限于只能获取最后一个存入的数据，因为数据都是成堆摆布的，如果需要访问需要通过指针__。\n\n`堆`对数据的操作速度没有`栈`快，因为`堆`需要通过指针才能访问数据.\n\n若数据大部分存在`堆`上，则有可能出现一些重复数据，为了清除这些无用的数据，确保内存空间不会被耗尽。这些问题正是所有权系统需要处理的。想必读者们也应该知道，所有权的存在就是为了管理堆数据的，当你理解了所有权后，将在编码时不用总考虑栈和堆了。\n\n# 所有权规则\n\n- Rust中，每一个值都有一个称为__所有者(owner)的变量。\n\n- 值只能有一个所有者。\n\n- 当所有者离开作用域，这个值则会被遗弃。\n\n# 变量作用域\n\n让我们看第一个关于所有权的例子\n\n~~~\n// 在这里使用s无效，s尚未生命\n{\n    let s = \"hello\"; // 从此处起，s 有效\n\n}\n// 在这里使用s无效，因为作用域已结束\n~~~\n\n这个例子中，当`s`进入作用域后，直到它离开作用域为止，它一直是有效的。\n\n\n\n\n","source":"_posts/Rust-理解所有权.md","raw":"---\ntitle: Rust-理解所有权\ncopyright: true\ndate: 2019-07-30 03:11:46\ncategories: 学习笔记\ntags:\n - Rust\n---\n\n根据Rust中文学习了些Rust的知识，所以记录下Rust中很重要的特性之一:所有权\n<!--more-->\n\n# 认识所有权\n\n所有权是Rust最独特的功能，使得Rust不需要GC即可保证内存安全.\n\n本篇文章介绍所有权及其相关功能：借用、slice，以及Rust如何在内存中布局数据\n\n# 什么是所有权\n\n所有权（ownership)是Rust的核心特性之一，其最大的特点是解决了目前大部分编程语言对内存管理方式的缺陷，例如:一些语言通过GC(垃圾回收机制)进行管理内存，在程序运行时不断的寻找无用的内存，但这种方式会使得程序的效率降低。另一种方式则是内存的分配和释放由程序员进行管理，所以经常会出现遗漏或设计缺陷，从而使得程序问题不断。而Rust的所有权特性则恰好解决了以上两个常见的问题。\n\n在理解所有权之前，让我们先了解一个常用的数据结构:Stack Heap.\n\n## 栈(Stack) 与 堆(Heap)\n\n> 程序是由__算法__和__数据__组成的，`栈堆`这种数据结构则是一种处理数据的算法，而在所有权的概念中，数据是存在栈上还是堆上很大的影响了程序的行为。\n\n`栈`的结构是一种后进先出的方式处理数据的，生活中的羽毛球例子可以清晰的描述这一关系:当我们将羽毛球放入羽毛球桶时，想要拿走时，总是拿走的最后一个放入的羽毛球，我们不能拿走最后一个放入之前的羽毛球。我们把放入羽毛球(增加数据)叫做__入栈__，拿出羽毛球(移出数据)叫做__出栈__。\n\n__'栈'的优点是，速度快。这主要是因为如果要获取数据则总是从栈顶直接获取，而不需要寻找某个特定的位置需要读取数据。第二个原因是:栈中数据所占内存大小都已固定也可知。__\n\n`堆`的结构是一种随机的方式处理数据的，生活中的例子每天吃饭可以清晰的描述这一关系:一日三餐，我们总是会想要吃什么，世界上有那么多美食，此时我们就需要选择想要的菜品才能进食，并且在要选择菜品时，我们还必须考虑是否有足够的金钱付款，而在我们选择菜品时是根据菜名通过服务员才能让厨房处理，最终上菜。我们把为菜品付款称作在__堆上分配内存__，而菜名称作__指针__，我们需要通过通过指针访问在堆上分配的内存.\n\n__`堆`的优点是，不受限于只能获取最后一个存入的数据，因为数据都是成堆摆布的，如果需要访问需要通过指针__。\n\n`堆`对数据的操作速度没有`栈`快，因为`堆`需要通过指针才能访问数据.\n\n若数据大部分存在`堆`上，则有可能出现一些重复数据，为了清除这些无用的数据，确保内存空间不会被耗尽。这些问题正是所有权系统需要处理的。想必读者们也应该知道，所有权的存在就是为了管理堆数据的，当你理解了所有权后，将在编码时不用总考虑栈和堆了。\n\n# 所有权规则\n\n- Rust中，每一个值都有一个称为__所有者(owner)的变量。\n\n- 值只能有一个所有者。\n\n- 当所有者离开作用域，这个值则会被遗弃。\n\n# 变量作用域\n\n让我们看第一个关于所有权的例子\n\n~~~\n// 在这里使用s无效，s尚未生命\n{\n    let s = \"hello\"; // 从此处起，s 有效\n\n}\n// 在这里使用s无效，因为作用域已结束\n~~~\n\n这个例子中，当`s`进入作用域后，直到它离开作用域为止，它一直是有效的。\n\n\n\n\n","slug":"Rust-理解所有权","published":1,"updated":"2020-01-19T03:49:51.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocs004bomoorh9xatxz","content":"<p>根据Rust中文学习了些Rust的知识，所以记录下Rust中很重要的特性之一:所有权<br><a id=\"more\"></a></p>\n<h1 id=\"认识所有权\"><a href=\"#认识所有权\" class=\"headerlink\" title=\"认识所有权\"></a>认识所有权</h1><p>所有权是Rust最独特的功能，使得Rust不需要GC即可保证内存安全.</p>\n<p>本篇文章介绍所有权及其相关功能：借用、slice，以及Rust如何在内存中布局数据</p>\n<h1 id=\"什么是所有权\"><a href=\"#什么是所有权\" class=\"headerlink\" title=\"什么是所有权\"></a>什么是所有权</h1><p>所有权（ownership)是Rust的核心特性之一，其最大的特点是解决了目前大部分编程语言对内存管理方式的缺陷，例如:一些语言通过GC(垃圾回收机制)进行管理内存，在程序运行时不断的寻找无用的内存，但这种方式会使得程序的效率降低。另一种方式则是内存的分配和释放由程序员进行管理，所以经常会出现遗漏或设计缺陷，从而使得程序问题不断。而Rust的所有权特性则恰好解决了以上两个常见的问题。</p>\n<p>在理解所有权之前，让我们先了解一个常用的数据结构:Stack Heap.</p>\n<h2 id=\"栈-Stack-与-堆-Heap\"><a href=\"#栈-Stack-与-堆-Heap\" class=\"headerlink\" title=\"栈(Stack) 与 堆(Heap)\"></a>栈(Stack) 与 堆(Heap)</h2><blockquote>\n<p>程序是由<strong>算法</strong>和<strong>数据</strong>组成的，<code>栈堆</code>这种数据结构则是一种处理数据的算法，而在所有权的概念中，数据是存在栈上还是堆上很大的影响了程序的行为。</p>\n</blockquote>\n<p><code>栈</code>的结构是一种后进先出的方式处理数据的，生活中的羽毛球例子可以清晰的描述这一关系:当我们将羽毛球放入羽毛球桶时，想要拿走时，总是拿走的最后一个放入的羽毛球，我们不能拿走最后一个放入之前的羽毛球。我们把放入羽毛球(增加数据)叫做<strong>入栈</strong>，拿出羽毛球(移出数据)叫做<strong>出栈</strong>。</p>\n<p><strong>‘栈’的优点是，速度快。这主要是因为如果要获取数据则总是从栈顶直接获取，而不需要寻找某个特定的位置需要读取数据。第二个原因是:栈中数据所占内存大小都已固定也可知。</strong></p>\n<p><code>堆</code>的结构是一种随机的方式处理数据的，生活中的例子每天吃饭可以清晰的描述这一关系:一日三餐，我们总是会想要吃什么，世界上有那么多美食，此时我们就需要选择想要的菜品才能进食，并且在要选择菜品时，我们还必须考虑是否有足够的金钱付款，而在我们选择菜品时是根据菜名通过服务员才能让厨房处理，最终上菜。我们把为菜品付款称作在<strong>堆上分配内存</strong>，而菜名称作<strong>指针</strong>，我们需要通过通过指针访问在堆上分配的内存.</p>\n<p><strong><code>堆</code>的优点是，不受限于只能获取最后一个存入的数据，因为数据都是成堆摆布的，如果需要访问需要通过指针</strong>。</p>\n<p><code>堆</code>对数据的操作速度没有<code>栈</code>快，因为<code>堆</code>需要通过指针才能访问数据.</p>\n<p>若数据大部分存在<code>堆</code>上，则有可能出现一些重复数据，为了清除这些无用的数据，确保内存空间不会被耗尽。这些问题正是所有权系统需要处理的。想必读者们也应该知道，所有权的存在就是为了管理堆数据的，当你理解了所有权后，将在编码时不用总考虑栈和堆了。</p>\n<h1 id=\"所有权规则\"><a href=\"#所有权规则\" class=\"headerlink\" title=\"所有权规则\"></a>所有权规则</h1><ul>\n<li><p>Rust中，每一个值都有一个称为__所有者(owner)的变量。</p>\n</li>\n<li><p>值只能有一个所有者。</p>\n</li>\n<li><p>当所有者离开作用域，这个值则会被遗弃。</p>\n</li>\n</ul>\n<h1 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h1><p>让我们看第一个关于所有权的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在这里使用s无效，s尚未生命</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let s = &quot;hello&quot;; // 从此处起，s 有效</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 在这里使用s无效，因为作用域已结束</span><br></pre></td></tr></table></figure>\n<p>这个例子中，当<code>s</code>进入作用域后，直到它离开作用域为止，它一直是有效的。</p>\n","site":{"data":{}},"excerpt":"<p>根据Rust中文学习了些Rust的知识，所以记录下Rust中很重要的特性之一:所有权<br></p>","more":"<p></p>\n<h1 id=\"认识所有权\"><a href=\"#认识所有权\" class=\"headerlink\" title=\"认识所有权\"></a>认识所有权</h1><p>所有权是Rust最独特的功能，使得Rust不需要GC即可保证内存安全.</p>\n<p>本篇文章介绍所有权及其相关功能：借用、slice，以及Rust如何在内存中布局数据</p>\n<h1 id=\"什么是所有权\"><a href=\"#什么是所有权\" class=\"headerlink\" title=\"什么是所有权\"></a>什么是所有权</h1><p>所有权（ownership)是Rust的核心特性之一，其最大的特点是解决了目前大部分编程语言对内存管理方式的缺陷，例如:一些语言通过GC(垃圾回收机制)进行管理内存，在程序运行时不断的寻找无用的内存，但这种方式会使得程序的效率降低。另一种方式则是内存的分配和释放由程序员进行管理，所以经常会出现遗漏或设计缺陷，从而使得程序问题不断。而Rust的所有权特性则恰好解决了以上两个常见的问题。</p>\n<p>在理解所有权之前，让我们先了解一个常用的数据结构:Stack Heap.</p>\n<h2 id=\"栈-Stack-与-堆-Heap\"><a href=\"#栈-Stack-与-堆-Heap\" class=\"headerlink\" title=\"栈(Stack) 与 堆(Heap)\"></a>栈(Stack) 与 堆(Heap)</h2><blockquote>\n<p>程序是由<strong>算法</strong>和<strong>数据</strong>组成的，<code>栈堆</code>这种数据结构则是一种处理数据的算法，而在所有权的概念中，数据是存在栈上还是堆上很大的影响了程序的行为。</p>\n</blockquote>\n<p><code>栈</code>的结构是一种后进先出的方式处理数据的，生活中的羽毛球例子可以清晰的描述这一关系:当我们将羽毛球放入羽毛球桶时，想要拿走时，总是拿走的最后一个放入的羽毛球，我们不能拿走最后一个放入之前的羽毛球。我们把放入羽毛球(增加数据)叫做<strong>入栈</strong>，拿出羽毛球(移出数据)叫做<strong>出栈</strong>。</p>\n<p><strong>‘栈’的优点是，速度快。这主要是因为如果要获取数据则总是从栈顶直接获取，而不需要寻找某个特定的位置需要读取数据。第二个原因是:栈中数据所占内存大小都已固定也可知。</strong></p>\n<p><code>堆</code>的结构是一种随机的方式处理数据的，生活中的例子每天吃饭可以清晰的描述这一关系:一日三餐，我们总是会想要吃什么，世界上有那么多美食，此时我们就需要选择想要的菜品才能进食，并且在要选择菜品时，我们还必须考虑是否有足够的金钱付款，而在我们选择菜品时是根据菜名通过服务员才能让厨房处理，最终上菜。我们把为菜品付款称作在<strong>堆上分配内存</strong>，而菜名称作<strong>指针</strong>，我们需要通过通过指针访问在堆上分配的内存.</p>\n<p><strong><code>堆</code>的优点是，不受限于只能获取最后一个存入的数据，因为数据都是成堆摆布的，如果需要访问需要通过指针</strong>。</p>\n<p><code>堆</code>对数据的操作速度没有<code>栈</code>快，因为<code>堆</code>需要通过指针才能访问数据.</p>\n<p>若数据大部分存在<code>堆</code>上，则有可能出现一些重复数据，为了清除这些无用的数据，确保内存空间不会被耗尽。这些问题正是所有权系统需要处理的。想必读者们也应该知道，所有权的存在就是为了管理堆数据的，当你理解了所有权后，将在编码时不用总考虑栈和堆了。</p>\n<h1 id=\"所有权规则\"><a href=\"#所有权规则\" class=\"headerlink\" title=\"所有权规则\"></a>所有权规则</h1><ul>\n<li><p>Rust中，每一个值都有一个称为__所有者(owner)的变量。</p>\n</li>\n<li><p>值只能有一个所有者。</p>\n</li>\n<li><p>当所有者离开作用域，这个值则会被遗弃。</p>\n</li>\n</ul>\n<h1 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h1><p>让我们看第一个关于所有权的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在这里使用s无效，s尚未生命</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let s = &quot;hello&quot;; // 从此处起，s 有效</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 在这里使用s无效，因为作用域已结束</span><br></pre></td></tr></table></figure>\n<p>这个例子中，当<code>s</code>进入作用域后，直到它离开作用域为止，它一直是有效的。</p>"},{"title":"[Python-06]Python流程控制","copyright":true,"date":"2019-09-28T06:14:26.000Z","_content":"\nPython系列第六章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/str_method/)\n\n<!--more-->\n\nPython中的流程结构也就是选择语句，选择语句又分为3种语法形式，分别是if、if else、if elif else。\n\nif 语句语法格式:\n\n```\nif 表达式:\n  代码块\n```\nif else 语句语法格式:\n\n```\nif 表达式:\n  代码块 1\nelse:\n  代码块 2\n```\n\nif elif else 语句语法格式:\n\n```\nif 表达式1:\n  代码块 1\nelif 表达式2:\n  代码块 2\nelif 表达式3:\n  代码块 3\n...\nelse:\n  代码块 n\n```\n\n以上三种选择结构的语法形式差别不大，它们有个共性，就是**当表达式的值为True时会执行代码块内的代码** 。\n\n选择语句的表达式相当于条件，当表达式的条件满足后，就会执行代码块内的代码啦。\n\n**注意:Python的代码块是通过缩进标记的，具有相同缩进的多行代码属于同一个代码块** .\n\n**if表达式真假值得判断方法** \n\n表达式可以是任意类型，不过下面的几种类型将会被Python解释器当做False处理:\n\n`Flase、None、0、\"\"、()、[]、{}` \n\n# Python if else语句用法范例(注意事项_)\n\n**1)代码块不要忘记缩进** \n\n每一个缩进就代表了一个代码块，如果没有没有缩进程序可能会出现各种问题。\n\n```\ns_age = input(\"请输入您的年龄:\")\nage = int(s_age)\nif age >= 18:\nprint(\"你成年了.\")\n```\n\n输出结果:\n\n```\nFile \"test.py\", line 4\n  print(\"你成年了.\")\n      ^\nIndentationError: expected an indented block\n```\n\n有时没有缩进不代表程序没有错误。\n\n```\ns_age = input(\"请输入您的年龄:\")\nage = int(s_age)\nif age >= 18:\n    print(\"你成年了.\")\nprint(\"成年了，就要修身养性.\")\nprint(\"你未成年.\")\n```\n\n运行过程:\n\n```\n请输入您的年龄:10\n成年了，就要修身养性.\n你未成年.\n\n[Process exited 0]\n```\n\n虽然程序没有报错，但是确是不符合逻辑的，应该是当输入的年龄大于等于18岁才输出成年了，就要修身养性，但是由于没有将其缩进，所以造成了代码的运行结果不如人意。\n\n**2)语句不要随意缩进** \n\n我们必须保证同一个代码块内的代码必须保持相同的缩进，如果多一个缩进或少一个缩进都会出现不可预料的错误。\n\n```\nint a = 10\nif a > 9:\n    print(\"a > 9\")\n        print(\"====\")\n```\n\n运行结果:\n\n```\n  File \"test.py\", line 1\n    int a = 10\n        ^\nSyntaxError: invalid syntax\n```\n\nPython解释器抛出了一个SyntaxError错误\n\n**3)if表达式不要遗忘冒号** \n\nPython解释器将冒号表示为代码块的开始，如果遗忘冒号也会引发一些错误，因为Python解释器无法识别代码块的开始。\n\n```\nif 10 > 9\n    print(\"9 > 10\")\nelse:\n    print(\"10 < 9\")\n```\n\n输出结果:\n\n```\n  File \"test.py\", line 1\n    if 10 > 9\n            ^\nSyntaxError: invalid syntax\n\n[Process exited 1]\n```\n\n以冒号作为代码块的开始在其他语句结构也是如此，例如循环、类等。\n\n# Python if语句嵌套\n\n此笔记不讨论此内容，如需了解，请点击此处[查看原文](https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/) \n\n# Python pass语句及其作用\n\n如果你想要一个代码块内什么都不做，但是没有这个代码块语法又不通过，你可以使用`pass` ，其是Python中的空语句，它什么也不做，唯一的功能就是占位了。\n\n```\nif 10 > 9:\n    print(\"xxx\")\nelse:\n    pass\nprint(\"xxxx\")\n```\n\n# Python assert断言函数及用法\n\n`assert断言函数` 与if分支类似，不过它的特点是:**当它的表达式条件为False时将会抛出异常，程序崩溃** 。\n\n```\nnum = int(input(\"请输入大于10且小于100的数字:\"))\nassert 10 < num < 100\nprint(num)\n```\n\n当我们输入非大于10且小于100的数字将会抛出异常:\n\n```\n请输入大于10且小于100的数字:1000\nTraceback (most recent call last):\n  File \"test.py\", line 2, in <module>\n    assert 10 < num < 100\nAssertionError\n\n[Process exited 1]\n```\n\n# Python 如何合理使用assert\n\n本小节通过一些实际应用的例子，演示assert在Python中的用法。\n\n某商场促销活动，对商进行打折销售，现在需要做到如果折后价大于0或小于原价，那么输出折后价，否则报错。\n\n```\n# 原价\nprice = float(input(\"请输入原价:\"))\n# 折扣力度\ndiscount = float(input(\"请输入打几折:\"))\n# 折后价\nupdate_price = price * (discount * 0.1)\nassert 0 < update_price < price\nprint(\"折后价为:{:.2f}¥\".format(update_price))\n```\n\n正常结果:\n\n```\n请输入原价:100\n请输入打几折:8\n折后价为:80.00¥\n\n[Process exited 0]\n```\n\n错误结果:\n\n```\n请输入原价:100\n请输入打几折:18\nTraceback (most recent call last):\n  File \"test.py\", line 7, in <module>\n    assert 0 < update_price < price\nAssertionError\n\n[Process exited 1]\n```\n\n在实际工作中，assert可以提前预防一些问题。\n\n# Python while循环语句详解\n\n本笔记不讨论`while` 循环语句的使用，想要了解的同学，可以点击[查看原文](http://c.biancheng.net/view/4427.html) \n\n# Python for循环及用法详解\n\n本笔记不讨论`for` 循环语句的使用，想要了解的同学，可以点击[查看原文](http://c.biancheng.net/view/2225.html) \n\n# Python循环结构中else用法(入门必读)\n\nPython中，循环语句后可以跟着一个else语句块。其作用是，当循环条件为Fale时，会直接执行紧跟着循环语句块后的else语句块内的代码。 \n\n例子:\n\n```\ncount_i = 0\nwhile count_i < 5:\n    print(\"count_i小于5:\",count_i)\n    count_i+=1\nelse:\n    print(\"count_i大于或等于5:\",count_i)\n```\n\n输出结果:\n\n```\ncount_i小于5: 0\ncount_i小于5: 1\ncount_i小于5: 2\ncount_i小于5: 3\ncount_i小于5: 4\ncount_i大于或等于5: 5\n\n[Process exited 0]\n```\n\n读者可能会想，这样做其实也没什么，就算没有else程序也照样会执行else内的代码。\n\n其实这种语法是Python中一个为了让代码更加具有可读性、美观而有的一个语法。\n\nfor循环也是可以紧跟else的。\n\n例子:\n\n```\nfor i in range(1,6):\n    print(i)\nelse:\n    print(\"输出完毕\")\n```\n\n输出结果:\n\n```\n1\n2\n3\n4\n5\n输出完毕\n\n[Process exited 0]\n```\n\n# Python(for和while)循环嵌套及用法\n\n如果将一个循环语句放入一个循环体内，就会形成循环嵌套。\n\n当程序遇到循环嵌套时，如果外层循环的循环条件允许，则会执行外层循环的循环体，而内层循环将会被外层循环的循环体来执行(只是内层循环需要反复执行自己的循环体而已)。只有当内层循环执行结束且外层循环的循环体也执行结束时，才会再次通过判断外层循环的条件，决定是否再次开始执行外层循环的循环体。\n\n居上所述，假设外层循环的循环次数为n次，那么内层循环的循环次数为m次，那么可得出内层循环的循环体实际上需要执行`n x m` 次。\n\n例子:\n\n```\nfor i in range(0,3):\n    j = 0\n    while j < 3:\n        print(\"i:{}\\tj:{}\".format(i,j))\n        j += 1\n```\n\n输出结果:\n\n```\ni:0     j:0\ni:0     j:1\ni:0     j:2\ni:1     j:0\ni:1     j:1\ni:1     j:2\ni:2     j:0\ni:2     j:1\ni:2     j:2\n\n[Process exited 0]\n```\n\ni 为外层循环的数，j为内层循环的数，可以看到每次内层循环结束后外层循环的i才会发生改变，当时每次外层循环结束后，再次进入循环体后，将会重置内层循环j的值。\n\n嵌套循环可以无限嵌套，但开发者最好不要超过三层循环，不然逻辑很容易混乱。\n\n# Python嵌套循环实现冒泡排序\n\n冒泡排序算法的实现思想:\n\n- 比较相邻元素大小，若前一个比后一个大则交换位置。\n\n- 从第一对相邻元素到结尾的最后一对相邻元素，对每一对相邻元素做上一步骤的比较工作，并将最大的元素放在后面。\n\n- 将循环缩短，除去最后一个数，再重复第二步骤操作。\n\n- 持续做步骤三操作，将每次循环缩短一位。\n\n实现:\n\n```\ntest_list = [10,23,4522,55,13,5123,5,1321235.33,42.123]\n\nfor i in range(len(test_list)-1):\n    # 每次得到最大值后循环缩短，因为最大值已经在最后\n    for j in range(len(test_list)-i-1):\n        # 如果相邻元素的第一个元素比第二元素大则:\n        if(test_list[j]>test_list[j+1]):\n            test_list[j],test_list[j+1]=test_list[j+1],test_list[j]\nprint(\"排序后:\",test_list)\n```\n\n输出结果:\n\n```\n排序后: [5, 10, 13, 23, 42.123, 55, 4522, 5123, 1321235.33]\n```\n\n# Pyton break用法详解\n\n在我们使用循环时，当条件满足那么循环体内的代码将会一路执行，直到循环体结束为止，如果我们想在执行循环体时直接终止循环或跳出本次循环，则可以使用`coontinue`或`break` 语句。\n\n\n**break用于完全结束一个循环，杀死循环。** \n\n例子:\n\n```\nsum = 0\nfor i in range(0,100000):\n    print(\"i的值为:\",i)\n    sum += i\n    if sum == 5050:\n        break\n```\n\n输出结果:\n\n```\ni的值为: 0\ni的值为: 1\ni的值为: 2\ni的值为: 3\ni的值为: 4\n...\n...\ni的值为: 94\ni的值为: 95\ni的值为: 96\ni的值为: 97\ni的值为: 98\ni的值为: 99\ni的值为: 100\n```\n\n可以看到，当sum值为5050时，循环将会被杀死，不再执行。\n\n\n如果循环体外带上了else块，那么如果循环体内执行了break语句，则else语句块内的代码不会被执行。\n\n```\nfor i in range(1,4):\n    print(i)\n    if i > 2:\n        break\nelse:\n    print(\"else\")\n```\n\n输出结果:\n\n```\n1\n2\n3\n\n[Process exited 0]\n```\n\n可以看到，当for循环体内执行了break语句后，else内的代码也不会执行。\n\n**break语句只能结束当前执行的循环，而不能结束被嵌套循环的外层循环。**\n\n# Python continue用法\n\ncontinue与break类似，但不同点在于continue只能跳出本次循环，并不能终止循环。\n\n例子:\n\n```\nfor i in range(1,5):\n    if i == 2:\n        continue\n    print(i)\n```\n\n输出结果:\n\n```\n1\n3\n4\n\n[Process exited 0]\n```\n\n可以看到，当循环内部执行continue之后，下面的代码将不会被执行。\n\n# 如何避免Python出现死循环 \n\n为了避免Python程序出现死循环，所以**必须确保循环结构中至少有能让循环条件为False或让break语句得以执行的语句。** \n\n# Python推导式详解\n\nPython推导式，是Python独有的一种特性。使用推导式可以快速生成列表、元素、字典以及集合类型的数据。\n\n列表推导式利用range区间、元组、列表、字典和集合等数据类型、快速生成一个满足指定需求的列表。\n\n语法格式:\n\n`[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]` \n\n**if条件表达式为非必须的。**\n\n## 列表推导式\n\n例子:\n\n求0-10的平方\n\n```\ntest_list = [x * x for x in range(11)]\nprint(test_list)\n```\n\n输出结果:`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]`\n\n例子2:\n\n求0-10的平方，并且满足可以整除2\n\n```\ntest_list = [x * x for x in range(11) if x % 2 == 0]\nprint(test_list)\n```\n\n输出结果:\n\n`[0, 4, 16, 36, 64, 100]` \n\n上面的列表推导式都只有一个循环，但实际上它可以使用多个循环。\n\n例子:\n\n```\ntest_list = [(x,y)for x in range(5) for y in range(4)]\nprint(test_list)\n```\n\n输出结果:\n\n```\n[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1)\n, (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3\n)]\n\n[Process exited 0]\n```\n\n其实Python的列表推导式可以使用循环语句重写:\n\n```\ntest_list2 = []\nfor x in range(5):\n    for y in range(4):\n        test_list2.append((x,y))\nprint(test_list2)\n```\n\n输出结果同上\n\n当然，也支持多层循环嵌套的推导式。\n\n## 元组推导式\n\n元组推导式同列表推导式一样，可以使用range区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。\n\n语法格式:\n\n`(表达式 for 迭代变量 in 可迭代对象 [if条件表达式])` \n\n**if条件表达式为可选** \n\n首先将元组推导式与列表推导式做一个对比。\n\n例子:\n\n```\ntest_list = [x for x in range(10)]\nprint(test_list)\ntest_tuple = (x for x in range(10))\nprint(test_tuple)\n```\n\n输出结果:\n\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n<generator object <genexpr> at 0x106f3d450>\n\n[Process exited 0]\n```\n\n可以看到，除了元组推导式是使用`()` 圆括号而列表推导式是使用`[]` 方括号之外，还有就是元组推导式生成的结果并不是一个元组，而是一个`生成器对象` 。\n\n我们可以通过`tuple()` 函数将生成器对象转换为元组或使用循环遍历生成器对象，获取各元素。\n\n```\nx =  (x for x in range(10))\nfor ele in x:\n\\    print(ele,end=\" \")\nprint(tuple(x))\n```\n\n输出结果:\n\n`0 1 2 3 4 5 6 7 8 9 ()` \n\n**注意:当我们遍历了生成器对象后，原生成器对象将不复存在，这就是为什么我们遍历了生成器对象后再将原生成器对象转换却得到空元组的原因** \n\n我们还可以使用`__next__()` 方法遍历，但很不方便。\n\n```\nx =  (x for x in range(10))\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(tuple(x))\nprint(x.__next__())\n```\n\n输出结果:\n\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n()\nTraceback (most recent call last):\n  File \"test.py\", line 13, in <module>\n    print(x.__next__())\nStopIteration\n\n[Process exited 1]\n```\n\n可以看到被遍历后的生成器将会被清空，并且需要注意的是**__next__方法需要不能越界** \n\n## Python 字典推导式\n\n同前两个推导式一样，都可以接住多种数据类型生成符合需求的字典。\n\n语法格式:\n\n`{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}` \n\n例子:\n\n将列表内元素作为键，其元素长度为值\n\n```\ntest_list = ['Hello',\"World\"]\ntest_map = {key:len(key) for key in test_list}\nprint(test_map)\n```\n\n输出结果:\n\n`{'Hello': 5, 'World': 5}` \n\n例子2:\n\n调换键值对\n\n```\ntest_list = [\"语文\",\"数学\",\"英语\"]\ntest_dict = dict.fromkeys(test_list,100)\nprint(test_dict)\ntest_dict2 = {v:x for x,v in test_dict.items()}\nprint(test_dict2)\n```\n\n输出结果:\n\n```\n{'语文': 100, '数学': 100, '英语': 100}\n{100: '英语'}\n\n[Process exited 0]\n```\n\n## Python集合推导式\n\n同上，可以使用常用数据类型快速生成符合需求的集合。\n\n语法格式:\n\n`{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}` \n\n**注意：集合推导式的语法格式与字典推导式的语法格式相同，为了区分它们，同时看表达式的形式，如果是以键值对(key:value)的形式，那么就是字典，否则反之** \n\n例子:\n\n```\nnewset = {i**2 for i in range(3)}\nprint(newset)\nprint(type(newset))\n```\n\n输出结果:\n\n```\n{0, 1, 4}\n<class 'set'>\n\n```\n\n# Python zip函数及用法\n\n`zip()` 函数可以将多个列表转化一个zip对象(可迭代对象)。\n\n例子:\n\n```\nlist1 = list(range(1,10))\nlist2 = list(range(-10,0))\nprint([x for x in zip(list1,list2)])\n```\n\n输出结果:\n\n```\n[(1, -10), (2, -9), (3, -8), (4, -7), (5, -6), (6, -5), (7, -4), (8, -3), (9, -\n2)]\n\n[Process exited 0]\n```\n\n# Python reversed函数及用法\n\nreversed()函数用于将各种序列进行**逆序排序** ，但不会影响序列本身。\n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint([x for x in reversed(string)])\n```\n\n输出结果:\n\n`['d', 'l', 'r', 'o', 'W', 'o', 'l', 'l', 'e', 'H']` \n\n\n# Python sorted函数及用法\n\nsorted函数用于将各种序列进行排序。\n\n例子:\n\n\n```\nstring = \"123456789\"\nre_string = [x for x in reversed(string)]\nprint(re_string)\nsort_string = sorted(re_string)\nprint(sort_string)\n```\n\n输出结果:\n\n```\n['9', '8', '7', '6', '5', '4', '3', '2', '1']\n['1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n[Process exited 0]\n```\n\n# Python项目实战之猜数字游戏\n\n代码如下:\n\n```\n# 随机数模块\nimport random\n\nprint(\"{0:=^20s}{1:s}{0:=^20s}\\n\".format(\"==========\",\"欢迎游玩猜数字游戏\"))\n\n# 随机数(1-20之间)\nrandomNum = random.randint(1,20)\n\n# 只给用户5次机会\n\nfor count in range(1,6):\n    print(\"\\n算上这次，你还有{:d}次机会!\\n\".format(5-count))\n    num = int(input(\"请输入猜测的数(范围1~20):\"))\n    if num>randomNum:\n        print(\"\\n系统>> 大了点!!!\")\n    elif num < randomNum:\n        print(\"\\n系统>> 小了点!!!\")\n    else:\n        print(\"\\n系统>> 恭喜你猜中了数字!!!\")\n        break\nelse:\n    print(\"\\n系统>> 很遗憾，你没有猜到正确答案，答案为:{:d}\".format(randomNum))\n```\n\n猜中运行实例:\n\n```\n====================欢迎游玩猜数字游戏====================\n\n\n算上这次，你还有4次机会!\n\n请输入猜测的数(范围1~20):10\n\n系统>> 小了点!!!\n\n算上这次，你还有3次机会!\n\n请输入猜测的数(范围1~20):15\n\n系统>> 大了点!!!\n\n算上这次，你还有2次机会!\n\n请输入猜测的数(范围1~20):14\n\n系统>> 大了点!!!\n\n算上这次，你还有1次机会!\n\n请输入猜测的数(范围1~20):13\n\n系统>> 恭喜你猜中了数字!!!\n\n[Process exited 0]\n```\n\n猜错运行实例:\n\n```\n====================欢迎游玩猜数字游戏====================\n\n\n算上这次，你还有4次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有3次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有2次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有1次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有0次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n系统>> 很遗憾，你没有猜到正确答案，答案为:3\n\n[Process exited 0]\n```\n# Python项目实战: 绕圈圈面试题\n\n```\nSIZE = 7\n\narray = [[0] * SIZE]\n\n# 创建一个长度SIZE * SIZE的二维列表\nfor i in range(SIZE - 1):\n    array += [[0] * SIZE]\n\n# 绕圈的方向(0:下 1:右 2：左 3:上)\norient = 0\n\n# l 控制行索引 c控制列索引\nl = 0\nc = 0\n\nfor i in range(1,SIZE * SIZE + 1):\n    array[l][c] = i\n\n    # 如果位于1号转弯线上\n    if l+c == SIZE - 1:\n        # l > c，位于左下角\n        if l > c:\n            orient = 1\n        else :\n            orient = 2\n    elif (c == l) and (c >= SIZE / 2):\n        orient = 3\n    elif (l == c - 1) and (c <= SIZE / 2):\n        orient = 0\n    if orient == 0:\n        l += 1\n    elif orient == 1:\n        c += 1\n    elif orient == 2:\n        c -= 1\n    elif orient == 3:\n        l -= 1\nfor i in range(SIZE):\n    for j in range(SIZE):\n        print(\"%02d\" % array[i][j],end = \"\")\n    print(\"\")\n```\n\n","source":"_posts/Python-06-Python流程控制.md","raw":"---\ntitle: '[Python-06]Python流程控制'\ncopyright: true\ndate: 2019-09-28 14:14:26\ncategories: Python\ntags:\n  - Python系列\n---\n\nPython系列第六章笔记，查看Python系列所有文章，请点击[💿](http://c.biancheng.net/python/str_method/)\n\n<!--more-->\n\nPython中的流程结构也就是选择语句，选择语句又分为3种语法形式，分别是if、if else、if elif else。\n\nif 语句语法格式:\n\n```\nif 表达式:\n  代码块\n```\nif else 语句语法格式:\n\n```\nif 表达式:\n  代码块 1\nelse:\n  代码块 2\n```\n\nif elif else 语句语法格式:\n\n```\nif 表达式1:\n  代码块 1\nelif 表达式2:\n  代码块 2\nelif 表达式3:\n  代码块 3\n...\nelse:\n  代码块 n\n```\n\n以上三种选择结构的语法形式差别不大，它们有个共性，就是**当表达式的值为True时会执行代码块内的代码** 。\n\n选择语句的表达式相当于条件，当表达式的条件满足后，就会执行代码块内的代码啦。\n\n**注意:Python的代码块是通过缩进标记的，具有相同缩进的多行代码属于同一个代码块** .\n\n**if表达式真假值得判断方法** \n\n表达式可以是任意类型，不过下面的几种类型将会被Python解释器当做False处理:\n\n`Flase、None、0、\"\"、()、[]、{}` \n\n# Python if else语句用法范例(注意事项_)\n\n**1)代码块不要忘记缩进** \n\n每一个缩进就代表了一个代码块，如果没有没有缩进程序可能会出现各种问题。\n\n```\ns_age = input(\"请输入您的年龄:\")\nage = int(s_age)\nif age >= 18:\nprint(\"你成年了.\")\n```\n\n输出结果:\n\n```\nFile \"test.py\", line 4\n  print(\"你成年了.\")\n      ^\nIndentationError: expected an indented block\n```\n\n有时没有缩进不代表程序没有错误。\n\n```\ns_age = input(\"请输入您的年龄:\")\nage = int(s_age)\nif age >= 18:\n    print(\"你成年了.\")\nprint(\"成年了，就要修身养性.\")\nprint(\"你未成年.\")\n```\n\n运行过程:\n\n```\n请输入您的年龄:10\n成年了，就要修身养性.\n你未成年.\n\n[Process exited 0]\n```\n\n虽然程序没有报错，但是确是不符合逻辑的，应该是当输入的年龄大于等于18岁才输出成年了，就要修身养性，但是由于没有将其缩进，所以造成了代码的运行结果不如人意。\n\n**2)语句不要随意缩进** \n\n我们必须保证同一个代码块内的代码必须保持相同的缩进，如果多一个缩进或少一个缩进都会出现不可预料的错误。\n\n```\nint a = 10\nif a > 9:\n    print(\"a > 9\")\n        print(\"====\")\n```\n\n运行结果:\n\n```\n  File \"test.py\", line 1\n    int a = 10\n        ^\nSyntaxError: invalid syntax\n```\n\nPython解释器抛出了一个SyntaxError错误\n\n**3)if表达式不要遗忘冒号** \n\nPython解释器将冒号表示为代码块的开始，如果遗忘冒号也会引发一些错误，因为Python解释器无法识别代码块的开始。\n\n```\nif 10 > 9\n    print(\"9 > 10\")\nelse:\n    print(\"10 < 9\")\n```\n\n输出结果:\n\n```\n  File \"test.py\", line 1\n    if 10 > 9\n            ^\nSyntaxError: invalid syntax\n\n[Process exited 1]\n```\n\n以冒号作为代码块的开始在其他语句结构也是如此，例如循环、类等。\n\n# Python if语句嵌套\n\n此笔记不讨论此内容，如需了解，请点击此处[查看原文](https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/) \n\n# Python pass语句及其作用\n\n如果你想要一个代码块内什么都不做，但是没有这个代码块语法又不通过，你可以使用`pass` ，其是Python中的空语句，它什么也不做，唯一的功能就是占位了。\n\n```\nif 10 > 9:\n    print(\"xxx\")\nelse:\n    pass\nprint(\"xxxx\")\n```\n\n# Python assert断言函数及用法\n\n`assert断言函数` 与if分支类似，不过它的特点是:**当它的表达式条件为False时将会抛出异常，程序崩溃** 。\n\n```\nnum = int(input(\"请输入大于10且小于100的数字:\"))\nassert 10 < num < 100\nprint(num)\n```\n\n当我们输入非大于10且小于100的数字将会抛出异常:\n\n```\n请输入大于10且小于100的数字:1000\nTraceback (most recent call last):\n  File \"test.py\", line 2, in <module>\n    assert 10 < num < 100\nAssertionError\n\n[Process exited 1]\n```\n\n# Python 如何合理使用assert\n\n本小节通过一些实际应用的例子，演示assert在Python中的用法。\n\n某商场促销活动，对商进行打折销售，现在需要做到如果折后价大于0或小于原价，那么输出折后价，否则报错。\n\n```\n# 原价\nprice = float(input(\"请输入原价:\"))\n# 折扣力度\ndiscount = float(input(\"请输入打几折:\"))\n# 折后价\nupdate_price = price * (discount * 0.1)\nassert 0 < update_price < price\nprint(\"折后价为:{:.2f}¥\".format(update_price))\n```\n\n正常结果:\n\n```\n请输入原价:100\n请输入打几折:8\n折后价为:80.00¥\n\n[Process exited 0]\n```\n\n错误结果:\n\n```\n请输入原价:100\n请输入打几折:18\nTraceback (most recent call last):\n  File \"test.py\", line 7, in <module>\n    assert 0 < update_price < price\nAssertionError\n\n[Process exited 1]\n```\n\n在实际工作中，assert可以提前预防一些问题。\n\n# Python while循环语句详解\n\n本笔记不讨论`while` 循环语句的使用，想要了解的同学，可以点击[查看原文](http://c.biancheng.net/view/4427.html) \n\n# Python for循环及用法详解\n\n本笔记不讨论`for` 循环语句的使用，想要了解的同学，可以点击[查看原文](http://c.biancheng.net/view/2225.html) \n\n# Python循环结构中else用法(入门必读)\n\nPython中，循环语句后可以跟着一个else语句块。其作用是，当循环条件为Fale时，会直接执行紧跟着循环语句块后的else语句块内的代码。 \n\n例子:\n\n```\ncount_i = 0\nwhile count_i < 5:\n    print(\"count_i小于5:\",count_i)\n    count_i+=1\nelse:\n    print(\"count_i大于或等于5:\",count_i)\n```\n\n输出结果:\n\n```\ncount_i小于5: 0\ncount_i小于5: 1\ncount_i小于5: 2\ncount_i小于5: 3\ncount_i小于5: 4\ncount_i大于或等于5: 5\n\n[Process exited 0]\n```\n\n读者可能会想，这样做其实也没什么，就算没有else程序也照样会执行else内的代码。\n\n其实这种语法是Python中一个为了让代码更加具有可读性、美观而有的一个语法。\n\nfor循环也是可以紧跟else的。\n\n例子:\n\n```\nfor i in range(1,6):\n    print(i)\nelse:\n    print(\"输出完毕\")\n```\n\n输出结果:\n\n```\n1\n2\n3\n4\n5\n输出完毕\n\n[Process exited 0]\n```\n\n# Python(for和while)循环嵌套及用法\n\n如果将一个循环语句放入一个循环体内，就会形成循环嵌套。\n\n当程序遇到循环嵌套时，如果外层循环的循环条件允许，则会执行外层循环的循环体，而内层循环将会被外层循环的循环体来执行(只是内层循环需要反复执行自己的循环体而已)。只有当内层循环执行结束且外层循环的循环体也执行结束时，才会再次通过判断外层循环的条件，决定是否再次开始执行外层循环的循环体。\n\n居上所述，假设外层循环的循环次数为n次，那么内层循环的循环次数为m次，那么可得出内层循环的循环体实际上需要执行`n x m` 次。\n\n例子:\n\n```\nfor i in range(0,3):\n    j = 0\n    while j < 3:\n        print(\"i:{}\\tj:{}\".format(i,j))\n        j += 1\n```\n\n输出结果:\n\n```\ni:0     j:0\ni:0     j:1\ni:0     j:2\ni:1     j:0\ni:1     j:1\ni:1     j:2\ni:2     j:0\ni:2     j:1\ni:2     j:2\n\n[Process exited 0]\n```\n\ni 为外层循环的数，j为内层循环的数，可以看到每次内层循环结束后外层循环的i才会发生改变，当时每次外层循环结束后，再次进入循环体后，将会重置内层循环j的值。\n\n嵌套循环可以无限嵌套，但开发者最好不要超过三层循环，不然逻辑很容易混乱。\n\n# Python嵌套循环实现冒泡排序\n\n冒泡排序算法的实现思想:\n\n- 比较相邻元素大小，若前一个比后一个大则交换位置。\n\n- 从第一对相邻元素到结尾的最后一对相邻元素，对每一对相邻元素做上一步骤的比较工作，并将最大的元素放在后面。\n\n- 将循环缩短，除去最后一个数，再重复第二步骤操作。\n\n- 持续做步骤三操作，将每次循环缩短一位。\n\n实现:\n\n```\ntest_list = [10,23,4522,55,13,5123,5,1321235.33,42.123]\n\nfor i in range(len(test_list)-1):\n    # 每次得到最大值后循环缩短，因为最大值已经在最后\n    for j in range(len(test_list)-i-1):\n        # 如果相邻元素的第一个元素比第二元素大则:\n        if(test_list[j]>test_list[j+1]):\n            test_list[j],test_list[j+1]=test_list[j+1],test_list[j]\nprint(\"排序后:\",test_list)\n```\n\n输出结果:\n\n```\n排序后: [5, 10, 13, 23, 42.123, 55, 4522, 5123, 1321235.33]\n```\n\n# Pyton break用法详解\n\n在我们使用循环时，当条件满足那么循环体内的代码将会一路执行，直到循环体结束为止，如果我们想在执行循环体时直接终止循环或跳出本次循环，则可以使用`coontinue`或`break` 语句。\n\n\n**break用于完全结束一个循环，杀死循环。** \n\n例子:\n\n```\nsum = 0\nfor i in range(0,100000):\n    print(\"i的值为:\",i)\n    sum += i\n    if sum == 5050:\n        break\n```\n\n输出结果:\n\n```\ni的值为: 0\ni的值为: 1\ni的值为: 2\ni的值为: 3\ni的值为: 4\n...\n...\ni的值为: 94\ni的值为: 95\ni的值为: 96\ni的值为: 97\ni的值为: 98\ni的值为: 99\ni的值为: 100\n```\n\n可以看到，当sum值为5050时，循环将会被杀死，不再执行。\n\n\n如果循环体外带上了else块，那么如果循环体内执行了break语句，则else语句块内的代码不会被执行。\n\n```\nfor i in range(1,4):\n    print(i)\n    if i > 2:\n        break\nelse:\n    print(\"else\")\n```\n\n输出结果:\n\n```\n1\n2\n3\n\n[Process exited 0]\n```\n\n可以看到，当for循环体内执行了break语句后，else内的代码也不会执行。\n\n**break语句只能结束当前执行的循环，而不能结束被嵌套循环的外层循环。**\n\n# Python continue用法\n\ncontinue与break类似，但不同点在于continue只能跳出本次循环，并不能终止循环。\n\n例子:\n\n```\nfor i in range(1,5):\n    if i == 2:\n        continue\n    print(i)\n```\n\n输出结果:\n\n```\n1\n3\n4\n\n[Process exited 0]\n```\n\n可以看到，当循环内部执行continue之后，下面的代码将不会被执行。\n\n# 如何避免Python出现死循环 \n\n为了避免Python程序出现死循环，所以**必须确保循环结构中至少有能让循环条件为False或让break语句得以执行的语句。** \n\n# Python推导式详解\n\nPython推导式，是Python独有的一种特性。使用推导式可以快速生成列表、元素、字典以及集合类型的数据。\n\n列表推导式利用range区间、元组、列表、字典和集合等数据类型、快速生成一个满足指定需求的列表。\n\n语法格式:\n\n`[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]` \n\n**if条件表达式为非必须的。**\n\n## 列表推导式\n\n例子:\n\n求0-10的平方\n\n```\ntest_list = [x * x for x in range(11)]\nprint(test_list)\n```\n\n输出结果:`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]`\n\n例子2:\n\n求0-10的平方，并且满足可以整除2\n\n```\ntest_list = [x * x for x in range(11) if x % 2 == 0]\nprint(test_list)\n```\n\n输出结果:\n\n`[0, 4, 16, 36, 64, 100]` \n\n上面的列表推导式都只有一个循环，但实际上它可以使用多个循环。\n\n例子:\n\n```\ntest_list = [(x,y)for x in range(5) for y in range(4)]\nprint(test_list)\n```\n\n输出结果:\n\n```\n[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1)\n, (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3\n)]\n\n[Process exited 0]\n```\n\n其实Python的列表推导式可以使用循环语句重写:\n\n```\ntest_list2 = []\nfor x in range(5):\n    for y in range(4):\n        test_list2.append((x,y))\nprint(test_list2)\n```\n\n输出结果同上\n\n当然，也支持多层循环嵌套的推导式。\n\n## 元组推导式\n\n元组推导式同列表推导式一样，可以使用range区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。\n\n语法格式:\n\n`(表达式 for 迭代变量 in 可迭代对象 [if条件表达式])` \n\n**if条件表达式为可选** \n\n首先将元组推导式与列表推导式做一个对比。\n\n例子:\n\n```\ntest_list = [x for x in range(10)]\nprint(test_list)\ntest_tuple = (x for x in range(10))\nprint(test_tuple)\n```\n\n输出结果:\n\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n<generator object <genexpr> at 0x106f3d450>\n\n[Process exited 0]\n```\n\n可以看到，除了元组推导式是使用`()` 圆括号而列表推导式是使用`[]` 方括号之外，还有就是元组推导式生成的结果并不是一个元组，而是一个`生成器对象` 。\n\n我们可以通过`tuple()` 函数将生成器对象转换为元组或使用循环遍历生成器对象，获取各元素。\n\n```\nx =  (x for x in range(10))\nfor ele in x:\n\\    print(ele,end=\" \")\nprint(tuple(x))\n```\n\n输出结果:\n\n`0 1 2 3 4 5 6 7 8 9 ()` \n\n**注意:当我们遍历了生成器对象后，原生成器对象将不复存在，这就是为什么我们遍历了生成器对象后再将原生成器对象转换却得到空元组的原因** \n\n我们还可以使用`__next__()` 方法遍历，但很不方便。\n\n```\nx =  (x for x in range(10))\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(x.__next__())\nprint(tuple(x))\nprint(x.__next__())\n```\n\n输出结果:\n\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n()\nTraceback (most recent call last):\n  File \"test.py\", line 13, in <module>\n    print(x.__next__())\nStopIteration\n\n[Process exited 1]\n```\n\n可以看到被遍历后的生成器将会被清空，并且需要注意的是**__next__方法需要不能越界** \n\n## Python 字典推导式\n\n同前两个推导式一样，都可以接住多种数据类型生成符合需求的字典。\n\n语法格式:\n\n`{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}` \n\n例子:\n\n将列表内元素作为键，其元素长度为值\n\n```\ntest_list = ['Hello',\"World\"]\ntest_map = {key:len(key) for key in test_list}\nprint(test_map)\n```\n\n输出结果:\n\n`{'Hello': 5, 'World': 5}` \n\n例子2:\n\n调换键值对\n\n```\ntest_list = [\"语文\",\"数学\",\"英语\"]\ntest_dict = dict.fromkeys(test_list,100)\nprint(test_dict)\ntest_dict2 = {v:x for x,v in test_dict.items()}\nprint(test_dict2)\n```\n\n输出结果:\n\n```\n{'语文': 100, '数学': 100, '英语': 100}\n{100: '英语'}\n\n[Process exited 0]\n```\n\n## Python集合推导式\n\n同上，可以使用常用数据类型快速生成符合需求的集合。\n\n语法格式:\n\n`{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}` \n\n**注意：集合推导式的语法格式与字典推导式的语法格式相同，为了区分它们，同时看表达式的形式，如果是以键值对(key:value)的形式，那么就是字典，否则反之** \n\n例子:\n\n```\nnewset = {i**2 for i in range(3)}\nprint(newset)\nprint(type(newset))\n```\n\n输出结果:\n\n```\n{0, 1, 4}\n<class 'set'>\n\n```\n\n# Python zip函数及用法\n\n`zip()` 函数可以将多个列表转化一个zip对象(可迭代对象)。\n\n例子:\n\n```\nlist1 = list(range(1,10))\nlist2 = list(range(-10,0))\nprint([x for x in zip(list1,list2)])\n```\n\n输出结果:\n\n```\n[(1, -10), (2, -9), (3, -8), (4, -7), (5, -6), (6, -5), (7, -4), (8, -3), (9, -\n2)]\n\n[Process exited 0]\n```\n\n# Python reversed函数及用法\n\nreversed()函数用于将各种序列进行**逆序排序** ，但不会影响序列本身。\n\n例子:\n\n```\nstring = \"HelloWorld\"\nprint([x for x in reversed(string)])\n```\n\n输出结果:\n\n`['d', 'l', 'r', 'o', 'W', 'o', 'l', 'l', 'e', 'H']` \n\n\n# Python sorted函数及用法\n\nsorted函数用于将各种序列进行排序。\n\n例子:\n\n\n```\nstring = \"123456789\"\nre_string = [x for x in reversed(string)]\nprint(re_string)\nsort_string = sorted(re_string)\nprint(sort_string)\n```\n\n输出结果:\n\n```\n['9', '8', '7', '6', '5', '4', '3', '2', '1']\n['1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n[Process exited 0]\n```\n\n# Python项目实战之猜数字游戏\n\n代码如下:\n\n```\n# 随机数模块\nimport random\n\nprint(\"{0:=^20s}{1:s}{0:=^20s}\\n\".format(\"==========\",\"欢迎游玩猜数字游戏\"))\n\n# 随机数(1-20之间)\nrandomNum = random.randint(1,20)\n\n# 只给用户5次机会\n\nfor count in range(1,6):\n    print(\"\\n算上这次，你还有{:d}次机会!\\n\".format(5-count))\n    num = int(input(\"请输入猜测的数(范围1~20):\"))\n    if num>randomNum:\n        print(\"\\n系统>> 大了点!!!\")\n    elif num < randomNum:\n        print(\"\\n系统>> 小了点!!!\")\n    else:\n        print(\"\\n系统>> 恭喜你猜中了数字!!!\")\n        break\nelse:\n    print(\"\\n系统>> 很遗憾，你没有猜到正确答案，答案为:{:d}\".format(randomNum))\n```\n\n猜中运行实例:\n\n```\n====================欢迎游玩猜数字游戏====================\n\n\n算上这次，你还有4次机会!\n\n请输入猜测的数(范围1~20):10\n\n系统>> 小了点!!!\n\n算上这次，你还有3次机会!\n\n请输入猜测的数(范围1~20):15\n\n系统>> 大了点!!!\n\n算上这次，你还有2次机会!\n\n请输入猜测的数(范围1~20):14\n\n系统>> 大了点!!!\n\n算上这次，你还有1次机会!\n\n请输入猜测的数(范围1~20):13\n\n系统>> 恭喜你猜中了数字!!!\n\n[Process exited 0]\n```\n\n猜错运行实例:\n\n```\n====================欢迎游玩猜数字游戏====================\n\n\n算上这次，你还有4次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有3次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有2次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有1次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n算上这次，你还有0次机会!\n\n请输入猜测的数(范围1~20):1\n\n系统>> 小了点!!!\n\n系统>> 很遗憾，你没有猜到正确答案，答案为:3\n\n[Process exited 0]\n```\n# Python项目实战: 绕圈圈面试题\n\n```\nSIZE = 7\n\narray = [[0] * SIZE]\n\n# 创建一个长度SIZE * SIZE的二维列表\nfor i in range(SIZE - 1):\n    array += [[0] * SIZE]\n\n# 绕圈的方向(0:下 1:右 2：左 3:上)\norient = 0\n\n# l 控制行索引 c控制列索引\nl = 0\nc = 0\n\nfor i in range(1,SIZE * SIZE + 1):\n    array[l][c] = i\n\n    # 如果位于1号转弯线上\n    if l+c == SIZE - 1:\n        # l > c，位于左下角\n        if l > c:\n            orient = 1\n        else :\n            orient = 2\n    elif (c == l) and (c >= SIZE / 2):\n        orient = 3\n    elif (l == c - 1) and (c <= SIZE / 2):\n        orient = 0\n    if orient == 0:\n        l += 1\n    elif orient == 1:\n        c += 1\n    elif orient == 2:\n        c -= 1\n    elif orient == 3:\n        l -= 1\nfor i in range(SIZE):\n    for j in range(SIZE):\n        print(\"%02d\" % array[i][j],end = \"\")\n    print(\"\")\n```\n\n","slug":"Python-06-Python流程控制","published":1,"updated":"2020-01-19T03:49:51.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoct004fomoodguiskf5","content":"<p>Python系列第六章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/str_method/\" target=\"_blank\" rel=\"noopener\">💿</a></p>\n<a id=\"more\"></a>\n<p>Python中的流程结构也就是选择语句，选择语句又分为3种语法形式，分别是if、if else、if elif else。</p>\n<p>if 语句语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 表达式:</span><br><span class=\"line\">  代码块</span><br></pre></td></tr></table></figure>\n<p>if else 语句语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 表达式:</span><br><span class=\"line\">  代码块 1</span><br><span class=\"line\">else:</span><br><span class=\"line\">  代码块 2</span><br></pre></td></tr></table></figure>\n<p>if elif else 语句语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 表达式1:</span><br><span class=\"line\">  代码块 1</span><br><span class=\"line\">elif 表达式2:</span><br><span class=\"line\">  代码块 2</span><br><span class=\"line\">elif 表达式3:</span><br><span class=\"line\">  代码块 3</span><br><span class=\"line\">...</span><br><span class=\"line\">else:</span><br><span class=\"line\">  代码块 n</span><br></pre></td></tr></table></figure>\n<p>以上三种选择结构的语法形式差别不大，它们有个共性，就是<strong>当表达式的值为True时会执行代码块内的代码</strong> 。</p>\n<p>选择语句的表达式相当于条件，当表达式的条件满足后，就会执行代码块内的代码啦。</p>\n<p><strong>注意:Python的代码块是通过缩进标记的，具有相同缩进的多行代码属于同一个代码块</strong> .</p>\n<p><strong>if表达式真假值得判断方法</strong> </p>\n<p>表达式可以是任意类型，不过下面的几种类型将会被Python解释器当做False处理:</p>\n<p><code>Flase、None、0、&quot;&quot;、()、[]、{}</code> </p>\n<h1 id=\"Python-if-else语句用法范例-注意事项\"><a href=\"#Python-if-else语句用法范例-注意事项\" class=\"headerlink\" title=\"Python if else语句用法范例(注意事项_)\"></a>Python if else语句用法范例(注意事项_)</h1><p><strong>1)代码块不要忘记缩进</strong> </p>\n<p>每一个缩进就代表了一个代码块，如果没有没有缩进程序可能会出现各种问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s_age = input(&quot;请输入您的年龄:&quot;)</span><br><span class=\"line\">age = int(s_age)</span><br><span class=\"line\">if age &gt;= 18:</span><br><span class=\"line\">print(&quot;你成年了.&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File &quot;test.py&quot;, line 4</span><br><span class=\"line\">  print(&quot;你成年了.&quot;)</span><br><span class=\"line\">      ^</span><br><span class=\"line\">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure>\n<p>有时没有缩进不代表程序没有错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s_age = input(&quot;请输入您的年龄:&quot;)</span><br><span class=\"line\">age = int(s_age)</span><br><span class=\"line\">if age &gt;= 18:</span><br><span class=\"line\">    print(&quot;你成年了.&quot;)</span><br><span class=\"line\">print(&quot;成年了，就要修身养性.&quot;)</span><br><span class=\"line\">print(&quot;你未成年.&quot;)</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入您的年龄:10</span><br><span class=\"line\">成年了，就要修身养性.</span><br><span class=\"line\">你未成年.</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>虽然程序没有报错，但是确是不符合逻辑的，应该是当输入的年龄大于等于18岁才输出成年了，就要修身养性，但是由于没有将其缩进，所以造成了代码的运行结果不如人意。</p>\n<p><strong>2)语句不要随意缩进</strong> </p>\n<p>我们必须保证同一个代码块内的代码必须保持相同的缩进，如果多一个缩进或少一个缩进都会出现不可预料的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 10</span><br><span class=\"line\">if a &gt; 9:</span><br><span class=\"line\">    print(&quot;a &gt; 9&quot;)</span><br><span class=\"line\">        print(&quot;====&quot;)</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  File &quot;test.py&quot;, line 1</span><br><span class=\"line\">    int a = 10</span><br><span class=\"line\">        ^</span><br><span class=\"line\">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>\n<p>Python解释器抛出了一个SyntaxError错误</p>\n<p><strong>3)if表达式不要遗忘冒号</strong> </p>\n<p>Python解释器将冒号表示为代码块的开始，如果遗忘冒号也会引发一些错误，因为Python解释器无法识别代码块的开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 10 &gt; 9</span><br><span class=\"line\">    print(&quot;9 &gt; 10&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;10 &lt; 9&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  File &quot;test.py&quot;, line 1</span><br><span class=\"line\">    if 10 &gt; 9</span><br><span class=\"line\">            ^</span><br><span class=\"line\">SyntaxError: invalid syntax</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>以冒号作为代码块的开始在其他语句结构也是如此，例如循环、类等。</p>\n<h1 id=\"Python-if语句嵌套\"><a href=\"#Python-if语句嵌套\" class=\"headerlink\" title=\"Python if语句嵌套\"></a>Python if语句嵌套</h1><p>此笔记不讨论此内容，如需了解，请点击此处<a href=\"https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/\">查看原文</a> </p>\n<h1 id=\"Python-pass语句及其作用\"><a href=\"#Python-pass语句及其作用\" class=\"headerlink\" title=\"Python pass语句及其作用\"></a>Python pass语句及其作用</h1><p>如果你想要一个代码块内什么都不做，但是没有这个代码块语法又不通过，你可以使用<code>pass</code> ，其是Python中的空语句，它什么也不做，唯一的功能就是占位了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 10 &gt; 9:</span><br><span class=\"line\">    print(&quot;xxx&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    pass</span><br><span class=\"line\">print(&quot;xxxx&quot;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-assert断言函数及用法\"><a href=\"#Python-assert断言函数及用法\" class=\"headerlink\" title=\"Python assert断言函数及用法\"></a>Python assert断言函数及用法</h1><p><code>assert断言函数</code> 与if分支类似，不过它的特点是:<strong>当它的表达式条件为False时将会抛出异常，程序崩溃</strong> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = int(input(&quot;请输入大于10且小于100的数字:&quot;))</span><br><span class=\"line\">assert 10 &lt; num &lt; 100</span><br><span class=\"line\">print(num)</span><br></pre></td></tr></table></figure>\n<p>当我们输入非大于10且小于100的数字将会抛出异常:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入大于10且小于100的数字:1000</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 2, in &lt;module&gt;</span><br><span class=\"line\">    assert 10 &lt; num &lt; 100</span><br><span class=\"line\">AssertionError</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-如何合理使用assert\"><a href=\"#Python-如何合理使用assert\" class=\"headerlink\" title=\"Python 如何合理使用assert\"></a>Python 如何合理使用assert</h1><p>本小节通过一些实际应用的例子，演示assert在Python中的用法。</p>\n<p>某商场促销活动，对商进行打折销售，现在需要做到如果折后价大于0或小于原价，那么输出折后价，否则报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 原价</span><br><span class=\"line\">price = float(input(&quot;请输入原价:&quot;))</span><br><span class=\"line\"># 折扣力度</span><br><span class=\"line\">discount = float(input(&quot;请输入打几折:&quot;))</span><br><span class=\"line\"># 折后价</span><br><span class=\"line\">update_price = price * (discount * 0.1)</span><br><span class=\"line\">assert 0 &lt; update_price &lt; price</span><br><span class=\"line\">print(&quot;折后价为:&#123;:.2f&#125;¥&quot;.format(update_price))</span><br></pre></td></tr></table></figure>\n<p>正常结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入原价:100</span><br><span class=\"line\">请输入打几折:8</span><br><span class=\"line\">折后价为:80.00¥</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>错误结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入原价:100</span><br><span class=\"line\">请输入打几折:18</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">    assert 0 &lt; update_price &lt; price</span><br><span class=\"line\">AssertionError</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>在实际工作中，assert可以提前预防一些问题。</p>\n<h1 id=\"Python-while循环语句详解\"><a href=\"#Python-while循环语句详解\" class=\"headerlink\" title=\"Python while循环语句详解\"></a>Python while循环语句详解</h1><p>本笔记不讨论<code>while</code> 循环语句的使用，想要了解的同学，可以点击<a href=\"http://c.biancheng.net/view/4427.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python-for循环及用法详解\"><a href=\"#Python-for循环及用法详解\" class=\"headerlink\" title=\"Python for循环及用法详解\"></a>Python for循环及用法详解</h1><p>本笔记不讨论<code>for</code> 循环语句的使用，想要了解的同学，可以点击<a href=\"http://c.biancheng.net/view/2225.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python循环结构中else用法-入门必读\"><a href=\"#Python循环结构中else用法-入门必读\" class=\"headerlink\" title=\"Python循环结构中else用法(入门必读)\"></a>Python循环结构中else用法(入门必读)</h1><p>Python中，循环语句后可以跟着一个else语句块。其作用是，当循环条件为Fale时，会直接执行紧跟着循环语句块后的else语句块内的代码。 </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count_i = 0</span><br><span class=\"line\">while count_i &lt; 5:</span><br><span class=\"line\">    print(&quot;count_i小于5:&quot;,count_i)</span><br><span class=\"line\">    count_i+=1</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;count_i大于或等于5:&quot;,count_i)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count_i小于5: 0</span><br><span class=\"line\">count_i小于5: 1</span><br><span class=\"line\">count_i小于5: 2</span><br><span class=\"line\">count_i小于5: 3</span><br><span class=\"line\">count_i小于5: 4</span><br><span class=\"line\">count_i大于或等于5: 5</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>读者可能会想，这样做其实也没什么，就算没有else程序也照样会执行else内的代码。</p>\n<p>其实这种语法是Python中一个为了让代码更加具有可读性、美观而有的一个语法。</p>\n<p>for循环也是可以紧跟else的。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(1,6):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;输出完毕&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">输出完毕</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-for和while-循环嵌套及用法\"><a href=\"#Python-for和while-循环嵌套及用法\" class=\"headerlink\" title=\"Python(for和while)循环嵌套及用法\"></a>Python(for和while)循环嵌套及用法</h1><p>如果将一个循环语句放入一个循环体内，就会形成循环嵌套。</p>\n<p>当程序遇到循环嵌套时，如果外层循环的循环条件允许，则会执行外层循环的循环体，而内层循环将会被外层循环的循环体来执行(只是内层循环需要反复执行自己的循环体而已)。只有当内层循环执行结束且外层循环的循环体也执行结束时，才会再次通过判断外层循环的条件，决定是否再次开始执行外层循环的循环体。</p>\n<p>居上所述，假设外层循环的循环次数为n次，那么内层循环的循环次数为m次，那么可得出内层循环的循环体实际上需要执行<code>n x m</code> 次。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(0,3):</span><br><span class=\"line\">    j = 0</span><br><span class=\"line\">    while j &lt; 3:</span><br><span class=\"line\">        print(&quot;i:&#123;&#125;\\tj:&#123;&#125;&quot;.format(i,j))</span><br><span class=\"line\">        j += 1</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i:0     j:0</span><br><span class=\"line\">i:0     j:1</span><br><span class=\"line\">i:0     j:2</span><br><span class=\"line\">i:1     j:0</span><br><span class=\"line\">i:1     j:1</span><br><span class=\"line\">i:1     j:2</span><br><span class=\"line\">i:2     j:0</span><br><span class=\"line\">i:2     j:1</span><br><span class=\"line\">i:2     j:2</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>i 为外层循环的数，j为内层循环的数，可以看到每次内层循环结束后外层循环的i才会发生改变，当时每次外层循环结束后，再次进入循环体后，将会重置内层循环j的值。</p>\n<p>嵌套循环可以无限嵌套，但开发者最好不要超过三层循环，不然逻辑很容易混乱。</p>\n<h1 id=\"Python嵌套循环实现冒泡排序\"><a href=\"#Python嵌套循环实现冒泡排序\" class=\"headerlink\" title=\"Python嵌套循环实现冒泡排序\"></a>Python嵌套循环实现冒泡排序</h1><p>冒泡排序算法的实现思想:</p>\n<ul>\n<li><p>比较相邻元素大小，若前一个比后一个大则交换位置。</p>\n</li>\n<li><p>从第一对相邻元素到结尾的最后一对相邻元素，对每一对相邻元素做上一步骤的比较工作，并将最大的元素放在后面。</p>\n</li>\n<li><p>将循环缩短，除去最后一个数，再重复第二步骤操作。</p>\n</li>\n<li><p>持续做步骤三操作，将每次循环缩短一位。</p>\n</li>\n</ul>\n<p>实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [10,23,4522,55,13,5123,5,1321235.33,42.123]</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(len(test_list)-1):</span><br><span class=\"line\">    # 每次得到最大值后循环缩短，因为最大值已经在最后</span><br><span class=\"line\">    for j in range(len(test_list)-i-1):</span><br><span class=\"line\">        # 如果相邻元素的第一个元素比第二元素大则:</span><br><span class=\"line\">        if(test_list[j]&gt;test_list[j+1]):</span><br><span class=\"line\">            test_list[j],test_list[j+1]=test_list[j+1],test_list[j]</span><br><span class=\"line\">print(&quot;排序后:&quot;,test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">排序后: [5, 10, 13, 23, 42.123, 55, 4522, 5123, 1321235.33]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Pyton-break用法详解\"><a href=\"#Pyton-break用法详解\" class=\"headerlink\" title=\"Pyton break用法详解\"></a>Pyton break用法详解</h1><p>在我们使用循环时，当条件满足那么循环体内的代码将会一路执行，直到循环体结束为止，如果我们想在执行循环体时直接终止循环或跳出本次循环，则可以使用<code>coontinue</code>或<code>break</code> 语句。</p>\n<p><strong>break用于完全结束一个循环，杀死循环。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">for i in range(0,100000):</span><br><span class=\"line\">    print(&quot;i的值为:&quot;,i)</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">    if sum == 5050:</span><br><span class=\"line\">        break</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i的值为: 0</span><br><span class=\"line\">i的值为: 1</span><br><span class=\"line\">i的值为: 2</span><br><span class=\"line\">i的值为: 3</span><br><span class=\"line\">i的值为: 4</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">i的值为: 94</span><br><span class=\"line\">i的值为: 95</span><br><span class=\"line\">i的值为: 96</span><br><span class=\"line\">i的值为: 97</span><br><span class=\"line\">i的值为: 98</span><br><span class=\"line\">i的值为: 99</span><br><span class=\"line\">i的值为: 100</span><br></pre></td></tr></table></figure>\n<p>可以看到，当sum值为5050时，循环将会被杀死，不再执行。</p>\n<p>如果循环体外带上了else块，那么如果循环体内执行了break语句，则else语句块内的代码不会被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(1,4):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    if i &gt; 2:</span><br><span class=\"line\">        break</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;else&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，当for循环体内执行了break语句后，else内的代码也不会执行。</p>\n<p><strong>break语句只能结束当前执行的循环，而不能结束被嵌套循环的外层循环。</strong></p>\n<h1 id=\"Python-continue用法\"><a href=\"#Python-continue用法\" class=\"headerlink\" title=\"Python continue用法\"></a>Python continue用法</h1><p>continue与break类似，但不同点在于continue只能跳出本次循环，并不能终止循环。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(1,5):</span><br><span class=\"line\">    if i == 2:</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，当循环内部执行continue之后，下面的代码将不会被执行。</p>\n<h1 id=\"如何避免Python出现死循环\"><a href=\"#如何避免Python出现死循环\" class=\"headerlink\" title=\"如何避免Python出现死循环\"></a>如何避免Python出现死循环</h1><p>为了避免Python程序出现死循环，所以<strong>必须确保循环结构中至少有能让循环条件为False或让break语句得以执行的语句。</strong> </p>\n<h1 id=\"Python推导式详解\"><a href=\"#Python推导式详解\" class=\"headerlink\" title=\"Python推导式详解\"></a>Python推导式详解</h1><p>Python推导式，是Python独有的一种特性。使用推导式可以快速生成列表、元素、字典以及集合类型的数据。</p>\n<p>列表推导式利用range区间、元组、列表、字典和集合等数据类型、快速生成一个满足指定需求的列表。</p>\n<p>语法格式:</p>\n<p><code>[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]</code> </p>\n<p><strong>if条件表达式为非必须的。</strong></p>\n<h2 id=\"列表推导式\"><a href=\"#列表推导式\" class=\"headerlink\" title=\"列表推导式\"></a>列表推导式</h2><p>例子:</p>\n<p>求0-10的平方</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [x * x for x in range(11)]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></p>\n<p>例子2:</p>\n<p>求0-10的平方，并且满足可以整除2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [x * x for x in range(11) if x % 2 == 0]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>[0, 4, 16, 36, 64, 100]</code> </p>\n<p>上面的列表推导式都只有一个循环，但实际上它可以使用多个循环。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [(x,y)for x in range(5) for y in range(4)]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1)</span><br><span class=\"line\">, (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3</span><br><span class=\"line\">)]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>其实Python的列表推导式可以使用循环语句重写:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list2 = []</span><br><span class=\"line\">for x in range(5):</span><br><span class=\"line\">    for y in range(4):</span><br><span class=\"line\">        test_list2.append((x,y))</span><br><span class=\"line\">print(test_list2)</span><br></pre></td></tr></table></figure>\n<p>输出结果同上</p>\n<p>当然，也支持多层循环嵌套的推导式。</p>\n<h2 id=\"元组推导式\"><a href=\"#元组推导式\" class=\"headerlink\" title=\"元组推导式\"></a>元组推导式</h2><p>元组推导式同列表推导式一样，可以使用range区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>\n<p>语法格式:</p>\n<p><code>(表达式 for 迭代变量 in 可迭代对象 [if条件表达式])</code> </p>\n<p><strong>if条件表达式为可选</strong> </p>\n<p>首先将元组推导式与列表推导式做一个对比。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [x for x in range(10)]</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">test_tuple = (x for x in range(10))</span><br><span class=\"line\">print(test_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">&lt;generator object &lt;genexpr&gt; at 0x106f3d450&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，除了元组推导式是使用<code>()</code> 圆括号而列表推导式是使用<code>[]</code> 方括号之外，还有就是元组推导式生成的结果并不是一个元组，而是一个<code>生成器对象</code> 。</p>\n<p>我们可以通过<code>tuple()</code> 函数将生成器对象转换为元组或使用循环遍历生成器对象，获取各元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x =  (x for x in range(10))</span><br><span class=\"line\">for ele in x:</span><br><span class=\"line\">\\    print(ele,end=&quot; &quot;)</span><br><span class=\"line\">print(tuple(x))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>0 1 2 3 4 5 6 7 8 9 ()</code> </p>\n<p><strong>注意:当我们遍历了生成器对象后，原生成器对象将不复存在，这就是为什么我们遍历了生成器对象后再将原生成器对象转换却得到空元组的原因</strong> </p>\n<p>我们还可以使用<code>__next__()</code> 方法遍历，但很不方便。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x =  (x for x in range(10))</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(tuple(x))</span><br><span class=\"line\">print(x.__next__())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">()</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 13, in &lt;module&gt;</span><br><span class=\"line\">    print(x.__next__())</span><br><span class=\"line\">StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>可以看到被遍历后的生成器将会被清空，并且需要注意的是<strong><strong>next</strong>方法需要不能越界</strong> </p>\n<h2 id=\"Python-字典推导式\"><a href=\"#Python-字典推导式\" class=\"headerlink\" title=\"Python 字典推导式\"></a>Python 字典推导式</h2><p>同前两个推导式一样，都可以接住多种数据类型生成符合需求的字典。</p>\n<p>语法格式:</p>\n<p><code>{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</code> </p>\n<p>例子:</p>\n<p>将列表内元素作为键，其元素长度为值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&apos;Hello&apos;,&quot;World&quot;]</span><br><span class=\"line\">test_map = &#123;key:len(key) for key in test_list&#125;</span><br><span class=\"line\">print(test_map)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>{&#39;Hello&#39;: 5, &#39;World&#39;: 5}</code> </p>\n<p>例子2:</p>\n<p>调换键值对</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;]</span><br><span class=\"line\">test_dict = dict.fromkeys(test_list,100)</span><br><span class=\"line\">print(test_dict)</span><br><span class=\"line\">test_dict2 = &#123;v:x for x,v in test_dict.items()&#125;</span><br><span class=\"line\">print(test_dict2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;语文&apos;: 100, &apos;数学&apos;: 100, &apos;英语&apos;: 100&#125;</span><br><span class=\"line\">&#123;100: &apos;英语&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python集合推导式\"><a href=\"#Python集合推导式\" class=\"headerlink\" title=\"Python集合推导式\"></a>Python集合推导式</h2><p>同上，可以使用常用数据类型快速生成符合需求的集合。</p>\n<p>语法格式:</p>\n<p><code>{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</code> </p>\n<p><strong>注意：集合推导式的语法格式与字典推导式的语法格式相同，为了区分它们，同时看表达式的形式，如果是以键值对(key:value)的形式，那么就是字典，否则反之</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newset = &#123;i**2 for i in range(3)&#125;</span><br><span class=\"line\">print(newset)</span><br><span class=\"line\">print(type(newset))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;0, 1, 4&#125;</span><br><span class=\"line\">&lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-zip函数及用法\"><a href=\"#Python-zip函数及用法\" class=\"headerlink\" title=\"Python zip函数及用法\"></a>Python zip函数及用法</h1><p><code>zip()</code> 函数可以将多个列表转化一个zip对象(可迭代对象)。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = list(range(1,10))</span><br><span class=\"line\">list2 = list(range(-10,0))</span><br><span class=\"line\">print([x for x in zip(list1,list2)])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(1, -10), (2, -9), (3, -8), (4, -7), (5, -6), (6, -5), (7, -4), (8, -3), (9, -</span><br><span class=\"line\">2)]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-reversed函数及用法\"><a href=\"#Python-reversed函数及用法\" class=\"headerlink\" title=\"Python reversed函数及用法\"></a>Python reversed函数及用法</h1><p>reversed()函数用于将各种序列进行<strong>逆序排序</strong> ，但不会影响序列本身。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print([x for x in reversed(string)])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>[&#39;d&#39;, &#39;l&#39;, &#39;r&#39;, &#39;o&#39;, &#39;W&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;e&#39;, &#39;H&#39;]</code> </p>\n<h1 id=\"Python-sorted函数及用法\"><a href=\"#Python-sorted函数及用法\" class=\"headerlink\" title=\"Python sorted函数及用法\"></a>Python sorted函数及用法</h1><p>sorted函数用于将各种序列进行排序。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;123456789&quot;</span><br><span class=\"line\">re_string = [x for x in reversed(string)]</span><br><span class=\"line\">print(re_string)</span><br><span class=\"line\">sort_string = sorted(re_string)</span><br><span class=\"line\">print(sort_string)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;, &apos;1&apos;]</span><br><span class=\"line\">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python项目实战之猜数字游戏\"><a href=\"#Python项目实战之猜数字游戏\" class=\"headerlink\" title=\"Python项目实战之猜数字游戏\"></a>Python项目实战之猜数字游戏</h1><p>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 随机数模块</span><br><span class=\"line\">import random</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;&#123;0:=^20s&#125;&#123;1:s&#125;&#123;0:=^20s&#125;\\n&quot;.format(&quot;==========&quot;,&quot;欢迎游玩猜数字游戏&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\"># 随机数(1-20之间)</span><br><span class=\"line\">randomNum = random.randint(1,20)</span><br><span class=\"line\"></span><br><span class=\"line\"># 只给用户5次机会</span><br><span class=\"line\"></span><br><span class=\"line\">for count in range(1,6):</span><br><span class=\"line\">    print(&quot;\\n算上这次，你还有&#123;:d&#125;次机会!\\n&quot;.format(5-count))</span><br><span class=\"line\">    num = int(input(&quot;请输入猜测的数(范围1~20):&quot;))</span><br><span class=\"line\">    if num&gt;randomNum:</span><br><span class=\"line\">        print(&quot;\\n系统&gt;&gt; 大了点!!!&quot;)</span><br><span class=\"line\">    elif num &lt; randomNum:</span><br><span class=\"line\">        print(&quot;\\n系统&gt;&gt; 小了点!!!&quot;)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;\\n系统&gt;&gt; 恭喜你猜中了数字!!!&quot;)</span><br><span class=\"line\">        break</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;\\n系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:&#123;:d&#125;&quot;.format(randomNum))</span><br></pre></td></tr></table></figure>\n<p>猜中运行实例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">====================欢迎游玩猜数字游戏====================</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有4次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):10</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有3次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):15</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 大了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有2次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):14</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 大了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有1次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):13</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 恭喜你猜中了数字!!!</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>猜错运行实例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">====================欢迎游玩猜数字游戏====================</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有4次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有3次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有2次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有1次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有0次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:3</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python项目实战-绕圈圈面试题\"><a href=\"#Python项目实战-绕圈圈面试题\" class=\"headerlink\" title=\"Python项目实战: 绕圈圈面试题\"></a>Python项目实战: 绕圈圈面试题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SIZE = 7</span><br><span class=\"line\"></span><br><span class=\"line\">array = [[0] * SIZE]</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建一个长度SIZE * SIZE的二维列表</span><br><span class=\"line\">for i in range(SIZE - 1):</span><br><span class=\"line\">    array += [[0] * SIZE]</span><br><span class=\"line\"></span><br><span class=\"line\"># 绕圈的方向(0:下 1:右 2：左 3:上)</span><br><span class=\"line\">orient = 0</span><br><span class=\"line\"></span><br><span class=\"line\"># l 控制行索引 c控制列索引</span><br><span class=\"line\">l = 0</span><br><span class=\"line\">c = 0</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(1,SIZE * SIZE + 1):</span><br><span class=\"line\">    array[l][c] = i</span><br><span class=\"line\"></span><br><span class=\"line\">    # 如果位于1号转弯线上</span><br><span class=\"line\">    if l+c == SIZE - 1:</span><br><span class=\"line\">        # l &gt; c，位于左下角</span><br><span class=\"line\">        if l &gt; c:</span><br><span class=\"line\">            orient = 1</span><br><span class=\"line\">        else :</span><br><span class=\"line\">            orient = 2</span><br><span class=\"line\">    elif (c == l) and (c &gt;= SIZE / 2):</span><br><span class=\"line\">        orient = 3</span><br><span class=\"line\">    elif (l == c - 1) and (c &lt;= SIZE / 2):</span><br><span class=\"line\">        orient = 0</span><br><span class=\"line\">    if orient == 0:</span><br><span class=\"line\">        l += 1</span><br><span class=\"line\">    elif orient == 1:</span><br><span class=\"line\">        c += 1</span><br><span class=\"line\">    elif orient == 2:</span><br><span class=\"line\">        c -= 1</span><br><span class=\"line\">    elif orient == 3:</span><br><span class=\"line\">        l -= 1</span><br><span class=\"line\">for i in range(SIZE):</span><br><span class=\"line\">    for j in range(SIZE):</span><br><span class=\"line\">        print(&quot;%02d&quot; % array[i][j],end = &quot;&quot;)</span><br><span class=\"line\">    print(&quot;&quot;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Python系列第六章笔记，查看Python系列所有文章，请点击<a href=\"http://c.biancheng.net/python/str_method/\" target=\"_blank\" rel=\"noopener\">💿</a></p>","more":"<p>Python中的流程结构也就是选择语句，选择语句又分为3种语法形式，分别是if、if else、if elif else。</p>\n<p>if 语句语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 表达式:</span><br><span class=\"line\">  代码块</span><br></pre></td></tr></table></figure>\n<p>if else 语句语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 表达式:</span><br><span class=\"line\">  代码块 1</span><br><span class=\"line\">else:</span><br><span class=\"line\">  代码块 2</span><br></pre></td></tr></table></figure>\n<p>if elif else 语句语法格式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 表达式1:</span><br><span class=\"line\">  代码块 1</span><br><span class=\"line\">elif 表达式2:</span><br><span class=\"line\">  代码块 2</span><br><span class=\"line\">elif 表达式3:</span><br><span class=\"line\">  代码块 3</span><br><span class=\"line\">...</span><br><span class=\"line\">else:</span><br><span class=\"line\">  代码块 n</span><br></pre></td></tr></table></figure>\n<p>以上三种选择结构的语法形式差别不大，它们有个共性，就是<strong>当表达式的值为True时会执行代码块内的代码</strong> 。</p>\n<p>选择语句的表达式相当于条件，当表达式的条件满足后，就会执行代码块内的代码啦。</p>\n<p><strong>注意:Python的代码块是通过缩进标记的，具有相同缩进的多行代码属于同一个代码块</strong> .</p>\n<p><strong>if表达式真假值得判断方法</strong> </p>\n<p>表达式可以是任意类型，不过下面的几种类型将会被Python解释器当做False处理:</p>\n<p><code>Flase、None、0、&quot;&quot;、()、[]、{}</code> </p>\n<h1 id=\"Python-if-else语句用法范例-注意事项\"><a href=\"#Python-if-else语句用法范例-注意事项\" class=\"headerlink\" title=\"Python if else语句用法范例(注意事项_)\"></a>Python if else语句用法范例(注意事项_)</h1><p><strong>1)代码块不要忘记缩进</strong> </p>\n<p>每一个缩进就代表了一个代码块，如果没有没有缩进程序可能会出现各种问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s_age = input(&quot;请输入您的年龄:&quot;)</span><br><span class=\"line\">age = int(s_age)</span><br><span class=\"line\">if age &gt;= 18:</span><br><span class=\"line\">print(&quot;你成年了.&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File &quot;test.py&quot;, line 4</span><br><span class=\"line\">  print(&quot;你成年了.&quot;)</span><br><span class=\"line\">      ^</span><br><span class=\"line\">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure>\n<p>有时没有缩进不代表程序没有错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s_age = input(&quot;请输入您的年龄:&quot;)</span><br><span class=\"line\">age = int(s_age)</span><br><span class=\"line\">if age &gt;= 18:</span><br><span class=\"line\">    print(&quot;你成年了.&quot;)</span><br><span class=\"line\">print(&quot;成年了，就要修身养性.&quot;)</span><br><span class=\"line\">print(&quot;你未成年.&quot;)</span><br></pre></td></tr></table></figure>\n<p>运行过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入您的年龄:10</span><br><span class=\"line\">成年了，就要修身养性.</span><br><span class=\"line\">你未成年.</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>虽然程序没有报错，但是确是不符合逻辑的，应该是当输入的年龄大于等于18岁才输出成年了，就要修身养性，但是由于没有将其缩进，所以造成了代码的运行结果不如人意。</p>\n<p><strong>2)语句不要随意缩进</strong> </p>\n<p>我们必须保证同一个代码块内的代码必须保持相同的缩进，如果多一个缩进或少一个缩进都会出现不可预料的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 10</span><br><span class=\"line\">if a &gt; 9:</span><br><span class=\"line\">    print(&quot;a &gt; 9&quot;)</span><br><span class=\"line\">        print(&quot;====&quot;)</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  File &quot;test.py&quot;, line 1</span><br><span class=\"line\">    int a = 10</span><br><span class=\"line\">        ^</span><br><span class=\"line\">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>\n<p>Python解释器抛出了一个SyntaxError错误</p>\n<p><strong>3)if表达式不要遗忘冒号</strong> </p>\n<p>Python解释器将冒号表示为代码块的开始，如果遗忘冒号也会引发一些错误，因为Python解释器无法识别代码块的开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 10 &gt; 9</span><br><span class=\"line\">    print(&quot;9 &gt; 10&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;10 &lt; 9&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  File &quot;test.py&quot;, line 1</span><br><span class=\"line\">    if 10 &gt; 9</span><br><span class=\"line\">            ^</span><br><span class=\"line\">SyntaxError: invalid syntax</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>以冒号作为代码块的开始在其他语句结构也是如此，例如循环、类等。</p>\n<h1 id=\"Python-if语句嵌套\"><a href=\"#Python-if语句嵌套\" class=\"headerlink\" title=\"Python if语句嵌套\"></a>Python if语句嵌套</h1><p>此笔记不讨论此内容，如需了解，请点击此处<a href=\"https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/\">查看原文</a> </p>\n<h1 id=\"Python-pass语句及其作用\"><a href=\"#Python-pass语句及其作用\" class=\"headerlink\" title=\"Python pass语句及其作用\"></a>Python pass语句及其作用</h1><p>如果你想要一个代码块内什么都不做，但是没有这个代码块语法又不通过，你可以使用<code>pass</code> ，其是Python中的空语句，它什么也不做，唯一的功能就是占位了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 10 &gt; 9:</span><br><span class=\"line\">    print(&quot;xxx&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    pass</span><br><span class=\"line\">print(&quot;xxxx&quot;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-assert断言函数及用法\"><a href=\"#Python-assert断言函数及用法\" class=\"headerlink\" title=\"Python assert断言函数及用法\"></a>Python assert断言函数及用法</h1><p><code>assert断言函数</code> 与if分支类似，不过它的特点是:<strong>当它的表达式条件为False时将会抛出异常，程序崩溃</strong> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = int(input(&quot;请输入大于10且小于100的数字:&quot;))</span><br><span class=\"line\">assert 10 &lt; num &lt; 100</span><br><span class=\"line\">print(num)</span><br></pre></td></tr></table></figure>\n<p>当我们输入非大于10且小于100的数字将会抛出异常:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入大于10且小于100的数字:1000</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 2, in &lt;module&gt;</span><br><span class=\"line\">    assert 10 &lt; num &lt; 100</span><br><span class=\"line\">AssertionError</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-如何合理使用assert\"><a href=\"#Python-如何合理使用assert\" class=\"headerlink\" title=\"Python 如何合理使用assert\"></a>Python 如何合理使用assert</h1><p>本小节通过一些实际应用的例子，演示assert在Python中的用法。</p>\n<p>某商场促销活动，对商进行打折销售，现在需要做到如果折后价大于0或小于原价，那么输出折后价，否则报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 原价</span><br><span class=\"line\">price = float(input(&quot;请输入原价:&quot;))</span><br><span class=\"line\"># 折扣力度</span><br><span class=\"line\">discount = float(input(&quot;请输入打几折:&quot;))</span><br><span class=\"line\"># 折后价</span><br><span class=\"line\">update_price = price * (discount * 0.1)</span><br><span class=\"line\">assert 0 &lt; update_price &lt; price</span><br><span class=\"line\">print(&quot;折后价为:&#123;:.2f&#125;¥&quot;.format(update_price))</span><br></pre></td></tr></table></figure>\n<p>正常结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入原价:100</span><br><span class=\"line\">请输入打几折:8</span><br><span class=\"line\">折后价为:80.00¥</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>错误结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入原价:100</span><br><span class=\"line\">请输入打几折:18</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">    assert 0 &lt; update_price &lt; price</span><br><span class=\"line\">AssertionError</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>在实际工作中，assert可以提前预防一些问题。</p>\n<h1 id=\"Python-while循环语句详解\"><a href=\"#Python-while循环语句详解\" class=\"headerlink\" title=\"Python while循环语句详解\"></a>Python while循环语句详解</h1><p>本笔记不讨论<code>while</code> 循环语句的使用，想要了解的同学，可以点击<a href=\"http://c.biancheng.net/view/4427.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python-for循环及用法详解\"><a href=\"#Python-for循环及用法详解\" class=\"headerlink\" title=\"Python for循环及用法详解\"></a>Python for循环及用法详解</h1><p>本笔记不讨论<code>for</code> 循环语句的使用，想要了解的同学，可以点击<a href=\"http://c.biancheng.net/view/2225.html\" target=\"_blank\" rel=\"noopener\">查看原文</a> </p>\n<h1 id=\"Python循环结构中else用法-入门必读\"><a href=\"#Python循环结构中else用法-入门必读\" class=\"headerlink\" title=\"Python循环结构中else用法(入门必读)\"></a>Python循环结构中else用法(入门必读)</h1><p>Python中，循环语句后可以跟着一个else语句块。其作用是，当循环条件为Fale时，会直接执行紧跟着循环语句块后的else语句块内的代码。 </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count_i = 0</span><br><span class=\"line\">while count_i &lt; 5:</span><br><span class=\"line\">    print(&quot;count_i小于5:&quot;,count_i)</span><br><span class=\"line\">    count_i+=1</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;count_i大于或等于5:&quot;,count_i)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count_i小于5: 0</span><br><span class=\"line\">count_i小于5: 1</span><br><span class=\"line\">count_i小于5: 2</span><br><span class=\"line\">count_i小于5: 3</span><br><span class=\"line\">count_i小于5: 4</span><br><span class=\"line\">count_i大于或等于5: 5</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>读者可能会想，这样做其实也没什么，就算没有else程序也照样会执行else内的代码。</p>\n<p>其实这种语法是Python中一个为了让代码更加具有可读性、美观而有的一个语法。</p>\n<p>for循环也是可以紧跟else的。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(1,6):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;输出完毕&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">输出完毕</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-for和while-循环嵌套及用法\"><a href=\"#Python-for和while-循环嵌套及用法\" class=\"headerlink\" title=\"Python(for和while)循环嵌套及用法\"></a>Python(for和while)循环嵌套及用法</h1><p>如果将一个循环语句放入一个循环体内，就会形成循环嵌套。</p>\n<p>当程序遇到循环嵌套时，如果外层循环的循环条件允许，则会执行外层循环的循环体，而内层循环将会被外层循环的循环体来执行(只是内层循环需要反复执行自己的循环体而已)。只有当内层循环执行结束且外层循环的循环体也执行结束时，才会再次通过判断外层循环的条件，决定是否再次开始执行外层循环的循环体。</p>\n<p>居上所述，假设外层循环的循环次数为n次，那么内层循环的循环次数为m次，那么可得出内层循环的循环体实际上需要执行<code>n x m</code> 次。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(0,3):</span><br><span class=\"line\">    j = 0</span><br><span class=\"line\">    while j &lt; 3:</span><br><span class=\"line\">        print(&quot;i:&#123;&#125;\\tj:&#123;&#125;&quot;.format(i,j))</span><br><span class=\"line\">        j += 1</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i:0     j:0</span><br><span class=\"line\">i:0     j:1</span><br><span class=\"line\">i:0     j:2</span><br><span class=\"line\">i:1     j:0</span><br><span class=\"line\">i:1     j:1</span><br><span class=\"line\">i:1     j:2</span><br><span class=\"line\">i:2     j:0</span><br><span class=\"line\">i:2     j:1</span><br><span class=\"line\">i:2     j:2</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>i 为外层循环的数，j为内层循环的数，可以看到每次内层循环结束后外层循环的i才会发生改变，当时每次外层循环结束后，再次进入循环体后，将会重置内层循环j的值。</p>\n<p>嵌套循环可以无限嵌套，但开发者最好不要超过三层循环，不然逻辑很容易混乱。</p>\n<h1 id=\"Python嵌套循环实现冒泡排序\"><a href=\"#Python嵌套循环实现冒泡排序\" class=\"headerlink\" title=\"Python嵌套循环实现冒泡排序\"></a>Python嵌套循环实现冒泡排序</h1><p>冒泡排序算法的实现思想:</p>\n<ul>\n<li><p>比较相邻元素大小，若前一个比后一个大则交换位置。</p>\n</li>\n<li><p>从第一对相邻元素到结尾的最后一对相邻元素，对每一对相邻元素做上一步骤的比较工作，并将最大的元素放在后面。</p>\n</li>\n<li><p>将循环缩短，除去最后一个数，再重复第二步骤操作。</p>\n</li>\n<li><p>持续做步骤三操作，将每次循环缩短一位。</p>\n</li>\n</ul>\n<p>实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [10,23,4522,55,13,5123,5,1321235.33,42.123]</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(len(test_list)-1):</span><br><span class=\"line\">    # 每次得到最大值后循环缩短，因为最大值已经在最后</span><br><span class=\"line\">    for j in range(len(test_list)-i-1):</span><br><span class=\"line\">        # 如果相邻元素的第一个元素比第二元素大则:</span><br><span class=\"line\">        if(test_list[j]&gt;test_list[j+1]):</span><br><span class=\"line\">            test_list[j],test_list[j+1]=test_list[j+1],test_list[j]</span><br><span class=\"line\">print(&quot;排序后:&quot;,test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">排序后: [5, 10, 13, 23, 42.123, 55, 4522, 5123, 1321235.33]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Pyton-break用法详解\"><a href=\"#Pyton-break用法详解\" class=\"headerlink\" title=\"Pyton break用法详解\"></a>Pyton break用法详解</h1><p>在我们使用循环时，当条件满足那么循环体内的代码将会一路执行，直到循环体结束为止，如果我们想在执行循环体时直接终止循环或跳出本次循环，则可以使用<code>coontinue</code>或<code>break</code> 语句。</p>\n<p><strong>break用于完全结束一个循环，杀死循环。</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">for i in range(0,100000):</span><br><span class=\"line\">    print(&quot;i的值为:&quot;,i)</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">    if sum == 5050:</span><br><span class=\"line\">        break</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i的值为: 0</span><br><span class=\"line\">i的值为: 1</span><br><span class=\"line\">i的值为: 2</span><br><span class=\"line\">i的值为: 3</span><br><span class=\"line\">i的值为: 4</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">i的值为: 94</span><br><span class=\"line\">i的值为: 95</span><br><span class=\"line\">i的值为: 96</span><br><span class=\"line\">i的值为: 97</span><br><span class=\"line\">i的值为: 98</span><br><span class=\"line\">i的值为: 99</span><br><span class=\"line\">i的值为: 100</span><br></pre></td></tr></table></figure>\n<p>可以看到，当sum值为5050时，循环将会被杀死，不再执行。</p>\n<p>如果循环体外带上了else块，那么如果循环体内执行了break语句，则else语句块内的代码不会被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(1,4):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    if i &gt; 2:</span><br><span class=\"line\">        break</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;else&quot;)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，当for循环体内执行了break语句后，else内的代码也不会执行。</p>\n<p><strong>break语句只能结束当前执行的循环，而不能结束被嵌套循环的外层循环。</strong></p>\n<h1 id=\"Python-continue用法\"><a href=\"#Python-continue用法\" class=\"headerlink\" title=\"Python continue用法\"></a>Python continue用法</h1><p>continue与break类似，但不同点在于continue只能跳出本次循环，并不能终止循环。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in range(1,5):</span><br><span class=\"line\">    if i == 2:</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，当循环内部执行continue之后，下面的代码将不会被执行。</p>\n<h1 id=\"如何避免Python出现死循环\"><a href=\"#如何避免Python出现死循环\" class=\"headerlink\" title=\"如何避免Python出现死循环\"></a>如何避免Python出现死循环</h1><p>为了避免Python程序出现死循环，所以<strong>必须确保循环结构中至少有能让循环条件为False或让break语句得以执行的语句。</strong> </p>\n<h1 id=\"Python推导式详解\"><a href=\"#Python推导式详解\" class=\"headerlink\" title=\"Python推导式详解\"></a>Python推导式详解</h1><p>Python推导式，是Python独有的一种特性。使用推导式可以快速生成列表、元素、字典以及集合类型的数据。</p>\n<p>列表推导式利用range区间、元组、列表、字典和集合等数据类型、快速生成一个满足指定需求的列表。</p>\n<p>语法格式:</p>\n<p><code>[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]</code> </p>\n<p><strong>if条件表达式为非必须的。</strong></p>\n<h2 id=\"列表推导式\"><a href=\"#列表推导式\" class=\"headerlink\" title=\"列表推导式\"></a>列表推导式</h2><p>例子:</p>\n<p>求0-10的平方</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [x * x for x in range(11)]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:<code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></p>\n<p>例子2:</p>\n<p>求0-10的平方，并且满足可以整除2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [x * x for x in range(11) if x % 2 == 0]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>[0, 4, 16, 36, 64, 100]</code> </p>\n<p>上面的列表推导式都只有一个循环，但实际上它可以使用多个循环。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [(x,y)for x in range(5) for y in range(4)]</span><br><span class=\"line\">print(test_list)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1)</span><br><span class=\"line\">, (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3</span><br><span class=\"line\">)]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>其实Python的列表推导式可以使用循环语句重写:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list2 = []</span><br><span class=\"line\">for x in range(5):</span><br><span class=\"line\">    for y in range(4):</span><br><span class=\"line\">        test_list2.append((x,y))</span><br><span class=\"line\">print(test_list2)</span><br></pre></td></tr></table></figure>\n<p>输出结果同上</p>\n<p>当然，也支持多层循环嵌套的推导式。</p>\n<h2 id=\"元组推导式\"><a href=\"#元组推导式\" class=\"headerlink\" title=\"元组推导式\"></a>元组推导式</h2><p>元组推导式同列表推导式一样，可以使用range区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>\n<p>语法格式:</p>\n<p><code>(表达式 for 迭代变量 in 可迭代对象 [if条件表达式])</code> </p>\n<p><strong>if条件表达式为可选</strong> </p>\n<p>首先将元组推导式与列表推导式做一个对比。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [x for x in range(10)]</span><br><span class=\"line\">print(test_list)</span><br><span class=\"line\">test_tuple = (x for x in range(10))</span><br><span class=\"line\">print(test_tuple)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">&lt;generator object &lt;genexpr&gt; at 0x106f3d450&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>可以看到，除了元组推导式是使用<code>()</code> 圆括号而列表推导式是使用<code>[]</code> 方括号之外，还有就是元组推导式生成的结果并不是一个元组，而是一个<code>生成器对象</code> 。</p>\n<p>我们可以通过<code>tuple()</code> 函数将生成器对象转换为元组或使用循环遍历生成器对象，获取各元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x =  (x for x in range(10))</span><br><span class=\"line\">for ele in x:</span><br><span class=\"line\">\\    print(ele,end=&quot; &quot;)</span><br><span class=\"line\">print(tuple(x))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>0 1 2 3 4 5 6 7 8 9 ()</code> </p>\n<p><strong>注意:当我们遍历了生成器对象后，原生成器对象将不复存在，这就是为什么我们遍历了生成器对象后再将原生成器对象转换却得到空元组的原因</strong> </p>\n<p>我们还可以使用<code>__next__()</code> 方法遍历，但很不方便。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x =  (x for x in range(10))</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(x.__next__())</span><br><span class=\"line\">print(tuple(x))</span><br><span class=\"line\">print(x.__next__())</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">()</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;test.py&quot;, line 13, in &lt;module&gt;</span><br><span class=\"line\">    print(x.__next__())</span><br><span class=\"line\">StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 1]</span><br></pre></td></tr></table></figure>\n<p>可以看到被遍历后的生成器将会被清空，并且需要注意的是<strong><strong>next</strong>方法需要不能越界</strong> </p>\n<h2 id=\"Python-字典推导式\"><a href=\"#Python-字典推导式\" class=\"headerlink\" title=\"Python 字典推导式\"></a>Python 字典推导式</h2><p>同前两个推导式一样，都可以接住多种数据类型生成符合需求的字典。</p>\n<p>语法格式:</p>\n<p><code>{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</code> </p>\n<p>例子:</p>\n<p>将列表内元素作为键，其元素长度为值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&apos;Hello&apos;,&quot;World&quot;]</span><br><span class=\"line\">test_map = &#123;key:len(key) for key in test_list&#125;</span><br><span class=\"line\">print(test_map)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>{&#39;Hello&#39;: 5, &#39;World&#39;: 5}</code> </p>\n<p>例子2:</p>\n<p>调换键值对</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test_list = [&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;]</span><br><span class=\"line\">test_dict = dict.fromkeys(test_list,100)</span><br><span class=\"line\">print(test_dict)</span><br><span class=\"line\">test_dict2 = &#123;v:x for x,v in test_dict.items()&#125;</span><br><span class=\"line\">print(test_dict2)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;语文&apos;: 100, &apos;数学&apos;: 100, &apos;英语&apos;: 100&#125;</span><br><span class=\"line\">&#123;100: &apos;英语&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python集合推导式\"><a href=\"#Python集合推导式\" class=\"headerlink\" title=\"Python集合推导式\"></a>Python集合推导式</h2><p>同上，可以使用常用数据类型快速生成符合需求的集合。</p>\n<p>语法格式:</p>\n<p><code>{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</code> </p>\n<p><strong>注意：集合推导式的语法格式与字典推导式的语法格式相同，为了区分它们，同时看表达式的形式，如果是以键值对(key:value)的形式，那么就是字典，否则反之</strong> </p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newset = &#123;i**2 for i in range(3)&#125;</span><br><span class=\"line\">print(newset)</span><br><span class=\"line\">print(type(newset))</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;0, 1, 4&#125;</span><br><span class=\"line\">&lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-zip函数及用法\"><a href=\"#Python-zip函数及用法\" class=\"headerlink\" title=\"Python zip函数及用法\"></a>Python zip函数及用法</h1><p><code>zip()</code> 函数可以将多个列表转化一个zip对象(可迭代对象)。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = list(range(1,10))</span><br><span class=\"line\">list2 = list(range(-10,0))</span><br><span class=\"line\">print([x for x in zip(list1,list2)])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(1, -10), (2, -9), (3, -8), (4, -7), (5, -6), (6, -5), (7, -4), (8, -3), (9, -</span><br><span class=\"line\">2)]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python-reversed函数及用法\"><a href=\"#Python-reversed函数及用法\" class=\"headerlink\" title=\"Python reversed函数及用法\"></a>Python reversed函数及用法</h1><p>reversed()函数用于将各种序列进行<strong>逆序排序</strong> ，但不会影响序列本身。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;HelloWorld&quot;</span><br><span class=\"line\">print([x for x in reversed(string)])</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<p><code>[&#39;d&#39;, &#39;l&#39;, &#39;r&#39;, &#39;o&#39;, &#39;W&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;e&#39;, &#39;H&#39;]</code> </p>\n<h1 id=\"Python-sorted函数及用法\"><a href=\"#Python-sorted函数及用法\" class=\"headerlink\" title=\"Python sorted函数及用法\"></a>Python sorted函数及用法</h1><p>sorted函数用于将各种序列进行排序。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = &quot;123456789&quot;</span><br><span class=\"line\">re_string = [x for x in reversed(string)]</span><br><span class=\"line\">print(re_string)</span><br><span class=\"line\">sort_string = sorted(re_string)</span><br><span class=\"line\">print(sort_string)</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;, &apos;1&apos;]</span><br><span class=\"line\">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python项目实战之猜数字游戏\"><a href=\"#Python项目实战之猜数字游戏\" class=\"headerlink\" title=\"Python项目实战之猜数字游戏\"></a>Python项目实战之猜数字游戏</h1><p>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 随机数模块</span><br><span class=\"line\">import random</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;&#123;0:=^20s&#125;&#123;1:s&#125;&#123;0:=^20s&#125;\\n&quot;.format(&quot;==========&quot;,&quot;欢迎游玩猜数字游戏&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\"># 随机数(1-20之间)</span><br><span class=\"line\">randomNum = random.randint(1,20)</span><br><span class=\"line\"></span><br><span class=\"line\"># 只给用户5次机会</span><br><span class=\"line\"></span><br><span class=\"line\">for count in range(1,6):</span><br><span class=\"line\">    print(&quot;\\n算上这次，你还有&#123;:d&#125;次机会!\\n&quot;.format(5-count))</span><br><span class=\"line\">    num = int(input(&quot;请输入猜测的数(范围1~20):&quot;))</span><br><span class=\"line\">    if num&gt;randomNum:</span><br><span class=\"line\">        print(&quot;\\n系统&gt;&gt; 大了点!!!&quot;)</span><br><span class=\"line\">    elif num &lt; randomNum:</span><br><span class=\"line\">        print(&quot;\\n系统&gt;&gt; 小了点!!!&quot;)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;\\n系统&gt;&gt; 恭喜你猜中了数字!!!&quot;)</span><br><span class=\"line\">        break</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;\\n系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:&#123;:d&#125;&quot;.format(randomNum))</span><br></pre></td></tr></table></figure>\n<p>猜中运行实例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">====================欢迎游玩猜数字游戏====================</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有4次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):10</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有3次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):15</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 大了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有2次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):14</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 大了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有1次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):13</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 恭喜你猜中了数字!!!</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<p>猜错运行实例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">====================欢迎游玩猜数字游戏====================</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有4次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有3次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有2次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有1次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">算上这次，你还有0次机会!</span><br><span class=\"line\"></span><br><span class=\"line\">请输入猜测的数(范围1~20):1</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 小了点!!!</span><br><span class=\"line\"></span><br><span class=\"line\">系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:3</span><br><span class=\"line\"></span><br><span class=\"line\">[Process exited 0]</span><br></pre></td></tr></table></figure>\n<h1 id=\"Python项目实战-绕圈圈面试题\"><a href=\"#Python项目实战-绕圈圈面试题\" class=\"headerlink\" title=\"Python项目实战: 绕圈圈面试题\"></a>Python项目实战: 绕圈圈面试题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SIZE = 7</span><br><span class=\"line\"></span><br><span class=\"line\">array = [[0] * SIZE]</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建一个长度SIZE * SIZE的二维列表</span><br><span class=\"line\">for i in range(SIZE - 1):</span><br><span class=\"line\">    array += [[0] * SIZE]</span><br><span class=\"line\"></span><br><span class=\"line\"># 绕圈的方向(0:下 1:右 2：左 3:上)</span><br><span class=\"line\">orient = 0</span><br><span class=\"line\"></span><br><span class=\"line\"># l 控制行索引 c控制列索引</span><br><span class=\"line\">l = 0</span><br><span class=\"line\">c = 0</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(1,SIZE * SIZE + 1):</span><br><span class=\"line\">    array[l][c] = i</span><br><span class=\"line\"></span><br><span class=\"line\">    # 如果位于1号转弯线上</span><br><span class=\"line\">    if l+c == SIZE - 1:</span><br><span class=\"line\">        # l &gt; c，位于左下角</span><br><span class=\"line\">        if l &gt; c:</span><br><span class=\"line\">            orient = 1</span><br><span class=\"line\">        else :</span><br><span class=\"line\">            orient = 2</span><br><span class=\"line\">    elif (c == l) and (c &gt;= SIZE / 2):</span><br><span class=\"line\">        orient = 3</span><br><span class=\"line\">    elif (l == c - 1) and (c &lt;= SIZE / 2):</span><br><span class=\"line\">        orient = 0</span><br><span class=\"line\">    if orient == 0:</span><br><span class=\"line\">        l += 1</span><br><span class=\"line\">    elif orient == 1:</span><br><span class=\"line\">        c += 1</span><br><span class=\"line\">    elif orient == 2:</span><br><span class=\"line\">        c -= 1</span><br><span class=\"line\">    elif orient == 3:</span><br><span class=\"line\">        l -= 1</span><br><span class=\"line\">for i in range(SIZE):</span><br><span class=\"line\">    for j in range(SIZE):</span><br><span class=\"line\">        print(&quot;%02d&quot; % array[i][j],end = &quot;&quot;)</span><br><span class=\"line\">    print(&quot;&quot;)</span><br></pre></td></tr></table></figure>"},{"title":"Serimu Lake Day Trip","copyright":true,"date":"2019-07-19T18:04:31.000Z","_content":"\n几天前，我去了新疆的赛里木湖，所以便有了这篇文章。\n\nA few days ago,I went to Serimu Lake in Xinjiang,So I had this article.\n\n<!--more-->\n\n# English\n\n&emsp; Early, I was woken up by a phone call,not the monitor's phone(monitor will not get up so early),I was __confused__ to __pick up__ the phone to answer,the phone came from my father's __voice__.After the phone call,I __immediately__ get out of bed and wash.Let me get up at 7 a.m in the summer __vaction__, in addition to the monitor's phone,that may be what let me __attention__ the new.\n\n&emsp;__In a hurry__,I __arrived__ at Grandma's house.I asked my father,\"What are you going to do today? Why so early? My father answered,\"Today your uncle is going to take you to Serimu Lake to play,so let you come and your uncle will pick us up later.\"After my father said that.I was so happy that when i returned to XinJiang.I hardly ever went out to play.Every day I went out to eat meat.\n\n# 中文\n\n&emsp;早早的，我被一通电话闹醒，不是班长的电话，班长不会那么早起，我迷迷糊糊地拿起手机接听，电话那头传来我爸的声音。通完电话，我立刻下床，洗漱，能让我暑假早晨7点就起床的，除了班长的电话，那可能就是什么好消息了吧。\n\n&emsp;匆匆忙忙地，我到了奶奶家。我问爸:\"今天要去干什么啊,怎么那么早？\",我爸回答:\"今天你大伯要带你去赛里木湖玩，所以让你来，等下你大伯就来接我们。\"，我爸说完，我心里开心得不行，回到新疆，就没怎么出去玩过，每天都是出去吃肉..\n\n&emsp;不知过了多久，我大伯终于来了，我们便开启了我们的旅程。我们一路人从伊宁市64团出发，要行驶将近70km才能到达赛里木湖。途中我看到很多曾经只能在\n\n","source":"_posts/Serimu-Lake-Day-Trip.md","raw":"---\ntitle: Serimu Lake Day Trip\ncopyright: true\ndate: 2019-07-20 02:04:31\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\n几天前，我去了新疆的赛里木湖，所以便有了这篇文章。\n\nA few days ago,I went to Serimu Lake in Xinjiang,So I had this article.\n\n<!--more-->\n\n# English\n\n&emsp; Early, I was woken up by a phone call,not the monitor's phone(monitor will not get up so early),I was __confused__ to __pick up__ the phone to answer,the phone came from my father's __voice__.After the phone call,I __immediately__ get out of bed and wash.Let me get up at 7 a.m in the summer __vaction__, in addition to the monitor's phone,that may be what let me __attention__ the new.\n\n&emsp;__In a hurry__,I __arrived__ at Grandma's house.I asked my father,\"What are you going to do today? Why so early? My father answered,\"Today your uncle is going to take you to Serimu Lake to play,so let you come and your uncle will pick us up later.\"After my father said that.I was so happy that when i returned to XinJiang.I hardly ever went out to play.Every day I went out to eat meat.\n\n# 中文\n\n&emsp;早早的，我被一通电话闹醒，不是班长的电话，班长不会那么早起，我迷迷糊糊地拿起手机接听，电话那头传来我爸的声音。通完电话，我立刻下床，洗漱，能让我暑假早晨7点就起床的，除了班长的电话，那可能就是什么好消息了吧。\n\n&emsp;匆匆忙忙地，我到了奶奶家。我问爸:\"今天要去干什么啊,怎么那么早？\",我爸回答:\"今天你大伯要带你去赛里木湖玩，所以让你来，等下你大伯就来接我们。\"，我爸说完，我心里开心得不行，回到新疆，就没怎么出去玩过，每天都是出去吃肉..\n\n&emsp;不知过了多久，我大伯终于来了，我们便开启了我们的旅程。我们一路人从伊宁市64团出发，要行驶将近70km才能到达赛里木湖。途中我看到很多曾经只能在\n\n","slug":"Serimu-Lake-Day-Trip","published":1,"updated":"2020-01-19T03:49:51.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocu004jomoom4fx76z0","content":"<p>几天前，我去了新疆的赛里木湖，所以便有了这篇文章。</p>\n<p>A few days ago,I went to Serimu Lake in Xinjiang,So I had this article.</p>\n<a id=\"more\"></a>\n<h1 id=\"English\"><a href=\"#English\" class=\"headerlink\" title=\"English\"></a>English</h1><p>&emsp; Early, I was woken up by a phone call,not the monitor’s phone(monitor will not get up so early),I was <strong>confused</strong> to <strong>pick up</strong> the phone to answer,the phone came from my father’s <strong>voice</strong>.After the phone call,I <strong>immediately</strong> get out of bed and wash.Let me get up at 7 a.m in the summer <strong>vaction</strong>, in addition to the monitor’s phone,that may be what let me <strong>attention</strong> the new.</p>\n<p>&emsp;<strong>In a hurry</strong>,I <strong>arrived</strong> at Grandma’s house.I asked my father,”What are you going to do today? Why so early? My father answered,”Today your uncle is going to take you to Serimu Lake to play,so let you come and your uncle will pick us up later.”After my father said that.I was so happy that when i returned to XinJiang.I hardly ever went out to play.Every day I went out to eat meat.</p>\n<h1 id=\"中文\"><a href=\"#中文\" class=\"headerlink\" title=\"中文\"></a>中文</h1><p>&emsp;早早的，我被一通电话闹醒，不是班长的电话，班长不会那么早起，我迷迷糊糊地拿起手机接听，电话那头传来我爸的声音。通完电话，我立刻下床，洗漱，能让我暑假早晨7点就起床的，除了班长的电话，那可能就是什么好消息了吧。</p>\n<p>&emsp;匆匆忙忙地，我到了奶奶家。我问爸:”今天要去干什么啊,怎么那么早？”,我爸回答:”今天你大伯要带你去赛里木湖玩，所以让你来，等下你大伯就来接我们。”，我爸说完，我心里开心得不行，回到新疆，就没怎么出去玩过，每天都是出去吃肉..</p>\n<p>&emsp;不知过了多久，我大伯终于来了，我们便开启了我们的旅程。我们一路人从伊宁市64团出发，要行驶将近70km才能到达赛里木湖。途中我看到很多曾经只能在</p>\n","site":{"data":{}},"excerpt":"<p>几天前，我去了新疆的赛里木湖，所以便有了这篇文章。</p>\n<p>A few days ago,I went to Serimu Lake in Xinjiang,So I had this article.</p>","more":"<h1 id=\"English\"><a href=\"#English\" class=\"headerlink\" title=\"English\"></a>English</h1><p>&emsp; Early, I was woken up by a phone call,not the monitor’s phone(monitor will not get up so early),I was <strong>confused</strong> to <strong>pick up</strong> the phone to answer,the phone came from my father’s <strong>voice</strong>.After the phone call,I <strong>immediately</strong> get out of bed and wash.Let me get up at 7 a.m in the summer <strong>vaction</strong>, in addition to the monitor’s phone,that may be what let me <strong>attention</strong> the new.</p>\n<p>&emsp;<strong>In a hurry</strong>,I <strong>arrived</strong> at Grandma’s house.I asked my father,”What are you going to do today? Why so early? My father answered,”Today your uncle is going to take you to Serimu Lake to play,so let you come and your uncle will pick us up later.”After my father said that.I was so happy that when i returned to XinJiang.I hardly ever went out to play.Every day I went out to eat meat.</p>\n<h1 id=\"中文\"><a href=\"#中文\" class=\"headerlink\" title=\"中文\"></a>中文</h1><p>&emsp;早早的，我被一通电话闹醒，不是班长的电话，班长不会那么早起，我迷迷糊糊地拿起手机接听，电话那头传来我爸的声音。通完电话，我立刻下床，洗漱，能让我暑假早晨7点就起床的，除了班长的电话，那可能就是什么好消息了吧。</p>\n<p>&emsp;匆匆忙忙地，我到了奶奶家。我问爸:”今天要去干什么啊,怎么那么早？”,我爸回答:”今天你大伯要带你去赛里木湖玩，所以让你来，等下你大伯就来接我们。”，我爸说完，我心里开心得不行，回到新疆，就没怎么出去玩过，每天都是出去吃肉..</p>\n<p>&emsp;不知过了多久，我大伯终于来了，我们便开启了我们的旅程。我们一路人从伊宁市64团出发，要行驶将近70km才能到达赛里木湖。途中我看到很多曾经只能在</p>"},{"title":"The process of purchasing MacBook Pro","copyright":true,"date":"2019-08-02T10:18:24.000Z","_content":"\n这篇文章记录我买MBP的过程.\n\n<!--more-->\n\n&emsp;Because I need to use PS and lightweight PR and have the need to prgramming,and the current AlienWareR13 can no longer met my needs.After one day and on night's selection,I finally chose MacBookPro 15.6 with difficulty.\n\n&emsp;The configuration diagram is as follows.![配置图](The-process-of-purchasing-MacBook-Pro/配置图.jpg)\n\n&emsp;First of all, 16GB is enogh for me to run a few more virtual machines, and it is also fast in drawing and editing. Although many people on the Internet said that heat dissipation is not good.I found that 2018 version of heat dissipation is not very good when I readlly got to know it. Considering the problem of heat dissipation, I also bought i9 version instead of i9 version. I hope erverthing goes well!\n\n&emsp;The fllowing is the spitting. When I was preparing to place an order, I was looking for the student discount page for half a day. When I found it, I wanted to know what the student discount conditions were. As a result, I didn't see the relevant instructions until I went to Baidu to know that I needed the student certificate from full-time universities.\n\n&emsp;When I learned some rough information from the internet, I placed the order. when placing the order, I had to pay first to verify whether the student id card was qualified. this is really disgusting ... as for why, I will mention later.  After I placed the order, I just waited for Apple to send me an email so that I could know what the student discount request was. In the middle of the night, I received a text message from Apple, which said: Let me check the email, and the information about the student discount conditions is in it.  The second disgusting thing that happened to me at this moment was that I didn't receive e-mail!  However, I did not have the option to apply for resending the mail, which made me very angry and the shopping experience was very poor.  Since the customer service is off duty, I can only ask the next morning.  The customer service personnel helped me successfully send the student id card, and then I waited for the verification to pass.  What made me feel sick for the third time has happened again!  My order was cancelled because my credentials were invalid. However, Apple did not send a single email. Only when I checked the order status could I find that it had been cancelled.  I went to ask the customer service again, and the information the customer service gave me was: the name of the student id card and the name of the consignee did not match, so it was cancelled.  I feel very speechless … can't parents give their children computers?  !  The consignee must also match the student ID.  Now I sit and wait for the refund. However, the refund time makes me despair even more. It takes me 5 working days at the latest, and I bought it on Friday. Apple employees will have a holiday at the weekend, so I can't handle it yet. That is to say, I have to wait for a whole week at the latest to receive the refund!  I think it takes so much time to place a new order!  It just makes me feel that the shopping experience is terrible!\n\n&emsp;I'm just waiting for a refund and then placing another order. I don't even want to buy Mac Book Pro now. It's so annoying!\n\n\n\n\n&emsp;由于我需要使用PS和轻量级的PR并且还有写代码的需求，并且现役的这台AlienWareR13已经不能够满足我的需求了。经过一天一夜的挑选，最终艰难的选择了Mac Book Pro 15.6。\n\n&emsp;这是我的配置图.\n\n&emsp;首先，16GB对于我来说是足够的，可以用来跑多几个虚拟机，而且制图时和剪辑时速度也快，虽然网上很多人说散热不行，但当我真实去了解后才发现是2018版的散热不太行，而且考虑到散热的问题，我也没有买i9版本，而是买了9代 i7，希望一切顺利吧！\n\n&emsp;下面就是吐槽了。在我准备下单时，我一直在找学生优惠的页面，找了半天，当我找到后，我想了解一下学生优惠的条件是什么，结果我应是没有看到相关的说明，直到我去百度才知道需要全日制高校的学生证明。\n\n&emsp;当我从网络上了解到了一些粗略的信息后，我便下单了，下单时是先付款才能验证学生证是否合格，这一点真的恶心...至于为什么，我后面会提到。我下单后就是等待Apple给我发送邮件，这样我才能知道学生优惠的要求是什么，在半夜时，我收到了Apple的短信，短信内容是:让我检查电子邮件，有关学生优惠的条件信息在里面。这时就让我遇到第二件很恶心的事，就是我并没有收到电子邮件！但是并没有申请重新发送邮件的选项，这就让我很生气了，购物体验极差。由于客服已下班，我只能第二天早晨去询问了。客服人员帮助我成功的发送了学生证的凭证，然后我就等待验证通过。让我感到第三次恶心的事又发生了！我的订单被取消了，因为我的凭证无效，然而Apple连一个邮件也不发，只有我去查看订单状态才能发现已经被取消。我又去询问客服，客服给我的信息是：由于学生证的姓名和收货人的姓名不符合，所以被取消了。我感到十分无语...难道父母送给孩子电脑都不可以吗？！还必须要收货人跟学生证相符。现在我就坐等退款了，然而退款的时间更让我绝望，最晚需要5个工作日，而且我是周五买的，周末时Apple的员工要放假，所以还不能处理，也就是说我最晚需要等待整整一周的时间，才能收到退款！我想重新下单就需要浪费这么多的时间！简直是让我感到，购物体验极差！\n\n&emsp;吐槽完了，我现在就是等待退款，然后重新下单，我甚至在都不想买Mac Book Pro了，太让人生气了！\n\n\n\n\n","source":"_posts/The-process-of-purchasing-MacBook-Pro.md","raw":"---\ntitle: The process of purchasing MacBook Pro\ncopyright: true\ndate: 2019-08-02 18:18:24\ncategories: 英文文章\ntags:\n- 购物体验\n---\n\n这篇文章记录我买MBP的过程.\n\n<!--more-->\n\n&emsp;Because I need to use PS and lightweight PR and have the need to prgramming,and the current AlienWareR13 can no longer met my needs.After one day and on night's selection,I finally chose MacBookPro 15.6 with difficulty.\n\n&emsp;The configuration diagram is as follows.![配置图](The-process-of-purchasing-MacBook-Pro/配置图.jpg)\n\n&emsp;First of all, 16GB is enogh for me to run a few more virtual machines, and it is also fast in drawing and editing. Although many people on the Internet said that heat dissipation is not good.I found that 2018 version of heat dissipation is not very good when I readlly got to know it. Considering the problem of heat dissipation, I also bought i9 version instead of i9 version. I hope erverthing goes well!\n\n&emsp;The fllowing is the spitting. When I was preparing to place an order, I was looking for the student discount page for half a day. When I found it, I wanted to know what the student discount conditions were. As a result, I didn't see the relevant instructions until I went to Baidu to know that I needed the student certificate from full-time universities.\n\n&emsp;When I learned some rough information from the internet, I placed the order. when placing the order, I had to pay first to verify whether the student id card was qualified. this is really disgusting ... as for why, I will mention later.  After I placed the order, I just waited for Apple to send me an email so that I could know what the student discount request was. In the middle of the night, I received a text message from Apple, which said: Let me check the email, and the information about the student discount conditions is in it.  The second disgusting thing that happened to me at this moment was that I didn't receive e-mail!  However, I did not have the option to apply for resending the mail, which made me very angry and the shopping experience was very poor.  Since the customer service is off duty, I can only ask the next morning.  The customer service personnel helped me successfully send the student id card, and then I waited for the verification to pass.  What made me feel sick for the third time has happened again!  My order was cancelled because my credentials were invalid. However, Apple did not send a single email. Only when I checked the order status could I find that it had been cancelled.  I went to ask the customer service again, and the information the customer service gave me was: the name of the student id card and the name of the consignee did not match, so it was cancelled.  I feel very speechless … can't parents give their children computers?  !  The consignee must also match the student ID.  Now I sit and wait for the refund. However, the refund time makes me despair even more. It takes me 5 working days at the latest, and I bought it on Friday. Apple employees will have a holiday at the weekend, so I can't handle it yet. That is to say, I have to wait for a whole week at the latest to receive the refund!  I think it takes so much time to place a new order!  It just makes me feel that the shopping experience is terrible!\n\n&emsp;I'm just waiting for a refund and then placing another order. I don't even want to buy Mac Book Pro now. It's so annoying!\n\n\n\n\n&emsp;由于我需要使用PS和轻量级的PR并且还有写代码的需求，并且现役的这台AlienWareR13已经不能够满足我的需求了。经过一天一夜的挑选，最终艰难的选择了Mac Book Pro 15.6。\n\n&emsp;这是我的配置图.\n\n&emsp;首先，16GB对于我来说是足够的，可以用来跑多几个虚拟机，而且制图时和剪辑时速度也快，虽然网上很多人说散热不行，但当我真实去了解后才发现是2018版的散热不太行，而且考虑到散热的问题，我也没有买i9版本，而是买了9代 i7，希望一切顺利吧！\n\n&emsp;下面就是吐槽了。在我准备下单时，我一直在找学生优惠的页面，找了半天，当我找到后，我想了解一下学生优惠的条件是什么，结果我应是没有看到相关的说明，直到我去百度才知道需要全日制高校的学生证明。\n\n&emsp;当我从网络上了解到了一些粗略的信息后，我便下单了，下单时是先付款才能验证学生证是否合格，这一点真的恶心...至于为什么，我后面会提到。我下单后就是等待Apple给我发送邮件，这样我才能知道学生优惠的要求是什么，在半夜时，我收到了Apple的短信，短信内容是:让我检查电子邮件，有关学生优惠的条件信息在里面。这时就让我遇到第二件很恶心的事，就是我并没有收到电子邮件！但是并没有申请重新发送邮件的选项，这就让我很生气了，购物体验极差。由于客服已下班，我只能第二天早晨去询问了。客服人员帮助我成功的发送了学生证的凭证，然后我就等待验证通过。让我感到第三次恶心的事又发生了！我的订单被取消了，因为我的凭证无效，然而Apple连一个邮件也不发，只有我去查看订单状态才能发现已经被取消。我又去询问客服，客服给我的信息是：由于学生证的姓名和收货人的姓名不符合，所以被取消了。我感到十分无语...难道父母送给孩子电脑都不可以吗？！还必须要收货人跟学生证相符。现在我就坐等退款了，然而退款的时间更让我绝望，最晚需要5个工作日，而且我是周五买的，周末时Apple的员工要放假，所以还不能处理，也就是说我最晚需要等待整整一周的时间，才能收到退款！我想重新下单就需要浪费这么多的时间！简直是让我感到，购物体验极差！\n\n&emsp;吐槽完了，我现在就是等待退款，然后重新下单，我甚至在都不想买Mac Book Pro了，太让人生气了！\n\n\n\n\n","slug":"The-process-of-purchasing-MacBook-Pro","published":1,"updated":"2020-01-19T03:49:51.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocv004momoo7hbzlmxh","content":"<p>这篇文章记录我买MBP的过程.</p>\n<a id=\"more\"></a>\n<p>&emsp;Because I need to use PS and lightweight PR and have the need to prgramming,and the current AlienWareR13 can no longer met my needs.After one day and on night’s selection,I finally chose MacBookPro 15.6 with difficulty.</p>\n<p>&emsp;The configuration diagram is as follows.<img src=\"/2019/08/02/The-process-of-purchasing-MacBook-Pro/配置图.jpg\" alt=\"配置图\"></p>\n<p>&emsp;First of all, 16GB is enogh for me to run a few more virtual machines, and it is also fast in drawing and editing. Although many people on the Internet said that heat dissipation is not good.I found that 2018 version of heat dissipation is not very good when I readlly got to know it. Considering the problem of heat dissipation, I also bought i9 version instead of i9 version. I hope erverthing goes well!</p>\n<p>&emsp;The fllowing is the spitting. When I was preparing to place an order, I was looking for the student discount page for half a day. When I found it, I wanted to know what the student discount conditions were. As a result, I didn’t see the relevant instructions until I went to Baidu to know that I needed the student certificate from full-time universities.</p>\n<p>&emsp;When I learned some rough information from the internet, I placed the order. when placing the order, I had to pay first to verify whether the student id card was qualified. this is really disgusting … as for why, I will mention later.  After I placed the order, I just waited for Apple to send me an email so that I could know what the student discount request was. In the middle of the night, I received a text message from Apple, which said: Let me check the email, and the information about the student discount conditions is in it.  The second disgusting thing that happened to me at this moment was that I didn’t receive e-mail!  However, I did not have the option to apply for resending the mail, which made me very angry and the shopping experience was very poor.  Since the customer service is off duty, I can only ask the next morning.  The customer service personnel helped me successfully send the student id card, and then I waited for the verification to pass.  What made me feel sick for the third time has happened again!  My order was cancelled because my credentials were invalid. However, Apple did not send a single email. Only when I checked the order status could I find that it had been cancelled.  I went to ask the customer service again, and the information the customer service gave me was: the name of the student id card and the name of the consignee did not match, so it was cancelled.  I feel very speechless … can’t parents give their children computers?  !  The consignee must also match the student ID.  Now I sit and wait for the refund. However, the refund time makes me despair even more. It takes me 5 working days at the latest, and I bought it on Friday. Apple employees will have a holiday at the weekend, so I can’t handle it yet. That is to say, I have to wait for a whole week at the latest to receive the refund!  I think it takes so much time to place a new order!  It just makes me feel that the shopping experience is terrible!</p>\n<p>&emsp;I’m just waiting for a refund and then placing another order. I don’t even want to buy Mac Book Pro now. It’s so annoying!</p>\n<p>&emsp;由于我需要使用PS和轻量级的PR并且还有写代码的需求，并且现役的这台AlienWareR13已经不能够满足我的需求了。经过一天一夜的挑选，最终艰难的选择了Mac Book Pro 15.6。</p>\n<p>&emsp;这是我的配置图.</p>\n<p>&emsp;首先，16GB对于我来说是足够的，可以用来跑多几个虚拟机，而且制图时和剪辑时速度也快，虽然网上很多人说散热不行，但当我真实去了解后才发现是2018版的散热不太行，而且考虑到散热的问题，我也没有买i9版本，而是买了9代 i7，希望一切顺利吧！</p>\n<p>&emsp;下面就是吐槽了。在我准备下单时，我一直在找学生优惠的页面，找了半天，当我找到后，我想了解一下学生优惠的条件是什么，结果我应是没有看到相关的说明，直到我去百度才知道需要全日制高校的学生证明。</p>\n<p>&emsp;当我从网络上了解到了一些粗略的信息后，我便下单了，下单时是先付款才能验证学生证是否合格，这一点真的恶心…至于为什么，我后面会提到。我下单后就是等待Apple给我发送邮件，这样我才能知道学生优惠的要求是什么，在半夜时，我收到了Apple的短信，短信内容是:让我检查电子邮件，有关学生优惠的条件信息在里面。这时就让我遇到第二件很恶心的事，就是我并没有收到电子邮件！但是并没有申请重新发送邮件的选项，这就让我很生气了，购物体验极差。由于客服已下班，我只能第二天早晨去询问了。客服人员帮助我成功的发送了学生证的凭证，然后我就等待验证通过。让我感到第三次恶心的事又发生了！我的订单被取消了，因为我的凭证无效，然而Apple连一个邮件也不发，只有我去查看订单状态才能发现已经被取消。我又去询问客服，客服给我的信息是：由于学生证的姓名和收货人的姓名不符合，所以被取消了。我感到十分无语…难道父母送给孩子电脑都不可以吗？！还必须要收货人跟学生证相符。现在我就坐等退款了，然而退款的时间更让我绝望，最晚需要5个工作日，而且我是周五买的，周末时Apple的员工要放假，所以还不能处理，也就是说我最晚需要等待整整一周的时间，才能收到退款！我想重新下单就需要浪费这么多的时间！简直是让我感到，购物体验极差！</p>\n<p>&emsp;吐槽完了，我现在就是等待退款，然后重新下单，我甚至在都不想买Mac Book Pro了，太让人生气了！</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章记录我买MBP的过程.</p>","more":"<p>&emsp;Because I need to use PS and lightweight PR and have the need to prgramming,and the current AlienWareR13 can no longer met my needs.After one day and on night’s selection,I finally chose MacBookPro 15.6 with difficulty.</p>\n<p>&emsp;The configuration diagram is as follows.<img src=\"/2019/08/02/The-process-of-purchasing-MacBook-Pro/配置图.jpg\" alt=\"配置图\"></p>\n<p>&emsp;First of all, 16GB is enogh for me to run a few more virtual machines, and it is also fast in drawing and editing. Although many people on the Internet said that heat dissipation is not good.I found that 2018 version of heat dissipation is not very good when I readlly got to know it. Considering the problem of heat dissipation, I also bought i9 version instead of i9 version. I hope erverthing goes well!</p>\n<p>&emsp;The fllowing is the spitting. When I was preparing to place an order, I was looking for the student discount page for half a day. When I found it, I wanted to know what the student discount conditions were. As a result, I didn’t see the relevant instructions until I went to Baidu to know that I needed the student certificate from full-time universities.</p>\n<p>&emsp;When I learned some rough information from the internet, I placed the order. when placing the order, I had to pay first to verify whether the student id card was qualified. this is really disgusting … as for why, I will mention later.  After I placed the order, I just waited for Apple to send me an email so that I could know what the student discount request was. In the middle of the night, I received a text message from Apple, which said: Let me check the email, and the information about the student discount conditions is in it.  The second disgusting thing that happened to me at this moment was that I didn’t receive e-mail!  However, I did not have the option to apply for resending the mail, which made me very angry and the shopping experience was very poor.  Since the customer service is off duty, I can only ask the next morning.  The customer service personnel helped me successfully send the student id card, and then I waited for the verification to pass.  What made me feel sick for the third time has happened again!  My order was cancelled because my credentials were invalid. However, Apple did not send a single email. Only when I checked the order status could I find that it had been cancelled.  I went to ask the customer service again, and the information the customer service gave me was: the name of the student id card and the name of the consignee did not match, so it was cancelled.  I feel very speechless … can’t parents give their children computers?  !  The consignee must also match the student ID.  Now I sit and wait for the refund. However, the refund time makes me despair even more. It takes me 5 working days at the latest, and I bought it on Friday. Apple employees will have a holiday at the weekend, so I can’t handle it yet. That is to say, I have to wait for a whole week at the latest to receive the refund!  I think it takes so much time to place a new order!  It just makes me feel that the shopping experience is terrible!</p>\n<p>&emsp;I’m just waiting for a refund and then placing another order. I don’t even want to buy Mac Book Pro now. It’s so annoying!</p>\n<p>&emsp;由于我需要使用PS和轻量级的PR并且还有写代码的需求，并且现役的这台AlienWareR13已经不能够满足我的需求了。经过一天一夜的挑选，最终艰难的选择了Mac Book Pro 15.6。</p>\n<p>&emsp;这是我的配置图.</p>\n<p>&emsp;首先，16GB对于我来说是足够的，可以用来跑多几个虚拟机，而且制图时和剪辑时速度也快，虽然网上很多人说散热不行，但当我真实去了解后才发现是2018版的散热不太行，而且考虑到散热的问题，我也没有买i9版本，而是买了9代 i7，希望一切顺利吧！</p>\n<p>&emsp;下面就是吐槽了。在我准备下单时，我一直在找学生优惠的页面，找了半天，当我找到后，我想了解一下学生优惠的条件是什么，结果我应是没有看到相关的说明，直到我去百度才知道需要全日制高校的学生证明。</p>\n<p>&emsp;当我从网络上了解到了一些粗略的信息后，我便下单了，下单时是先付款才能验证学生证是否合格，这一点真的恶心…至于为什么，我后面会提到。我下单后就是等待Apple给我发送邮件，这样我才能知道学生优惠的要求是什么，在半夜时，我收到了Apple的短信，短信内容是:让我检查电子邮件，有关学生优惠的条件信息在里面。这时就让我遇到第二件很恶心的事，就是我并没有收到电子邮件！但是并没有申请重新发送邮件的选项，这就让我很生气了，购物体验极差。由于客服已下班，我只能第二天早晨去询问了。客服人员帮助我成功的发送了学生证的凭证，然后我就等待验证通过。让我感到第三次恶心的事又发生了！我的订单被取消了，因为我的凭证无效，然而Apple连一个邮件也不发，只有我去查看订单状态才能发现已经被取消。我又去询问客服，客服给我的信息是：由于学生证的姓名和收货人的姓名不符合，所以被取消了。我感到十分无语…难道父母送给孩子电脑都不可以吗？！还必须要收货人跟学生证相符。现在我就坐等退款了，然而退款的时间更让我绝望，最晚需要5个工作日，而且我是周五买的，周末时Apple的员工要放假，所以还不能处理，也就是说我最晚需要等待整整一周的时间，才能收到退款！我想重新下单就需要浪费这么多的时间！简直是让我感到，购物体验极差！</p>\n<p>&emsp;吐槽完了，我现在就是等待退款，然后重新下单，我甚至在都不想买Mac Book Pro了，太让人生气了！</p>"},{"title":"What is Vim?","copyright":true,"date":"2019-07-14T12:08:54.000Z","_content":"\nThe editor I use every day is VIM.This article introduces the hirstory of the VIM.\n<!--more-->\n\n![VIM](What-is-Vim/VIM.png)\n\n&emsp;Bram Miller __purchased__ hisr Amiga computer in the late 1980s,At this time,there is no editor vi on his computer. So he started with an open source vi __repilica__ version of Stevie，developed version 1.0 of Vim.__The initial goal__ was to completely copy the function of vi.\n\n&emsp;After that,Vim has added countless new features. As the first milestone.version 3.0 of 1944 joined the split window mode,It can edit multiple files __simultanesouly__ in the same terminal.\n\n&emsp;At 1996 released Vim 4.0 in 1996 using the version of the GUI.1998 Vim 5.0 version added syntax highlighting.2001 Vim 6.0 version added Code floding,Plugin,__Multi-anguage support__ ,Vertical segmentation window etc.The Vim 7.0 release was released in May 2006 added __Spell check__,__Context-sensitice completion__,__Tab editing__ etc.\n\n&emsp;The latest version of Vim is now Vim8\n\n\n","source":"_posts/What-is-Vim.md","raw":"---\ntitle: What is Vim?\ncopyright: true\ndate: 2019-07-14 20:08:54\ncategories: 英文文章\ntags:\n  - VIM\n---\n\nThe editor I use every day is VIM.This article introduces the hirstory of the VIM.\n<!--more-->\n\n![VIM](What-is-Vim/VIM.png)\n\n&emsp;Bram Miller __purchased__ hisr Amiga computer in the late 1980s,At this time,there is no editor vi on his computer. So he started with an open source vi __repilica__ version of Stevie，developed version 1.0 of Vim.__The initial goal__ was to completely copy the function of vi.\n\n&emsp;After that,Vim has added countless new features. As the first milestone.version 3.0 of 1944 joined the split window mode,It can edit multiple files __simultanesouly__ in the same terminal.\n\n&emsp;At 1996 released Vim 4.0 in 1996 using the version of the GUI.1998 Vim 5.0 version added syntax highlighting.2001 Vim 6.0 version added Code floding,Plugin,__Multi-anguage support__ ,Vertical segmentation window etc.The Vim 7.0 release was released in May 2006 added __Spell check__,__Context-sensitice completion__,__Tab editing__ etc.\n\n&emsp;The latest version of Vim is now Vim8\n\n\n","slug":"What-is-Vim","published":1,"updated":"2020-01-19T03:49:51.397Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocw004qomoo0l5plv7t","content":"<p>The editor I use every day is VIM.This article introduces the hirstory of the VIM.<br><a id=\"more\"></a></p>\n<p><img src=\"/2019/07/14/What-is-Vim/VIM.png\" alt=\"VIM\"></p>\n<p>&emsp;Bram Miller <strong>purchased</strong> hisr Amiga computer in the late 1980s,At this time,there is no editor vi on his computer. So he started with an open source vi <strong>repilica</strong> version of Stevie，developed version 1.0 of Vim.<strong>The initial goal</strong> was to completely copy the function of vi.</p>\n<p>&emsp;After that,Vim has added countless new features. As the first milestone.version 3.0 of 1944 joined the split window mode,It can edit multiple files <strong>simultanesouly</strong> in the same terminal.</p>\n<p>&emsp;At 1996 released Vim 4.0 in 1996 using the version of the GUI.1998 Vim 5.0 version added syntax highlighting.2001 Vim 6.0 version added Code floding,Plugin,<strong>Multi-anguage support</strong> ,Vertical segmentation window etc.The Vim 7.0 release was released in May 2006 added <strong>Spell check</strong>,<strong>Context-sensitice completion</strong>,<strong>Tab editing</strong> etc.</p>\n<p>&emsp;The latest version of Vim is now Vim8</p>\n","site":{"data":{}},"excerpt":"<p>The editor I use every day is VIM.This article introduces the hirstory of the VIM.<br></p>","more":"<p></p>\n<p><img src=\"/2019/07/14/What-is-Vim/VIM.png\" alt=\"VIM\"></p>\n<p>&emsp;Bram Miller <strong>purchased</strong> hisr Amiga computer in the late 1980s,At this time,there is no editor vi on his computer. So he started with an open source vi <strong>repilica</strong> version of Stevie，developed version 1.0 of Vim.<strong>The initial goal</strong> was to completely copy the function of vi.</p>\n<p>&emsp;After that,Vim has added countless new features. As the first milestone.version 3.0 of 1944 joined the split window mode,It can edit multiple files <strong>simultanesouly</strong> in the same terminal.</p>\n<p>&emsp;At 1996 released Vim 4.0 in 1996 using the version of the GUI.1998 Vim 5.0 version added syntax highlighting.2001 Vim 6.0 version added Code floding,Plugin,<strong>Multi-anguage support</strong> ,Vertical segmentation window etc.The Vim 7.0 release was released in May 2006 added <strong>Spell check</strong>,<strong>Context-sensitice completion</strong>,<strong>Tab editing</strong> etc.</p>\n<p>&emsp;The latest version of Vim is now Vim8</p>"},{"title":"hexo+next插入网易云音乐","date":"2019-04-30T12:05:20.000Z","copyright":true,"_content":"\n让大爷们在阅读博客时能优哉游哉的听着歌看文章。\n\n<!--more-->\n\n# 获取外链\n\n打开[网易云音乐](https://music.163.com)官网\n\n找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。\n\n![01](hexo-next插入网易云音乐/01.png)\n\n可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!\n\n# 插入外链\n\n**如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.**\n\n**如果是想插入到侧边栏**\n\n需要编辑next/layout/_macro/sidebar.swig文件\n\n此时我们就需要使用开发者工具插入到自己合适的位置下\n\n![插哪](hexo-next插入网易云音乐/插哪.png)\n\n可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。\n\n---","source":"_posts/hexo-next插入网易云音乐.md","raw":"---\ntitle: hexo+next插入网易云音乐\ndate: 2019-04-30 20:05:20\ncategories: 折腾记录\ntags: \n  - hexo\n  - 网易云音乐\ncopyright: true\n---\n\n让大爷们在阅读博客时能优哉游哉的听着歌看文章。\n\n<!--more-->\n\n# 获取外链\n\n打开[网易云音乐](https://music.163.com)官网\n\n找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。\n\n![01](hexo-next插入网易云音乐/01.png)\n\n可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!\n\n# 插入外链\n\n**如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.**\n\n**如果是想插入到侧边栏**\n\n需要编辑next/layout/_macro/sidebar.swig文件\n\n此时我们就需要使用开发者工具插入到自己合适的位置下\n\n![插哪](hexo-next插入网易云音乐/插哪.png)\n\n可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。\n\n---","slug":"hexo-next插入网易云音乐","published":1,"updated":"2020-01-19T03:49:51.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocw004tomooq5z20hcf","content":"<p>让大爷们在阅读博客时能优哉游哉的听着歌看文章。</p>\n<a id=\"more\"></a>\n<h1 id=\"获取外链\"><a href=\"#获取外链\" class=\"headerlink\" title=\"获取外链\"></a>获取外链</h1><p>打开<a href=\"https://music.163.com\" target=\"_blank\" rel=\"noopener\">网易云音乐</a>官网</p>\n<p>找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/01.png\" alt=\"01\"></p>\n<p>可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!</p>\n<h1 id=\"插入外链\"><a href=\"#插入外链\" class=\"headerlink\" title=\"插入外链\"></a>插入外链</h1><p><strong>如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.</strong></p>\n<p><strong>如果是想插入到侧边栏</strong></p>\n<p>需要编辑next/layout/_macro/sidebar.swig文件</p>\n<p>此时我们就需要使用开发者工具插入到自己合适的位置下</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/插哪.png\" alt=\"插哪\"></p>\n<p>可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>让大爷们在阅读博客时能优哉游哉的听着歌看文章。</p>","more":"<h1 id=\"获取外链\"><a href=\"#获取外链\" class=\"headerlink\" title=\"获取外链\"></a>获取外链</h1><p>打开<a href=\"https://music.163.com\" target=\"_blank\" rel=\"noopener\">网易云音乐</a>官网</p>\n<p>找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/01.png\" alt=\"01\"></p>\n<p>可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!</p>\n<h1 id=\"插入外链\"><a href=\"#插入外链\" class=\"headerlink\" title=\"插入外链\"></a>插入外链</h1><p><strong>如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.</strong></p>\n<p><strong>如果是想插入到侧边栏</strong></p>\n<p>需要编辑next/layout/_macro/sidebar.swig文件</p>\n<p>此时我们就需要使用开发者工具插入到自己合适的位置下</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/插哪.png\" alt=\"插哪\"></p>\n<p>可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。</p>\n<hr>"},{"title":"fcitx5安装与配置","copyright":true,"date":"2019-06-13T18:11:41.000Z","_content":"\n某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。(抱歉，文章标题一直写错了..直到这篇博客被人看到提醒我才发现..)\n\n<!--more-->\n\n![演示](fcitx5安装与配置/输入.gif)\n\n所需安装的软件包:\n  - fcitx5-git 输入法基础框架主程序\n  - fcitx5-chinese-addons-git 简体中文输入的支持，云拼音\n  - fcitx5-gtk-git gtk 程序的支持\n  - fcitx5-qt4-git qt4 的支持\n  - fcitx5-qt5-git qt5 的支持\n可能还需要：\n  - kcm-fcitx5-git 如果你用的是 KDE ，请装这个\n  - fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎\n\n如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法:\n\n![kcm](fcitx5安装与配置/kcm.png)\n\n否则将改配置文件`~/.config/fcitx5/profile`\n\n~~~\n[Groups/0]\n# Group Name\nName=Default\n# Layout\nDefault Layout=us\n# Default Input Method\nDefaultIM=pinyin\n\n[Groups/0/Items/0]\n# Name\nName=keyboard-us\n# Layout\nLayout=\n\n[Groups/0/Items/1]\n# Name\nName=pinyin\n# Layout\nLayout=\n\n[GroupOrder]\n0=Default\n~~~\n\n__若没有`fcitx5`这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。__\n\n由于fcitx5不能自动启动，我们需要添加环境变量\n\n将如下内容添加到`~/.xprofile`\n\n~~~\nfcitx5 &\n~~~\n\n然后再将如下内容添加到~/.pam_environment`，没有则创建\n\n~~~\nGTK_IM_MODULE=fcitx5\nXMODIFIERS=@im=fcitx\nQT_IM_MODULE=fcitx5\n~~~\n\nKDE用户可以直接在`系统设置模块-自动启动`设置\n\n默认的皮肤很丑，我们可以使用这个[fcitx5-simple-theme](https://github.com/iovxw/fcitx5-simple-theme)\n\n然后你就可以把fcitx4给删了...\n\n\n\n","source":"_posts/fcitx5安装与配置.md","raw":"---\ntitle: fcitx5安装与配置\ncopyright: true\ndate: 2019-06-14 02:11:41\ncategories: 折腾日记\ntags:\n  - fcitx5\n---\n\n某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。(抱歉，文章标题一直写错了..直到这篇博客被人看到提醒我才发现..)\n\n<!--more-->\n\n![演示](fcitx5安装与配置/输入.gif)\n\n所需安装的软件包:\n  - fcitx5-git 输入法基础框架主程序\n  - fcitx5-chinese-addons-git 简体中文输入的支持，云拼音\n  - fcitx5-gtk-git gtk 程序的支持\n  - fcitx5-qt4-git qt4 的支持\n  - fcitx5-qt5-git qt5 的支持\n可能还需要：\n  - kcm-fcitx5-git 如果你用的是 KDE ，请装这个\n  - fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎\n\n如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法:\n\n![kcm](fcitx5安装与配置/kcm.png)\n\n否则将改配置文件`~/.config/fcitx5/profile`\n\n~~~\n[Groups/0]\n# Group Name\nName=Default\n# Layout\nDefault Layout=us\n# Default Input Method\nDefaultIM=pinyin\n\n[Groups/0/Items/0]\n# Name\nName=keyboard-us\n# Layout\nLayout=\n\n[Groups/0/Items/1]\n# Name\nName=pinyin\n# Layout\nLayout=\n\n[GroupOrder]\n0=Default\n~~~\n\n__若没有`fcitx5`这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。__\n\n由于fcitx5不能自动启动，我们需要添加环境变量\n\n将如下内容添加到`~/.xprofile`\n\n~~~\nfcitx5 &\n~~~\n\n然后再将如下内容添加到~/.pam_environment`，没有则创建\n\n~~~\nGTK_IM_MODULE=fcitx5\nXMODIFIERS=@im=fcitx\nQT_IM_MODULE=fcitx5\n~~~\n\nKDE用户可以直接在`系统设置模块-自动启动`设置\n\n默认的皮肤很丑，我们可以使用这个[fcitx5-simple-theme](https://github.com/iovxw/fcitx5-simple-theme)\n\n然后你就可以把fcitx4给删了...\n\n\n\n","slug":"fcitx5安装与配置","published":1,"updated":"2020-01-19T03:49:51.397Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocy004xomoors3pls6z","content":"<p>某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。(抱歉，文章标题一直写错了..直到这篇博客被人看到提醒我才发现..)</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/06/14/fcitx5安装与配置/输入.gif\" alt=\"演示\"></p>\n<p>所需安装的软件包:</p>\n<ul>\n<li>fcitx5-git 输入法基础框架主程序</li>\n<li>fcitx5-chinese-addons-git 简体中文输入的支持，云拼音</li>\n<li>fcitx5-gtk-git gtk 程序的支持</li>\n<li>fcitx5-qt4-git qt4 的支持</li>\n<li>fcitx5-qt5-git qt5 的支持<br>可能还需要：</li>\n<li>kcm-fcitx5-git 如果你用的是 KDE ，请装这个</li>\n<li>fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎</li>\n</ul>\n<p>如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法:</p>\n<p><img src=\"/2019/06/14/fcitx5安装与配置/kcm.png\" alt=\"kcm\"></p>\n<p>否则将改配置文件<code>~/.config/fcitx5/profile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Groups/0]</span><br><span class=\"line\"># Group Name</span><br><span class=\"line\">Name=Default</span><br><span class=\"line\"># Layout</span><br><span class=\"line\">Default Layout=us</span><br><span class=\"line\"># Default Input Method</span><br><span class=\"line\">DefaultIM=pinyin</span><br><span class=\"line\"></span><br><span class=\"line\">[Groups/0/Items/0]</span><br><span class=\"line\"># Name</span><br><span class=\"line\">Name=keyboard-us</span><br><span class=\"line\"># Layout</span><br><span class=\"line\">Layout=</span><br><span class=\"line\"></span><br><span class=\"line\">[Groups/0/Items/1]</span><br><span class=\"line\"># Name</span><br><span class=\"line\">Name=pinyin</span><br><span class=\"line\"># Layout</span><br><span class=\"line\">Layout=</span><br><span class=\"line\"></span><br><span class=\"line\">[GroupOrder]</span><br><span class=\"line\">0=Default</span><br></pre></td></tr></table></figure>\n<p><strong>若没有<code>fcitx5</code>这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。</strong></p>\n<p>由于fcitx5不能自动启动，我们需要添加环境变量</p>\n<p>将如下内容添加到<code>~/.xprofile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fcitx5 &amp;</span><br></pre></td></tr></table></figure>\n<p>然后再将如下内容添加到~/.pam_environment`，没有则创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GTK_IM_MODULE=fcitx5</span><br><span class=\"line\">XMODIFIERS=@im=fcitx</span><br><span class=\"line\">QT_IM_MODULE=fcitx5</span><br></pre></td></tr></table></figure>\n<p>KDE用户可以直接在<code>系统设置模块-自动启动</code>设置</p>\n<p>默认的皮肤很丑，我们可以使用这个<a href=\"https://github.com/iovxw/fcitx5-simple-theme\" target=\"_blank\" rel=\"noopener\">fcitx5-simple-theme</a></p>\n<p>然后你就可以把fcitx4给删了…</p>\n","site":{"data":{}},"excerpt":"<p>某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。(抱歉，文章标题一直写错了..直到这篇博客被人看到提醒我才发现..)</p>","more":"<p><img src=\"/2019/06/14/fcitx5安装与配置/输入.gif\" alt=\"演示\"></p>\n<p>所需安装的软件包:</p>\n<ul>\n<li>fcitx5-git 输入法基础框架主程序</li>\n<li>fcitx5-chinese-addons-git 简体中文输入的支持，云拼音</li>\n<li>fcitx5-gtk-git gtk 程序的支持</li>\n<li>fcitx5-qt4-git qt4 的支持</li>\n<li>fcitx5-qt5-git qt5 的支持<br>可能还需要：</li>\n<li>kcm-fcitx5-git 如果你用的是 KDE ，请装这个</li>\n<li>fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎</li>\n</ul>\n<p>如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法:</p>\n<p><img src=\"/2019/06/14/fcitx5安装与配置/kcm.png\" alt=\"kcm\"></p>\n<p>否则将改配置文件<code>~/.config/fcitx5/profile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Groups/0]</span><br><span class=\"line\"># Group Name</span><br><span class=\"line\">Name=Default</span><br><span class=\"line\"># Layout</span><br><span class=\"line\">Default Layout=us</span><br><span class=\"line\"># Default Input Method</span><br><span class=\"line\">DefaultIM=pinyin</span><br><span class=\"line\"></span><br><span class=\"line\">[Groups/0/Items/0]</span><br><span class=\"line\"># Name</span><br><span class=\"line\">Name=keyboard-us</span><br><span class=\"line\"># Layout</span><br><span class=\"line\">Layout=</span><br><span class=\"line\"></span><br><span class=\"line\">[Groups/0/Items/1]</span><br><span class=\"line\"># Name</span><br><span class=\"line\">Name=pinyin</span><br><span class=\"line\"># Layout</span><br><span class=\"line\">Layout=</span><br><span class=\"line\"></span><br><span class=\"line\">[GroupOrder]</span><br><span class=\"line\">0=Default</span><br></pre></td></tr></table></figure>\n<p><strong>若没有<code>fcitx5</code>这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。</strong></p>\n<p>由于fcitx5不能自动启动，我们需要添加环境变量</p>\n<p>将如下内容添加到<code>~/.xprofile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fcitx5 &amp;</span><br></pre></td></tr></table></figure>\n<p>然后再将如下内容添加到~/.pam_environment`，没有则创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GTK_IM_MODULE=fcitx5</span><br><span class=\"line\">XMODIFIERS=@im=fcitx</span><br><span class=\"line\">QT_IM_MODULE=fcitx5</span><br></pre></td></tr></table></figure>\n<p>KDE用户可以直接在<code>系统设置模块-自动启动</code>设置</p>\n<p>默认的皮肤很丑，我们可以使用这个<a href=\"https://github.com/iovxw/fcitx5-simple-theme\" target=\"_blank\" rel=\"noopener\">fcitx5-simple-theme</a></p>\n<p>然后你就可以把fcitx4给删了…</p>"},{"title":"hexo博客文章插入图片","date":"2019-04-29T07:15:29.000Z","copyright":true,"_content":"\n# 前言\n\n在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。\n\n<!--more-->\n\n# 如何安装\n\n安装此插件很简单，你只需要在你的hexo目录下执行如下命令:\n\n~~~shell\n$ npm install hexo-asset-image --save\n~~~\n\n如果安装速度很慢可以把npm源改为国内源。\n\n[点击打开npm源改为国内源的方法](https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/)\n\n在设置镜像源->npm国内源下\n\n# 如何使用\n\n## 第一步\n首先，我们得先设置主目录(博客目录)下的 **_config.yml** 文件.\n\n找到 **post_asset_folder:** 项，将其修改为 **true**\n\n## 第二步\n\n使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。\n\n然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。\n\n# 栗子\n\n~~~shell\n$ hexo n \"test\"\n$ mv test.jpg source/_posts/test\n~~~\n\n插入图片\n\n~~~\n![图片alt](图片地址)\n\n# ![test](./test/test.jpng)\n~~~\n\n---","source":"_posts/hexo博客文章插入图片.md","raw":"---\ntitle: hexo博客文章插入图片\ndate: 2019-04-29 15:15:29\ncategories: 折腾记录\ncopyright: true\ntags:\n  - hexo\n---\n\n# 前言\n\n在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。\n\n<!--more-->\n\n# 如何安装\n\n安装此插件很简单，你只需要在你的hexo目录下执行如下命令:\n\n~~~shell\n$ npm install hexo-asset-image --save\n~~~\n\n如果安装速度很慢可以把npm源改为国内源。\n\n[点击打开npm源改为国内源的方法](https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/)\n\n在设置镜像源->npm国内源下\n\n# 如何使用\n\n## 第一步\n首先，我们得先设置主目录(博客目录)下的 **_config.yml** 文件.\n\n找到 **post_asset_folder:** 项，将其修改为 **true**\n\n## 第二步\n\n使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。\n\n然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。\n\n# 栗子\n\n~~~shell\n$ hexo n \"test\"\n$ mv test.jpg source/_posts/test\n~~~\n\n插入图片\n\n~~~\n![图片alt](图片地址)\n\n# ![test](./test/test.jpng)\n~~~\n\n---","slug":"hexo博客文章插入图片","published":1,"updated":"2020-01-19T03:49:51.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozocz0051omoowxsnbzdu","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p>\n<a id=\"more\"></a>\n<h1 id=\"如何安装\"><a href=\"#如何安装\" class=\"headerlink\" title=\"如何安装\"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n<p>如果安装速度很慢可以把npm源改为国内源。</p>\n<p><a href=\"https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/\">点击打开npm源改为国内源的方法</a></p>\n<p>在设置镜像源-&gt;npm国内源下</p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h2 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p>\n<p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p>\n<h2 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p>\n<p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p>\n<h1 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"test\"</span><br><span class=\"line\"><span class=\"meta\">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure>\n<p>插入图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片alt](图片地址)</span><br><span class=\"line\"></span><br><span class=\"line\"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p>","more":"<h1 id=\"如何安装\"><a href=\"#如何安装\" class=\"headerlink\" title=\"如何安装\"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n<p>如果安装速度很慢可以把npm源改为国内源。</p>\n<p><a href=\"https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/\">点击打开npm源改为国内源的方法</a></p>\n<p>在设置镜像源-&gt;npm国内源下</p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h2 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p>\n<p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p>\n<h2 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p>\n<p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p>\n<h1 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"test\"</span><br><span class=\"line\"><span class=\"meta\">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure>\n<p>插入图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片alt](图片地址)</span><br><span class=\"line\"></span><br><span class=\"line\"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"使用两天MacBookPro真实感受","copyright":true,"date":"2019-08-17T08:59:10.000Z","_content":"\n经过漫长的等待，我的MacBook Pro终于是到货了，经过我的两天调教，我已经逐渐习惯了。\n<!--more-->\n\n&emsp;前天一大早，我接到了电话，不用想，肯定就是我得mbp到货了。可能是我看过太多测评视频的缘故，当我亲手开箱时，却没有被mbp给惊艳到，不过机身确实非常薄，应该是我接触过的电脑最薄的台15寸笔记本了。mbp支持单手开合，这一点我非常满意，草草的设置完第一次启动系统后，我迫不及待的安装我所需的软件，由于早前我看过一些关于Mac OS X的文章，我马上就去配置了`Homebrew`，但我发现，貌似配置国内源有点困难，没有我在`Manjaro`下那么方便，快捷。\n\n&emsp;经过我的一番折腾，`Homebrew`总算是安装好了，我便开始配置开发环境，首先选择了传说中功能非常强大的`iterm2`，功能强大到我不能快速上手，必须花费时间去研究研究它才能顺手使用。在我折腾Mac时，十分讨厌这个键盘布局，现在亦是如此，把fn键放在键盘的边缘处，我每次想要按`control`时总是误触，以及touchbar的escape键，简直按起来一点反馈没有，所以我就通过`karabiner`这款软件修改了个我习惯的键位布局。\n\n&emsp;不得不说mbp的这个屏幕，简直是太棒了，我原先用的是dell的4k屏幕，但在我用mbp时，甚至会觉得比4k屏好，可能是色彩非常准确的缘故吧。可能因为屏幕素质太过于优秀的缘故，耗电并不如网上说的那样，从早到晚不用充电，经过实测，这款标配的mbp 2019款在`chrome`十几个网页+`Emacs`+`NeoVim`+`微信`+`腾讯QQ`+`Telegram`+`蓝牙耳机`+`Wifi开启`+`网易云`+`屏幕亮度80%`+`键盘背光最亮`的情况下，3个半小时耗电50%，你可能觉得我在吹它～，但它确实就是这么厉害。\n\n&emsp;超大的触摸板，简直太好用，配合上Mac OS X的触摸板手势，对窗口的管理完全掌握在你的手指间。再说说机器发热的情况，在我上面所提到的使用环境下，几乎感觉不到mbp在发热，但是在打开一些大型应用，例如ps,pr,ae这些软件时，Mac OSX就像是提高了机器性能一般，风扇开启了高转速，机器也随之发热了，但得得益于mbp的外壳，可以在边缘垫上一元硬币辅助散热，并且效果还不错，虽说在开启大型应用mbp会发热严重，但也只是部分区域会感受到热，在手腕，手拖处几乎感觉不到，打字时由于蝶式键盘的缘故，只要是每个手指精确的放在键帽上，只能感觉到微微发热，但是在键帽之间的缝中可以明显感受到烫手。\n\n&emsp;最后吹一下mbp，它确实时非常好用，就是价格稍高，对于普通家庭来说，进两万元的支出也不是一个小数目了，希望有生之年能看到Apple能做物美价廉，感动人心的好产品(笑\n\n\n\n","source":"_posts/使用两天MacBookPro真实感受.md","raw":"---\ntitle: 使用两天MacBookPro真实感受\ncopyright: true\ndate: 2019-08-17 16:59:10\ncategories: 英文文章\ntags:\n  - 个人感想\n---\n\n经过漫长的等待，我的MacBook Pro终于是到货了，经过我的两天调教，我已经逐渐习惯了。\n<!--more-->\n\n&emsp;前天一大早，我接到了电话，不用想，肯定就是我得mbp到货了。可能是我看过太多测评视频的缘故，当我亲手开箱时，却没有被mbp给惊艳到，不过机身确实非常薄，应该是我接触过的电脑最薄的台15寸笔记本了。mbp支持单手开合，这一点我非常满意，草草的设置完第一次启动系统后，我迫不及待的安装我所需的软件，由于早前我看过一些关于Mac OS X的文章，我马上就去配置了`Homebrew`，但我发现，貌似配置国内源有点困难，没有我在`Manjaro`下那么方便，快捷。\n\n&emsp;经过我的一番折腾，`Homebrew`总算是安装好了，我便开始配置开发环境，首先选择了传说中功能非常强大的`iterm2`，功能强大到我不能快速上手，必须花费时间去研究研究它才能顺手使用。在我折腾Mac时，十分讨厌这个键盘布局，现在亦是如此，把fn键放在键盘的边缘处，我每次想要按`control`时总是误触，以及touchbar的escape键，简直按起来一点反馈没有，所以我就通过`karabiner`这款软件修改了个我习惯的键位布局。\n\n&emsp;不得不说mbp的这个屏幕，简直是太棒了，我原先用的是dell的4k屏幕，但在我用mbp时，甚至会觉得比4k屏好，可能是色彩非常准确的缘故吧。可能因为屏幕素质太过于优秀的缘故，耗电并不如网上说的那样，从早到晚不用充电，经过实测，这款标配的mbp 2019款在`chrome`十几个网页+`Emacs`+`NeoVim`+`微信`+`腾讯QQ`+`Telegram`+`蓝牙耳机`+`Wifi开启`+`网易云`+`屏幕亮度80%`+`键盘背光最亮`的情况下，3个半小时耗电50%，你可能觉得我在吹它～，但它确实就是这么厉害。\n\n&emsp;超大的触摸板，简直太好用，配合上Mac OS X的触摸板手势，对窗口的管理完全掌握在你的手指间。再说说机器发热的情况，在我上面所提到的使用环境下，几乎感觉不到mbp在发热，但是在打开一些大型应用，例如ps,pr,ae这些软件时，Mac OSX就像是提高了机器性能一般，风扇开启了高转速，机器也随之发热了，但得得益于mbp的外壳，可以在边缘垫上一元硬币辅助散热，并且效果还不错，虽说在开启大型应用mbp会发热严重，但也只是部分区域会感受到热，在手腕，手拖处几乎感觉不到，打字时由于蝶式键盘的缘故，只要是每个手指精确的放在键帽上，只能感觉到微微发热，但是在键帽之间的缝中可以明显感受到烫手。\n\n&emsp;最后吹一下mbp，它确实时非常好用，就是价格稍高，对于普通家庭来说，进两万元的支出也不是一个小数目了，希望有生之年能看到Apple能做物美价廉，感动人心的好产品(笑\n\n\n\n","slug":"使用两天MacBookPro真实感受","published":1,"updated":"2020-01-19T03:49:51.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod00054omooe0f292qg","content":"<p>经过漫长的等待，我的MacBook Pro终于是到货了，经过我的两天调教，我已经逐渐习惯了。<br><a id=\"more\"></a></p>\n<p>&emsp;前天一大早，我接到了电话，不用想，肯定就是我得mbp到货了。可能是我看过太多测评视频的缘故，当我亲手开箱时，却没有被mbp给惊艳到，不过机身确实非常薄，应该是我接触过的电脑最薄的台15寸笔记本了。mbp支持单手开合，这一点我非常满意，草草的设置完第一次启动系统后，我迫不及待的安装我所需的软件，由于早前我看过一些关于Mac OS X的文章，我马上就去配置了<code>Homebrew</code>，但我发现，貌似配置国内源有点困难，没有我在<code>Manjaro</code>下那么方便，快捷。</p>\n<p>&emsp;经过我的一番折腾，<code>Homebrew</code>总算是安装好了，我便开始配置开发环境，首先选择了传说中功能非常强大的<code>iterm2</code>，功能强大到我不能快速上手，必须花费时间去研究研究它才能顺手使用。在我折腾Mac时，十分讨厌这个键盘布局，现在亦是如此，把fn键放在键盘的边缘处，我每次想要按<code>control</code>时总是误触，以及touchbar的escape键，简直按起来一点反馈没有，所以我就通过<code>karabiner</code>这款软件修改了个我习惯的键位布局。</p>\n<p>&emsp;不得不说mbp的这个屏幕，简直是太棒了，我原先用的是dell的4k屏幕，但在我用mbp时，甚至会觉得比4k屏好，可能是色彩非常准确的缘故吧。可能因为屏幕素质太过于优秀的缘故，耗电并不如网上说的那样，从早到晚不用充电，经过实测，这款标配的mbp 2019款在<code>chrome</code>十几个网页+<code>Emacs</code>+<code>NeoVim</code>+<code>微信</code>+<code>腾讯QQ</code>+<code>Telegram</code>+<code>蓝牙耳机</code>+<code>Wifi开启</code>+<code>网易云</code>+<code>屏幕亮度80%</code>+<code>键盘背光最亮</code>的情况下，3个半小时耗电50%，你可能觉得我在吹它～，但它确实就是这么厉害。</p>\n<p>&emsp;超大的触摸板，简直太好用，配合上Mac OS X的触摸板手势，对窗口的管理完全掌握在你的手指间。再说说机器发热的情况，在我上面所提到的使用环境下，几乎感觉不到mbp在发热，但是在打开一些大型应用，例如ps,pr,ae这些软件时，Mac OSX就像是提高了机器性能一般，风扇开启了高转速，机器也随之发热了，但得得益于mbp的外壳，可以在边缘垫上一元硬币辅助散热，并且效果还不错，虽说在开启大型应用mbp会发热严重，但也只是部分区域会感受到热，在手腕，手拖处几乎感觉不到，打字时由于蝶式键盘的缘故，只要是每个手指精确的放在键帽上，只能感觉到微微发热，但是在键帽之间的缝中可以明显感受到烫手。</p>\n<p>&emsp;最后吹一下mbp，它确实时非常好用，就是价格稍高，对于普通家庭来说，进两万元的支出也不是一个小数目了，希望有生之年能看到Apple能做物美价廉，感动人心的好产品(笑</p>\n","site":{"data":{}},"excerpt":"<p>经过漫长的等待，我的MacBook Pro终于是到货了，经过我的两天调教，我已经逐渐习惯了。<br></p>","more":"<p></p>\n<p>&emsp;前天一大早，我接到了电话，不用想，肯定就是我得mbp到货了。可能是我看过太多测评视频的缘故，当我亲手开箱时，却没有被mbp给惊艳到，不过机身确实非常薄，应该是我接触过的电脑最薄的台15寸笔记本了。mbp支持单手开合，这一点我非常满意，草草的设置完第一次启动系统后，我迫不及待的安装我所需的软件，由于早前我看过一些关于Mac OS X的文章，我马上就去配置了<code>Homebrew</code>，但我发现，貌似配置国内源有点困难，没有我在<code>Manjaro</code>下那么方便，快捷。</p>\n<p>&emsp;经过我的一番折腾，<code>Homebrew</code>总算是安装好了，我便开始配置开发环境，首先选择了传说中功能非常强大的<code>iterm2</code>，功能强大到我不能快速上手，必须花费时间去研究研究它才能顺手使用。在我折腾Mac时，十分讨厌这个键盘布局，现在亦是如此，把fn键放在键盘的边缘处，我每次想要按<code>control</code>时总是误触，以及touchbar的escape键，简直按起来一点反馈没有，所以我就通过<code>karabiner</code>这款软件修改了个我习惯的键位布局。</p>\n<p>&emsp;不得不说mbp的这个屏幕，简直是太棒了，我原先用的是dell的4k屏幕，但在我用mbp时，甚至会觉得比4k屏好，可能是色彩非常准确的缘故吧。可能因为屏幕素质太过于优秀的缘故，耗电并不如网上说的那样，从早到晚不用充电，经过实测，这款标配的mbp 2019款在<code>chrome</code>十几个网页+<code>Emacs</code>+<code>NeoVim</code>+<code>微信</code>+<code>腾讯QQ</code>+<code>Telegram</code>+<code>蓝牙耳机</code>+<code>Wifi开启</code>+<code>网易云</code>+<code>屏幕亮度80%</code>+<code>键盘背光最亮</code>的情况下，3个半小时耗电50%，你可能觉得我在吹它～，但它确实就是这么厉害。</p>\n<p>&emsp;超大的触摸板，简直太好用，配合上Mac OS X的触摸板手势，对窗口的管理完全掌握在你的手指间。再说说机器发热的情况，在我上面所提到的使用环境下，几乎感觉不到mbp在发热，但是在打开一些大型应用，例如ps,pr,ae这些软件时，Mac OSX就像是提高了机器性能一般，风扇开启了高转速，机器也随之发热了，但得得益于mbp的外壳，可以在边缘垫上一元硬币辅助散热，并且效果还不错，虽说在开启大型应用mbp会发热严重，但也只是部分区域会感受到热，在手腕，手拖处几乎感觉不到，打字时由于蝶式键盘的缘故，只要是每个手指精确的放在键帽上，只能感觉到微微发热，但是在键帽之间的缝中可以明显感受到烫手。</p>\n<p>&emsp;最后吹一下mbp，它确实时非常好用，就是价格稍高，对于普通家庭来说，进两万元的支出也不是一个小数目了，希望有生之年能看到Apple能做物美价廉，感动人心的好产品(笑</p>"},{"title":"功能强大-基于GPU加速-Kitty终端","copyright":true,"date":"2019-09-26T15:49:08.000Z","_content":"\n由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty\n\n<!--more-->\n\n# Kitt终端简介\n\n从官方介绍内，Kitty具有以下特性:\n\n- 使用GPU进行渲染，以降低系统负载和更加平滑的滚动效果。使用多线程渲染使得输入延迟最低。\n\n- 现代终端功能: 图像、Unicode、真彩色、OpenTye连体字、鼠标、聚焦跟随\n\n- 对多个终端窗口进行不同的窗口布局操作\n\n- 可通过脚本或Shell进行控制\n\n- 使用`Kittens`框架，可以让一些小型程序用于扩展Kitty\n\n- 允许在任意程序中使用回滚历史的功能\n","source":"_posts/功能强大-基于GPU加速-Kitty终端.md","raw":"---\ntitle: 功能强大-基于GPU加速-Kitty终端\ncopyright: true\ndate: 2019-09-26 23:49:08\ncategories: 折腾日记\ntags:\n  - 软件折腾\n---\n\n由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty\n\n<!--more-->\n\n# Kitt终端简介\n\n从官方介绍内，Kitty具有以下特性:\n\n- 使用GPU进行渲染，以降低系统负载和更加平滑的滚动效果。使用多线程渲染使得输入延迟最低。\n\n- 现代终端功能: 图像、Unicode、真彩色、OpenTye连体字、鼠标、聚焦跟随\n\n- 对多个终端窗口进行不同的窗口布局操作\n\n- 可通过脚本或Shell进行控制\n\n- 使用`Kittens`框架，可以让一些小型程序用于扩展Kitty\n\n- 允许在任意程序中使用回滚历史的功能\n","slug":"功能强大-基于GPU加速-Kitty终端","published":1,"updated":"2020-01-19T03:49:51.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod10057omoog0navbvp","content":"<p>由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty</p>\n<a id=\"more\"></a>\n<h1 id=\"Kitt终端简介\"><a href=\"#Kitt终端简介\" class=\"headerlink\" title=\"Kitt终端简介\"></a>Kitt终端简介</h1><p>从官方介绍内，Kitty具有以下特性:</p>\n<ul>\n<li><p>使用GPU进行渲染，以降低系统负载和更加平滑的滚动效果。使用多线程渲染使得输入延迟最低。</p>\n</li>\n<li><p>现代终端功能: 图像、Unicode、真彩色、OpenTye连体字、鼠标、聚焦跟随</p>\n</li>\n<li><p>对多个终端窗口进行不同的窗口布局操作</p>\n</li>\n<li><p>可通过脚本或Shell进行控制</p>\n</li>\n<li><p>使用<code>Kittens</code>框架，可以让一些小型程序用于扩展Kitty</p>\n</li>\n<li><p>允许在任意程序中使用回滚历史的功能</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty</p>","more":"<h1 id=\"Kitt终端简介\"><a href=\"#Kitt终端简介\" class=\"headerlink\" title=\"Kitt终端简介\"></a>Kitt终端简介</h1><p>从官方介绍内，Kitty具有以下特性:</p>\n<ul>\n<li><p>使用GPU进行渲染，以降低系统负载和更加平滑的滚动效果。使用多线程渲染使得输入延迟最低。</p>\n</li>\n<li><p>现代终端功能: 图像、Unicode、真彩色、OpenTye连体字、鼠标、聚焦跟随</p>\n</li>\n<li><p>对多个终端窗口进行不同的窗口布局操作</p>\n</li>\n<li><p>可通过脚本或Shell进行控制</p>\n</li>\n<li><p>使用<code>Kittens</code>框架，可以让一些小型程序用于扩展Kitty</p>\n</li>\n<li><p>允许在任意程序中使用回滚历史的功能</p>\n</li>\n</ul>"},{"title":"参加广州LUG线下见面会","copyright":true,"date":"2019-12-15T15:57:36.000Z","_content":"\n今天下午我去参加了广州LUG线下见面会!\n\n<!--more-->\n\n&Emsp;&emsp;首先先对持续关注(Nobody)我博客的同仁们说声抱歉，博客好像有几个月没有更新了，主要是因为从NeoVim换为Emacs还未习惯。再加上我一直在找直接编写org文件，然后让后端渲染器能直接渲染org文件的博客后端渲染器。中间也确实见到过几个，例如`org-page`，但折腾来折腾去也未折腾好，所以还是使用Emacs编写Markdown吧。\n","source":"_posts/参加广州LUG线下见面会.md","raw":"---\ntitle: 参加广州LUG线下见面会\ncopyright: true\ndate: 2019-12-15 23:57:36\ncategories: 个人感想\ntags: Linux\n---\n\n今天下午我去参加了广州LUG线下见面会!\n\n<!--more-->\n\n&Emsp;&emsp;首先先对持续关注(Nobody)我博客的同仁们说声抱歉，博客好像有几个月没有更新了，主要是因为从NeoVim换为Emacs还未习惯。再加上我一直在找直接编写org文件，然后让后端渲染器能直接渲染org文件的博客后端渲染器。中间也确实见到过几个，例如`org-page`，但折腾来折腾去也未折腾好，所以还是使用Emacs编写Markdown吧。\n","slug":"参加广州LUG线下见面会","published":1,"updated":"2020-01-19T03:49:51.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod4005comoo4m5w0o4n","content":"<p>今天下午我去参加了广州LUG线下见面会!</p>\n<a id=\"more\"></a>\n<p>&Emsp;&emsp;首先先对持续关注(Nobody)我博客的同仁们说声抱歉，博客好像有几个月没有更新了，主要是因为从NeoVim换为Emacs还未习惯。再加上我一直在找直接编写org文件，然后让后端渲染器能直接渲染org文件的博客后端渲染器。中间也确实见到过几个，例如<code>org-page</code>，但折腾来折腾去也未折腾好，所以还是使用Emacs编写Markdown吧。</p>\n","site":{"data":{}},"excerpt":"<p>今天下午我去参加了广州LUG线下见面会!</p>","more":"<p>&Emsp;&emsp;首先先对持续关注(Nobody)我博客的同仁们说声抱歉，博客好像有几个月没有更新了，主要是因为从NeoVim换为Emacs还未习惯。再加上我一直在找直接编写org文件，然后让后端渲染器能直接渲染org文件的博客后端渲染器。中间也确实见到过几个，例如<code>org-page</code>，但折腾来折腾去也未折腾好，所以还是使用Emacs编写Markdown吧。</p>"},{"title":"如何用hexo+github-pages搭建博客","date":"2019-04-29T14:56:54.000Z","copyright":true,"_content":"\n成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.\n\n<!--more-->\n\n![逆光](如何用hexo-github-pages搭建博客/逆光.jpg)\n\n# 为何选择hexo\n\n- hexo博客框架的网上资料较多，技术较为成熟.\n\n- hexo使用Makrdown进行渲染.\n\n- hexo只需几步就可部署博客.\n\n- hexo具有丰富的主题/插件可选.\n\n# 安装hexo\n\n## 安装Nodejs,Git\n\n要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。\n\n大部分发行版自带Git,Nodejs只需要一条命令:\n\n**apt**\n\n~~~shell\n$ sudo apt install nodejs npm\n~~~\n\n**pacman**\n\n~~~shell\n$ sudo pacman -S nodejs npm\n~~~\n## 配置Nodejs\n\n**安装完成Nodejs和Git后还需要设置npm的软件源.**\n\n在任意目录下执行如下命令:\n\n~~~shell\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):\n\n~~~shell\n$ npm config get registry\n~~~\n\n## 配置Git\n\n### **注册Github**\n\n[注册Github](https://github.com/join)\n\n### **创建仓库**\n\n[创建Github仓库](https://github.com/new)\n\n注意: 仓库名必须是**name.github.io**\n\n例如我的 evanmeek.github.io\n\n![创建Github仓库](如何用hexo-github-pages搭建博客/创建仓库.png)\n\n\n需要设置两点:\n\n- Git身份标识\n\n~~~shell\n$ git config --global user.email \"你的邮箱\"\n$ git config --global user.name \"你的名字\"\n~~~\n\n推荐把邮箱和名字设置为Github上的邮箱和名字相同\n\n\n- SSH密钥\n\n如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:\n\n~~~shell\n$ ls ~/.ssh\n~~~\n\n若没有则创建新的密钥\n\n~~~shell\n$ ssh-keygen -t rsa -C \"你的邮箱\"\n~~~\n\n创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。\n\n创建完成后，你会在~/.ssh内看到两个文件\n\n![ssh目录](如何用hexo-github-pages搭建博客/ssh目录.png)\n\n分别是私钥(id_rsa),公钥(id_rsa.pub)\n\n下一步则是需要在Github中添加刚刚生成的密钥\n\n首先登陆Github,打开设置.\n\n如图所示：\n\n![登陆Github](如何用hexo-github-pages搭建博客/打开设置.png)\n\n下一步找到SSH选项\n\n如图所示：\n\n![设置SSH](如何用hexo-github-pages搭建博客/设置SSH.png)\n\n下一步导入公钥\n\n![导入密钥](如何用hexo-github-pages搭建博客/导入密钥.png)\n\n复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名\n\n~~~shell\n$ cat ~/.ssh/id_rsa.pub\n~~~\n\n## 安装hexo\n\n前面安装完Nodejs和Git之后可以通过一条命令安装hexo\n\n**要使用sudo提权**\n\n执行如下命令:\n\n~~~shell\n$ npm install -g hexo-cli\n~~~\n\n看到Done!之后则为安装成功.\n\n# 开始搭建\n\n## 初始化hexo博客\n\n使用如下命令初始化博客\n\n~~~shell\n$ hexo init <目录>\n~~~\n\n![hexoinit](如何用hexo-github-pages搭建博客/hexoinit.png)\n\n初始化完成之后目录结构大概是这样的:\n\n~~~\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n~~~\n\n下面分别讲下这些文件或目录分别存放了些什么。\n\n主配置文件: **_config.yml**\n\n> 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.\n\n插件信息: **package.json**\n\n> 包含了当前hexo博客中安装了哪些插件.\n\n模板目录: **scaffolds/**\n\n> 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.\n\n资源目录: **source/**\n\n> 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.\n\n主题目录: **themes/**\n\n> 主题目录，所有的主题都丢在这里。\n\n---\n\n## 生成博客\n\n执行如下命令创建一篇博文:\n\n~~~shell\n$ hexo n \"文章名\"\n~~~\n\nhexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!\n\n这一步用于生成静态文件(就是把md转为html的操作)\n\n**要在网站目录(就是初始化的目录下)下执行**\n\n~~~shell\n$ hexo generate\n~~~\n\n这个命令可以简化，并且还可以带两个参数\n\n简化+参数:\n~~~shell\n$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)\n\n$ hexo g -w # 可以监视有哪些文件被生成了\n~~~\n\n---\n\n# 配置hexo\n\n这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.\n\n下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。\n\n找到deploy项\n\n修改为:\n\n![deploy](如何用hexo-github-pages搭建博客/deploy.png)\n\n**type为git不能为大写**\n\n\n\n---\n\n## 部署博客\n\n部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署\n\n**本地部署**\n\n\n执行如下命令:\n~~~shell\n$ npm install hexo-deployer-git --save\n~~~\n\n~~~shell\n$ hexo s\n~~~\n\n执行完后可以通过localhost:4000进行[查看](localhost:4000).\n\n![本地部署](如何用hexo-github-pages搭建博客/本地部署.png)\n\n**部署到Github**\n\n~~~shell\n$ hexo d\n~~~\n\n这样就可以部署到Github了，通过https://你的Github用户名.github.io访问\n\n# 寻找主题\n\n[Hexo主题](https://hexo.io/themes/)\n\n把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。\n\n# 使用体验\n\n还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com\n\n---","source":"_posts/如何用hexo-github-pages搭建博客.md","raw":"---\ntitle: 如何用hexo+github-pages搭建博客\ndate: 2019-04-29 22:56:54\ncategories: 折腾记录\ntags:\n - hexo\n - 博客\ncopyright: true\n---\n\n成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.\n\n<!--more-->\n\n![逆光](如何用hexo-github-pages搭建博客/逆光.jpg)\n\n# 为何选择hexo\n\n- hexo博客框架的网上资料较多，技术较为成熟.\n\n- hexo使用Makrdown进行渲染.\n\n- hexo只需几步就可部署博客.\n\n- hexo具有丰富的主题/插件可选.\n\n# 安装hexo\n\n## 安装Nodejs,Git\n\n要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。\n\n大部分发行版自带Git,Nodejs只需要一条命令:\n\n**apt**\n\n~~~shell\n$ sudo apt install nodejs npm\n~~~\n\n**pacman**\n\n~~~shell\n$ sudo pacman -S nodejs npm\n~~~\n## 配置Nodejs\n\n**安装完成Nodejs和Git后还需要设置npm的软件源.**\n\n在任意目录下执行如下命令:\n\n~~~shell\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):\n\n~~~shell\n$ npm config get registry\n~~~\n\n## 配置Git\n\n### **注册Github**\n\n[注册Github](https://github.com/join)\n\n### **创建仓库**\n\n[创建Github仓库](https://github.com/new)\n\n注意: 仓库名必须是**name.github.io**\n\n例如我的 evanmeek.github.io\n\n![创建Github仓库](如何用hexo-github-pages搭建博客/创建仓库.png)\n\n\n需要设置两点:\n\n- Git身份标识\n\n~~~shell\n$ git config --global user.email \"你的邮箱\"\n$ git config --global user.name \"你的名字\"\n~~~\n\n推荐把邮箱和名字设置为Github上的邮箱和名字相同\n\n\n- SSH密钥\n\n如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:\n\n~~~shell\n$ ls ~/.ssh\n~~~\n\n若没有则创建新的密钥\n\n~~~shell\n$ ssh-keygen -t rsa -C \"你的邮箱\"\n~~~\n\n创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。\n\n创建完成后，你会在~/.ssh内看到两个文件\n\n![ssh目录](如何用hexo-github-pages搭建博客/ssh目录.png)\n\n分别是私钥(id_rsa),公钥(id_rsa.pub)\n\n下一步则是需要在Github中添加刚刚生成的密钥\n\n首先登陆Github,打开设置.\n\n如图所示：\n\n![登陆Github](如何用hexo-github-pages搭建博客/打开设置.png)\n\n下一步找到SSH选项\n\n如图所示：\n\n![设置SSH](如何用hexo-github-pages搭建博客/设置SSH.png)\n\n下一步导入公钥\n\n![导入密钥](如何用hexo-github-pages搭建博客/导入密钥.png)\n\n复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名\n\n~~~shell\n$ cat ~/.ssh/id_rsa.pub\n~~~\n\n## 安装hexo\n\n前面安装完Nodejs和Git之后可以通过一条命令安装hexo\n\n**要使用sudo提权**\n\n执行如下命令:\n\n~~~shell\n$ npm install -g hexo-cli\n~~~\n\n看到Done!之后则为安装成功.\n\n# 开始搭建\n\n## 初始化hexo博客\n\n使用如下命令初始化博客\n\n~~~shell\n$ hexo init <目录>\n~~~\n\n![hexoinit](如何用hexo-github-pages搭建博客/hexoinit.png)\n\n初始化完成之后目录结构大概是这样的:\n\n~~~\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n~~~\n\n下面分别讲下这些文件或目录分别存放了些什么。\n\n主配置文件: **_config.yml**\n\n> 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.\n\n插件信息: **package.json**\n\n> 包含了当前hexo博客中安装了哪些插件.\n\n模板目录: **scaffolds/**\n\n> 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.\n\n资源目录: **source/**\n\n> 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.\n\n主题目录: **themes/**\n\n> 主题目录，所有的主题都丢在这里。\n\n---\n\n## 生成博客\n\n执行如下命令创建一篇博文:\n\n~~~shell\n$ hexo n \"文章名\"\n~~~\n\nhexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!\n\n这一步用于生成静态文件(就是把md转为html的操作)\n\n**要在网站目录(就是初始化的目录下)下执行**\n\n~~~shell\n$ hexo generate\n~~~\n\n这个命令可以简化，并且还可以带两个参数\n\n简化+参数:\n~~~shell\n$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)\n\n$ hexo g -w # 可以监视有哪些文件被生成了\n~~~\n\n---\n\n# 配置hexo\n\n这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.\n\n下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。\n\n找到deploy项\n\n修改为:\n\n![deploy](如何用hexo-github-pages搭建博客/deploy.png)\n\n**type为git不能为大写**\n\n\n\n---\n\n## 部署博客\n\n部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署\n\n**本地部署**\n\n\n执行如下命令:\n~~~shell\n$ npm install hexo-deployer-git --save\n~~~\n\n~~~shell\n$ hexo s\n~~~\n\n执行完后可以通过localhost:4000进行[查看](localhost:4000).\n\n![本地部署](如何用hexo-github-pages搭建博客/本地部署.png)\n\n**部署到Github**\n\n~~~shell\n$ hexo d\n~~~\n\n这样就可以部署到Github了，通过https://你的Github用户名.github.io访问\n\n# 寻找主题\n\n[Hexo主题](https://hexo.io/themes/)\n\n把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。\n\n# 使用体验\n\n还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com\n\n---","slug":"如何用hexo-github-pages搭建博客","published":1,"updated":"2020-01-19T03:49:51.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod5005fomoomqa2rvxn","content":"<p>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg\" alt=\"逆光\"></p>\n<h1 id=\"为何选择hexo\"><a href=\"#为何选择hexo\" class=\"headerlink\" title=\"为何选择hexo\"></a>为何选择hexo</h1><ul>\n<li><p>hexo博客框架的网上资料较多，技术较为成熟.</p>\n</li>\n<li><p>hexo使用Makrdown进行渲染.</p>\n</li>\n<li><p>hexo只需几步就可部署博客.</p>\n</li>\n<li><p>hexo具有丰富的主题/插件可选.</p>\n</li>\n</ul>\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><h2 id=\"安装Nodejs-Git\"><a href=\"#安装Nodejs-Git\" class=\"headerlink\" title=\"安装Nodejs,Git\"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p>\n<p>大部分发行版自带Git,Nodejs只需要一条命令:</p>\n<p><strong>apt</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure>\n<p><strong>pacman</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Nodejs\"><a href=\"#配置Nodejs\" class=\"headerlink\" title=\"配置Nodejs\"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p>\n<p>在任意目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config get registry</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h2><h3 id=\"注册Github\"><a href=\"#注册Github\" class=\"headerlink\" title=\"注册Github\"></a><strong>注册Github</strong></h3><p><a href=\"https://github.com/join\" target=\"_blank\" rel=\"noopener\">注册Github</a></p>\n<h3 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a><strong>创建仓库</strong></h3><p><a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">创建Github仓库</a></p>\n<p>注意: 仓库名必须是<strong>name.github.io</strong></p>\n<p>例如我的 evanmeek.github.io</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png\" alt=\"创建Github仓库\"></p>\n<p>需要设置两点:</p>\n<ul>\n<li>Git身份标识</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> git config --global user.email \"你的邮箱\"</span><br><span class=\"line\"><span class=\"meta\">$</span> git config --global user.name \"你的名字\"</span><br></pre></td></tr></table></figure>\n<p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p>\n<ul>\n<li>SSH密钥</li>\n</ul>\n<p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>若没有则创建新的密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ssh-keygen -t rsa -C \"你的邮箱\"</span><br></pre></td></tr></table></figure>\n<p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p>\n<p>创建完成后，你会在~/.ssh内看到两个文件</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png\" alt=\"ssh目录\"></p>\n<p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p>\n<p>下一步则是需要在Github中添加刚刚生成的密钥</p>\n<p>首先登陆Github,打开设置.</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png\" alt=\"登陆Github\"></p>\n<p>下一步找到SSH选项</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png\" alt=\"设置SSH\"></p>\n<p>下一步导入公钥</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png\" alt=\"导入密钥\"></p>\n<p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p>\n<p><strong>要使用sudo提权</strong></p>\n<p>执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>看到Done!之后则为安装成功.</p>\n<h1 id=\"开始搭建\"><a href=\"#开始搭建\" class=\"headerlink\" title=\"开始搭建\"></a>开始搭建</h1><h2 id=\"初始化hexo博客\"><a href=\"#初始化hexo博客\" class=\"headerlink\" title=\"初始化hexo博客\"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png\" alt=\"hexoinit\"></p>\n<p>初始化完成之后目录结构大概是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>下面分别讲下这些文件或目录分别存放了些什么。</p>\n<p>主配置文件: <strong>_config.yml</strong></p>\n<blockquote>\n<p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p>\n</blockquote>\n<p>插件信息: <strong>package.json</strong></p>\n<blockquote>\n<p>包含了当前hexo博客中安装了哪些插件.</p>\n</blockquote>\n<p>模板目录: <strong>scaffolds/</strong></p>\n<blockquote>\n<p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p>\n</blockquote>\n<p>资源目录: <strong>source/</strong></p>\n<blockquote>\n<p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p>\n</blockquote>\n<p>主题目录: <strong>themes/</strong></p>\n<blockquote>\n<p>主题目录，所有的主题都丢在这里。</p>\n</blockquote>\n<hr>\n<h2 id=\"生成博客\"><a href=\"#生成博客\" class=\"headerlink\" title=\"生成博客\"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"文章名\"</span><br></pre></td></tr></table></figure>\n<p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p>\n<p>这一步用于生成静态文件(就是把md转为html的操作)</p>\n<p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo generate</span><br></pre></td></tr></table></figure>\n<p>这个命令可以简化，并且还可以带两个参数</p>\n<p>简化+参数:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p>\n<p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p>\n<p>找到deploy项</p>\n<p>修改为:</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png\" alt=\"deploy\"></p>\n<p><strong>type为git不能为大写</strong></p>\n<hr>\n<h2 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p>\n<p><strong>本地部署</strong></p>\n<p>执行如下命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo s</span><br></pre></td></tr></table></figure>\n<p>执行完后可以通过localhost:4000进行<a href=\"localhost:4000\" target=\"_blank\" rel=\"noopener\">查看</a>.</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png\" alt=\"本地部署\"></p>\n<p><strong>部署到Github</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo d</span><br></pre></td></tr></table></figure>\n<p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p>\n<h1 id=\"寻找主题\"><a href=\"#寻找主题\" class=\"headerlink\" title=\"寻找主题\"></a>寻找主题</h1><p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a></p>\n<p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p>\n<h1 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</p>","more":"<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg\" alt=\"逆光\"></p>\n<h1 id=\"为何选择hexo\"><a href=\"#为何选择hexo\" class=\"headerlink\" title=\"为何选择hexo\"></a>为何选择hexo</h1><ul>\n<li><p>hexo博客框架的网上资料较多，技术较为成熟.</p>\n</li>\n<li><p>hexo使用Makrdown进行渲染.</p>\n</li>\n<li><p>hexo只需几步就可部署博客.</p>\n</li>\n<li><p>hexo具有丰富的主题/插件可选.</p>\n</li>\n</ul>\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><h2 id=\"安装Nodejs-Git\"><a href=\"#安装Nodejs-Git\" class=\"headerlink\" title=\"安装Nodejs,Git\"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p>\n<p>大部分发行版自带Git,Nodejs只需要一条命令:</p>\n<p><strong>apt</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure>\n<p><strong>pacman</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Nodejs\"><a href=\"#配置Nodejs\" class=\"headerlink\" title=\"配置Nodejs\"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p>\n<p>在任意目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config get registry</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h2><h3 id=\"注册Github\"><a href=\"#注册Github\" class=\"headerlink\" title=\"注册Github\"></a><strong>注册Github</strong></h3><p><a href=\"https://github.com/join\" target=\"_blank\" rel=\"noopener\">注册Github</a></p>\n<h3 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a><strong>创建仓库</strong></h3><p><a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">创建Github仓库</a></p>\n<p>注意: 仓库名必须是<strong>name.github.io</strong></p>\n<p>例如我的 evanmeek.github.io</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png\" alt=\"创建Github仓库\"></p>\n<p>需要设置两点:</p>\n<ul>\n<li>Git身份标识</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> git config --global user.email \"你的邮箱\"</span><br><span class=\"line\"><span class=\"meta\">$</span> git config --global user.name \"你的名字\"</span><br></pre></td></tr></table></figure>\n<p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p>\n<ul>\n<li>SSH密钥</li>\n</ul>\n<p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>若没有则创建新的密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ssh-keygen -t rsa -C \"你的邮箱\"</span><br></pre></td></tr></table></figure>\n<p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p>\n<p>创建完成后，你会在~/.ssh内看到两个文件</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png\" alt=\"ssh目录\"></p>\n<p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p>\n<p>下一步则是需要在Github中添加刚刚生成的密钥</p>\n<p>首先登陆Github,打开设置.</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png\" alt=\"登陆Github\"></p>\n<p>下一步找到SSH选项</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png\" alt=\"设置SSH\"></p>\n<p>下一步导入公钥</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png\" alt=\"导入密钥\"></p>\n<p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p>\n<p><strong>要使用sudo提权</strong></p>\n<p>执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>看到Done!之后则为安装成功.</p>\n<h1 id=\"开始搭建\"><a href=\"#开始搭建\" class=\"headerlink\" title=\"开始搭建\"></a>开始搭建</h1><h2 id=\"初始化hexo博客\"><a href=\"#初始化hexo博客\" class=\"headerlink\" title=\"初始化hexo博客\"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png\" alt=\"hexoinit\"></p>\n<p>初始化完成之后目录结构大概是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>下面分别讲下这些文件或目录分别存放了些什么。</p>\n<p>主配置文件: <strong>_config.yml</strong></p>\n<blockquote>\n<p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p>\n</blockquote>\n<p>插件信息: <strong>package.json</strong></p>\n<blockquote>\n<p>包含了当前hexo博客中安装了哪些插件.</p>\n</blockquote>\n<p>模板目录: <strong>scaffolds/</strong></p>\n<blockquote>\n<p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p>\n</blockquote>\n<p>资源目录: <strong>source/</strong></p>\n<blockquote>\n<p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p>\n</blockquote>\n<p>主题目录: <strong>themes/</strong></p>\n<blockquote>\n<p>主题目录，所有的主题都丢在这里。</p>\n</blockquote>\n<hr>\n<h2 id=\"生成博客\"><a href=\"#生成博客\" class=\"headerlink\" title=\"生成博客\"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"文章名\"</span><br></pre></td></tr></table></figure>\n<p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p>\n<p>这一步用于生成静态文件(就是把md转为html的操作)</p>\n<p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo generate</span><br></pre></td></tr></table></figure>\n<p>这个命令可以简化，并且还可以带两个参数</p>\n<p>简化+参数:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p>\n<p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p>\n<p>找到deploy项</p>\n<p>修改为:</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png\" alt=\"deploy\"></p>\n<p><strong>type为git不能为大写</strong></p>\n<hr>\n<h2 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p>\n<p><strong>本地部署</strong></p>\n<p>执行如下命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo s</span><br></pre></td></tr></table></figure>\n<p>执行完后可以通过localhost:4000进行<a href=\"localhost:4000\" target=\"_blank\" rel=\"noopener\">查看</a>.</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png\" alt=\"本地部署\"></p>\n<p><strong>部署到Github</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo d</span><br></pre></td></tr></table></figure>\n<p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p>\n<h1 id=\"寻找主题\"><a href=\"#寻找主题\" class=\"headerlink\" title=\"寻找主题\"></a>寻找主题</h1><p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a></p>\n<p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p>\n<h1 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n<hr>"},{"title":"《GNU Emacs Lisp编程入门》读书笔记","copyright":true,"date":"2019-12-21T08:17:25.000Z","_content":"\n借了本Elisp的书，不厚，200多页，大概一周(两周)就能看完吧!\n\n<!--more-->\n    \n# 第一章 列表处理 #\n\n列表是Lisp的基础。\n\n## Lisp列表 ##\n### 介绍 ###\n\n简单的Lisp列表书写形式:\n\n``` emacs-lisp\n'(rose violet daisy buttercup) ;; => (rose violet daisy buttercup)\n```\n\n这个简单的列表中的四个元素时四种不同花的名称。**元素之间用空格隔开，并且被括号包住。**\n\n另有一种在elisp中常用到的写法:\n\n \n```emacs-lisp\n(+ 2 2) ;; => 4\n```\n\n这种写法是Lisp的一个特性————**数据和代码都用相同的方式表示**。\n\n**列表还允许嵌套列表，也就是说列表的元素也可以是列表**。\n\n### Lisp原子 ###\n\n\n原子意味着\"不可再分\"。例如刚刚列表内的'2'或者是'rose'等等，这些都是原子。\n\n而列表却不是原子，因为**列表是由CAR和CDR与CONS构成的**。\n\n技术上说，Lisp的列表有三种组合方式:\n  * 括号和括号中由空格分隔的原子\n  * 括号和括号中的其他列表\n  * 括号和括号中的其他列表和原子\n\n**一个列表可以仅有一个原子或完全没有原子**\n\n无任何原子的列表称作空列表: `()`。你可以把空列表看为原子或列表。\n\n*原子和列表可以被称为**符号表达式**(symbolic expression)，又可称为**S-表达式** *。\n\nLisp编程几乎都是关于列表中的符号的(且有时是关于数字的).\n\n**双引号中的文本，都是单个原子**:`'(Info \"Name:EvanMeek Age:18 Sex:Men**)`\n\n这种被双引号括起来的文本叫做**字符串(string)**。\n\n### 列表中的空格 ###\n\nLisp中括号的数量无关紧要。下面两个的列表是完全相同的。\n\n括号多\n``` emacs-lisp\n'(1 2 3 4      5       6) ;; => (1 2 3 4 5 6)\n```\n\n括号少\n``` emacs-lisp\n'(1 2 3 4 5 6) ;; => (1 2 3 4 5 6)\n```\n\n适当的在列表中加入一些空格以及换行符可以提高可读性。\n\n\n### GNU Emacs帮助你输入列表 ###\n\n在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用`Tab`按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是`C-M-\\`\n\n并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。\n\n有兴趣的可以看下这个知乎提问。<https://www.zhihu.com/question/356026550>\n\n## 运行一个程序 ##\n\n如果你想运行一段Lisp程序，那么计算机可能会做三种事:\n* 只返回列表本身;\n* 提示出错信息;\n* 将列表中第一个符号作为要执行的命令;\n大多数情况，我们希望计算机做的是第三件事\n\n前面我们看到过一些列表的前面有一个单引号\"'\"，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。\n\n``` emacs-lisp\n'(只是返回本身 即可) ;; => (只是返回本身 即可)\n```\n\n而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。\n\n``` emacs-lisp\n(+ 1 2 3 4) ;; => 10\n```\n\nEmacs中可以将光标放置一对S-表达式后按 `C-x C-e`就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 `mini buffer`。\n\n也可以对原子(没有被括号括起来)求值\n\n## 产生错误消息 ##\n\n编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。\n\n下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。\n\n``` emacs-lisp\n(Just Error!) ;; => Symbol's function definition is void: Just\n```\n这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将`(Just Error!)`当成类似`(+ 1 2)`这种列表进行求值，但由于后者的第一个元素\"+\"是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素\"Just\"是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。\n\n\n ##\n\n我们已经讨论过一些符号或函数，例如\"+\"。就以\"+\"为例子，当我们对`(+ 2 2)`表达式求值时，计算机并不是执行的\"+\"这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把\"+\"改为\"Plus\"。\n\n\n\n\n\n## Lisp解释器 ##\n\n下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。\n* 首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。\n* 若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。\n* 若没有则提示错误消息。\n以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。\n\n* 第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。\n* 第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。\n* 第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。\n\n否则Lisp解释器将会从左往右依次执行。\n\n### 字节编译 ###\n\nLisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。\n\n被编译成字节码后的源码叫做elc，可以通过命令`(byte-compile-file)`进行编译。\n\n\n## 求值 ##\n\n前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。\n\n解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。\n\n解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。\n\n### 对一个内部列表求值\n\n上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。\n\n下面通过一个例子了解这个求值的过程。\n\n``` emacs-lisp\n(+ 1 (+ 2 3))\n```\n\n我们知道使用快捷键`C-x C-e`可以对一个表达式求值，那么我们将光标放置`(+ 2 3)`表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值`5`，那么再将光标放置整个表达式之后，按下快捷键得到返回值`6`。这就很好的解释了Lisp解释器对嵌套列表的求值过程。\n\n我们可以通过快捷键`C-h k`然后键入`C-x C-e`查看这个快捷键所对应的符号(命令\\函数)，也就是`eval-last-sexp`。 这个函数的作用是**对最近的一个表达式进行求值，并且将结果打印至输出区域**。\n\n\n\n\n\n## 变量 ##\n\n其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)?\n\n**在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)**，并且符号的值是可变的，我们把一个有值的符号称为变量。\n\n前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。**Lisp的符号可以同时具有一个函数定义和一个值。**我们可以把这种概念想象成具有多个抽屉的柜子。\n\n例如变量`fill-column`是一个有值的符号，对它求值可以获取自动换行的字符数。\n\n任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。\n\n`fill-column`只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。\n\n``` emacs-lisp\n(fill-column) ;; => Symbol's function definition is void: fill-column\n```\n这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。\n\n### 符号无值时的错误信息 ###\n\n下面我对一个没有赋值的符号进行求值。\n``` emacs-lisp\n(+ 2 2) ;; => 4\n```\n很显然，如果是在这个表达式右括号后执行`eval-last-sexp`将不会有任何问题，但我们现在将光标移动至`+`后，执行`eval-last-sexp`，会引发这个报错提示:`Symbol's value as variable void: +`。\n\n这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于`+`的变量，只找到了函数定义，因为就报错了。\n\n## 参量 ##\n\n参量对应着`argument`，也就是其他语言中参数的意思。例如`(+ 2 3**`这个列表的参数就是`2`和`3`，而这个`+`则是函数，`+`允许由多个参量。\n\n**不同的函数需要不同数目的参量，有些函数甚至不需要参量。**\n\n### 参量的数据类型 ###\n\n函数所接收的参量也是有数据类型的限制的，例如`+`函数就规定其参量的值必须是数字。\n\n有些函数允许有任意数量个参量，例如`concat`函数，它将任意多个字符串类型的参量合并为一个字符串。\n\n``` emacs-lisp\n(concat \"My name is:\" \"EvanMeek\") ;; => \"My name is: EvanMeek\"\n```\n\n**请注意，`concat`函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。**\n\n例如我们可以在`concat`的参量中写上`substring`函数。\n\n``` emacs-lisp\n(concat \"Nice to meet \" (substring \"fuck you\" 5 8))\n```\n上面的`concat`是一个参量必须都为字符串类型且任意数量的函数，而`substring`是一个可变数量参量且有多种参量类型的函数。\n`substring`是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称`原子分裂机`。\n\n\n\n\n\n### 作为变量和列表的值的参量 ###\n\n> 上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。\n\n这一节，我们将谈谈函数的参量还支持那些。\n\n函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如:\n\n``` emacs-lisp\n;; 结果可能不同，取决于你的Emacs配置。\n(+ 2 fill-column) ;; => 82\n```\n\n并且参量还可以是一个列表，例如:\n\n``` emacs-lisp\n(+ 2 (+ 3 (+ 4))) ;; =>  9\n```\n\n\n### 数目可变的参量 ###\n前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的`+`函数:\n\n``` emacs-lisp\n(+) ;; => 0\n(+ 2) ;; => 2\n```\n又或是`\\*`函数:\n\n``` emacs-lisp\n(*) ;; => 1\n(* 2) ;; => 2\n```\n\n所以它们都具有一个特性————参量数量可变。\n\n``` emacs-lisp\n(* 1 2 3) ;; => 66\n(+ 1 2 3) ;; => 6\n```\n\n\n\n### 用一个错误类型的数据对象作为参量 ###\n\n试想下，如果我们对函数提供了错误类型的参量会发生什么？\n\n``` emacs-lisp\n(+ 2 'hello) ;; => Wrong type argument: number-or-marker-p,hello\n```\n我们知道`+`函数的参量必须是数字，而我们传入的参量2的`'hello`被Lisp解释器操作时会试图将`2`和`'hello`的返回值相加，但是`'hello`的返回值不是一个数字，所以就会引发这个错误。\n\n让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号`number-or-marker-p`这个符号意味着:Lisp解释器提示我们`+`函数的参量所需的数据类型，`number`也就是数字，而`marker`是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而`p`则是Lisp的一个历史问题(早期Lisp程序员中用\"p\"替代\"predicate\"用于表示是否为真)，类似的有`zerop`用于判断参量值是否为零。最后的`hello`则是我们传给`+`函数出错的参量的值。\n\n### message函数 ###\n`message`函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个`FORMAT STRING`(可格式化字符串)。\n\n``` emacs-lisp\n(message \"Should you sleep now?\") ;; => Should you sleep now?\n```\n双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。\n\n``` emacs-lisp\n(message \"The name of this buffer is: %s\" (buffer-name)) ;; => \"The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串`%s`，`message`函数的第二个参量的值将用于它，这个`%s`代表了接收一段字符传，类似的还有`%d`用于接收一个十进制数。\n\n``` emacs-lisp\n(message \"The value of fill-column is %d\" fill-column) ;; => \"The value of fill-column is 80\"\n```\n\n这些特殊子串都支持变量、列表或符号，例如：\n\n``` emacs-lisp\n(message \"我想吃%s，各来%d斤!\" (concat \"苹果、\" \"梨子、\" \"葡萄\") (+ 1 1)) ;; => \"我想吃苹果、梨子、葡萄，各来2斤!\"\n```\n\n从第二个参量开始将会一次取代第一个参量中特殊子串的位置。\n## 给一个变量赋值 ##\n\n这一小节学习为一个变量赋值，常用的操作有`set`、`setq`、`let`，在这节主要将`set`和`setq`。并且描述这两个函数是如何工作的。\n\n### 使用set函数 ###\n\n我们要为`flowers`符号附上一个列表值，那么可以这么写 \n```emacs-lisp\n(set 'flowers '(菊花 百合 玫瑰)) ;; => (菊花 百合 玫瑰)\n```\n这意味着我们将列表`菊花 百合...`绑定给了`flowers`符号。\n\n两个参量的引用是为了让其不要求值，所以你可以知道`set`函数的第一个参量最好要加上引用，这大概是很常用的搭配。\n\n### 使用setq函数 ###\n\n`setq`函数与`set`函数很相似，它们只有一个区别，就是`setq`函数会自动给第一个参量加上引用，例如用`setq`完成上一小节的例子:\n\n``` emacs-lisp\n(setq flowers '(菊花 百合 玫瑰)) ;; => (菊花 百合 玫瑰)\n```\n\n并且它们俩都是可以为多个变量绑定多个值的，例如:\n\n``` emacs-lisp\n(setq 学生 '(学号 地址 姓名 电话)\n      老师 '(教师号 地址 姓名 电话))\n学生 ;; => (学号 地址 姓名 电话)\n老师 ;; => (教师号 地址 姓名 电话)\n```\n\n其中参量二绑定给参量一，参量四绑定给参量三，以此类推。\n\n\n\n\n### 计数 ###\n\n就是用`setq`函数完成了一个递增的操作。\n\n首先生成一个初始化器，再生成一个递增器，再进行输出数值。\n\n``` emacs-lisp\n(setq count 0) ;; 初始器\n(setq count (1+ count)) ;; 递增器\ncount ;;输出\n```\n\n## 小结 ##\n记录一下，加油努力，毕竟书中都说了，我已经跨过了最陡峭的那段山路。\n\n  * Lisp程序由表达式组成，表达式是列表或单个原子。\n  * 列表由0个或更多的原子或内部列表组成，原子或列表之间由空格隔开，并由括号括起来，列表可为空。\n  * 原子是多字符的符号(如fill-column)，单字符的符号(如+号)，双引号之间的字符串或者数字。\n  * 对数字求值就是其本身\n  * 对双引号之间的字符串求值也是其本身\n  * 当对一个符号求值时，将返回它的值。\n  * 当对一个列表求值时，Lisp解释器查看列表首符号绑定在其上的函数定义，并执行其指令。\n  * 单引号告诉Lisp解释器返回后续表达式的书写形式，而不是像没有单引号时那样对其求值。\n  * 参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。\n  * 当对一个函数求值时总是返回一个值(除非得到错误信息)。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。\n  \n  **最后，希望这篇博客可以记录好第一章所讲。**\n\n## 练习 ##\n\n一个一个来，题目写在博客内吧...\n\n* 通过对一个不在括号内的适当符号求值，产生一个错误信息。\n\n解答:\n\n``` emacs-lisp\n一个不存在的变量 ;; => Symbol's value as variable is void: 一个不存在的变量 \n```\n\n* 通过对一个在括号内的适当符号求值，产生一个错误信息。\n\n解答:\n\n``` emacs-lisp\n(又一个不存在的符号) ;; => Symbol's function definition is void: 又一个不存在的符号\n```\n\n* 创建一个每次增加2而不是1的计数器。\n\n解答:\n\n``` emacs-lisp\n(setq count 0) ;; 初始器 \n(setq count (+ 2 count)) ;; 递增器\ncount ;;输出\n```\n\n* 写一个表达式，当对它求值时，它在回显区输出一条消息。\n\n解答:\n\n``` emacs-lisp\n(message \"这段消息是要输出至%s%s的\" '回显 \"区\")\n```\n\n# 第二章 求值实践 #\n\n这一章主要讲了关于buffer的一些知识，讲了一些关于buffer的函数，并且讲解了一些buffer的注意事项。\n\n## 缓冲区名 ##\n\n讲了两个函数，分别是`(buffer-name)`以及`(buffer-file-name)`。\n\n首先得清楚buffer和文件的概念，buffer的中文翻译叫做缓冲区，它其实是将文件中的内容拷贝到Emacs中，所以在我们修改buffer时，文件并不会改动，只有当我们进行保存修改时才会。而文件是保存在磁盘上的信息，人们常常在修改buffer时说成\"我在修改xx文件\"，这严格意义上讲是错误的，但人们都知道其实我只是在修改buffer，而不是那个文件，只不过说成文件罢了，所以各位小伙伴不要误解。\n\n计算机没有人类那么聪明，所以大家在写代码时要分清楚这两个的不同。\n\n``` emacs-lisp (buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n(buffer-file-name) ;; =>\"/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n**表达式`(buffer-name)`用于获取当前buffer的名称而`(buffer-file-name)`用于获取当前buffer所对应文件的完整路径**，还要说明一点，并不是所有的buffer都有所对应的文件，例如`\\*scratch\\*`buffer就没有所对应的文件。\n\n## 获得缓冲区 ##\n\n如果想获得缓冲区本身，那么可以使用`current-buffer`。\n\n``` emacs-lisp\n(buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n(current-buffer) ;; => #<buffer 《GNU-Emacs-Lisp编程入门》读书笔记.md>\n```\n我们发现这两个函数的返回值挺相似的，但实际上他们却完全不同，`buffer-name`获取到的只是一个名称罢了，而`current-buffer`函数获取到的是一个名称所指向的对象或实体。举个生活上的例子:你对小明说:\"小明，帮我拿个苹果\"，然后小明就拿给了你\"苹\"和\"果\"字，显然这不是你真正想要的，你想要的是叫苹果的那个实体，可以吃的，有维生素的水果。经过这个例子，希望大家都能理解。 \n\n## 切换缓冲区 ##\n\n先介绍一个函数————`other-buffer`，这个函数用于发挥最近常打开过的buffer对象。例如最近常在`\\*scratch\\*`与`test.el`之间切换buffer，那么当前buffer为`\\*scratch\\*`时调用`(other-buffer)`时将会返回`test.el`的buffer对象。\n\n再介绍一个函数————`switch-to-buffer`，这个函数接收一个`Buffer`对象的参量，可以切换当前buffer为`Buffer`参量。\n\n``` emacs-lisp\n(buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n(other-buffer) ;; => #<buffer *Backtrace*>\n;; 根据最近最常打开过的buffer对象切换buffer\n(switch-to-buffer (other-buffer))\n(buffer-name) ;; => \"*Backtrace*\"\n```\n如果想要回到上一个buffer可以键入键序列`C-x b RET`，RET是回车。\n\n前面几次提到`调用(call)`这个概念，实际上Lisp解释器对一个列表的首元素为一个函数进行处理时，就是在调用那个函数。\n\n## 缓冲区大小和位点的定位 ##\n\n先为大家介绍下四个函数:\n  * `(point)`  \n  ;; 获取当前光标在当前buffer的位点。\n  * `(buffer-size)`\n  ;; 获取当前buffer的字符数(包括空格)\n  * `(point-min)`\n  ;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始\n  * `(point-max)`\n  ;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。\n  \n``` emacs-lisp\n;; 获取当前buffer的字符数(包括空格)\n(buffer-size) ;; => 10636\n;; 获取当前光标在当前buffer的位点。\n(point) ;; => 10525\n;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始\n(point-min) ;; => 1\n\n;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。\n(point-max) ;; => 10670\n```\n\n## 练习 ##\n\n找一个文件，对它进行操作，将光标移动到缓冲区的中间部分。找出它的缓冲区名、文件名、长度、和你在文件中的位置。\n\n* 缓冲区名\n\n``` emacs-lisp\n(buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n\n* 文件名\n\n``` emacs-lisp\n(buffer-file-name) ;; => \"/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n\n* 长度\n\n``` emacs-lisp\n(buffer-size) ;; => 11005\n```\n\n* 在文件中的位置\n\n``` emacs-lisp\n(point) ;; => 11033\n```\n\n# 第三章 如何编写函数定义 #\n    \n本章内容较多，不止于函数定义，还介绍了一些常用的函数。\n\n## defun 特殊表 ##\n\n`defun`不以通常的方式对它的参量求值，因为它是特殊表。\n\n这节将简单描述函数定义的过程。\n\n一个函数定义在`defun`之后最多可有5个部分:\n* 符号名，这个符号指向了这个函数的定义。\n* 一个列表，包含了要传给函数的参量。若没有任何参量要传递，那么可以写空列表。\n* 这个函数的文档，由双引号括住，此选项为可选。\n* 使当前函数成为一个交互式函数的列表，此选项为可选。交互式函数将会在后的小节讲到。\n* 函数的主题，也就是一系列的命令。\n下面是一个包含了五个部分的函数模板:\n\n``` emacs-lisp\n(defun funciton-name (arguments...)\n  \"optional-documentation\"\n  (interactive argument-passing-info) ;; optional\n  body...)\n```\n\n我们通过这个模板写一个简单的函数吧，这个函数的功能呢是让其参量乘以7。\n\n``` emacs-lisp\n(defun multiply-by-seven (number)\n  \"使number(参量)乘以7\"\n  (* number 7))\n```\n\n这个函数的函数名就是`multiply-by-seven`，而函数名后面的列表也就是函数的参量，当我们调用函数时，传递给函数的参量的值就会被绑定到这个`number`上。并且`number`也可以为其他的名称，这取决于写代码的人，你可以改为`multiplicand`，这可能更符合函数定义的意思。并且这里的`number`的范围是仅在函数定义内才有效的，如果我们在函数定义外对`number`求值，可能会返回个错误信息。所以说，参量列表内的参量名可以是任意的，只要不与参量列表内的其他参量相同即可。这就比如：你班上的外号叫李大头，那么在这个班里的李大头代表的人就是你，而如果是在学校中，也有人的名字叫李大头，这时这个李大头就不代表你了。\n\n跟随参量列表后的叫做函数文档，它的作用是当我们或任何人使用`C-h f`并键入函数名时所查看的函数帮助文档中的文本。这里还要注意一点，有些函数例如`apropos`在查看函数文档时会只显示文档的第一行，所以我们要在第一行就尽量写清楚这个函数的作用。通过`C-h f`查看函数文档将会弹出一个`\\*Help\\*`Buffer。\n\n而这个例子的第三行就是函数的主体(往往比例子里多很多**，它是一个列表，功能是将`number`乘以7。\n\n函数定义好了，但我们不要直接尝试调用，我先告诉你们调用的方式吧，**把函数名作为一个列表的首元素，其余的作为参量**最后eval即可。\n``` emacs-lisp\n(multiply-by-seven 7)\n```\n但可千万不要急着求值，因为肯定会报错。这主要是因为你只是写好了函数定义，并没有把函数定义给安装上。\n\n\n## 安装函数定义 ##\n\n将光标移动到我们写好的函数定义之后，eval一下即可安装好函数。安装完成后的函数就被包含在Emacs之中了，直到退出Emacs之前。如果已经尝试安装函数定义的童鞋应该已经发现了，在我们eval函数定义后，会在回显区显示函数名，这就代表我们成功安装了这个函数。\n\n### 改变函数定义  ###\n\n想要修改已经安装好的函数定义很简单，我们只需要重新安装一遍即可，例如我们想要将`multiply-by-seven`函数改为用`+`来实现，这样做:\n\n``` emacs-lisp\n(defun multiply-by-seven (number)\n  \"使number(参量)加7次\"\n  (+ number number number number number number number)) ;; => multiply-by-seven\n\n(multiply-by-seven 7) ;; => 49\n```\n所以编写Emacs Lisp代码时的流程通常是:**写函数，装函数，测函数，改函数，装函数**。\n\n## 使函数成为交互式函数 ##\n\n交互式函数的特点是可以通过`M-x`调用，还可以通过键序列调用，例如常用的移动光标`C-n`就是一个交互式函数，并且交互式函数是不会自动将返回值输出至回显区的，因为让一个函数称为交互式函数通常被认为是想得到函数的附加效果，而不是返回值。\n\n想要使一个函数称为交互式函数，可以在函数定义时，将`defun`特殊表开头的列表的第四个元素写成一个`interactive`特殊表开头的列表。例如:\n\n``` emacs-lisp\n(defun multiply-by-seven-interactive (number)\n  \"打印 number(参量) 乘以 7\n这是个交互式函数\"\n  (interactive \"p\")\n  (message \"7 * %d = %d\" number (* number 7))) ;; => multiply-by-seven-interactive\n```\n\n安装好这个函数后，可以有三种方式调用它:\n* 对表达式`(multiply-by-seven-interactive 7**`求值\n* 键入`C-u`然后输入一个数字作为函数的参量，键入`M-x`然后键入函数名最后键入`RET`。\n* 还有一种暂时没搞成功，等学到16章的第7节就知道了。\n\n**交互式函数不会自动将返回值打印至回显区** 并且当使用第二种调用方式时，没有在`C-u`之后键入数字的话将会以默认值4来替代。\n\n### 交互的multiply-by-seven函数 ###\n\n我们为`multiply-by-seven`函数定义了交互式版本，但没有解释其中的`(interactive \"p\")`列表是个什么东西，这里就说一下。\n\n首先`(interactive \"p\")`中的`p`代表将接收一个前缀参量，这个前缀参量也就是我们通过`C-u 数字 M-x 函数名`这种方式调用时的`数字`了，例如这个数字是`5`那么就会把`5`传递给`number`参量，然后在`message`函数中的`(* 7 5)`求值，最终由于函数是一个交互式函数，所以函数不会自动将返回值输出到回显区中，而`message`函数的返回值原本是带双引号的，由于是交互式函数，我们要的只是函数带来的附加效果，而不是返回值。\n\n### interactive函数的不同选项 ###\n\n前面已经解释过`interactive`函数的`p`选项，其实`interactive`特殊表有20多个预定义的选项，我们可以结合多个选项使得将信息正确交互地选送给函数。\n\n下面介绍两个选项，首先是`r`，**它可以让Emacs将位点所在区域的开始值和结束值作为函数的两个参量**:\n\n``` emacs-lisp\n(interactive \"r\") ;; => (13945 13978)\n```\n\n再则是`B`选项，**它可告诉Emacs用缓冲区的名字作为函数的参量**，它会让Emacs在小缓冲区提示用户输入缓冲区名字，并将跟在`B`后面的字符串作为提示，而且Emacs还会进行函数名的补全（按TAB）。\n\n``` emacs-lisp\n;; 会出来一个交互式的窗口\n(interactive \"B请输入Buffer名称:\") ;; => (\"test.el\")\n```\n\n下面再看一个例子，可以获取任意Buffer所对应的文件路径以及位点的开始及结束点。\n\n``` emacs-lisp\n(defun get-buffer_name-point_start-point_end (buffer start end)\n  \"获取buffer所对应的文件以及位点的开始结束值\"\n  (interactive \"B请输入Buffer名称: \\nr\")\n  (message \"Buffer-file:%s\\npoint-start:%d\\npoint-end:%d\"(buffer-file-name (get-buffer buffer)) start end))\n```\n\n通过`interactive`的`B`选项获取任意buffer的名称，再通过`r`选项后去位点的开始和结束值。最后在输出时通过`get-buffer`获取Buffer对象，从而达到目的。\n\n**`interactive`是支持控制字符的，例如上个例子中用到的`\\n`。并且`interactive`还可以无参量，这样的话跟`mark-whole-buffer`函数差不多。如果`interactive`的选项不能满足你的要求，那么你可以将参量传递给`nteractive`做为一个列表。**\n\n### 永久地安装代码 ###\n\n前面我们写了那么多的函数，在我们没有关闭Emacs之前这些函数都是可以被我们随意求值的，但是当我们关闭Emacs之后再打开就必须重新安装函数才能求值了。所以有几种方式可以永久地安装函数或其他的代码。\n\n* 如果代码作为个人使用，可以把函数定义的代码放到`.emacs`初始化文件中，当启动Emacs时，将会自动对`.emacs`文件中的代码求值。\n* 如果代码很多，可以将函数定义存放至多个文件，然后使用`load`函数使得emacs对单独存放函数的文件求值。\n* 如果是当前计算机其他用户需要使用的代码，可以将代码放入`site-init.el`文件中，这样使得所有的用户都可以使用你的代码。\n* 如果你想让你的作为全世界的人使用，那么你可以将代码放到互联网上，或着给自由软件基金会发送一份拷贝，它有可能被加入下一个发行版本中。\n\n**Emacs在过去的年代里成长的道路————奉献。**\n\n\n## let函数 ##\n\n\n`let`函数与`defun`函数一样，都是EmacsLisp中的特殊表。\n\n`let`函数将一个符号附着到或者绑定到一个值上。这些被绑定的值是只能在`let`函数之内使用，就像说`defun`特殊表举的例子，两个同名的事物在不同的场景下代表了不同的意思，例如你的房子和你朋友的房子都是房子，你对你朋友说，你要粉刷房子，在你听来是要粉刷你家的房子，但你朋友有可能会认为你要粉刷他的房子。\n\n而`let`函数就避免了这种问题，在`let`函数中绑定的变量都只能在`let`函数中访问，这就是局部变量的概念。\n\n`let`函数跟`setq`以及`set`函数有个很大的区别就在于:\n\n* `let`函数绑定的变量可有任意个 `setq`和`set`只能有一个\n* `let`函数可以执行一个或多个列表。\n* `let`函数绑定的变量都是局部的。\n\n### let表达式的各个部分 ###\n\n`let`表达式分为三个部分，第一个就是`let`符号，第二个是变量列表，第三个是主体。\n\n**第二个部分的变量列表是由一个列表组成的，这个列表内可以是任意多个符号或任意多个由两个元素组成且第一个元素必定是符号的列表。***\n\n**第三个部分是`let`表达式主体，由任意多个列表组成。**\n\n`let`表达式的模板看起来像:\n\n``` emacs-lisp\n(let varlist body...)\n```\n\n其中变量列表的符号是由`let`特殊表赋初始化值的变量.符号本身的初始值是nil.而作为两元素列表的首元素的每一个符号被绑定到对第二个元素求值后的返回值.\n\n所以一个简单的变量列表看起来可能是这样的:`(apple (pear 10))`.在这个例子中,`apple`的值是nil,因为我们没有为其赋予初始值.而`pear`的值为10.\n\n那么当变量是由两个元素的列表组成,就可以是下面这样的模板:\n\n``` emacs-lisp\n(let ((variable value) (variable value) variable...)\n  (body1)\n  (body2)...)\n```\n\n\n\n\n\n\n\n\n\n\n\n### let表达式例子 ###\n\n现在需要创建一些关于水果的栗子,不同的水果有不同的数量.\n\n``` emacs-lisp\n(let (apple (pear 10) (banana '4斤) watermelon)\n  (message \"苹果数量:%S\\t梨子数量:%d\\t香蕉数量:%s\\t西瓜数量:%S\" apple pear banana watermelon)) ;; => \"苹果数量:nil\t梨子数量:10\t香蕉数量:4斤\t西瓜数量:nil\"\n```\n\n我们创建了两个初始值为nil的变量`apple`和`watermelon`,以及一个绑定到10的变量pear,还有一个绑定到`4斤`的变量banana.随后在`let`主体中将创建的变量都用`message`函数打印在回显区.\n\n### let语句中的未初始化变量 ###\n\n在`let`表达式的变量列表中,允许不给予变量初始化值,那么Lisp解释器将会为其默认绑定到nil值上.\n\n并且,如果没有给予初始值,那么它可以称作:`作为独立的原子出现`.\n\n\n\n\n## if特殊表 ##\n\n`if`函数是除了`defun`/`let`特殊表之外的一个特殊表,它用于让计算机做一些判断的工作.\n\n首先来看`if`函数的模板:\n\n``` emacs-lisp\n(if if-part\n    then)\n```\n其工作方式是：首先测试`if-part`的返回值是否不为nil，如果不为nil，那么就执行`then`的表达式。\n\n**通常会把then部分放在if-part的下一行，这样更有利于阅读。**\n\n下面做一个简单的栗子:\n\n``` emacs-lisp\n(if (> 5 4)\n    (message \"5 比 4 大!\")) ;; => \"5 比 4 大!\"\n```\n其中`>`函数测试它的第一个参量和第二个参量进行比较大小，如果第一个参量大于第二个参量则返回“真”，否则返回nil。\n\n可往往在日常编码中，`if-part`的值不能直接确定，它可能是一个表达式，又可能是一个函数调用。\n\n例如测试参量可能被绑定在函数定义的参量上:\n\n``` emacs-lisp\n(defun type-of-animal (animal-name)\n  \"根据animal-name打印信息到回显区\n如果animal-name是符号'fierce则返回'tiger\"\n  (if (equal animal-name 'fierce)\n      (message \"It's a tiger\")))\n(type-of-animal 'fierce) ;; => \"It’s a tiger\"\n```\n\n**type-of-animal函数详解**\n\n首先`type-of-animal`是包含了两个特殊表模板，分别是`defun`和`if`。`type-of-animal`是函数名，紧跟着函数名的是函数参量列表，然后跟着的是函数的文档。最后函数的主体内是一个if函数，if函数的的一个参量是一个列表，这个列表的首元素的符号是一个函数`equal`，在Lisp中，`equal`函数用于比较参量一和参量二是否相等，如果相等则输出`if`函数的第二个参量，也是一个列表，这个列表的首元素是符号且是函数`message`，将`It's a tiger`打印至回显区。\n\n## if-then-else表达式 ##\n\n\n其实`if-then-else`表达式就是在`if`特殊表之上加了一个参量，其他没什么不同，新增的参量是当参量一的值为nil时，对参量三求值。\n\n它的函数模板可以写成这样:\n\n``` emacs-lisp\n(if true-or-false-test\n    action-to-carry-out-if-the-test-returns-true\n  action-to-carry-out-if-the-test-returns-false)\n```\n\n例如:\n\n``` emacs-lisp\n(if (> 4 5)\n  (message \"5 大于 4!\")\n(message \"4 小于 5\")) ;; => \"4 小于 5\"\n```\n\n通过这个例子，我们发现当`if`函数的第一参量值为nil时就会对第三参量求值。并且第三参量的缩进也要少于第二参量。\n\n那我们现在将`type-of-animal`函数改造成:\n\n```emacs-lisp\n(defun type-of-animal (animal-name) ;second version\n  \"根据animal-name打印信息到回显区\n如果animal-name是符号'fierce则输出'It's tiger!否则输出Tt not fierce\"\n  (if (equal animal-name 'fierce)\n      (message \"It's tiger\")\n    (message \"It not fierce\")))\n(type-of-animal 'fierce) ;; =>\"It’s tiger\"\n(type-of-animal 'notfierce)  ;; => \"It not fierce\"\n```\n\n## Lisp中的真与假 ##\n\n\n\n\nLisp中所有除了nil的都是真，nil也就是我们常说的假，nil有多种意思，一种就是nil代表假，另一种则是代表空列表，但往往都把空列表写成`()`，而当Lisp解释器对表达式求值时，只要值不是nil或空列表那么都是真，不管得到的值为一个数字或字符串或列表，它都代表真。\n\n``` emacs-lisp\n(if nil\n    'true\n  'false) ;; => false\n(if t\n    'true\n  'false) ;; => true\n```\n\n真也有另外一种表示方式，在表达式求值后没什么可返回时就会返回`t`，例如:\n\n``` emacs-lisp\n(> 5 4) ;; => t\n```\n\n## save-excursion函数 ##\n\n各位还记得什么是位点(point)，什么是标记(mark)吗?\n\nEmacs是一个文本编辑器，主要还是与文本打交道，那么`save-excursion函数`就是与文本打交道的一个经典函数。\n\n先让我们来回顾一下位点与标记:\n\n* 位点(point)：及当前buffer中光标所在字符位置，例如当光标置于buffer的开头，那么point应该是1，若置于buffer的末尾，那么point就是当前buffer的字符数了。\n\n* 标记(mark)：标记是buffer的另外一个位置，其中一个就是位点。在buffer中可以自定义很多标记，这样可以方便我们跳转至某个位点。设置标记的函数是`(set-mark-command)`，它绑定了一个键序列`C-SPC`，如果此时想要快速跳转至某个标记点，就可以使用命令`(exehange-point-and-mark`快速回到标记处，它绑定了一个键序列`C-x C-x`，并且还会将当初的位点设置一个标记，方便来回跳转。\n\n**位点与标记之间的缓冲区叫做现域(region)**，有很多条命令是专用于操作现域的，例如:`center-region|count-lines-region|kill-region|print-region`\n\n前面将了很多关于位点与标记的知识，下面正式介绍`save-excursion`函数，这个函数的作用主要是将位点和标记的当前位置保存，然后当其他会影响位点或标记的函数执行完后，再将标记的位点复原。 \n\n`save-excursion`函数模板:\n\n``` emacs-lisp\n(save-excursion\n  body...)\n```\n**注意，`save-excursion`函数的函数体允许有多条表达式，但是只返回最后一条表达式的值。**\n\n\n\n\n\n## 回顾 ##\n\n这一章学的东西还是挺多的，下面我就把书中的所有文字一字不差的抄下来。\n\n先说几个提到但是没有过多解释的函数:\n\n* eval-last-sexp\n对光标所处的位点前的最后一个符号表达式求值。如果这个函数激活时没有参量，那么将返回值输出在回显区，否则将打印在当前缓冲区中。\n\n* defun\n定义函数。这个特殊表最多可有五个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。\n\n* interactiv\n向解释器声明这个函数可以被交互的使用，并且这个特殊表还可以用一个字符串，分成单个或多个部分，依次传送信息至这个函数的参量。 \n\n* let\n声明在`let`表达式主体中使用的变量列表并且给它们赋初始值，初始值要么是nil，要么是一个指定的值，然后对`let`表达式主体的其他表达式求值并返回最后一个表达式的值。\n\n* save-excursion\n对这个函数主体求值前，记录位点和标记的值以及当前缓冲区。求值后恢复位点和标记。\n\n* if\n对函数的第一个参量求值，如果值为真，则对第二个参量求值，否则对第三个参量求值。\n\n* equal、eq\n测试两个对象的结构或内容是否相等用equal，测试两个对象是否完全相当用eq\n\n* < > <= >=\n用于判断第一个参量的值是否大于/小于/大于或等于/小于或等于第二个参量的值，如果是则返回真，否则返回nil\n\n* message\n用于往回显区内打印消息\n\n* setq set\nsetq 用于将第一个参量的值绑定到第二个参量的值，而第一个参量的值由`setq`自动加上引用。\nset 用于将第一个参量的值绑定到第二个参量的值，但是不会自动为第一个参量加上引用。\n\n* buffer-name\n这个函数用于获取一个缓冲区的名字\n\n* buffer-file-name\n这个函数用于获取缓冲区所对饮的名字\n\n* current-buffer\n这个函数用于获取当前缓冲区的buffer对象\n\n* other-buffer\n返回最近选择过的缓冲区\n\n* switch-to-buffer\n选择一个缓冲区\n\n* set-buffer\n设置当前缓冲区为某一个缓冲区\n\n* buffer-size\n返回当前缓冲区的字符数\n\n* point\n返回当前光标所对应缓冲区的位置\n\n* point-min\n返回当前缓冲区最小的字符数\n\n* point-max\n返回当前缓冲区最大的字符数\n\n\n\n\n\n## 练习 ##\n\n* 编写一个非交互的函数，这个函数将其第一个参量(是一个数)的值翻倍。然后使这个函数成为一个交互函数\n\n非交互:\n\n``` emacs-lisp\n(defun double(number)\n  \"使number翻倍\"\n  (setq number (* number 2)))\n\n(double 10) ;; => 20\n```\n\n交互式:\n\n``` emacs-lisp\n(defun double(number)\n  \"使number翻倍\"\n  (interactive \"n请输入要翻倍的数字: \")\n  (setq number (* number 2))\n  (message \"翻倍后:%d\" number))\n```\n\n* 编写一个函数，测试`fill-column`的当前值是否大于传送给函数参量的值，如果是则打印适当的信息\n\n``` emacs-lisp\n(defun is-bigger-to-fill-column (number)\n  \"判断number是否比fill-column大\"\n  (if (> number fill-column)\n      (message \"%d比fill-column要大\" number)\n    (message \"%d比fill-column要小\" number)))\n\n(is-bigger-to-fill-column 79) ;; => \"79比fill-column要小\"\n(is-bigger-to-fill-column 81) ;; => \"81比fill-column要大\"\n```\n\n\n# 第四章 与缓冲区有关的函数 #\n\n本章将会介绍大量的函数定义。\n\n## 查找更多的信息 ##\n\n可以使用`C-h f`查看一个函数所对应的文档，使用`C-h v`查看一个变量所对应的文档，如果要在源代码文件中查看函数定义，可以使用函数`find-tags`，跳到相应的位置。\n\nLisp代码可以分为多个模块或包，如果想要查看某个模块的帮助，可以键入`C-h p`。\n\n## 简化的beginning-of-buffer函数定义 ##\n\n对于`beginning-of-buffer`函数你们可能已经使用过了，其绑定的键序列是`M-<`。其作用是将当前光标移动至buffer的起始处。\n\n下面我们将自己实现一个简单的`beginning-of-buffer`函数。\n\n让我们来看看我们需要做什么事:\n\n1. 首先这个函数得是个交互式函数，以便我们能通过键序列调用或用`M-x`调用。\n2. 其次我们需要记录个位点为标记\n3. 最后我们再跳转到buffer起始处\n\n相比与真正的`beginning-of-buffer`函数定义，没有考虑一些复杂的选项，但是我们先完成这个简化版本吧!\n\n``` emacs-lisp\n(defun simple-beginning-of-buffer ()\n  \"移动光标至buffer开始处\"\n  (interactive)\n  (push-mark)\n  (goto-char (point-min)))\n```\n\n这个`defun`函数包含了5个部分:\n\n1. 首先是这个函数的函数名————`simple-beginning-of-buffer`\n2. 再就是函数的文档\n3. 随后是交互式表达式\n4. 然后记录位点为标记\n5. 最后跳转至buffer的起始处 \n\n由于这个函数是无参量的，所以交互式表达式内也不用写任何字符串，而`push-mark`函数默认将`point`加入到标记中，最后通过`goto-char`跳转至`point-min`的位置。如果想要回到原来的位置可以使用`C-x C-x`。\n\n既然已经写了一个`simple-beginning-of-buffer`那我们也可以写一个`simple-end-of-buffer`吧!\n\n``` emacs-lisp\n(defun simple-end-of-buffer()\n  \"移动光标至buffer结束处\"\n  (interactive)\n  (push-mark)\n  (goto-char (point-max)))\n```\n\n最后则是，如果遇到不了解的函数，可以将光标放置函数之上，键入键序列`C-h f RET`即可。 \n\n## mark-whole-buffer函数定义 ##\n\n`mark-whole-buffer` 不比`simple-end-of-buffer`复杂多少。\n\n这次我们来看一个函数的完整定义\n\n这是书中的定义:\n\n``` emacs-lisp\n(defun mark-whole-buffer ()\n  \"Put point at beginning and mark at end of buffer.\"\n  (interactive)\n  (push-mark (point))\n  (push-mark (point-max))\n  (goto-char (point-min)))\n```\n\n书中讲不知道为啥函数体内的第一条表达式`push-mark`内还需要写`(point)`，但我现在再去看，这个函数已经改变了，并且也改掉了这个冗余的代码。\n\n``` emacs-lisp\n(defun mark-whole-buffer ()\n  \"Put point at beginning and mark at end of buffer.\nIf narrowing is in effect, only uses the accessible part of the buffer.\nYou probably should not use this function in Lisp programs;\nit is usually a mistake for a Lisp function to use any subroutine\nthat uses or sets the mark.\"\n  (declare (interactive-only t))\n  (interactive)\n  (push-mark)\n  (push-mark (point-max) nil t)\n  ;; This is really `point-min' in most cases, but if we're in the\n  ;; minibuffer, this is at the end of the prompt.\n  (goto-char (minibuffer-prompt-end)))\n```\n\n并且还改了一些代码，先不看`declare`，我们发现变化的有`(push-mark (point-max))`，最新的`mark-whole-buffer`函数中函数体第二个表达式多了两个参量，第二个参量代表如果值不为nil则显示`Mark set`。第三个参量代表如果在瞬时标记模式下，值不为nil则激活。\n\n并且最后一条表达式也修改过了，原本是`point-min`但改为`minibuffer-prompt-end`，其区别在于:\n\n`minibuffer-prompt-end会在返回buffer位置时输出信息至minibuffer`\n\n在是如果当前buffer不是minibuffer那么就返回`point-min`\n\n\n\n\n## append-to-buffer函数定义 ##\n\n由于我看的这本书年代久远(2001)，现在是2019年，整整过去18年，Emacs也已经发生了巨大的变化。\n\n所以我将先试着记录书中所讲的`append-to-buffer`函数再对Emacs 26.3版本的`append-to-buffer`函数进行讲解，希望对看到这篇博客的同仁们提供一些微薄的帮助。\n\n> 这个计划已经鸽了，我发现用我现在所学还是很难解释清楚26.3版本的append-to-buffer函数的工作方式。所以后面的26.版 append-to-buffer会在以后完成，十分抱歉。\n\n首先`append-to-buffer`函数的作用是将指定buffer区域(region)中的文本追加到当前Buffer的point前。\n\n### 旧版append-to-buffer ###\n\n先让我们看看书中的`append-to-buffer`函数定义:\n\n``` emacs-lisp\n(defun append-to-buffer (buffer start end)\n  \"Append to specified buffer the text of the region.\nIt is inserted into that buffer before its point.\nWhen alling from a program, give three arguments:\na buffer or the name of one, and two character numbers\nspecifying the portion of the current buffer to be copied.\"\n  (interactive \"BAppend to buffer: \\nr\")\n  (let ((oldbuf (current-buffer)))\n    (save-excursion\n      (set-buffer (get-buffer-create buffer))\n      (insert-buffer-substring oldbuf start end))))\n```\n\n通过阅读这个函数的文档就能很清晰的了解这个函数的工作方式。\n\n略过函数名和文档，我们直接来看`interactive`。`interative`中的`B`代表让用户选择一个Buffer(可能不存在)并将buffer名称传给函数参量一，其次是一些友好的文本`Append to buffer: `，紧跟其后的`\\n`用于控制换行，最后的`r`获取当前区域(point和mark)，并将其传给函数的参量二和参量三。 \n\n随后是一个`let`特殊表，在`let`的变量列表中，定义了一个`oldbuf`，其绑定的值是`(current-buffer)`的返回值，也就是当前Buffer对象。在`let`的表达式体中有一个`save-excursion`函数。\n\n`save-excursion`函数体中有两条表达式，第一条表达式`(set-buffer)`用于将当前缓冲区变换到另外一个缓冲区，而其参量又是一个函数`get-buffer-create`，这个函数的作用是获取指定BUFFER对象或名(称为BUFFER-OR-NAME)，如果这个BUFFER-OR-NAME不存在，将会自动创建。\n\n`save-excursion`函数体的第二条表达式是一个`(insert-buffer-substring)`函数这个函数将参量一从参量二到参量三的区域的字符串插入到当前Buffer的point之前。\n\n\n\n\n### 26.3版append-to-buffer ###\n\n由于本人水平有限，如有错误，欢迎提出issue.\n\n先让我们看函数定义原型:\n\n``` emacs-lisp\n(defun append-to-buffer (buffer start end)\n  \"Append to specified BUFFER the text of the region.\nThe text is inserted into that buffer before its point.\nBUFFER can be a buffer or the name of a buffer; this\nfunction will create BUFFER if it doesn't already exist.\n\nWhen calling from a program, give three arguments:\nBUFFER (or buffer name), START and END.\nSTART and END specify the portion of the current buffer to be copied.\"\n  (interactive\n   (list (read-buffer \"Append to buffer: \" (other-buffer (current-buffer) t))\n\t (region-beginning) (region-end)))\n  (let* ((oldbuf (current-buffer))\n         (append-to (get-buffer-create buffer))\n         (windows (get-buffer-window-list append-to t t))\n         point)\n    (save-excursion\n      (with-current-buffer append-to\n        (setq point (point))\n        (barf-if-buffer-read-only)\n        (insert-buffer-substring oldbuf start end)\n        (dolist (window windows)\n          (when (= (window-point window) point)\n            (set-window-point window (point))))))))\n```\n\n我们发现函数参量没有变化，并且注释也没有大的变化，只是函数体内发生了较大的变化。\n\n首先是`interactive`函数参量发生了变化，变成了一个`list`函数，回想一下，`list`函数是用于构造一个列表的函数，这个`list`函数的第一个参量是`(read-buffer)`函数。\n\n`read-buffer`函数可以通过buffer名称读取buffer中的字符串并返回。其第一个参量是用于提示用户的友好信息，并且特意指出这个提示信息必须是由冒号和空格结尾且被双引号包围的字符串。第二个参量用于也就是返回值，它的默认值为列表\n\n\n\n\n## 回顾 ##\n\n惯例抄书\n\n* describe-function\\describe-variable\n打印一个函数或一个变量的文档。通常将其绑定到`C-h f`和`C-h v`\n\n* find-tag\n找到存放某个函数或变量的源代码的文件，并切换到这个缓冲区，将位点(光标)置于相应函数或这变量的开始处。习惯上将其绑定到`M--`。\n\n* save-excursion\n保存位点和标记的位置，并在对`save-excursion`参量求值之后恢复这些值。它也保存当前缓冲区并返回到该缓冲区。\n\n* push-mark\n在指定位置设置一个标记，并在标记环中记录原来标记的值。标记是缓冲区中的一个位置，即使由一些文本被从缓冲区删除或者增加到缓冲区，标记仍将保持它的相对位置。\n\n* goto-char\n将位点设置为由参量指定的位置。参量值可以是一个数，也可以是一个标记，甚至可以是一个返回一个位置数字的表达式(point-min)\n\n* insert-buffer-substring\n将来自一个缓冲区（这是被作为一个参量而传递给函数的）的文本域拷贝到当前缓冲区\n\n* mark-whole-buffer\n将整个缓冲区标记为一个域。一般将这个函数绑定到`C-x h`。\n\n* set-buffer\n将Emacs的注意力转移到另一个缓冲区，但是不该便显示的窗口。 \n\n* get-buffer-create\\get-buffer\n寻找一个已指定名字的缓冲区，或当指定名字的缓冲区不存在时就创建它。如果指定名称的缓冲区不存在，get-buffer函数就返回nil。\n\n## 练习  ##\n\n* 编写自己的`simplified-end-of-buffer`函数定义，然后测试它是否能工作。\n\n``` emacs-lisp\n(defun simple-end-of-buffer()\n  \"移动光标至buffer结束处\"\n  (interactive)\n  (push-mark)\n  (goto-char (point-max)))\n```\n\n* 用if和get-buffer编写一个函数，这个函数要打印一个说明某个缓冲区是否存在的消息 \n\n``` emacs-lisp\n(defun is-exist-buffer (buffer-or-name)\n  \"判断buffer-or-name是否为一个已存在的buffer\"\n  (if (bufferp (get-buffer buffer-or-name))\n      (message \"%s存在!\" buffer-or-name)\n    (message \"此缓冲区不存在!\")))\n    \n(is-exist-buffer \"test.el\") ;; => \"test.el存在!\"\n```\n\n* 用find-tag找到copy-to-buffer函数的源代码\n\n不会...\n\n# 第五章 更复杂的函数\n\n本章我们将在已学内容的基础之上学习更复杂的函数，例如有使用两次`save-excursion`的\n`copy-to-buffer`函数，以及一个在`interactive`中使用`*`和`or`函数的函数。\n\n## copy-to-buffer函数的定义\n\n`copy-to-buffer`函数与前面学过的`append-to-buffer`的定义很类似。\n\n`copy-to-buffer`是替换指定`BUFFER`的内容，而`append-to-buffer`是在指定`BUFFER`中追加内容。\n\n首先来看看`copy-to-buffer`的函数定义:\n\n``` emacs-lisp\n(defun copy-to-buffer-t (BUFFER START END)\n  \"docutments...\"\n  (interactive \"BCopy to buffer: \\nr\")\n  (let ((oldbuf (get-buffer-create BUFFER)))\n    (save-excursion\n      (set-buffer BUFFER)\n      (save-excursion\n        (insert-buffer-substring oldbuf START END)))))\n```\n\n略过函数名与文档不看，可以看到这个函数被定义为交互式函数，并且这个函数的参量要求\n是一个BUFFER对象，以及两个表示位置的数字。这三个参量都由`interactive`所解决，其\n使得让用户选择一个BUFFER，然后获取当前`Buffer`的`point`和`mark`，作为`START`和\n`END`。\n\n随后是一个`let`表达式，其在它的`varlist`部分将`BUFFER`参量通过\n`get-buffer-create`函数获取了其对象(就算`BUFFER`参量的值不存在也会创建一个)，并\n且将这个BUFFER对象赋值给`oldbuf`。在`let`表达式的`BODY`部分，出现了一个\n`save-excursion`函数，这个函数用于记录当前`point`和`mark`的位置，然后在其参量求\n值完毕后恢复记录的位置，这个参量也就是`set-buffer`，这个函数用于改变当前BUFFER为\n  参量`BUFFER`。随后又是一个`save-excursion`函数，其参量\n  `insert-buffer-substring`函数我们也了解过，其用于将当前BUFFER的START到END之间\n  的区间插入到`oldbuf`内。\n\n## insert-buffer函数的定义\n\n前面我们用过`append-to-buffer`以及`copy-to-buffer`，他们都是将当前`BUFFER`的内容\n拷贝或追加到某一个`BUFFER`中，而`insert-buffer`可以将当前`BUFFER`的内容，拷贝至\n一个已存在的`BUFFER`当中。\n\n先来看看其函数定义:\n\n``` emacs-lisp\n(defun insert-buffer-t (buffer)\n  \"docutmens..\"\n  (interactive \"*bInsert buffer: \")\n  (or (bufferp buffer)\n      (setq buffer (get-buffer buffer)))\n  (let (start end newmark)\n    (save-excursion\n      (save-excursion\n        (set-buffer buffer)\n        (setq start (point-min) end (point-max)))\n      (insert-buffer-substring buffer start end)\n      (setq newmark (point)))\n    (push-mark newmark)))\n```\n\n先简单整理一下这个函数都包含了什么东西:\n\n- 一个参量\n- 函数文档\n- 定义交互式函数\n- `interactive`参量说明有\\*和 `b`\n- 以及一个`or`函数，这个函数内有两个参量\n- 第一个参量是`bufferp`函数\n- 第二个参量是`setq`函数，`setq`的第二个参量是`get-buffer`函数。\n- 随后是一个`let`表达式\n- `let`表达式中先是初始化了三个空变量\n- 一个外层`save-excursion`函数\n- 一个内层`save-excursion`函数\n- 其第一个参量是一个`set-buffer`函数\n- 第二个参量是`setq`函数\n- 外层`save-excursion`的第二个参量是一个`insert-buffer-substring`函数\n- 第三个参量是一个`setq`函数。\n- 最后是一个`push-mark`函数。 \n\n### insert-buffer函数中的交互表达式\n\n让我们先从`interactive`表达式说起，首先起表达式说明分为三个部分：\n\n1. `*`代表只读缓冲区，这个说明会在当`b`说明返回的buffer是一个只读缓冲区时在回显\n   区提示错误。也就是说当这个`insert-buffer`函数当在一个只读缓冲区被调用时，将不\n   被允许。\n2. `b`代表要求是一个存在的缓冲区或者是缓冲区名，它与`B`说明不同。\n\n3. `Insert buffer: `是友好的提示。\n\n**提示:\\*控制符无需后接一个换行符来分割不同的参量。**\n\n### insert-buffer函数体\n\n主要有两个部分，分别是`or`函数和`let`函数。\n\n先让我们来看看`or`函数，其第一个参量是一个`bufferp`函数，这个函数用于当其参量是\n是一个已存在的buffer或buffer的名称才会返回`non-nil`的值，也就是真/非假，其第二个\n参量是一个`setq`函数，里面有一个`get-buffer`函数，这个函数是用于获取一个已存在的\nbuffer对象根据buffer对象或buffer的名称，并将buffer绑定到`get-buffer`的值之上。\n\n其实这个函数的意思是，要让`buffer`参量确定是一个已存在的buffer，我们可以用`if`函\n数重写一遍。\n\n### 用if表达式编写insert-buffer函数\n\n我们的需求是，必须确保`buffer`的值是一个已存在的buffer或buffer的名称。\n\n``` emacs-lisp\n(if (not (bufferp buffer)\n         (setq buffer (get-buffer buffer))))\n```\n\n就可以这样写，当`bufferp`函数的值为nil时，那么就会尝试获取`buffer`的对象并且保存，\n否则则报错。\n\n\n### insert-buffer函数中的let表达式\n\n在我们确保`buffer`参量是一个非只读缓冲区后，可以开始写拷贝内容的代码了。\n\n首先我们初始化三个空变量: start end newmark\n\n  `let`表达式体中有一个外层`save-excursion`函数，其记录了我们的`point`和`mark`，\n其第一个参量又是一个`save-excursion`函数，我们称为内层`save-excursion`。内层\n`save-excursion`主要做了两件事，首先是将Emacs的注意力转移到`buffer`之上，随后为\n`start`以及`end`附上`buffer`的`point-min`和`point-max`的值，并且由于内层\n`save-excursion`已经求值完毕，那么会恢复在求值过程中可能变动的位点和标记的值。随\n后外层`save-excursion`函数的第二个参量是将`buffer`参量的内容插入到当前buffer从\n`start`到`end`结束的内容，这个`start`和`end`也就是`buffer`参量所有的内容。随后又\n把`newmark`变量绑定到值`point`之上，最后将`newmark`记录为`标记`。\n\n## beginning-of-buffer函数的完整定义\n\n前面我们尝试写了`beginning-of-buffer`函数的部分定义，它是一个无参量的函数，那么\n这次我们来写一个有参量的`beginning-of-buffer`函数。\n\n这个带参量的`beginning-of-buffer`函数可以指定在当前缓冲区的几分之几标记位置。\n\n那么现来说下需求:`beginning-of-buffer`函数接受一个可选参量，这个参量的返回是1-10\n之间，这个参量作为标记点的位置。\n\n### 可选参量\n\n在需求里我们提到: \n\n> `beginning-of-buffer`函数接受一个可选参量\n\n除非特别声明，否则Lisp会认为函数的参量是必须在函数被调用时传递一个值给该参量的。\n如果不传入参量，则该函数就会出错:`Wrong number of arguments`。\n\n而如果需要使一个或多个参量变为可选参数只需要在参量前加上`&optional`关键字，例如:\n\n``` emacs-lisp\n(defun beginning-of-defun-function-t (&optional arg1 arg2)\n  \"documentation\"\n  (interactive \"P\")\n  (push-mark)\n  (goto-char\n   ;; if-there-is-an-argument\n   ;;   xxxx\n   ;; else-go-to\n   (point-min)))\n```\n\n对比前面的`simple-beginning-to-buffer`函数，好像唯一多的地方是在`goto-char`函数\n的第一个参量，变成了`if`特殊表。这个`if`函数判断由`interactive`的`P`参量获得到的前\n缀参量是否为一个非nil值，如果是则执行`if then`部分，否则执行跟\n`simple-beginning-to-buffer`一样的操作。\n\n### 带参量的beginning-of-buffer函数 \n\n`goto-char`函数中有一个`if`表达式，这个表达式做了很多关于算术的操作。 \n\n ``` emacs-lisp\n(defun beginning-of-defun-function-t (&optional arg)\n  \"documentation\"\n  (interactive \"P\")\n  (push-mark)\n  (goto-char\n   (if (> (buffer-size) 10000)\n       (/ (prefix-numeric-value arg) 10)\n     (/\n      (+ 10\n         (*\n          (buffer-size) (prefix-numeric-value arg))) 10))\n   (point-min)))\n ```\n \n 一眼看上去有些复杂，其实我们通过函数模板来揭开其中的奥秘，十分简单。\n \n我们看将`if`函数的结构看成这样:\n\n``` emacs-lisp\n(if (buffer-is-large\n     divide-buffer-size-by-10-and-multiply-by-arg)\n    else-use-alternate-calculation)\n```\n\n要吃饭了\n\n这里的`if`函数用于检查缓冲区的大小，这是因为书中使用的是第18版本的Elisp，其使用\n了不大于800w的数字来描述缓冲区的大小，如果有在某次求值中遇到更大的缓冲区，Emacs\n\n\n\n\n","source":"_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md","raw":"---\ntitle: 《GNU Emacs Lisp编程入门》读书笔记\ncopyright: true\ndate: 2019-12-21 16:17:25\ncategories: Lisp\ntags:\n - EmacsLisp\n---\n\n借了本Elisp的书，不厚，200多页，大概一周(两周)就能看完吧!\n\n<!--more-->\n    \n# 第一章 列表处理 #\n\n列表是Lisp的基础。\n\n## Lisp列表 ##\n### 介绍 ###\n\n简单的Lisp列表书写形式:\n\n``` emacs-lisp\n'(rose violet daisy buttercup) ;; => (rose violet daisy buttercup)\n```\n\n这个简单的列表中的四个元素时四种不同花的名称。**元素之间用空格隔开，并且被括号包住。**\n\n另有一种在elisp中常用到的写法:\n\n \n```emacs-lisp\n(+ 2 2) ;; => 4\n```\n\n这种写法是Lisp的一个特性————**数据和代码都用相同的方式表示**。\n\n**列表还允许嵌套列表，也就是说列表的元素也可以是列表**。\n\n### Lisp原子 ###\n\n\n原子意味着\"不可再分\"。例如刚刚列表内的'2'或者是'rose'等等，这些都是原子。\n\n而列表却不是原子，因为**列表是由CAR和CDR与CONS构成的**。\n\n技术上说，Lisp的列表有三种组合方式:\n  * 括号和括号中由空格分隔的原子\n  * 括号和括号中的其他列表\n  * 括号和括号中的其他列表和原子\n\n**一个列表可以仅有一个原子或完全没有原子**\n\n无任何原子的列表称作空列表: `()`。你可以把空列表看为原子或列表。\n\n*原子和列表可以被称为**符号表达式**(symbolic expression)，又可称为**S-表达式** *。\n\nLisp编程几乎都是关于列表中的符号的(且有时是关于数字的).\n\n**双引号中的文本，都是单个原子**:`'(Info \"Name:EvanMeek Age:18 Sex:Men**)`\n\n这种被双引号括起来的文本叫做**字符串(string)**。\n\n### 列表中的空格 ###\n\nLisp中括号的数量无关紧要。下面两个的列表是完全相同的。\n\n括号多\n``` emacs-lisp\n'(1 2 3 4      5       6) ;; => (1 2 3 4 5 6)\n```\n\n括号少\n``` emacs-lisp\n'(1 2 3 4 5 6) ;; => (1 2 3 4 5 6)\n```\n\n适当的在列表中加入一些空格以及换行符可以提高可读性。\n\n\n### GNU Emacs帮助你输入列表 ###\n\n在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用`Tab`按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是`C-M-\\`\n\n并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。\n\n有兴趣的可以看下这个知乎提问。<https://www.zhihu.com/question/356026550>\n\n## 运行一个程序 ##\n\n如果你想运行一段Lisp程序，那么计算机可能会做三种事:\n* 只返回列表本身;\n* 提示出错信息;\n* 将列表中第一个符号作为要执行的命令;\n大多数情况，我们希望计算机做的是第三件事\n\n前面我们看到过一些列表的前面有一个单引号\"'\"，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。\n\n``` emacs-lisp\n'(只是返回本身 即可) ;; => (只是返回本身 即可)\n```\n\n而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。\n\n``` emacs-lisp\n(+ 1 2 3 4) ;; => 10\n```\n\nEmacs中可以将光标放置一对S-表达式后按 `C-x C-e`就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 `mini buffer`。\n\n也可以对原子(没有被括号括起来)求值\n\n## 产生错误消息 ##\n\n编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。\n\n下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。\n\n``` emacs-lisp\n(Just Error!) ;; => Symbol's function definition is void: Just\n```\n这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将`(Just Error!)`当成类似`(+ 1 2)`这种列表进行求值，但由于后者的第一个元素\"+\"是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素\"Just\"是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。\n\n\n ##\n\n我们已经讨论过一些符号或函数，例如\"+\"。就以\"+\"为例子，当我们对`(+ 2 2)`表达式求值时，计算机并不是执行的\"+\"这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把\"+\"改为\"Plus\"。\n\n\n\n\n\n## Lisp解释器 ##\n\n下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。\n* 首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。\n* 若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。\n* 若没有则提示错误消息。\n以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。\n\n* 第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。\n* 第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。\n* 第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。\n\n否则Lisp解释器将会从左往右依次执行。\n\n### 字节编译 ###\n\nLisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。\n\n被编译成字节码后的源码叫做elc，可以通过命令`(byte-compile-file)`进行编译。\n\n\n## 求值 ##\n\n前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。\n\n解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。\n\n解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。\n\n### 对一个内部列表求值\n\n上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。\n\n下面通过一个例子了解这个求值的过程。\n\n``` emacs-lisp\n(+ 1 (+ 2 3))\n```\n\n我们知道使用快捷键`C-x C-e`可以对一个表达式求值，那么我们将光标放置`(+ 2 3)`表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值`5`，那么再将光标放置整个表达式之后，按下快捷键得到返回值`6`。这就很好的解释了Lisp解释器对嵌套列表的求值过程。\n\n我们可以通过快捷键`C-h k`然后键入`C-x C-e`查看这个快捷键所对应的符号(命令\\函数)，也就是`eval-last-sexp`。 这个函数的作用是**对最近的一个表达式进行求值，并且将结果打印至输出区域**。\n\n\n\n\n\n## 变量 ##\n\n其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)?\n\n**在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)**，并且符号的值是可变的，我们把一个有值的符号称为变量。\n\n前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。**Lisp的符号可以同时具有一个函数定义和一个值。**我们可以把这种概念想象成具有多个抽屉的柜子。\n\n例如变量`fill-column`是一个有值的符号，对它求值可以获取自动换行的字符数。\n\n任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。\n\n`fill-column`只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。\n\n``` emacs-lisp\n(fill-column) ;; => Symbol's function definition is void: fill-column\n```\n这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。\n\n### 符号无值时的错误信息 ###\n\n下面我对一个没有赋值的符号进行求值。\n``` emacs-lisp\n(+ 2 2) ;; => 4\n```\n很显然，如果是在这个表达式右括号后执行`eval-last-sexp`将不会有任何问题，但我们现在将光标移动至`+`后，执行`eval-last-sexp`，会引发这个报错提示:`Symbol's value as variable void: +`。\n\n这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于`+`的变量，只找到了函数定义，因为就报错了。\n\n## 参量 ##\n\n参量对应着`argument`，也就是其他语言中参数的意思。例如`(+ 2 3**`这个列表的参数就是`2`和`3`，而这个`+`则是函数，`+`允许由多个参量。\n\n**不同的函数需要不同数目的参量，有些函数甚至不需要参量。**\n\n### 参量的数据类型 ###\n\n函数所接收的参量也是有数据类型的限制的，例如`+`函数就规定其参量的值必须是数字。\n\n有些函数允许有任意数量个参量，例如`concat`函数，它将任意多个字符串类型的参量合并为一个字符串。\n\n``` emacs-lisp\n(concat \"My name is:\" \"EvanMeek\") ;; => \"My name is: EvanMeek\"\n```\n\n**请注意，`concat`函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。**\n\n例如我们可以在`concat`的参量中写上`substring`函数。\n\n``` emacs-lisp\n(concat \"Nice to meet \" (substring \"fuck you\" 5 8))\n```\n上面的`concat`是一个参量必须都为字符串类型且任意数量的函数，而`substring`是一个可变数量参量且有多种参量类型的函数。\n`substring`是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称`原子分裂机`。\n\n\n\n\n\n### 作为变量和列表的值的参量 ###\n\n> 上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。\n\n这一节，我们将谈谈函数的参量还支持那些。\n\n函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如:\n\n``` emacs-lisp\n;; 结果可能不同，取决于你的Emacs配置。\n(+ 2 fill-column) ;; => 82\n```\n\n并且参量还可以是一个列表，例如:\n\n``` emacs-lisp\n(+ 2 (+ 3 (+ 4))) ;; =>  9\n```\n\n\n### 数目可变的参量 ###\n前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的`+`函数:\n\n``` emacs-lisp\n(+) ;; => 0\n(+ 2) ;; => 2\n```\n又或是`\\*`函数:\n\n``` emacs-lisp\n(*) ;; => 1\n(* 2) ;; => 2\n```\n\n所以它们都具有一个特性————参量数量可变。\n\n``` emacs-lisp\n(* 1 2 3) ;; => 66\n(+ 1 2 3) ;; => 6\n```\n\n\n\n### 用一个错误类型的数据对象作为参量 ###\n\n试想下，如果我们对函数提供了错误类型的参量会发生什么？\n\n``` emacs-lisp\n(+ 2 'hello) ;; => Wrong type argument: number-or-marker-p,hello\n```\n我们知道`+`函数的参量必须是数字，而我们传入的参量2的`'hello`被Lisp解释器操作时会试图将`2`和`'hello`的返回值相加，但是`'hello`的返回值不是一个数字，所以就会引发这个错误。\n\n让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号`number-or-marker-p`这个符号意味着:Lisp解释器提示我们`+`函数的参量所需的数据类型，`number`也就是数字，而`marker`是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而`p`则是Lisp的一个历史问题(早期Lisp程序员中用\"p\"替代\"predicate\"用于表示是否为真)，类似的有`zerop`用于判断参量值是否为零。最后的`hello`则是我们传给`+`函数出错的参量的值。\n\n### message函数 ###\n`message`函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个`FORMAT STRING`(可格式化字符串)。\n\n``` emacs-lisp\n(message \"Should you sleep now?\") ;; => Should you sleep now?\n```\n双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。\n\n``` emacs-lisp\n(message \"The name of this buffer is: %s\" (buffer-name)) ;; => \"The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串`%s`，`message`函数的第二个参量的值将用于它，这个`%s`代表了接收一段字符传，类似的还有`%d`用于接收一个十进制数。\n\n``` emacs-lisp\n(message \"The value of fill-column is %d\" fill-column) ;; => \"The value of fill-column is 80\"\n```\n\n这些特殊子串都支持变量、列表或符号，例如：\n\n``` emacs-lisp\n(message \"我想吃%s，各来%d斤!\" (concat \"苹果、\" \"梨子、\" \"葡萄\") (+ 1 1)) ;; => \"我想吃苹果、梨子、葡萄，各来2斤!\"\n```\n\n从第二个参量开始将会一次取代第一个参量中特殊子串的位置。\n## 给一个变量赋值 ##\n\n这一小节学习为一个变量赋值，常用的操作有`set`、`setq`、`let`，在这节主要将`set`和`setq`。并且描述这两个函数是如何工作的。\n\n### 使用set函数 ###\n\n我们要为`flowers`符号附上一个列表值，那么可以这么写 \n```emacs-lisp\n(set 'flowers '(菊花 百合 玫瑰)) ;; => (菊花 百合 玫瑰)\n```\n这意味着我们将列表`菊花 百合...`绑定给了`flowers`符号。\n\n两个参量的引用是为了让其不要求值，所以你可以知道`set`函数的第一个参量最好要加上引用，这大概是很常用的搭配。\n\n### 使用setq函数 ###\n\n`setq`函数与`set`函数很相似，它们只有一个区别，就是`setq`函数会自动给第一个参量加上引用，例如用`setq`完成上一小节的例子:\n\n``` emacs-lisp\n(setq flowers '(菊花 百合 玫瑰)) ;; => (菊花 百合 玫瑰)\n```\n\n并且它们俩都是可以为多个变量绑定多个值的，例如:\n\n``` emacs-lisp\n(setq 学生 '(学号 地址 姓名 电话)\n      老师 '(教师号 地址 姓名 电话))\n学生 ;; => (学号 地址 姓名 电话)\n老师 ;; => (教师号 地址 姓名 电话)\n```\n\n其中参量二绑定给参量一，参量四绑定给参量三，以此类推。\n\n\n\n\n### 计数 ###\n\n就是用`setq`函数完成了一个递增的操作。\n\n首先生成一个初始化器，再生成一个递增器，再进行输出数值。\n\n``` emacs-lisp\n(setq count 0) ;; 初始器\n(setq count (1+ count)) ;; 递增器\ncount ;;输出\n```\n\n## 小结 ##\n记录一下，加油努力，毕竟书中都说了，我已经跨过了最陡峭的那段山路。\n\n  * Lisp程序由表达式组成，表达式是列表或单个原子。\n  * 列表由0个或更多的原子或内部列表组成，原子或列表之间由空格隔开，并由括号括起来，列表可为空。\n  * 原子是多字符的符号(如fill-column)，单字符的符号(如+号)，双引号之间的字符串或者数字。\n  * 对数字求值就是其本身\n  * 对双引号之间的字符串求值也是其本身\n  * 当对一个符号求值时，将返回它的值。\n  * 当对一个列表求值时，Lisp解释器查看列表首符号绑定在其上的函数定义，并执行其指令。\n  * 单引号告诉Lisp解释器返回后续表达式的书写形式，而不是像没有单引号时那样对其求值。\n  * 参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。\n  * 当对一个函数求值时总是返回一个值(除非得到错误信息)。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。\n  \n  **最后，希望这篇博客可以记录好第一章所讲。**\n\n## 练习 ##\n\n一个一个来，题目写在博客内吧...\n\n* 通过对一个不在括号内的适当符号求值，产生一个错误信息。\n\n解答:\n\n``` emacs-lisp\n一个不存在的变量 ;; => Symbol's value as variable is void: 一个不存在的变量 \n```\n\n* 通过对一个在括号内的适当符号求值，产生一个错误信息。\n\n解答:\n\n``` emacs-lisp\n(又一个不存在的符号) ;; => Symbol's function definition is void: 又一个不存在的符号\n```\n\n* 创建一个每次增加2而不是1的计数器。\n\n解答:\n\n``` emacs-lisp\n(setq count 0) ;; 初始器 \n(setq count (+ 2 count)) ;; 递增器\ncount ;;输出\n```\n\n* 写一个表达式，当对它求值时，它在回显区输出一条消息。\n\n解答:\n\n``` emacs-lisp\n(message \"这段消息是要输出至%s%s的\" '回显 \"区\")\n```\n\n# 第二章 求值实践 #\n\n这一章主要讲了关于buffer的一些知识，讲了一些关于buffer的函数，并且讲解了一些buffer的注意事项。\n\n## 缓冲区名 ##\n\n讲了两个函数，分别是`(buffer-name)`以及`(buffer-file-name)`。\n\n首先得清楚buffer和文件的概念，buffer的中文翻译叫做缓冲区，它其实是将文件中的内容拷贝到Emacs中，所以在我们修改buffer时，文件并不会改动，只有当我们进行保存修改时才会。而文件是保存在磁盘上的信息，人们常常在修改buffer时说成\"我在修改xx文件\"，这严格意义上讲是错误的，但人们都知道其实我只是在修改buffer，而不是那个文件，只不过说成文件罢了，所以各位小伙伴不要误解。\n\n计算机没有人类那么聪明，所以大家在写代码时要分清楚这两个的不同。\n\n``` emacs-lisp (buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n(buffer-file-name) ;; =>\"/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n**表达式`(buffer-name)`用于获取当前buffer的名称而`(buffer-file-name)`用于获取当前buffer所对应文件的完整路径**，还要说明一点，并不是所有的buffer都有所对应的文件，例如`\\*scratch\\*`buffer就没有所对应的文件。\n\n## 获得缓冲区 ##\n\n如果想获得缓冲区本身，那么可以使用`current-buffer`。\n\n``` emacs-lisp\n(buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n(current-buffer) ;; => #<buffer 《GNU-Emacs-Lisp编程入门》读书笔记.md>\n```\n我们发现这两个函数的返回值挺相似的，但实际上他们却完全不同，`buffer-name`获取到的只是一个名称罢了，而`current-buffer`函数获取到的是一个名称所指向的对象或实体。举个生活上的例子:你对小明说:\"小明，帮我拿个苹果\"，然后小明就拿给了你\"苹\"和\"果\"字，显然这不是你真正想要的，你想要的是叫苹果的那个实体，可以吃的，有维生素的水果。经过这个例子，希望大家都能理解。 \n\n## 切换缓冲区 ##\n\n先介绍一个函数————`other-buffer`，这个函数用于发挥最近常打开过的buffer对象。例如最近常在`\\*scratch\\*`与`test.el`之间切换buffer，那么当前buffer为`\\*scratch\\*`时调用`(other-buffer)`时将会返回`test.el`的buffer对象。\n\n再介绍一个函数————`switch-to-buffer`，这个函数接收一个`Buffer`对象的参量，可以切换当前buffer为`Buffer`参量。\n\n``` emacs-lisp\n(buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n(other-buffer) ;; => #<buffer *Backtrace*>\n;; 根据最近最常打开过的buffer对象切换buffer\n(switch-to-buffer (other-buffer))\n(buffer-name) ;; => \"*Backtrace*\"\n```\n如果想要回到上一个buffer可以键入键序列`C-x b RET`，RET是回车。\n\n前面几次提到`调用(call)`这个概念，实际上Lisp解释器对一个列表的首元素为一个函数进行处理时，就是在调用那个函数。\n\n## 缓冲区大小和位点的定位 ##\n\n先为大家介绍下四个函数:\n  * `(point)`  \n  ;; 获取当前光标在当前buffer的位点。\n  * `(buffer-size)`\n  ;; 获取当前buffer的字符数(包括空格)\n  * `(point-min)`\n  ;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始\n  * `(point-max)`\n  ;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。\n  \n``` emacs-lisp\n;; 获取当前buffer的字符数(包括空格)\n(buffer-size) ;; => 10636\n;; 获取当前光标在当前buffer的位点。\n(point) ;; => 10525\n;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始\n(point-min) ;; => 1\n\n;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。\n(point-max) ;; => 10670\n```\n\n## 练习 ##\n\n找一个文件，对它进行操作，将光标移动到缓冲区的中间部分。找出它的缓冲区名、文件名、长度、和你在文件中的位置。\n\n* 缓冲区名\n\n``` emacs-lisp\n(buffer-name) ;; => \"《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n\n* 文件名\n\n``` emacs-lisp\n(buffer-file-name) ;; => \"/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md\"\n```\n\n* 长度\n\n``` emacs-lisp\n(buffer-size) ;; => 11005\n```\n\n* 在文件中的位置\n\n``` emacs-lisp\n(point) ;; => 11033\n```\n\n# 第三章 如何编写函数定义 #\n    \n本章内容较多，不止于函数定义，还介绍了一些常用的函数。\n\n## defun 特殊表 ##\n\n`defun`不以通常的方式对它的参量求值，因为它是特殊表。\n\n这节将简单描述函数定义的过程。\n\n一个函数定义在`defun`之后最多可有5个部分:\n* 符号名，这个符号指向了这个函数的定义。\n* 一个列表，包含了要传给函数的参量。若没有任何参量要传递，那么可以写空列表。\n* 这个函数的文档，由双引号括住，此选项为可选。\n* 使当前函数成为一个交互式函数的列表，此选项为可选。交互式函数将会在后的小节讲到。\n* 函数的主题，也就是一系列的命令。\n下面是一个包含了五个部分的函数模板:\n\n``` emacs-lisp\n(defun funciton-name (arguments...)\n  \"optional-documentation\"\n  (interactive argument-passing-info) ;; optional\n  body...)\n```\n\n我们通过这个模板写一个简单的函数吧，这个函数的功能呢是让其参量乘以7。\n\n``` emacs-lisp\n(defun multiply-by-seven (number)\n  \"使number(参量)乘以7\"\n  (* number 7))\n```\n\n这个函数的函数名就是`multiply-by-seven`，而函数名后面的列表也就是函数的参量，当我们调用函数时，传递给函数的参量的值就会被绑定到这个`number`上。并且`number`也可以为其他的名称，这取决于写代码的人，你可以改为`multiplicand`，这可能更符合函数定义的意思。并且这里的`number`的范围是仅在函数定义内才有效的，如果我们在函数定义外对`number`求值，可能会返回个错误信息。所以说，参量列表内的参量名可以是任意的，只要不与参量列表内的其他参量相同即可。这就比如：你班上的外号叫李大头，那么在这个班里的李大头代表的人就是你，而如果是在学校中，也有人的名字叫李大头，这时这个李大头就不代表你了。\n\n跟随参量列表后的叫做函数文档，它的作用是当我们或任何人使用`C-h f`并键入函数名时所查看的函数帮助文档中的文本。这里还要注意一点，有些函数例如`apropos`在查看函数文档时会只显示文档的第一行，所以我们要在第一行就尽量写清楚这个函数的作用。通过`C-h f`查看函数文档将会弹出一个`\\*Help\\*`Buffer。\n\n而这个例子的第三行就是函数的主体(往往比例子里多很多**，它是一个列表，功能是将`number`乘以7。\n\n函数定义好了，但我们不要直接尝试调用，我先告诉你们调用的方式吧，**把函数名作为一个列表的首元素，其余的作为参量**最后eval即可。\n``` emacs-lisp\n(multiply-by-seven 7)\n```\n但可千万不要急着求值，因为肯定会报错。这主要是因为你只是写好了函数定义，并没有把函数定义给安装上。\n\n\n## 安装函数定义 ##\n\n将光标移动到我们写好的函数定义之后，eval一下即可安装好函数。安装完成后的函数就被包含在Emacs之中了，直到退出Emacs之前。如果已经尝试安装函数定义的童鞋应该已经发现了，在我们eval函数定义后，会在回显区显示函数名，这就代表我们成功安装了这个函数。\n\n### 改变函数定义  ###\n\n想要修改已经安装好的函数定义很简单，我们只需要重新安装一遍即可，例如我们想要将`multiply-by-seven`函数改为用`+`来实现，这样做:\n\n``` emacs-lisp\n(defun multiply-by-seven (number)\n  \"使number(参量)加7次\"\n  (+ number number number number number number number)) ;; => multiply-by-seven\n\n(multiply-by-seven 7) ;; => 49\n```\n所以编写Emacs Lisp代码时的流程通常是:**写函数，装函数，测函数，改函数，装函数**。\n\n## 使函数成为交互式函数 ##\n\n交互式函数的特点是可以通过`M-x`调用，还可以通过键序列调用，例如常用的移动光标`C-n`就是一个交互式函数，并且交互式函数是不会自动将返回值输出至回显区的，因为让一个函数称为交互式函数通常被认为是想得到函数的附加效果，而不是返回值。\n\n想要使一个函数称为交互式函数，可以在函数定义时，将`defun`特殊表开头的列表的第四个元素写成一个`interactive`特殊表开头的列表。例如:\n\n``` emacs-lisp\n(defun multiply-by-seven-interactive (number)\n  \"打印 number(参量) 乘以 7\n这是个交互式函数\"\n  (interactive \"p\")\n  (message \"7 * %d = %d\" number (* number 7))) ;; => multiply-by-seven-interactive\n```\n\n安装好这个函数后，可以有三种方式调用它:\n* 对表达式`(multiply-by-seven-interactive 7**`求值\n* 键入`C-u`然后输入一个数字作为函数的参量，键入`M-x`然后键入函数名最后键入`RET`。\n* 还有一种暂时没搞成功，等学到16章的第7节就知道了。\n\n**交互式函数不会自动将返回值打印至回显区** 并且当使用第二种调用方式时，没有在`C-u`之后键入数字的话将会以默认值4来替代。\n\n### 交互的multiply-by-seven函数 ###\n\n我们为`multiply-by-seven`函数定义了交互式版本，但没有解释其中的`(interactive \"p\")`列表是个什么东西，这里就说一下。\n\n首先`(interactive \"p\")`中的`p`代表将接收一个前缀参量，这个前缀参量也就是我们通过`C-u 数字 M-x 函数名`这种方式调用时的`数字`了，例如这个数字是`5`那么就会把`5`传递给`number`参量，然后在`message`函数中的`(* 7 5)`求值，最终由于函数是一个交互式函数，所以函数不会自动将返回值输出到回显区中，而`message`函数的返回值原本是带双引号的，由于是交互式函数，我们要的只是函数带来的附加效果，而不是返回值。\n\n### interactive函数的不同选项 ###\n\n前面已经解释过`interactive`函数的`p`选项，其实`interactive`特殊表有20多个预定义的选项，我们可以结合多个选项使得将信息正确交互地选送给函数。\n\n下面介绍两个选项，首先是`r`，**它可以让Emacs将位点所在区域的开始值和结束值作为函数的两个参量**:\n\n``` emacs-lisp\n(interactive \"r\") ;; => (13945 13978)\n```\n\n再则是`B`选项，**它可告诉Emacs用缓冲区的名字作为函数的参量**，它会让Emacs在小缓冲区提示用户输入缓冲区名字，并将跟在`B`后面的字符串作为提示，而且Emacs还会进行函数名的补全（按TAB）。\n\n``` emacs-lisp\n;; 会出来一个交互式的窗口\n(interactive \"B请输入Buffer名称:\") ;; => (\"test.el\")\n```\n\n下面再看一个例子，可以获取任意Buffer所对应的文件路径以及位点的开始及结束点。\n\n``` emacs-lisp\n(defun get-buffer_name-point_start-point_end (buffer start end)\n  \"获取buffer所对应的文件以及位点的开始结束值\"\n  (interactive \"B请输入Buffer名称: \\nr\")\n  (message \"Buffer-file:%s\\npoint-start:%d\\npoint-end:%d\"(buffer-file-name (get-buffer buffer)) start end))\n```\n\n通过`interactive`的`B`选项获取任意buffer的名称，再通过`r`选项后去位点的开始和结束值。最后在输出时通过`get-buffer`获取Buffer对象，从而达到目的。\n\n**`interactive`是支持控制字符的，例如上个例子中用到的`\\n`。并且`interactive`还可以无参量，这样的话跟`mark-whole-buffer`函数差不多。如果`interactive`的选项不能满足你的要求，那么你可以将参量传递给`nteractive`做为一个列表。**\n\n### 永久地安装代码 ###\n\n前面我们写了那么多的函数，在我们没有关闭Emacs之前这些函数都是可以被我们随意求值的，但是当我们关闭Emacs之后再打开就必须重新安装函数才能求值了。所以有几种方式可以永久地安装函数或其他的代码。\n\n* 如果代码作为个人使用，可以把函数定义的代码放到`.emacs`初始化文件中，当启动Emacs时，将会自动对`.emacs`文件中的代码求值。\n* 如果代码很多，可以将函数定义存放至多个文件，然后使用`load`函数使得emacs对单独存放函数的文件求值。\n* 如果是当前计算机其他用户需要使用的代码，可以将代码放入`site-init.el`文件中，这样使得所有的用户都可以使用你的代码。\n* 如果你想让你的作为全世界的人使用，那么你可以将代码放到互联网上，或着给自由软件基金会发送一份拷贝，它有可能被加入下一个发行版本中。\n\n**Emacs在过去的年代里成长的道路————奉献。**\n\n\n## let函数 ##\n\n\n`let`函数与`defun`函数一样，都是EmacsLisp中的特殊表。\n\n`let`函数将一个符号附着到或者绑定到一个值上。这些被绑定的值是只能在`let`函数之内使用，就像说`defun`特殊表举的例子，两个同名的事物在不同的场景下代表了不同的意思，例如你的房子和你朋友的房子都是房子，你对你朋友说，你要粉刷房子，在你听来是要粉刷你家的房子，但你朋友有可能会认为你要粉刷他的房子。\n\n而`let`函数就避免了这种问题，在`let`函数中绑定的变量都只能在`let`函数中访问，这就是局部变量的概念。\n\n`let`函数跟`setq`以及`set`函数有个很大的区别就在于:\n\n* `let`函数绑定的变量可有任意个 `setq`和`set`只能有一个\n* `let`函数可以执行一个或多个列表。\n* `let`函数绑定的变量都是局部的。\n\n### let表达式的各个部分 ###\n\n`let`表达式分为三个部分，第一个就是`let`符号，第二个是变量列表，第三个是主体。\n\n**第二个部分的变量列表是由一个列表组成的，这个列表内可以是任意多个符号或任意多个由两个元素组成且第一个元素必定是符号的列表。***\n\n**第三个部分是`let`表达式主体，由任意多个列表组成。**\n\n`let`表达式的模板看起来像:\n\n``` emacs-lisp\n(let varlist body...)\n```\n\n其中变量列表的符号是由`let`特殊表赋初始化值的变量.符号本身的初始值是nil.而作为两元素列表的首元素的每一个符号被绑定到对第二个元素求值后的返回值.\n\n所以一个简单的变量列表看起来可能是这样的:`(apple (pear 10))`.在这个例子中,`apple`的值是nil,因为我们没有为其赋予初始值.而`pear`的值为10.\n\n那么当变量是由两个元素的列表组成,就可以是下面这样的模板:\n\n``` emacs-lisp\n(let ((variable value) (variable value) variable...)\n  (body1)\n  (body2)...)\n```\n\n\n\n\n\n\n\n\n\n\n\n### let表达式例子 ###\n\n现在需要创建一些关于水果的栗子,不同的水果有不同的数量.\n\n``` emacs-lisp\n(let (apple (pear 10) (banana '4斤) watermelon)\n  (message \"苹果数量:%S\\t梨子数量:%d\\t香蕉数量:%s\\t西瓜数量:%S\" apple pear banana watermelon)) ;; => \"苹果数量:nil\t梨子数量:10\t香蕉数量:4斤\t西瓜数量:nil\"\n```\n\n我们创建了两个初始值为nil的变量`apple`和`watermelon`,以及一个绑定到10的变量pear,还有一个绑定到`4斤`的变量banana.随后在`let`主体中将创建的变量都用`message`函数打印在回显区.\n\n### let语句中的未初始化变量 ###\n\n在`let`表达式的变量列表中,允许不给予变量初始化值,那么Lisp解释器将会为其默认绑定到nil值上.\n\n并且,如果没有给予初始值,那么它可以称作:`作为独立的原子出现`.\n\n\n\n\n## if特殊表 ##\n\n`if`函数是除了`defun`/`let`特殊表之外的一个特殊表,它用于让计算机做一些判断的工作.\n\n首先来看`if`函数的模板:\n\n``` emacs-lisp\n(if if-part\n    then)\n```\n其工作方式是：首先测试`if-part`的返回值是否不为nil，如果不为nil，那么就执行`then`的表达式。\n\n**通常会把then部分放在if-part的下一行，这样更有利于阅读。**\n\n下面做一个简单的栗子:\n\n``` emacs-lisp\n(if (> 5 4)\n    (message \"5 比 4 大!\")) ;; => \"5 比 4 大!\"\n```\n其中`>`函数测试它的第一个参量和第二个参量进行比较大小，如果第一个参量大于第二个参量则返回“真”，否则返回nil。\n\n可往往在日常编码中，`if-part`的值不能直接确定，它可能是一个表达式，又可能是一个函数调用。\n\n例如测试参量可能被绑定在函数定义的参量上:\n\n``` emacs-lisp\n(defun type-of-animal (animal-name)\n  \"根据animal-name打印信息到回显区\n如果animal-name是符号'fierce则返回'tiger\"\n  (if (equal animal-name 'fierce)\n      (message \"It's a tiger\")))\n(type-of-animal 'fierce) ;; => \"It’s a tiger\"\n```\n\n**type-of-animal函数详解**\n\n首先`type-of-animal`是包含了两个特殊表模板，分别是`defun`和`if`。`type-of-animal`是函数名，紧跟着函数名的是函数参量列表，然后跟着的是函数的文档。最后函数的主体内是一个if函数，if函数的的一个参量是一个列表，这个列表的首元素的符号是一个函数`equal`，在Lisp中，`equal`函数用于比较参量一和参量二是否相等，如果相等则输出`if`函数的第二个参量，也是一个列表，这个列表的首元素是符号且是函数`message`，将`It's a tiger`打印至回显区。\n\n## if-then-else表达式 ##\n\n\n其实`if-then-else`表达式就是在`if`特殊表之上加了一个参量，其他没什么不同，新增的参量是当参量一的值为nil时，对参量三求值。\n\n它的函数模板可以写成这样:\n\n``` emacs-lisp\n(if true-or-false-test\n    action-to-carry-out-if-the-test-returns-true\n  action-to-carry-out-if-the-test-returns-false)\n```\n\n例如:\n\n``` emacs-lisp\n(if (> 4 5)\n  (message \"5 大于 4!\")\n(message \"4 小于 5\")) ;; => \"4 小于 5\"\n```\n\n通过这个例子，我们发现当`if`函数的第一参量值为nil时就会对第三参量求值。并且第三参量的缩进也要少于第二参量。\n\n那我们现在将`type-of-animal`函数改造成:\n\n```emacs-lisp\n(defun type-of-animal (animal-name) ;second version\n  \"根据animal-name打印信息到回显区\n如果animal-name是符号'fierce则输出'It's tiger!否则输出Tt not fierce\"\n  (if (equal animal-name 'fierce)\n      (message \"It's tiger\")\n    (message \"It not fierce\")))\n(type-of-animal 'fierce) ;; =>\"It’s tiger\"\n(type-of-animal 'notfierce)  ;; => \"It not fierce\"\n```\n\n## Lisp中的真与假 ##\n\n\n\n\nLisp中所有除了nil的都是真，nil也就是我们常说的假，nil有多种意思，一种就是nil代表假，另一种则是代表空列表，但往往都把空列表写成`()`，而当Lisp解释器对表达式求值时，只要值不是nil或空列表那么都是真，不管得到的值为一个数字或字符串或列表，它都代表真。\n\n``` emacs-lisp\n(if nil\n    'true\n  'false) ;; => false\n(if t\n    'true\n  'false) ;; => true\n```\n\n真也有另外一种表示方式，在表达式求值后没什么可返回时就会返回`t`，例如:\n\n``` emacs-lisp\n(> 5 4) ;; => t\n```\n\n## save-excursion函数 ##\n\n各位还记得什么是位点(point)，什么是标记(mark)吗?\n\nEmacs是一个文本编辑器，主要还是与文本打交道，那么`save-excursion函数`就是与文本打交道的一个经典函数。\n\n先让我们来回顾一下位点与标记:\n\n* 位点(point)：及当前buffer中光标所在字符位置，例如当光标置于buffer的开头，那么point应该是1，若置于buffer的末尾，那么point就是当前buffer的字符数了。\n\n* 标记(mark)：标记是buffer的另外一个位置，其中一个就是位点。在buffer中可以自定义很多标记，这样可以方便我们跳转至某个位点。设置标记的函数是`(set-mark-command)`，它绑定了一个键序列`C-SPC`，如果此时想要快速跳转至某个标记点，就可以使用命令`(exehange-point-and-mark`快速回到标记处，它绑定了一个键序列`C-x C-x`，并且还会将当初的位点设置一个标记，方便来回跳转。\n\n**位点与标记之间的缓冲区叫做现域(region)**，有很多条命令是专用于操作现域的，例如:`center-region|count-lines-region|kill-region|print-region`\n\n前面将了很多关于位点与标记的知识，下面正式介绍`save-excursion`函数，这个函数的作用主要是将位点和标记的当前位置保存，然后当其他会影响位点或标记的函数执行完后，再将标记的位点复原。 \n\n`save-excursion`函数模板:\n\n``` emacs-lisp\n(save-excursion\n  body...)\n```\n**注意，`save-excursion`函数的函数体允许有多条表达式，但是只返回最后一条表达式的值。**\n\n\n\n\n\n## 回顾 ##\n\n这一章学的东西还是挺多的，下面我就把书中的所有文字一字不差的抄下来。\n\n先说几个提到但是没有过多解释的函数:\n\n* eval-last-sexp\n对光标所处的位点前的最后一个符号表达式求值。如果这个函数激活时没有参量，那么将返回值输出在回显区，否则将打印在当前缓冲区中。\n\n* defun\n定义函数。这个特殊表最多可有五个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。\n\n* interactiv\n向解释器声明这个函数可以被交互的使用，并且这个特殊表还可以用一个字符串，分成单个或多个部分，依次传送信息至这个函数的参量。 \n\n* let\n声明在`let`表达式主体中使用的变量列表并且给它们赋初始值，初始值要么是nil，要么是一个指定的值，然后对`let`表达式主体的其他表达式求值并返回最后一个表达式的值。\n\n* save-excursion\n对这个函数主体求值前，记录位点和标记的值以及当前缓冲区。求值后恢复位点和标记。\n\n* if\n对函数的第一个参量求值，如果值为真，则对第二个参量求值，否则对第三个参量求值。\n\n* equal、eq\n测试两个对象的结构或内容是否相等用equal，测试两个对象是否完全相当用eq\n\n* < > <= >=\n用于判断第一个参量的值是否大于/小于/大于或等于/小于或等于第二个参量的值，如果是则返回真，否则返回nil\n\n* message\n用于往回显区内打印消息\n\n* setq set\nsetq 用于将第一个参量的值绑定到第二个参量的值，而第一个参量的值由`setq`自动加上引用。\nset 用于将第一个参量的值绑定到第二个参量的值，但是不会自动为第一个参量加上引用。\n\n* buffer-name\n这个函数用于获取一个缓冲区的名字\n\n* buffer-file-name\n这个函数用于获取缓冲区所对饮的名字\n\n* current-buffer\n这个函数用于获取当前缓冲区的buffer对象\n\n* other-buffer\n返回最近选择过的缓冲区\n\n* switch-to-buffer\n选择一个缓冲区\n\n* set-buffer\n设置当前缓冲区为某一个缓冲区\n\n* buffer-size\n返回当前缓冲区的字符数\n\n* point\n返回当前光标所对应缓冲区的位置\n\n* point-min\n返回当前缓冲区最小的字符数\n\n* point-max\n返回当前缓冲区最大的字符数\n\n\n\n\n\n## 练习 ##\n\n* 编写一个非交互的函数，这个函数将其第一个参量(是一个数)的值翻倍。然后使这个函数成为一个交互函数\n\n非交互:\n\n``` emacs-lisp\n(defun double(number)\n  \"使number翻倍\"\n  (setq number (* number 2)))\n\n(double 10) ;; => 20\n```\n\n交互式:\n\n``` emacs-lisp\n(defun double(number)\n  \"使number翻倍\"\n  (interactive \"n请输入要翻倍的数字: \")\n  (setq number (* number 2))\n  (message \"翻倍后:%d\" number))\n```\n\n* 编写一个函数，测试`fill-column`的当前值是否大于传送给函数参量的值，如果是则打印适当的信息\n\n``` emacs-lisp\n(defun is-bigger-to-fill-column (number)\n  \"判断number是否比fill-column大\"\n  (if (> number fill-column)\n      (message \"%d比fill-column要大\" number)\n    (message \"%d比fill-column要小\" number)))\n\n(is-bigger-to-fill-column 79) ;; => \"79比fill-column要小\"\n(is-bigger-to-fill-column 81) ;; => \"81比fill-column要大\"\n```\n\n\n# 第四章 与缓冲区有关的函数 #\n\n本章将会介绍大量的函数定义。\n\n## 查找更多的信息 ##\n\n可以使用`C-h f`查看一个函数所对应的文档，使用`C-h v`查看一个变量所对应的文档，如果要在源代码文件中查看函数定义，可以使用函数`find-tags`，跳到相应的位置。\n\nLisp代码可以分为多个模块或包，如果想要查看某个模块的帮助，可以键入`C-h p`。\n\n## 简化的beginning-of-buffer函数定义 ##\n\n对于`beginning-of-buffer`函数你们可能已经使用过了，其绑定的键序列是`M-<`。其作用是将当前光标移动至buffer的起始处。\n\n下面我们将自己实现一个简单的`beginning-of-buffer`函数。\n\n让我们来看看我们需要做什么事:\n\n1. 首先这个函数得是个交互式函数，以便我们能通过键序列调用或用`M-x`调用。\n2. 其次我们需要记录个位点为标记\n3. 最后我们再跳转到buffer起始处\n\n相比与真正的`beginning-of-buffer`函数定义，没有考虑一些复杂的选项，但是我们先完成这个简化版本吧!\n\n``` emacs-lisp\n(defun simple-beginning-of-buffer ()\n  \"移动光标至buffer开始处\"\n  (interactive)\n  (push-mark)\n  (goto-char (point-min)))\n```\n\n这个`defun`函数包含了5个部分:\n\n1. 首先是这个函数的函数名————`simple-beginning-of-buffer`\n2. 再就是函数的文档\n3. 随后是交互式表达式\n4. 然后记录位点为标记\n5. 最后跳转至buffer的起始处 \n\n由于这个函数是无参量的，所以交互式表达式内也不用写任何字符串，而`push-mark`函数默认将`point`加入到标记中，最后通过`goto-char`跳转至`point-min`的位置。如果想要回到原来的位置可以使用`C-x C-x`。\n\n既然已经写了一个`simple-beginning-of-buffer`那我们也可以写一个`simple-end-of-buffer`吧!\n\n``` emacs-lisp\n(defun simple-end-of-buffer()\n  \"移动光标至buffer结束处\"\n  (interactive)\n  (push-mark)\n  (goto-char (point-max)))\n```\n\n最后则是，如果遇到不了解的函数，可以将光标放置函数之上，键入键序列`C-h f RET`即可。 \n\n## mark-whole-buffer函数定义 ##\n\n`mark-whole-buffer` 不比`simple-end-of-buffer`复杂多少。\n\n这次我们来看一个函数的完整定义\n\n这是书中的定义:\n\n``` emacs-lisp\n(defun mark-whole-buffer ()\n  \"Put point at beginning and mark at end of buffer.\"\n  (interactive)\n  (push-mark (point))\n  (push-mark (point-max))\n  (goto-char (point-min)))\n```\n\n书中讲不知道为啥函数体内的第一条表达式`push-mark`内还需要写`(point)`，但我现在再去看，这个函数已经改变了，并且也改掉了这个冗余的代码。\n\n``` emacs-lisp\n(defun mark-whole-buffer ()\n  \"Put point at beginning and mark at end of buffer.\nIf narrowing is in effect, only uses the accessible part of the buffer.\nYou probably should not use this function in Lisp programs;\nit is usually a mistake for a Lisp function to use any subroutine\nthat uses or sets the mark.\"\n  (declare (interactive-only t))\n  (interactive)\n  (push-mark)\n  (push-mark (point-max) nil t)\n  ;; This is really `point-min' in most cases, but if we're in the\n  ;; minibuffer, this is at the end of the prompt.\n  (goto-char (minibuffer-prompt-end)))\n```\n\n并且还改了一些代码，先不看`declare`，我们发现变化的有`(push-mark (point-max))`，最新的`mark-whole-buffer`函数中函数体第二个表达式多了两个参量，第二个参量代表如果值不为nil则显示`Mark set`。第三个参量代表如果在瞬时标记模式下，值不为nil则激活。\n\n并且最后一条表达式也修改过了，原本是`point-min`但改为`minibuffer-prompt-end`，其区别在于:\n\n`minibuffer-prompt-end会在返回buffer位置时输出信息至minibuffer`\n\n在是如果当前buffer不是minibuffer那么就返回`point-min`\n\n\n\n\n## append-to-buffer函数定义 ##\n\n由于我看的这本书年代久远(2001)，现在是2019年，整整过去18年，Emacs也已经发生了巨大的变化。\n\n所以我将先试着记录书中所讲的`append-to-buffer`函数再对Emacs 26.3版本的`append-to-buffer`函数进行讲解，希望对看到这篇博客的同仁们提供一些微薄的帮助。\n\n> 这个计划已经鸽了，我发现用我现在所学还是很难解释清楚26.3版本的append-to-buffer函数的工作方式。所以后面的26.版 append-to-buffer会在以后完成，十分抱歉。\n\n首先`append-to-buffer`函数的作用是将指定buffer区域(region)中的文本追加到当前Buffer的point前。\n\n### 旧版append-to-buffer ###\n\n先让我们看看书中的`append-to-buffer`函数定义:\n\n``` emacs-lisp\n(defun append-to-buffer (buffer start end)\n  \"Append to specified buffer the text of the region.\nIt is inserted into that buffer before its point.\nWhen alling from a program, give three arguments:\na buffer or the name of one, and two character numbers\nspecifying the portion of the current buffer to be copied.\"\n  (interactive \"BAppend to buffer: \\nr\")\n  (let ((oldbuf (current-buffer)))\n    (save-excursion\n      (set-buffer (get-buffer-create buffer))\n      (insert-buffer-substring oldbuf start end))))\n```\n\n通过阅读这个函数的文档就能很清晰的了解这个函数的工作方式。\n\n略过函数名和文档，我们直接来看`interactive`。`interative`中的`B`代表让用户选择一个Buffer(可能不存在)并将buffer名称传给函数参量一，其次是一些友好的文本`Append to buffer: `，紧跟其后的`\\n`用于控制换行，最后的`r`获取当前区域(point和mark)，并将其传给函数的参量二和参量三。 \n\n随后是一个`let`特殊表，在`let`的变量列表中，定义了一个`oldbuf`，其绑定的值是`(current-buffer)`的返回值，也就是当前Buffer对象。在`let`的表达式体中有一个`save-excursion`函数。\n\n`save-excursion`函数体中有两条表达式，第一条表达式`(set-buffer)`用于将当前缓冲区变换到另外一个缓冲区，而其参量又是一个函数`get-buffer-create`，这个函数的作用是获取指定BUFFER对象或名(称为BUFFER-OR-NAME)，如果这个BUFFER-OR-NAME不存在，将会自动创建。\n\n`save-excursion`函数体的第二条表达式是一个`(insert-buffer-substring)`函数这个函数将参量一从参量二到参量三的区域的字符串插入到当前Buffer的point之前。\n\n\n\n\n### 26.3版append-to-buffer ###\n\n由于本人水平有限，如有错误，欢迎提出issue.\n\n先让我们看函数定义原型:\n\n``` emacs-lisp\n(defun append-to-buffer (buffer start end)\n  \"Append to specified BUFFER the text of the region.\nThe text is inserted into that buffer before its point.\nBUFFER can be a buffer or the name of a buffer; this\nfunction will create BUFFER if it doesn't already exist.\n\nWhen calling from a program, give three arguments:\nBUFFER (or buffer name), START and END.\nSTART and END specify the portion of the current buffer to be copied.\"\n  (interactive\n   (list (read-buffer \"Append to buffer: \" (other-buffer (current-buffer) t))\n\t (region-beginning) (region-end)))\n  (let* ((oldbuf (current-buffer))\n         (append-to (get-buffer-create buffer))\n         (windows (get-buffer-window-list append-to t t))\n         point)\n    (save-excursion\n      (with-current-buffer append-to\n        (setq point (point))\n        (barf-if-buffer-read-only)\n        (insert-buffer-substring oldbuf start end)\n        (dolist (window windows)\n          (when (= (window-point window) point)\n            (set-window-point window (point))))))))\n```\n\n我们发现函数参量没有变化，并且注释也没有大的变化，只是函数体内发生了较大的变化。\n\n首先是`interactive`函数参量发生了变化，变成了一个`list`函数，回想一下，`list`函数是用于构造一个列表的函数，这个`list`函数的第一个参量是`(read-buffer)`函数。\n\n`read-buffer`函数可以通过buffer名称读取buffer中的字符串并返回。其第一个参量是用于提示用户的友好信息，并且特意指出这个提示信息必须是由冒号和空格结尾且被双引号包围的字符串。第二个参量用于也就是返回值，它的默认值为列表\n\n\n\n\n## 回顾 ##\n\n惯例抄书\n\n* describe-function\\describe-variable\n打印一个函数或一个变量的文档。通常将其绑定到`C-h f`和`C-h v`\n\n* find-tag\n找到存放某个函数或变量的源代码的文件，并切换到这个缓冲区，将位点(光标)置于相应函数或这变量的开始处。习惯上将其绑定到`M--`。\n\n* save-excursion\n保存位点和标记的位置，并在对`save-excursion`参量求值之后恢复这些值。它也保存当前缓冲区并返回到该缓冲区。\n\n* push-mark\n在指定位置设置一个标记，并在标记环中记录原来标记的值。标记是缓冲区中的一个位置，即使由一些文本被从缓冲区删除或者增加到缓冲区，标记仍将保持它的相对位置。\n\n* goto-char\n将位点设置为由参量指定的位置。参量值可以是一个数，也可以是一个标记，甚至可以是一个返回一个位置数字的表达式(point-min)\n\n* insert-buffer-substring\n将来自一个缓冲区（这是被作为一个参量而传递给函数的）的文本域拷贝到当前缓冲区\n\n* mark-whole-buffer\n将整个缓冲区标记为一个域。一般将这个函数绑定到`C-x h`。\n\n* set-buffer\n将Emacs的注意力转移到另一个缓冲区，但是不该便显示的窗口。 \n\n* get-buffer-create\\get-buffer\n寻找一个已指定名字的缓冲区，或当指定名字的缓冲区不存在时就创建它。如果指定名称的缓冲区不存在，get-buffer函数就返回nil。\n\n## 练习  ##\n\n* 编写自己的`simplified-end-of-buffer`函数定义，然后测试它是否能工作。\n\n``` emacs-lisp\n(defun simple-end-of-buffer()\n  \"移动光标至buffer结束处\"\n  (interactive)\n  (push-mark)\n  (goto-char (point-max)))\n```\n\n* 用if和get-buffer编写一个函数，这个函数要打印一个说明某个缓冲区是否存在的消息 \n\n``` emacs-lisp\n(defun is-exist-buffer (buffer-or-name)\n  \"判断buffer-or-name是否为一个已存在的buffer\"\n  (if (bufferp (get-buffer buffer-or-name))\n      (message \"%s存在!\" buffer-or-name)\n    (message \"此缓冲区不存在!\")))\n    \n(is-exist-buffer \"test.el\") ;; => \"test.el存在!\"\n```\n\n* 用find-tag找到copy-to-buffer函数的源代码\n\n不会...\n\n# 第五章 更复杂的函数\n\n本章我们将在已学内容的基础之上学习更复杂的函数，例如有使用两次`save-excursion`的\n`copy-to-buffer`函数，以及一个在`interactive`中使用`*`和`or`函数的函数。\n\n## copy-to-buffer函数的定义\n\n`copy-to-buffer`函数与前面学过的`append-to-buffer`的定义很类似。\n\n`copy-to-buffer`是替换指定`BUFFER`的内容，而`append-to-buffer`是在指定`BUFFER`中追加内容。\n\n首先来看看`copy-to-buffer`的函数定义:\n\n``` emacs-lisp\n(defun copy-to-buffer-t (BUFFER START END)\n  \"docutments...\"\n  (interactive \"BCopy to buffer: \\nr\")\n  (let ((oldbuf (get-buffer-create BUFFER)))\n    (save-excursion\n      (set-buffer BUFFER)\n      (save-excursion\n        (insert-buffer-substring oldbuf START END)))))\n```\n\n略过函数名与文档不看，可以看到这个函数被定义为交互式函数，并且这个函数的参量要求\n是一个BUFFER对象，以及两个表示位置的数字。这三个参量都由`interactive`所解决，其\n使得让用户选择一个BUFFER，然后获取当前`Buffer`的`point`和`mark`，作为`START`和\n`END`。\n\n随后是一个`let`表达式，其在它的`varlist`部分将`BUFFER`参量通过\n`get-buffer-create`函数获取了其对象(就算`BUFFER`参量的值不存在也会创建一个)，并\n且将这个BUFFER对象赋值给`oldbuf`。在`let`表达式的`BODY`部分，出现了一个\n`save-excursion`函数，这个函数用于记录当前`point`和`mark`的位置，然后在其参量求\n值完毕后恢复记录的位置，这个参量也就是`set-buffer`，这个函数用于改变当前BUFFER为\n  参量`BUFFER`。随后又是一个`save-excursion`函数，其参量\n  `insert-buffer-substring`函数我们也了解过，其用于将当前BUFFER的START到END之间\n  的区间插入到`oldbuf`内。\n\n## insert-buffer函数的定义\n\n前面我们用过`append-to-buffer`以及`copy-to-buffer`，他们都是将当前`BUFFER`的内容\n拷贝或追加到某一个`BUFFER`中，而`insert-buffer`可以将当前`BUFFER`的内容，拷贝至\n一个已存在的`BUFFER`当中。\n\n先来看看其函数定义:\n\n``` emacs-lisp\n(defun insert-buffer-t (buffer)\n  \"docutmens..\"\n  (interactive \"*bInsert buffer: \")\n  (or (bufferp buffer)\n      (setq buffer (get-buffer buffer)))\n  (let (start end newmark)\n    (save-excursion\n      (save-excursion\n        (set-buffer buffer)\n        (setq start (point-min) end (point-max)))\n      (insert-buffer-substring buffer start end)\n      (setq newmark (point)))\n    (push-mark newmark)))\n```\n\n先简单整理一下这个函数都包含了什么东西:\n\n- 一个参量\n- 函数文档\n- 定义交互式函数\n- `interactive`参量说明有\\*和 `b`\n- 以及一个`or`函数，这个函数内有两个参量\n- 第一个参量是`bufferp`函数\n- 第二个参量是`setq`函数，`setq`的第二个参量是`get-buffer`函数。\n- 随后是一个`let`表达式\n- `let`表达式中先是初始化了三个空变量\n- 一个外层`save-excursion`函数\n- 一个内层`save-excursion`函数\n- 其第一个参量是一个`set-buffer`函数\n- 第二个参量是`setq`函数\n- 外层`save-excursion`的第二个参量是一个`insert-buffer-substring`函数\n- 第三个参量是一个`setq`函数。\n- 最后是一个`push-mark`函数。 \n\n### insert-buffer函数中的交互表达式\n\n让我们先从`interactive`表达式说起，首先起表达式说明分为三个部分：\n\n1. `*`代表只读缓冲区，这个说明会在当`b`说明返回的buffer是一个只读缓冲区时在回显\n   区提示错误。也就是说当这个`insert-buffer`函数当在一个只读缓冲区被调用时，将不\n   被允许。\n2. `b`代表要求是一个存在的缓冲区或者是缓冲区名，它与`B`说明不同。\n\n3. `Insert buffer: `是友好的提示。\n\n**提示:\\*控制符无需后接一个换行符来分割不同的参量。**\n\n### insert-buffer函数体\n\n主要有两个部分，分别是`or`函数和`let`函数。\n\n先让我们来看看`or`函数，其第一个参量是一个`bufferp`函数，这个函数用于当其参量是\n是一个已存在的buffer或buffer的名称才会返回`non-nil`的值，也就是真/非假，其第二个\n参量是一个`setq`函数，里面有一个`get-buffer`函数，这个函数是用于获取一个已存在的\nbuffer对象根据buffer对象或buffer的名称，并将buffer绑定到`get-buffer`的值之上。\n\n其实这个函数的意思是，要让`buffer`参量确定是一个已存在的buffer，我们可以用`if`函\n数重写一遍。\n\n### 用if表达式编写insert-buffer函数\n\n我们的需求是，必须确保`buffer`的值是一个已存在的buffer或buffer的名称。\n\n``` emacs-lisp\n(if (not (bufferp buffer)\n         (setq buffer (get-buffer buffer))))\n```\n\n就可以这样写，当`bufferp`函数的值为nil时，那么就会尝试获取`buffer`的对象并且保存，\n否则则报错。\n\n\n### insert-buffer函数中的let表达式\n\n在我们确保`buffer`参量是一个非只读缓冲区后，可以开始写拷贝内容的代码了。\n\n首先我们初始化三个空变量: start end newmark\n\n  `let`表达式体中有一个外层`save-excursion`函数，其记录了我们的`point`和`mark`，\n其第一个参量又是一个`save-excursion`函数，我们称为内层`save-excursion`。内层\n`save-excursion`主要做了两件事，首先是将Emacs的注意力转移到`buffer`之上，随后为\n`start`以及`end`附上`buffer`的`point-min`和`point-max`的值，并且由于内层\n`save-excursion`已经求值完毕，那么会恢复在求值过程中可能变动的位点和标记的值。随\n后外层`save-excursion`函数的第二个参量是将`buffer`参量的内容插入到当前buffer从\n`start`到`end`结束的内容，这个`start`和`end`也就是`buffer`参量所有的内容。随后又\n把`newmark`变量绑定到值`point`之上，最后将`newmark`记录为`标记`。\n\n## beginning-of-buffer函数的完整定义\n\n前面我们尝试写了`beginning-of-buffer`函数的部分定义，它是一个无参量的函数，那么\n这次我们来写一个有参量的`beginning-of-buffer`函数。\n\n这个带参量的`beginning-of-buffer`函数可以指定在当前缓冲区的几分之几标记位置。\n\n那么现来说下需求:`beginning-of-buffer`函数接受一个可选参量，这个参量的返回是1-10\n之间，这个参量作为标记点的位置。\n\n### 可选参量\n\n在需求里我们提到: \n\n> `beginning-of-buffer`函数接受一个可选参量\n\n除非特别声明，否则Lisp会认为函数的参量是必须在函数被调用时传递一个值给该参量的。\n如果不传入参量，则该函数就会出错:`Wrong number of arguments`。\n\n而如果需要使一个或多个参量变为可选参数只需要在参量前加上`&optional`关键字，例如:\n\n``` emacs-lisp\n(defun beginning-of-defun-function-t (&optional arg1 arg2)\n  \"documentation\"\n  (interactive \"P\")\n  (push-mark)\n  (goto-char\n   ;; if-there-is-an-argument\n   ;;   xxxx\n   ;; else-go-to\n   (point-min)))\n```\n\n对比前面的`simple-beginning-to-buffer`函数，好像唯一多的地方是在`goto-char`函数\n的第一个参量，变成了`if`特殊表。这个`if`函数判断由`interactive`的`P`参量获得到的前\n缀参量是否为一个非nil值，如果是则执行`if then`部分，否则执行跟\n`simple-beginning-to-buffer`一样的操作。\n\n### 带参量的beginning-of-buffer函数 \n\n`goto-char`函数中有一个`if`表达式，这个表达式做了很多关于算术的操作。 \n\n ``` emacs-lisp\n(defun beginning-of-defun-function-t (&optional arg)\n  \"documentation\"\n  (interactive \"P\")\n  (push-mark)\n  (goto-char\n   (if (> (buffer-size) 10000)\n       (/ (prefix-numeric-value arg) 10)\n     (/\n      (+ 10\n         (*\n          (buffer-size) (prefix-numeric-value arg))) 10))\n   (point-min)))\n ```\n \n 一眼看上去有些复杂，其实我们通过函数模板来揭开其中的奥秘，十分简单。\n \n我们看将`if`函数的结构看成这样:\n\n``` emacs-lisp\n(if (buffer-is-large\n     divide-buffer-size-by-10-and-multiply-by-arg)\n    else-use-alternate-calculation)\n```\n\n要吃饭了\n\n这里的`if`函数用于检查缓冲区的大小，这是因为书中使用的是第18版本的Elisp，其使用\n了不大于800w的数字来描述缓冲区的大小，如果有在某次求值中遇到更大的缓冲区，Emacs\n\n\n\n\n","slug":"《GNU-Emacs-Lisp编程入门》读书笔记","published":1,"updated":"2020-01-21T00:13:55.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod6005komoo9v320mts","content":"<p>借了本Elisp的书，不厚，200多页，大概一周(两周)就能看完吧!</p>\n<a id=\"more\"></a>\n<h1 id=\"第一章-列表处理\"><a href=\"#第一章-列表处理\" class=\"headerlink\" title=\"第一章 列表处理\"></a>第一章 列表处理</h1><p>列表是Lisp的基础。</p>\n<h2 id=\"Lisp列表\"><a href=\"#Lisp列表\" class=\"headerlink\" title=\"Lisp列表\"></a>Lisp列表</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>简单的Lisp列表书写形式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(rose violet daisy buttercup) ;; =&gt; (rose violet daisy buttercup)</span><br></pre></td></tr></table></figure>\n<p>这个简单的列表中的四个元素时四种不同花的名称。<strong>元素之间用空格隔开，并且被括号包住。</strong></p>\n<p>另有一种在elisp中常用到的写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 2) ;; =&gt; 4</span><br></pre></td></tr></table></figure>\n<p>这种写法是Lisp的一个特性————<strong>数据和代码都用相同的方式表示</strong>。</p>\n<p><strong>列表还允许嵌套列表，也就是说列表的元素也可以是列表</strong>。</p>\n<h3 id=\"Lisp原子\"><a href=\"#Lisp原子\" class=\"headerlink\" title=\"Lisp原子\"></a>Lisp原子</h3><p>原子意味着”不可再分”。例如刚刚列表内的’2’或者是’rose’等等，这些都是原子。</p>\n<p>而列表却不是原子，因为<strong>列表是由CAR和CDR与CONS构成的</strong>。</p>\n<p>技术上说，Lisp的列表有三种组合方式:</p>\n<ul>\n<li>括号和括号中由空格分隔的原子</li>\n<li>括号和括号中的其他列表</li>\n<li>括号和括号中的其他列表和原子</li>\n</ul>\n<p><strong>一个列表可以仅有一个原子或完全没有原子</strong></p>\n<p>无任何原子的列表称作空列表: <code>()</code>。你可以把空列表看为原子或列表。</p>\n<p><em>原子和列表可以被称为<strong>符号表达式</strong>(symbolic expression)，又可称为<strong>S-表达式</strong> </em>。</p>\n<p>Lisp编程几乎都是关于列表中的符号的(且有时是关于数字的).</p>\n<p><strong>双引号中的文本，都是单个原子</strong>:<code>&#39;(Info &quot;Name:EvanMeek Age:18 Sex:Men**)</code></p>\n<p>这种被双引号括起来的文本叫做<strong>字符串(string)</strong>。</p>\n<h3 id=\"列表中的空格\"><a href=\"#列表中的空格\" class=\"headerlink\" title=\"列表中的空格\"></a>列表中的空格</h3><p>Lisp中括号的数量无关紧要。下面两个的列表是完全相同的。</p>\n<p>括号多<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(1 2 3 4      5       6) ;; =&gt; (1 2 3 4 5 6)</span><br></pre></td></tr></table></figure></p>\n<p>括号少<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(1 2 3 4 5 6) ;; =&gt; (1 2 3 4 5 6)</span><br></pre></td></tr></table></figure></p>\n<p>适当的在列表中加入一些空格以及换行符可以提高可读性。</p>\n<h3 id=\"GNU-Emacs帮助你输入列表\"><a href=\"#GNU-Emacs帮助你输入列表\" class=\"headerlink\" title=\"GNU Emacs帮助你输入列表\"></a>GNU Emacs帮助你输入列表</h3><p>在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用<code>Tab</code>按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是<code>C-M-\\</code></p>\n<p>并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。</p>\n<p>有兴趣的可以看下这个知乎提问。<a href=\"https://www.zhihu.com/question/356026550\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/356026550</a></p>\n<h2 id=\"运行一个程序\"><a href=\"#运行一个程序\" class=\"headerlink\" title=\"运行一个程序\"></a>运行一个程序</h2><p>如果你想运行一段Lisp程序，那么计算机可能会做三种事:</p>\n<ul>\n<li>只返回列表本身;</li>\n<li>提示出错信息;</li>\n<li>将列表中第一个符号作为要执行的命令;<br>大多数情况，我们希望计算机做的是第三件事</li>\n</ul>\n<p>前面我们看到过一些列表的前面有一个单引号”‘“，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(只是返回本身 即可) ;; =&gt; (只是返回本身 即可)</span><br></pre></td></tr></table></figure>\n<p>而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 1 2 3 4) ;; =&gt; 10</span><br></pre></td></tr></table></figure>\n<p>Emacs中可以将光标放置一对S-表达式后按 <code>C-x C-e</code>就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 <code>mini buffer</code>。</p>\n<p>也可以对原子(没有被括号括起来)求值</p>\n<h2 id=\"产生错误消息\"><a href=\"#产生错误消息\" class=\"headerlink\" title=\"产生错误消息\"></a>产生错误消息</h2><p>编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。</p>\n<p>下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Just Error!) ;; =&gt; Symbol&apos;s function definition is void: Just</span><br></pre></td></tr></table></figure>\n<p>这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将<code>(Just Error!)</code>当成类似<code>(+ 1 2)</code>这种列表进行求值，但由于后者的第一个元素”+”是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素”Just”是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。</p>\n<p> ##</p>\n<p>我们已经讨论过一些符号或函数，例如”+”。就以”+”为例子，当我们对<code>(+ 2 2)</code>表达式求值时，计算机并不是执行的”+”这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把”+”改为”Plus”。</p>\n<h2 id=\"Lisp解释器\"><a href=\"#Lisp解释器\" class=\"headerlink\" title=\"Lisp解释器\"></a>Lisp解释器</h2><p>下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。</p>\n<ul>\n<li>首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。</li>\n<li>若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。</li>\n<li><p>若没有则提示错误消息。<br>以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。</p>\n</li>\n<li><p>第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。</p>\n</li>\n<li>第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。</li>\n<li>第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。</li>\n</ul>\n<p>否则Lisp解释器将会从左往右依次执行。</p>\n<h3 id=\"字节编译\"><a href=\"#字节编译\" class=\"headerlink\" title=\"字节编译\"></a>字节编译</h3><p>Lisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。</p>\n<p>被编译成字节码后的源码叫做elc，可以通过命令<code>(byte-compile-file)</code>进行编译。</p>\n<h2 id=\"求值\"><a href=\"#求值\" class=\"headerlink\" title=\"求值\"></a>求值</h2><p>前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。</p>\n<p>解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。</p>\n<p>解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。</p>\n<h3 id=\"对一个内部列表求值\"><a href=\"#对一个内部列表求值\" class=\"headerlink\" title=\"对一个内部列表求值\"></a>对一个内部列表求值</h3><p>上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。</p>\n<p>下面通过一个例子了解这个求值的过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 1 (+ 2 3))</span><br></pre></td></tr></table></figure>\n<p>我们知道使用快捷键<code>C-x C-e</code>可以对一个表达式求值，那么我们将光标放置<code>(+ 2 3)</code>表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值<code>5</code>，那么再将光标放置整个表达式之后，按下快捷键得到返回值<code>6</code>。这就很好的解释了Lisp解释器对嵌套列表的求值过程。</p>\n<p>我们可以通过快捷键<code>C-h k</code>然后键入<code>C-x C-e</code>查看这个快捷键所对应的符号(命令\\函数)，也就是<code>eval-last-sexp</code>。 这个函数的作用是<strong>对最近的一个表达式进行求值，并且将结果打印至输出区域</strong>。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)?</p>\n<p><strong>在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)</strong>，并且符号的值是可变的，我们把一个有值的符号称为变量。</p>\n<p>前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。<strong>Lisp的符号可以同时具有一个函数定义和一个值。</strong>我们可以把这种概念想象成具有多个抽屉的柜子。</p>\n<p>例如变量<code>fill-column</code>是一个有值的符号，对它求值可以获取自动换行的字符数。</p>\n<p>任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。</p>\n<p><code>fill-column</code>只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(fill-column) ;; =&gt; Symbol&apos;s function definition is void: fill-column</span><br></pre></td></tr></table></figure>\n<p>这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。</p>\n<h3 id=\"符号无值时的错误信息\"><a href=\"#符号无值时的错误信息\" class=\"headerlink\" title=\"符号无值时的错误信息\"></a>符号无值时的错误信息</h3><p>下面我对一个没有赋值的符号进行求值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 2) ;; =&gt; 4</span><br></pre></td></tr></table></figure></p>\n<p>很显然，如果是在这个表达式右括号后执行<code>eval-last-sexp</code>将不会有任何问题，但我们现在将光标移动至<code>+</code>后，执行<code>eval-last-sexp</code>，会引发这个报错提示:<code>Symbol&#39;s value as variable void: +</code>。</p>\n<p>这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于<code>+</code>的变量，只找到了函数定义，因为就报错了。</p>\n<h2 id=\"参量\"><a href=\"#参量\" class=\"headerlink\" title=\"参量\"></a>参量</h2><p>参量对应着<code>argument</code>，也就是其他语言中参数的意思。例如<code>(+ 2 3**</code>这个列表的参数就是<code>2</code>和<code>3</code>，而这个<code>+</code>则是函数，<code>+</code>允许由多个参量。</p>\n<p><strong>不同的函数需要不同数目的参量，有些函数甚至不需要参量。</strong></p>\n<h3 id=\"参量的数据类型\"><a href=\"#参量的数据类型\" class=\"headerlink\" title=\"参量的数据类型\"></a>参量的数据类型</h3><p>函数所接收的参量也是有数据类型的限制的，例如<code>+</code>函数就规定其参量的值必须是数字。</p>\n<p>有些函数允许有任意数量个参量，例如<code>concat</code>函数，它将任意多个字符串类型的参量合并为一个字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(concat &quot;My name is:&quot; &quot;EvanMeek&quot;) ;; =&gt; &quot;My name is: EvanMeek&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>请注意，<code>concat</code>函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。</strong></p>\n<p>例如我们可以在<code>concat</code>的参量中写上<code>substring</code>函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(concat &quot;Nice to meet &quot; (substring &quot;fuck you&quot; 5 8))</span><br></pre></td></tr></table></figure>\n<p>上面的<code>concat</code>是一个参量必须都为字符串类型且任意数量的函数，而<code>substring</code>是一个可变数量参量且有多种参量类型的函数。<br><code>substring</code>是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称<code>原子分裂机</code>。</p>\n<h3 id=\"作为变量和列表的值的参量\"><a href=\"#作为变量和列表的值的参量\" class=\"headerlink\" title=\"作为变量和列表的值的参量\"></a>作为变量和列表的值的参量</h3><blockquote>\n<p>上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。</p>\n</blockquote>\n<p>这一节，我们将谈谈函数的参量还支持那些。</p>\n<p>函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; 结果可能不同，取决于你的Emacs配置。</span><br><span class=\"line\">(+ 2 fill-column) ;; =&gt; 82</span><br></pre></td></tr></table></figure>\n<p>并且参量还可以是一个列表，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 (+ 3 (+ 4))) ;; =&gt;  9</span><br></pre></td></tr></table></figure>\n<h3 id=\"数目可变的参量\"><a href=\"#数目可变的参量\" class=\"headerlink\" title=\"数目可变的参量\"></a>数目可变的参量</h3><p>前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的<code>+</code>函数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+) ;; =&gt; 0</span><br><span class=\"line\">(+ 2) ;; =&gt; 2</span><br></pre></td></tr></table></figure>\n<p>又或是<code>\\*</code>函数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*) ;; =&gt; 1</span><br><span class=\"line\">(* 2) ;; =&gt; 2</span><br></pre></td></tr></table></figure>\n<p>所以它们都具有一个特性————参量数量可变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(* 1 2 3) ;; =&gt; 66</span><br><span class=\"line\">(+ 1 2 3) ;; =&gt; 6</span><br></pre></td></tr></table></figure>\n<h3 id=\"用一个错误类型的数据对象作为参量\"><a href=\"#用一个错误类型的数据对象作为参量\" class=\"headerlink\" title=\"用一个错误类型的数据对象作为参量\"></a>用一个错误类型的数据对象作为参量</h3><p>试想下，如果我们对函数提供了错误类型的参量会发生什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 &apos;hello) ;; =&gt; Wrong type argument: number-or-marker-p,hello</span><br></pre></td></tr></table></figure>\n<p>我们知道<code>+</code>函数的参量必须是数字，而我们传入的参量2的<code>&#39;hello</code>被Lisp解释器操作时会试图将<code>2</code>和<code>&#39;hello</code>的返回值相加，但是<code>&#39;hello</code>的返回值不是一个数字，所以就会引发这个错误。</p>\n<p>让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号<code>number-or-marker-p</code>这个符号意味着:Lisp解释器提示我们<code>+</code>函数的参量所需的数据类型，<code>number</code>也就是数字，而<code>marker</code>是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而<code>p</code>则是Lisp的一个历史问题(早期Lisp程序员中用”p”替代”predicate”用于表示是否为真)，类似的有<code>zerop</code>用于判断参量值是否为零。最后的<code>hello</code>则是我们传给<code>+</code>函数出错的参量的值。</p>\n<h3 id=\"message函数\"><a href=\"#message函数\" class=\"headerlink\" title=\"message函数\"></a>message函数</h3><p><code>message</code>函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个<code>FORMAT STRING</code>(可格式化字符串)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;Should you sleep now?&quot;) ;; =&gt; Should you sleep now?</span><br></pre></td></tr></table></figure>\n<p>双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;The name of this buffer is: %s&quot; (buffer-name)) ;; =&gt; &quot;The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<p>这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串<code>%s</code>，<code>message</code>函数的第二个参量的值将用于它，这个<code>%s</code>代表了接收一段字符传，类似的还有<code>%d</code>用于接收一个十进制数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;The value of fill-column is %d&quot; fill-column) ;; =&gt; &quot;The value of fill-column is 80&quot;</span><br></pre></td></tr></table></figure>\n<p>这些特殊子串都支持变量、列表或符号，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;我想吃%s，各来%d斤!&quot; (concat &quot;苹果、&quot; &quot;梨子、&quot; &quot;葡萄&quot;) (+ 1 1)) ;; =&gt; &quot;我想吃苹果、梨子、葡萄，各来2斤!&quot;</span><br></pre></td></tr></table></figure>\n<p>从第二个参量开始将会一次取代第一个参量中特殊子串的位置。</p>\n<h2 id=\"给一个变量赋值\"><a href=\"#给一个变量赋值\" class=\"headerlink\" title=\"给一个变量赋值\"></a>给一个变量赋值</h2><p>这一小节学习为一个变量赋值，常用的操作有<code>set</code>、<code>setq</code>、<code>let</code>，在这节主要将<code>set</code>和<code>setq</code>。并且描述这两个函数是如何工作的。</p>\n<h3 id=\"使用set函数\"><a href=\"#使用set函数\" class=\"headerlink\" title=\"使用set函数\"></a>使用set函数</h3><p>我们要为<code>flowers</code>符号附上一个列表值，那么可以这么写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(set &apos;flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰)</span><br></pre></td></tr></table></figure></p>\n<p>这意味着我们将列表<code>菊花 百合...</code>绑定给了<code>flowers</code>符号。</p>\n<p>两个参量的引用是为了让其不要求值，所以你可以知道<code>set</code>函数的第一个参量最好要加上引用，这大概是很常用的搭配。</p>\n<h3 id=\"使用setq函数\"><a href=\"#使用setq函数\" class=\"headerlink\" title=\"使用setq函数\"></a>使用setq函数</h3><p><code>setq</code>函数与<code>set</code>函数很相似，它们只有一个区别，就是<code>setq</code>函数会自动给第一个参量加上引用，例如用<code>setq</code>完成上一小节的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰)</span><br></pre></td></tr></table></figure>\n<p>并且它们俩都是可以为多个变量绑定多个值的，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq 学生 &apos;(学号 地址 姓名 电话)</span><br><span class=\"line\">      老师 &apos;(教师号 地址 姓名 电话))</span><br><span class=\"line\">学生 ;; =&gt; (学号 地址 姓名 电话)</span><br><span class=\"line\">老师 ;; =&gt; (教师号 地址 姓名 电话)</span><br></pre></td></tr></table></figure>\n<p>其中参量二绑定给参量一，参量四绑定给参量三，以此类推。</p>\n<h3 id=\"计数\"><a href=\"#计数\" class=\"headerlink\" title=\"计数\"></a>计数</h3><p>就是用<code>setq</code>函数完成了一个递增的操作。</p>\n<p>首先生成一个初始化器，再生成一个递增器，再进行输出数值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq count 0) ;; 初始器</span><br><span class=\"line\">(setq count (1+ count)) ;; 递增器</span><br><span class=\"line\">count ;;输出</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>记录一下，加油努力，毕竟书中都说了，我已经跨过了最陡峭的那段山路。</p>\n<ul>\n<li>Lisp程序由表达式组成，表达式是列表或单个原子。</li>\n<li>列表由0个或更多的原子或内部列表组成，原子或列表之间由空格隔开，并由括号括起来，列表可为空。</li>\n<li>原子是多字符的符号(如fill-column)，单字符的符号(如+号)，双引号之间的字符串或者数字。</li>\n<li>对数字求值就是其本身</li>\n<li>对双引号之间的字符串求值也是其本身</li>\n<li>当对一个符号求值时，将返回它的值。</li>\n<li>当对一个列表求值时，Lisp解释器查看列表首符号绑定在其上的函数定义，并执行其指令。</li>\n<li>单引号告诉Lisp解释器返回后续表达式的书写形式，而不是像没有单引号时那样对其求值。</li>\n<li>参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。</li>\n<li><p>当对一个函数求值时总是返回一个值(除非得到错误信息)。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。</p>\n<p><strong>最后，希望这篇博客可以记录好第一章所讲。</strong></p>\n</li>\n</ul>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>一个一个来，题目写在博客内吧…</p>\n<ul>\n<li>通过对一个不在括号内的适当符号求值，产生一个错误信息。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个不存在的变量 ;; =&gt; Symbol&apos;s value as variable is void: 一个不存在的变量</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过对一个在括号内的适当符号求值，产生一个错误信息。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(又一个不存在的符号) ;; =&gt; Symbol&apos;s function definition is void: 又一个不存在的符号</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个每次增加2而不是1的计数器。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq count 0) ;; 初始器 </span><br><span class=\"line\">(setq count (+ 2 count)) ;; 递增器</span><br><span class=\"line\">count ;;输出</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写一个表达式，当对它求值时，它在回显区输出一条消息。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;这段消息是要输出至%s%s的&quot; &apos;回显 &quot;区&quot;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二章-求值实践\"><a href=\"#第二章-求值实践\" class=\"headerlink\" title=\"第二章 求值实践\"></a>第二章 求值实践</h1><p>这一章主要讲了关于buffer的一些知识，讲了一些关于buffer的函数，并且讲解了一些buffer的注意事项。</p>\n<h2 id=\"缓冲区名\"><a href=\"#缓冲区名\" class=\"headerlink\" title=\"缓冲区名\"></a>缓冲区名</h2><p>讲了两个函数，分别是<code>(buffer-name)</code>以及<code>(buffer-file-name)</code>。</p>\n<p>首先得清楚buffer和文件的概念，buffer的中文翻译叫做缓冲区，它其实是将文件中的内容拷贝到Emacs中，所以在我们修改buffer时，文件并不会改动，只有当我们进行保存修改时才会。而文件是保存在磁盘上的信息，人们常常在修改buffer时说成”我在修改xx文件”，这严格意义上讲是错误的，但人们都知道其实我只是在修改buffer，而不是那个文件，只不过说成文件罢了，所以各位小伙伴不要误解。</p>\n<p>计算机没有人类那么聪明，所以大家在写代码时要分清楚这两个的不同。</p>\n<figure class=\"highlight plain\"><figcaption><span>(buffer-name) ;; </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-file-name) ;; =&gt;&quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>表达式<code>(buffer-name)</code>用于获取当前buffer的名称而<code>(buffer-file-name)</code>用于获取当前buffer所对应文件的完整路径</strong>，还要说明一点，并不是所有的buffer都有所对应的文件，例如<code>\\*scratch\\*</code>buffer就没有所对应的文件。</p>\n<h2 id=\"获得缓冲区\"><a href=\"#获得缓冲区\" class=\"headerlink\" title=\"获得缓冲区\"></a>获得缓冲区</h2><p>如果想获得缓冲区本身，那么可以使用<code>current-buffer</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br><span class=\"line\">(current-buffer) ;; =&gt; #&lt;buffer 《GNU-Emacs-Lisp编程入门》读书笔记.md&gt;</span><br></pre></td></tr></table></figure>\n<p>我们发现这两个函数的返回值挺相似的，但实际上他们却完全不同，<code>buffer-name</code>获取到的只是一个名称罢了，而<code>current-buffer</code>函数获取到的是一个名称所指向的对象或实体。举个生活上的例子:你对小明说:”小明，帮我拿个苹果”，然后小明就拿给了你”苹”和”果”字，显然这不是你真正想要的，你想要的是叫苹果的那个实体，可以吃的，有维生素的水果。经过这个例子，希望大家都能理解。 </p>\n<h2 id=\"切换缓冲区\"><a href=\"#切换缓冲区\" class=\"headerlink\" title=\"切换缓冲区\"></a>切换缓冲区</h2><p>先介绍一个函数————<code>other-buffer</code>，这个函数用于发挥最近常打开过的buffer对象。例如最近常在<code>\\*scratch\\*</code>与<code>test.el</code>之间切换buffer，那么当前buffer为<code>\\*scratch\\*</code>时调用<code>(other-buffer)</code>时将会返回<code>test.el</code>的buffer对象。</p>\n<p>再介绍一个函数————<code>switch-to-buffer</code>，这个函数接收一个<code>Buffer</code>对象的参量，可以切换当前buffer为<code>Buffer</code>参量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br><span class=\"line\">(other-buffer) ;; =&gt; #&lt;buffer *Backtrace*&gt;</span><br><span class=\"line\">;; 根据最近最常打开过的buffer对象切换buffer</span><br><span class=\"line\">(switch-to-buffer (other-buffer))</span><br><span class=\"line\">(buffer-name) ;; =&gt; &quot;*Backtrace*&quot;</span><br></pre></td></tr></table></figure>\n<p>如果想要回到上一个buffer可以键入键序列<code>C-x b RET</code>，RET是回车。</p>\n<p>前面几次提到<code>调用(call)</code>这个概念，实际上Lisp解释器对一个列表的首元素为一个函数进行处理时，就是在调用那个函数。</p>\n<h2 id=\"缓冲区大小和位点的定位\"><a href=\"#缓冲区大小和位点的定位\" class=\"headerlink\" title=\"缓冲区大小和位点的定位\"></a>缓冲区大小和位点的定位</h2><p>先为大家介绍下四个函数:</p>\n<ul>\n<li><code>(point)</code><br>;; 获取当前光标在当前buffer的位点。</li>\n<li><code>(buffer-size)</code><br>;; 获取当前buffer的字符数(包括空格)</li>\n<li><code>(point-min)</code><br>;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始</li>\n<li><code>(point-max)</code><br>;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; 获取当前buffer的字符数(包括空格)</span><br><span class=\"line\">(buffer-size) ;; =&gt; 10636</span><br><span class=\"line\">;; 获取当前光标在当前buffer的位点。</span><br><span class=\"line\">(point) ;; =&gt; 10525</span><br><span class=\"line\">;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始</span><br><span class=\"line\">(point-min) ;; =&gt; 1</span><br><span class=\"line\"></span><br><span class=\"line\">;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。</span><br><span class=\"line\">(point-max) ;; =&gt; 10670</span><br></pre></td></tr></table></figure>\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>找一个文件，对它进行操作，将光标移动到缓冲区的中间部分。找出它的缓冲区名、文件名、长度、和你在文件中的位置。</p>\n<ul>\n<li>缓冲区名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-file-name) ;; =&gt; &quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>长度</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-size) ;; =&gt; 11005</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在文件中的位置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(point) ;; =&gt; 11033</span><br></pre></td></tr></table></figure>\n<h1 id=\"第三章-如何编写函数定义\"><a href=\"#第三章-如何编写函数定义\" class=\"headerlink\" title=\"第三章 如何编写函数定义\"></a>第三章 如何编写函数定义</h1><p>本章内容较多，不止于函数定义，还介绍了一些常用的函数。</p>\n<h2 id=\"defun-特殊表\"><a href=\"#defun-特殊表\" class=\"headerlink\" title=\"defun 特殊表\"></a>defun 特殊表</h2><p><code>defun</code>不以通常的方式对它的参量求值，因为它是特殊表。</p>\n<p>这节将简单描述函数定义的过程。</p>\n<p>一个函数定义在<code>defun</code>之后最多可有5个部分:</p>\n<ul>\n<li>符号名，这个符号指向了这个函数的定义。</li>\n<li>一个列表，包含了要传给函数的参量。若没有任何参量要传递，那么可以写空列表。</li>\n<li>这个函数的文档，由双引号括住，此选项为可选。</li>\n<li>使当前函数成为一个交互式函数的列表，此选项为可选。交互式函数将会在后的小节讲到。</li>\n<li>函数的主题，也就是一系列的命令。<br>下面是一个包含了五个部分的函数模板:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun funciton-name (arguments...)</span><br><span class=\"line\">  &quot;optional-documentation&quot;</span><br><span class=\"line\">  (interactive argument-passing-info) ;; optional</span><br><span class=\"line\">  body...)</span><br></pre></td></tr></table></figure>\n<p>我们通过这个模板写一个简单的函数吧，这个函数的功能呢是让其参量乘以7。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun multiply-by-seven (number)</span><br><span class=\"line\">  &quot;使number(参量)乘以7&quot;</span><br><span class=\"line\">  (* number 7))</span><br></pre></td></tr></table></figure>\n<p>这个函数的函数名就是<code>multiply-by-seven</code>，而函数名后面的列表也就是函数的参量，当我们调用函数时，传递给函数的参量的值就会被绑定到这个<code>number</code>上。并且<code>number</code>也可以为其他的名称，这取决于写代码的人，你可以改为<code>multiplicand</code>，这可能更符合函数定义的意思。并且这里的<code>number</code>的范围是仅在函数定义内才有效的，如果我们在函数定义外对<code>number</code>求值，可能会返回个错误信息。所以说，参量列表内的参量名可以是任意的，只要不与参量列表内的其他参量相同即可。这就比如：你班上的外号叫李大头，那么在这个班里的李大头代表的人就是你，而如果是在学校中，也有人的名字叫李大头，这时这个李大头就不代表你了。</p>\n<p>跟随参量列表后的叫做函数文档，它的作用是当我们或任何人使用<code>C-h f</code>并键入函数名时所查看的函数帮助文档中的文本。这里还要注意一点，有些函数例如<code>apropos</code>在查看函数文档时会只显示文档的第一行，所以我们要在第一行就尽量写清楚这个函数的作用。通过<code>C-h f</code>查看函数文档将会弹出一个<code>\\*Help\\*</code>Buffer。</p>\n<p>而这个例子的第三行就是函数的主体(往往比例子里多很多**，它是一个列表，功能是将<code>number</code>乘以7。</p>\n<p>函数定义好了，但我们不要直接尝试调用，我先告诉你们调用的方式吧，<strong>把函数名作为一个列表的首元素，其余的作为参量</strong>最后eval即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(multiply-by-seven 7)</span><br></pre></td></tr></table></figure></p>\n<p>但可千万不要急着求值，因为肯定会报错。这主要是因为你只是写好了函数定义，并没有把函数定义给安装上。</p>\n<h2 id=\"安装函数定义\"><a href=\"#安装函数定义\" class=\"headerlink\" title=\"安装函数定义\"></a>安装函数定义</h2><p>将光标移动到我们写好的函数定义之后，eval一下即可安装好函数。安装完成后的函数就被包含在Emacs之中了，直到退出Emacs之前。如果已经尝试安装函数定义的童鞋应该已经发现了，在我们eval函数定义后，会在回显区显示函数名，这就代表我们成功安装了这个函数。</p>\n<h3 id=\"改变函数定义\"><a href=\"#改变函数定义\" class=\"headerlink\" title=\"改变函数定义\"></a>改变函数定义</h3><p>想要修改已经安装好的函数定义很简单，我们只需要重新安装一遍即可，例如我们想要将<code>multiply-by-seven</code>函数改为用<code>+</code>来实现，这样做:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun multiply-by-seven (number)</span><br><span class=\"line\">  &quot;使number(参量)加7次&quot;</span><br><span class=\"line\">  (+ number number number number number number number)) ;; =&gt; multiply-by-seven</span><br><span class=\"line\"></span><br><span class=\"line\">(multiply-by-seven 7) ;; =&gt; 49</span><br></pre></td></tr></table></figure>\n<p>所以编写Emacs Lisp代码时的流程通常是:<strong>写函数，装函数，测函数，改函数，装函数</strong>。</p>\n<h2 id=\"使函数成为交互式函数\"><a href=\"#使函数成为交互式函数\" class=\"headerlink\" title=\"使函数成为交互式函数\"></a>使函数成为交互式函数</h2><p>交互式函数的特点是可以通过<code>M-x</code>调用，还可以通过键序列调用，例如常用的移动光标<code>C-n</code>就是一个交互式函数，并且交互式函数是不会自动将返回值输出至回显区的，因为让一个函数称为交互式函数通常被认为是想得到函数的附加效果，而不是返回值。</p>\n<p>想要使一个函数称为交互式函数，可以在函数定义时，将<code>defun</code>特殊表开头的列表的第四个元素写成一个<code>interactive</code>特殊表开头的列表。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun multiply-by-seven-interactive (number)</span><br><span class=\"line\">  &quot;打印 number(参量) 乘以 7</span><br><span class=\"line\">这是个交互式函数&quot;</span><br><span class=\"line\">  (interactive &quot;p&quot;)</span><br><span class=\"line\">  (message &quot;7 * %d = %d&quot; number (* number 7))) ;; =&gt; multiply-by-seven-interactive</span><br></pre></td></tr></table></figure>\n<p>安装好这个函数后，可以有三种方式调用它:</p>\n<ul>\n<li>对表达式<code>(multiply-by-seven-interactive 7**</code>求值</li>\n<li>键入<code>C-u</code>然后输入一个数字作为函数的参量，键入<code>M-x</code>然后键入函数名最后键入<code>RET</code>。</li>\n<li>还有一种暂时没搞成功，等学到16章的第7节就知道了。</li>\n</ul>\n<p><strong>交互式函数不会自动将返回值打印至回显区</strong> 并且当使用第二种调用方式时，没有在<code>C-u</code>之后键入数字的话将会以默认值4来替代。</p>\n<h3 id=\"交互的multiply-by-seven函数\"><a href=\"#交互的multiply-by-seven函数\" class=\"headerlink\" title=\"交互的multiply-by-seven函数\"></a>交互的multiply-by-seven函数</h3><p>我们为<code>multiply-by-seven</code>函数定义了交互式版本，但没有解释其中的<code>(interactive &quot;p&quot;)</code>列表是个什么东西，这里就说一下。</p>\n<p>首先<code>(interactive &quot;p&quot;)</code>中的<code>p</code>代表将接收一个前缀参量，这个前缀参量也就是我们通过<code>C-u 数字 M-x 函数名</code>这种方式调用时的<code>数字</code>了，例如这个数字是<code>5</code>那么就会把<code>5</code>传递给<code>number</code>参量，然后在<code>message</code>函数中的<code>(* 7 5)</code>求值，最终由于函数是一个交互式函数，所以函数不会自动将返回值输出到回显区中，而<code>message</code>函数的返回值原本是带双引号的，由于是交互式函数，我们要的只是函数带来的附加效果，而不是返回值。</p>\n<h3 id=\"interactive函数的不同选项\"><a href=\"#interactive函数的不同选项\" class=\"headerlink\" title=\"interactive函数的不同选项\"></a>interactive函数的不同选项</h3><p>前面已经解释过<code>interactive</code>函数的<code>p</code>选项，其实<code>interactive</code>特殊表有20多个预定义的选项，我们可以结合多个选项使得将信息正确交互地选送给函数。</p>\n<p>下面介绍两个选项，首先是<code>r</code>，<strong>它可以让Emacs将位点所在区域的开始值和结束值作为函数的两个参量</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(interactive &quot;r&quot;) ;; =&gt; (13945 13978)</span><br></pre></td></tr></table></figure>\n<p>再则是<code>B</code>选项，<strong>它可告诉Emacs用缓冲区的名字作为函数的参量</strong>，它会让Emacs在小缓冲区提示用户输入缓冲区名字，并将跟在<code>B</code>后面的字符串作为提示，而且Emacs还会进行函数名的补全（按TAB）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; 会出来一个交互式的窗口</span><br><span class=\"line\">(interactive &quot;B请输入Buffer名称:&quot;) ;; =&gt; (&quot;test.el&quot;)</span><br></pre></td></tr></table></figure>\n<p>下面再看一个例子，可以获取任意Buffer所对应的文件路径以及位点的开始及结束点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun get-buffer_name-point_start-point_end (buffer start end)</span><br><span class=\"line\">  &quot;获取buffer所对应的文件以及位点的开始结束值&quot;</span><br><span class=\"line\">  (interactive &quot;B请输入Buffer名称: \\nr&quot;)</span><br><span class=\"line\">  (message &quot;Buffer-file:%s\\npoint-start:%d\\npoint-end:%d&quot;(buffer-file-name (get-buffer buffer)) start end))</span><br></pre></td></tr></table></figure>\n<p>通过<code>interactive</code>的<code>B</code>选项获取任意buffer的名称，再通过<code>r</code>选项后去位点的开始和结束值。最后在输出时通过<code>get-buffer</code>获取Buffer对象，从而达到目的。</p>\n<p><strong><code>interactive</code>是支持控制字符的，例如上个例子中用到的<code>\\n</code>。并且<code>interactive</code>还可以无参量，这样的话跟<code>mark-whole-buffer</code>函数差不多。如果<code>interactive</code>的选项不能满足你的要求，那么你可以将参量传递给<code>nteractive</code>做为一个列表。</strong></p>\n<h3 id=\"永久地安装代码\"><a href=\"#永久地安装代码\" class=\"headerlink\" title=\"永久地安装代码\"></a>永久地安装代码</h3><p>前面我们写了那么多的函数，在我们没有关闭Emacs之前这些函数都是可以被我们随意求值的，但是当我们关闭Emacs之后再打开就必须重新安装函数才能求值了。所以有几种方式可以永久地安装函数或其他的代码。</p>\n<ul>\n<li>如果代码作为个人使用，可以把函数定义的代码放到<code>.emacs</code>初始化文件中，当启动Emacs时，将会自动对<code>.emacs</code>文件中的代码求值。</li>\n<li>如果代码很多，可以将函数定义存放至多个文件，然后使用<code>load</code>函数使得emacs对单独存放函数的文件求值。</li>\n<li>如果是当前计算机其他用户需要使用的代码，可以将代码放入<code>site-init.el</code>文件中，这样使得所有的用户都可以使用你的代码。</li>\n<li>如果你想让你的作为全世界的人使用，那么你可以将代码放到互联网上，或着给自由软件基金会发送一份拷贝，它有可能被加入下一个发行版本中。</li>\n</ul>\n<p><strong>Emacs在过去的年代里成长的道路————奉献。</strong></p>\n<h2 id=\"let函数\"><a href=\"#let函数\" class=\"headerlink\" title=\"let函数\"></a>let函数</h2><p><code>let</code>函数与<code>defun</code>函数一样，都是EmacsLisp中的特殊表。</p>\n<p><code>let</code>函数将一个符号附着到或者绑定到一个值上。这些被绑定的值是只能在<code>let</code>函数之内使用，就像说<code>defun</code>特殊表举的例子，两个同名的事物在不同的场景下代表了不同的意思，例如你的房子和你朋友的房子都是房子，你对你朋友说，你要粉刷房子，在你听来是要粉刷你家的房子，但你朋友有可能会认为你要粉刷他的房子。</p>\n<p>而<code>let</code>函数就避免了这种问题，在<code>let</code>函数中绑定的变量都只能在<code>let</code>函数中访问，这就是局部变量的概念。</p>\n<p><code>let</code>函数跟<code>setq</code>以及<code>set</code>函数有个很大的区别就在于:</p>\n<ul>\n<li><code>let</code>函数绑定的变量可有任意个 <code>setq</code>和<code>set</code>只能有一个</li>\n<li><code>let</code>函数可以执行一个或多个列表。</li>\n<li><code>let</code>函数绑定的变量都是局部的。</li>\n</ul>\n<h3 id=\"let表达式的各个部分\"><a href=\"#let表达式的各个部分\" class=\"headerlink\" title=\"let表达式的各个部分\"></a>let表达式的各个部分</h3><p><code>let</code>表达式分为三个部分，第一个就是<code>let</code>符号，第二个是变量列表，第三个是主体。</p>\n<p><strong>第二个部分的变量列表是由一个列表组成的，这个列表内可以是任意多个符号或任意多个由两个元素组成且第一个元素必定是符号的列表。*</strong></p>\n<p><strong>第三个部分是<code>let</code>表达式主体，由任意多个列表组成。</strong></p>\n<p><code>let</code>表达式的模板看起来像:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(let varlist body...)</span><br></pre></td></tr></table></figure>\n<p>其中变量列表的符号是由<code>let</code>特殊表赋初始化值的变量.符号本身的初始值是nil.而作为两元素列表的首元素的每一个符号被绑定到对第二个元素求值后的返回值.</p>\n<p>所以一个简单的变量列表看起来可能是这样的:<code>(apple (pear 10))</code>.在这个例子中,<code>apple</code>的值是nil,因为我们没有为其赋予初始值.而<code>pear</code>的值为10.</p>\n<p>那么当变量是由两个元素的列表组成,就可以是下面这样的模板:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(let ((variable value) (variable value) variable...)</span><br><span class=\"line\">  (body1)</span><br><span class=\"line\">  (body2)...)</span><br></pre></td></tr></table></figure>\n<h3 id=\"let表达式例子\"><a href=\"#let表达式例子\" class=\"headerlink\" title=\"let表达式例子\"></a>let表达式例子</h3><p>现在需要创建一些关于水果的栗子,不同的水果有不同的数量.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(let (apple (pear 10) (banana &apos;4斤) watermelon)</span><br><span class=\"line\">  (message &quot;苹果数量:%S\\t梨子数量:%d\\t香蕉数量:%s\\t西瓜数量:%S&quot; apple pear banana watermelon)) ;; =&gt; &quot;苹果数量:nil\t梨子数量:10\t香蕉数量:4斤\t西瓜数量:nil&quot;</span><br></pre></td></tr></table></figure>\n<p>我们创建了两个初始值为nil的变量<code>apple</code>和<code>watermelon</code>,以及一个绑定到10的变量pear,还有一个绑定到<code>4斤</code>的变量banana.随后在<code>let</code>主体中将创建的变量都用<code>message</code>函数打印在回显区.</p>\n<h3 id=\"let语句中的未初始化变量\"><a href=\"#let语句中的未初始化变量\" class=\"headerlink\" title=\"let语句中的未初始化变量\"></a>let语句中的未初始化变量</h3><p>在<code>let</code>表达式的变量列表中,允许不给予变量初始化值,那么Lisp解释器将会为其默认绑定到nil值上.</p>\n<p>并且,如果没有给予初始值,那么它可以称作:<code>作为独立的原子出现</code>.</p>\n<h2 id=\"if特殊表\"><a href=\"#if特殊表\" class=\"headerlink\" title=\"if特殊表\"></a>if特殊表</h2><p><code>if</code>函数是除了<code>defun</code>/<code>let</code>特殊表之外的一个特殊表,它用于让计算机做一些判断的工作.</p>\n<p>首先来看<code>if</code>函数的模板:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if if-part</span><br><span class=\"line\">    then)</span><br></pre></td></tr></table></figure>\n<p>其工作方式是：首先测试<code>if-part</code>的返回值是否不为nil，如果不为nil，那么就执行<code>then</code>的表达式。</p>\n<p><strong>通常会把then部分放在if-part的下一行，这样更有利于阅读。</strong></p>\n<p>下面做一个简单的栗子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (&gt; 5 4)</span><br><span class=\"line\">    (message &quot;5 比 4 大!&quot;)) ;; =&gt; &quot;5 比 4 大!&quot;</span><br></pre></td></tr></table></figure>\n<p>其中<code>&gt;</code>函数测试它的第一个参量和第二个参量进行比较大小，如果第一个参量大于第二个参量则返回“真”，否则返回nil。</p>\n<p>可往往在日常编码中，<code>if-part</code>的值不能直接确定，它可能是一个表达式，又可能是一个函数调用。</p>\n<p>例如测试参量可能被绑定在函数定义的参量上:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun type-of-animal (animal-name)</span><br><span class=\"line\">  &quot;根据animal-name打印信息到回显区</span><br><span class=\"line\">如果animal-name是符号&apos;fierce则返回&apos;tiger&quot;</span><br><span class=\"line\">  (if (equal animal-name &apos;fierce)</span><br><span class=\"line\">      (message &quot;It&apos;s a tiger&quot;)))</span><br><span class=\"line\">(type-of-animal &apos;fierce) ;; =&gt; &quot;It’s a tiger&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>type-of-animal函数详解</strong></p>\n<p>首先<code>type-of-animal</code>是包含了两个特殊表模板，分别是<code>defun</code>和<code>if</code>。<code>type-of-animal</code>是函数名，紧跟着函数名的是函数参量列表，然后跟着的是函数的文档。最后函数的主体内是一个if函数，if函数的的一个参量是一个列表，这个列表的首元素的符号是一个函数<code>equal</code>，在Lisp中，<code>equal</code>函数用于比较参量一和参量二是否相等，如果相等则输出<code>if</code>函数的第二个参量，也是一个列表，这个列表的首元素是符号且是函数<code>message</code>，将<code>It&#39;s a tiger</code>打印至回显区。</p>\n<h2 id=\"if-then-else表达式\"><a href=\"#if-then-else表达式\" class=\"headerlink\" title=\"if-then-else表达式\"></a>if-then-else表达式</h2><p>其实<code>if-then-else</code>表达式就是在<code>if</code>特殊表之上加了一个参量，其他没什么不同，新增的参量是当参量一的值为nil时，对参量三求值。</p>\n<p>它的函数模板可以写成这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if true-or-false-test</span><br><span class=\"line\">    action-to-carry-out-if-the-test-returns-true</span><br><span class=\"line\">  action-to-carry-out-if-the-test-returns-false)</span><br></pre></td></tr></table></figure>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (&gt; 4 5)</span><br><span class=\"line\">  (message &quot;5 大于 4!&quot;)</span><br><span class=\"line\">(message &quot;4 小于 5&quot;)) ;; =&gt; &quot;4 小于 5&quot;</span><br></pre></td></tr></table></figure>\n<p>通过这个例子，我们发现当<code>if</code>函数的第一参量值为nil时就会对第三参量求值。并且第三参量的缩进也要少于第二参量。</p>\n<p>那我们现在将<code>type-of-animal</code>函数改造成:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun type-of-animal (animal-name) ;second version</span><br><span class=\"line\">  &quot;根据animal-name打印信息到回显区</span><br><span class=\"line\">如果animal-name是符号&apos;fierce则输出&apos;It&apos;s tiger!否则输出Tt not fierce&quot;</span><br><span class=\"line\">  (if (equal animal-name &apos;fierce)</span><br><span class=\"line\">      (message &quot;It&apos;s tiger&quot;)</span><br><span class=\"line\">    (message &quot;It not fierce&quot;)))</span><br><span class=\"line\">(type-of-animal &apos;fierce) ;; =&gt;&quot;It’s tiger&quot;</span><br><span class=\"line\">(type-of-animal &apos;notfierce)  ;; =&gt; &quot;It not fierce&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lisp中的真与假\"><a href=\"#Lisp中的真与假\" class=\"headerlink\" title=\"Lisp中的真与假\"></a>Lisp中的真与假</h2><p>Lisp中所有除了nil的都是真，nil也就是我们常说的假，nil有多种意思，一种就是nil代表假，另一种则是代表空列表，但往往都把空列表写成<code>()</code>，而当Lisp解释器对表达式求值时，只要值不是nil或空列表那么都是真，不管得到的值为一个数字或字符串或列表，它都代表真。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if nil</span><br><span class=\"line\">    &apos;true</span><br><span class=\"line\">  &apos;false) ;; =&gt; false</span><br><span class=\"line\">(if t</span><br><span class=\"line\">    &apos;true</span><br><span class=\"line\">  &apos;false) ;; =&gt; true</span><br></pre></td></tr></table></figure>\n<p>真也有另外一种表示方式，在表达式求值后没什么可返回时就会返回<code>t</code>，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&gt; 5 4) ;; =&gt; t</span><br></pre></td></tr></table></figure>\n<h2 id=\"save-excursion函数\"><a href=\"#save-excursion函数\" class=\"headerlink\" title=\"save-excursion函数\"></a>save-excursion函数</h2><p>各位还记得什么是位点(point)，什么是标记(mark)吗?</p>\n<p>Emacs是一个文本编辑器，主要还是与文本打交道，那么<code>save-excursion函数</code>就是与文本打交道的一个经典函数。</p>\n<p>先让我们来回顾一下位点与标记:</p>\n<ul>\n<li><p>位点(point)：及当前buffer中光标所在字符位置，例如当光标置于buffer的开头，那么point应该是1，若置于buffer的末尾，那么point就是当前buffer的字符数了。</p>\n</li>\n<li><p>标记(mark)：标记是buffer的另外一个位置，其中一个就是位点。在buffer中可以自定义很多标记，这样可以方便我们跳转至某个位点。设置标记的函数是<code>(set-mark-command)</code>，它绑定了一个键序列<code>C-SPC</code>，如果此时想要快速跳转至某个标记点，就可以使用命令<code>(exehange-point-and-mark</code>快速回到标记处，它绑定了一个键序列<code>C-x C-x</code>，并且还会将当初的位点设置一个标记，方便来回跳转。</p>\n</li>\n</ul>\n<p><strong>位点与标记之间的缓冲区叫做现域(region)</strong>，有很多条命令是专用于操作现域的，例如:<code>center-region|count-lines-region|kill-region|print-region</code></p>\n<p>前面将了很多关于位点与标记的知识，下面正式介绍<code>save-excursion</code>函数，这个函数的作用主要是将位点和标记的当前位置保存，然后当其他会影响位点或标记的函数执行完后，再将标记的位点复原。 </p>\n<p><code>save-excursion</code>函数模板:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(save-excursion</span><br><span class=\"line\">  body...)</span><br></pre></td></tr></table></figure>\n<p><strong>注意，<code>save-excursion</code>函数的函数体允许有多条表达式，但是只返回最后一条表达式的值。</strong></p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>这一章学的东西还是挺多的，下面我就把书中的所有文字一字不差的抄下来。</p>\n<p>先说几个提到但是没有过多解释的函数:</p>\n<ul>\n<li><p>eval-last-sexp<br>对光标所处的位点前的最后一个符号表达式求值。如果这个函数激活时没有参量，那么将返回值输出在回显区，否则将打印在当前缓冲区中。</p>\n</li>\n<li><p>defun<br>定义函数。这个特殊表最多可有五个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。</p>\n</li>\n<li><p>interactiv<br>向解释器声明这个函数可以被交互的使用，并且这个特殊表还可以用一个字符串，分成单个或多个部分，依次传送信息至这个函数的参量。 </p>\n</li>\n<li><p>let<br>声明在<code>let</code>表达式主体中使用的变量列表并且给它们赋初始值，初始值要么是nil，要么是一个指定的值，然后对<code>let</code>表达式主体的其他表达式求值并返回最后一个表达式的值。</p>\n</li>\n<li><p>save-excursion<br>对这个函数主体求值前，记录位点和标记的值以及当前缓冲区。求值后恢复位点和标记。</p>\n</li>\n<li><p>if<br>对函数的第一个参量求值，如果值为真，则对第二个参量求值，否则对第三个参量求值。</p>\n</li>\n<li><p>equal、eq<br>测试两个对象的结构或内容是否相等用equal，测试两个对象是否完全相当用eq</p>\n</li>\n<li><p>&lt; &gt; &lt;= &gt;=<br>用于判断第一个参量的值是否大于/小于/大于或等于/小于或等于第二个参量的值，如果是则返回真，否则返回nil</p>\n</li>\n<li><p>message<br>用于往回显区内打印消息</p>\n</li>\n<li><p>setq set<br>setq 用于将第一个参量的值绑定到第二个参量的值，而第一个参量的值由<code>setq</code>自动加上引用。<br>set 用于将第一个参量的值绑定到第二个参量的值，但是不会自动为第一个参量加上引用。</p>\n</li>\n<li><p>buffer-name<br>这个函数用于获取一个缓冲区的名字</p>\n</li>\n<li><p>buffer-file-name<br>这个函数用于获取缓冲区所对饮的名字</p>\n</li>\n<li><p>current-buffer<br>这个函数用于获取当前缓冲区的buffer对象</p>\n</li>\n<li><p>other-buffer<br>返回最近选择过的缓冲区</p>\n</li>\n<li><p>switch-to-buffer<br>选择一个缓冲区</p>\n</li>\n<li><p>set-buffer<br>设置当前缓冲区为某一个缓冲区</p>\n</li>\n<li><p>buffer-size<br>返回当前缓冲区的字符数</p>\n</li>\n<li><p>point<br>返回当前光标所对应缓冲区的位置</p>\n</li>\n<li><p>point-min<br>返回当前缓冲区最小的字符数</p>\n</li>\n<li><p>point-max<br>返回当前缓冲区最大的字符数</p>\n</li>\n</ul>\n<h2 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ul>\n<li>编写一个非交互的函数，这个函数将其第一个参量(是一个数)的值翻倍。然后使这个函数成为一个交互函数</li>\n</ul>\n<p>非交互:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun double(number)</span><br><span class=\"line\">  &quot;使number翻倍&quot;</span><br><span class=\"line\">  (setq number (* number 2)))</span><br><span class=\"line\"></span><br><span class=\"line\">(double 10) ;; =&gt; 20</span><br></pre></td></tr></table></figure>\n<p>交互式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun double(number)</span><br><span class=\"line\">  &quot;使number翻倍&quot;</span><br><span class=\"line\">  (interactive &quot;n请输入要翻倍的数字: &quot;)</span><br><span class=\"line\">  (setq number (* number 2))</span><br><span class=\"line\">  (message &quot;翻倍后:%d&quot; number))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个函数，测试<code>fill-column</code>的当前值是否大于传送给函数参量的值，如果是则打印适当的信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun is-bigger-to-fill-column (number)</span><br><span class=\"line\">  &quot;判断number是否比fill-column大&quot;</span><br><span class=\"line\">  (if (&gt; number fill-column)</span><br><span class=\"line\">      (message &quot;%d比fill-column要大&quot; number)</span><br><span class=\"line\">    (message &quot;%d比fill-column要小&quot; number)))</span><br><span class=\"line\"></span><br><span class=\"line\">(is-bigger-to-fill-column 79) ;; =&gt; &quot;79比fill-column要小&quot;</span><br><span class=\"line\">(is-bigger-to-fill-column 81) ;; =&gt; &quot;81比fill-column要大&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第四章-与缓冲区有关的函数\"><a href=\"#第四章-与缓冲区有关的函数\" class=\"headerlink\" title=\"第四章 与缓冲区有关的函数\"></a>第四章 与缓冲区有关的函数</h1><p>本章将会介绍大量的函数定义。</p>\n<h2 id=\"查找更多的信息\"><a href=\"#查找更多的信息\" class=\"headerlink\" title=\"查找更多的信息\"></a>查找更多的信息</h2><p>可以使用<code>C-h f</code>查看一个函数所对应的文档，使用<code>C-h v</code>查看一个变量所对应的文档，如果要在源代码文件中查看函数定义，可以使用函数<code>find-tags</code>，跳到相应的位置。</p>\n<p>Lisp代码可以分为多个模块或包，如果想要查看某个模块的帮助，可以键入<code>C-h p</code>。</p>\n<h2 id=\"简化的beginning-of-buffer函数定义\"><a href=\"#简化的beginning-of-buffer函数定义\" class=\"headerlink\" title=\"简化的beginning-of-buffer函数定义\"></a>简化的beginning-of-buffer函数定义</h2><p>对于<code>beginning-of-buffer</code>函数你们可能已经使用过了，其绑定的键序列是<code>M-&lt;</code>。其作用是将当前光标移动至buffer的起始处。</p>\n<p>下面我们将自己实现一个简单的<code>beginning-of-buffer</code>函数。</p>\n<p>让我们来看看我们需要做什么事:</p>\n<ol>\n<li>首先这个函数得是个交互式函数，以便我们能通过键序列调用或用<code>M-x</code>调用。</li>\n<li>其次我们需要记录个位点为标记</li>\n<li>最后我们再跳转到buffer起始处</li>\n</ol>\n<p>相比与真正的<code>beginning-of-buffer</code>函数定义，没有考虑一些复杂的选项，但是我们先完成这个简化版本吧!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun simple-beginning-of-buffer ()</span><br><span class=\"line\">  &quot;移动光标至buffer开始处&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char (point-min)))</span><br></pre></td></tr></table></figure>\n<p>这个<code>defun</code>函数包含了5个部分:</p>\n<ol>\n<li>首先是这个函数的函数名————<code>simple-beginning-of-buffer</code></li>\n<li>再就是函数的文档</li>\n<li>随后是交互式表达式</li>\n<li>然后记录位点为标记</li>\n<li>最后跳转至buffer的起始处 </li>\n</ol>\n<p>由于这个函数是无参量的，所以交互式表达式内也不用写任何字符串，而<code>push-mark</code>函数默认将<code>point</code>加入到标记中，最后通过<code>goto-char</code>跳转至<code>point-min</code>的位置。如果想要回到原来的位置可以使用<code>C-x C-x</code>。</p>\n<p>既然已经写了一个<code>simple-beginning-of-buffer</code>那我们也可以写一个<code>simple-end-of-buffer</code>吧!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun simple-end-of-buffer()</span><br><span class=\"line\">  &quot;移动光标至buffer结束处&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char (point-max)))</span><br></pre></td></tr></table></figure>\n<p>最后则是，如果遇到不了解的函数，可以将光标放置函数之上，键入键序列<code>C-h f RET</code>即可。 </p>\n<h2 id=\"mark-whole-buffer函数定义\"><a href=\"#mark-whole-buffer函数定义\" class=\"headerlink\" title=\"mark-whole-buffer函数定义\"></a>mark-whole-buffer函数定义</h2><p><code>mark-whole-buffer</code> 不比<code>simple-end-of-buffer</code>复杂多少。</p>\n<p>这次我们来看一个函数的完整定义</p>\n<p>这是书中的定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun mark-whole-buffer ()</span><br><span class=\"line\">  &quot;Put point at beginning and mark at end of buffer.&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark (point))</span><br><span class=\"line\">  (push-mark (point-max))</span><br><span class=\"line\">  (goto-char (point-min)))</span><br></pre></td></tr></table></figure>\n<p>书中讲不知道为啥函数体内的第一条表达式<code>push-mark</code>内还需要写<code>(point)</code>，但我现在再去看，这个函数已经改变了，并且也改掉了这个冗余的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun mark-whole-buffer ()</span><br><span class=\"line\">  &quot;Put point at beginning and mark at end of buffer.</span><br><span class=\"line\">If narrowing is in effect, only uses the accessible part of the buffer.</span><br><span class=\"line\">You probably should not use this function in Lisp programs;</span><br><span class=\"line\">it is usually a mistake for a Lisp function to use any subroutine</span><br><span class=\"line\">that uses or sets the mark.&quot;</span><br><span class=\"line\">  (declare (interactive-only t))</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (push-mark (point-max) nil t)</span><br><span class=\"line\">  ;; This is really `point-min&apos; in most cases, but if we&apos;re in the</span><br><span class=\"line\">  ;; minibuffer, this is at the end of the prompt.</span><br><span class=\"line\">  (goto-char (minibuffer-prompt-end)))</span><br></pre></td></tr></table></figure>\n<p>并且还改了一些代码，先不看<code>declare</code>，我们发现变化的有<code>(push-mark (point-max))</code>，最新的<code>mark-whole-buffer</code>函数中函数体第二个表达式多了两个参量，第二个参量代表如果值不为nil则显示<code>Mark set</code>。第三个参量代表如果在瞬时标记模式下，值不为nil则激活。</p>\n<p>并且最后一条表达式也修改过了，原本是<code>point-min</code>但改为<code>minibuffer-prompt-end</code>，其区别在于:</p>\n<p><code>minibuffer-prompt-end会在返回buffer位置时输出信息至minibuffer</code></p>\n<p>在是如果当前buffer不是minibuffer那么就返回<code>point-min</code></p>\n<h2 id=\"append-to-buffer函数定义\"><a href=\"#append-to-buffer函数定义\" class=\"headerlink\" title=\"append-to-buffer函数定义\"></a>append-to-buffer函数定义</h2><p>由于我看的这本书年代久远(2001)，现在是2019年，整整过去18年，Emacs也已经发生了巨大的变化。</p>\n<p>所以我将先试着记录书中所讲的<code>append-to-buffer</code>函数再对Emacs 26.3版本的<code>append-to-buffer</code>函数进行讲解，希望对看到这篇博客的同仁们提供一些微薄的帮助。</p>\n<blockquote>\n<p>这个计划已经鸽了，我发现用我现在所学还是很难解释清楚26.3版本的append-to-buffer函数的工作方式。所以后面的26.版 append-to-buffer会在以后完成，十分抱歉。</p>\n</blockquote>\n<p>首先<code>append-to-buffer</code>函数的作用是将指定buffer区域(region)中的文本追加到当前Buffer的point前。</p>\n<h3 id=\"旧版append-to-buffer\"><a href=\"#旧版append-to-buffer\" class=\"headerlink\" title=\"旧版append-to-buffer\"></a>旧版append-to-buffer</h3><p>先让我们看看书中的<code>append-to-buffer</code>函数定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun append-to-buffer (buffer start end)</span><br><span class=\"line\">  &quot;Append to specified buffer the text of the region.</span><br><span class=\"line\">It is inserted into that buffer before its point.</span><br><span class=\"line\">When alling from a program, give three arguments:</span><br><span class=\"line\">a buffer or the name of one, and two character numbers</span><br><span class=\"line\">specifying the portion of the current buffer to be copied.&quot;</span><br><span class=\"line\">  (interactive &quot;BAppend to buffer: \\nr&quot;)</span><br><span class=\"line\">  (let ((oldbuf (current-buffer)))</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (set-buffer (get-buffer-create buffer))</span><br><span class=\"line\">      (insert-buffer-substring oldbuf start end))))</span><br></pre></td></tr></table></figure>\n<p>通过阅读这个函数的文档就能很清晰的了解这个函数的工作方式。</p>\n<p>略过函数名和文档，我们直接来看<code>interactive</code>。<code>interative</code>中的<code>B</code>代表让用户选择一个Buffer(可能不存在)并将buffer名称传给函数参量一，其次是一些友好的文本<code>Append to buffer:</code>，紧跟其后的<code>\\n</code>用于控制换行，最后的<code>r</code>获取当前区域(point和mark)，并将其传给函数的参量二和参量三。 </p>\n<p>随后是一个<code>let</code>特殊表，在<code>let</code>的变量列表中，定义了一个<code>oldbuf</code>，其绑定的值是<code>(current-buffer)</code>的返回值，也就是当前Buffer对象。在<code>let</code>的表达式体中有一个<code>save-excursion</code>函数。</p>\n<p><code>save-excursion</code>函数体中有两条表达式，第一条表达式<code>(set-buffer)</code>用于将当前缓冲区变换到另外一个缓冲区，而其参量又是一个函数<code>get-buffer-create</code>，这个函数的作用是获取指定BUFFER对象或名(称为BUFFER-OR-NAME)，如果这个BUFFER-OR-NAME不存在，将会自动创建。</p>\n<p><code>save-excursion</code>函数体的第二条表达式是一个<code>(insert-buffer-substring)</code>函数这个函数将参量一从参量二到参量三的区域的字符串插入到当前Buffer的point之前。</p>\n<h3 id=\"26-3版append-to-buffer\"><a href=\"#26-3版append-to-buffer\" class=\"headerlink\" title=\"26.3版append-to-buffer\"></a>26.3版append-to-buffer</h3><p>由于本人水平有限，如有错误，欢迎提出issue.</p>\n<p>先让我们看函数定义原型:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun append-to-buffer (buffer start end)</span><br><span class=\"line\">  &quot;Append to specified BUFFER the text of the region.</span><br><span class=\"line\">The text is inserted into that buffer before its point.</span><br><span class=\"line\">BUFFER can be a buffer or the name of a buffer; this</span><br><span class=\"line\">function will create BUFFER if it doesn&apos;t already exist.</span><br><span class=\"line\"></span><br><span class=\"line\">When calling from a program, give three arguments:</span><br><span class=\"line\">BUFFER (or buffer name), START and END.</span><br><span class=\"line\">START and END specify the portion of the current buffer to be copied.&quot;</span><br><span class=\"line\">  (interactive</span><br><span class=\"line\">   (list (read-buffer &quot;Append to buffer: &quot; (other-buffer (current-buffer) t))</span><br><span class=\"line\">\t (region-beginning) (region-end)))</span><br><span class=\"line\">  (let* ((oldbuf (current-buffer))</span><br><span class=\"line\">         (append-to (get-buffer-create buffer))</span><br><span class=\"line\">         (windows (get-buffer-window-list append-to t t))</span><br><span class=\"line\">         point)</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (with-current-buffer append-to</span><br><span class=\"line\">        (setq point (point))</span><br><span class=\"line\">        (barf-if-buffer-read-only)</span><br><span class=\"line\">        (insert-buffer-substring oldbuf start end)</span><br><span class=\"line\">        (dolist (window windows)</span><br><span class=\"line\">          (when (= (window-point window) point)</span><br><span class=\"line\">            (set-window-point window (point))))))))</span><br></pre></td></tr></table></figure>\n<p>我们发现函数参量没有变化，并且注释也没有大的变化，只是函数体内发生了较大的变化。</p>\n<p>首先是<code>interactive</code>函数参量发生了变化，变成了一个<code>list</code>函数，回想一下，<code>list</code>函数是用于构造一个列表的函数，这个<code>list</code>函数的第一个参量是<code>(read-buffer)</code>函数。</p>\n<p><code>read-buffer</code>函数可以通过buffer名称读取buffer中的字符串并返回。其第一个参量是用于提示用户的友好信息，并且特意指出这个提示信息必须是由冒号和空格结尾且被双引号包围的字符串。第二个参量用于也就是返回值，它的默认值为列表</p>\n<h2 id=\"回顾-1\"><a href=\"#回顾-1\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>惯例抄书</p>\n<ul>\n<li><p>describe-function\\describe-variable<br>打印一个函数或一个变量的文档。通常将其绑定到<code>C-h f</code>和<code>C-h v</code></p>\n</li>\n<li><p>find-tag<br>找到存放某个函数或变量的源代码的文件，并切换到这个缓冲区，将位点(光标)置于相应函数或这变量的开始处。习惯上将其绑定到<code>M--</code>。</p>\n</li>\n<li><p>save-excursion<br>保存位点和标记的位置，并在对<code>save-excursion</code>参量求值之后恢复这些值。它也保存当前缓冲区并返回到该缓冲区。</p>\n</li>\n<li><p>push-mark<br>在指定位置设置一个标记，并在标记环中记录原来标记的值。标记是缓冲区中的一个位置，即使由一些文本被从缓冲区删除或者增加到缓冲区，标记仍将保持它的相对位置。</p>\n</li>\n<li><p>goto-char<br>将位点设置为由参量指定的位置。参量值可以是一个数，也可以是一个标记，甚至可以是一个返回一个位置数字的表达式(point-min)</p>\n</li>\n<li><p>insert-buffer-substring<br>将来自一个缓冲区（这是被作为一个参量而传递给函数的）的文本域拷贝到当前缓冲区</p>\n</li>\n<li><p>mark-whole-buffer<br>将整个缓冲区标记为一个域。一般将这个函数绑定到<code>C-x h</code>。</p>\n</li>\n<li><p>set-buffer<br>将Emacs的注意力转移到另一个缓冲区，但是不该便显示的窗口。 </p>\n</li>\n<li><p>get-buffer-create\\get-buffer<br>寻找一个已指定名字的缓冲区，或当指定名字的缓冲区不存在时就创建它。如果指定名称的缓冲区不存在，get-buffer函数就返回nil。</p>\n</li>\n</ul>\n<h2 id=\"练习-3\"><a href=\"#练习-3\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ul>\n<li>编写自己的<code>simplified-end-of-buffer</code>函数定义，然后测试它是否能工作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun simple-end-of-buffer()</span><br><span class=\"line\">  &quot;移动光标至buffer结束处&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char (point-max)))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用if和get-buffer编写一个函数，这个函数要打印一个说明某个缓冲区是否存在的消息 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun is-exist-buffer (buffer-or-name)</span><br><span class=\"line\">  &quot;判断buffer-or-name是否为一个已存在的buffer&quot;</span><br><span class=\"line\">  (if (bufferp (get-buffer buffer-or-name))</span><br><span class=\"line\">      (message &quot;%s存在!&quot; buffer-or-name)</span><br><span class=\"line\">    (message &quot;此缓冲区不存在!&quot;)))</span><br><span class=\"line\">    </span><br><span class=\"line\">(is-exist-buffer &quot;test.el&quot;) ;; =&gt; &quot;test.el存在!&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用find-tag找到copy-to-buffer函数的源代码</li>\n</ul>\n<p>不会…</p>\n<h1 id=\"第五章-更复杂的函数\"><a href=\"#第五章-更复杂的函数\" class=\"headerlink\" title=\"第五章 更复杂的函数\"></a>第五章 更复杂的函数</h1><p>本章我们将在已学内容的基础之上学习更复杂的函数，例如有使用两次<code>save-excursion</code>的<br><code>copy-to-buffer</code>函数，以及一个在<code>interactive</code>中使用<code>*</code>和<code>or</code>函数的函数。</p>\n<h2 id=\"copy-to-buffer函数的定义\"><a href=\"#copy-to-buffer函数的定义\" class=\"headerlink\" title=\"copy-to-buffer函数的定义\"></a>copy-to-buffer函数的定义</h2><p><code>copy-to-buffer</code>函数与前面学过的<code>append-to-buffer</code>的定义很类似。</p>\n<p><code>copy-to-buffer</code>是替换指定<code>BUFFER</code>的内容，而<code>append-to-buffer</code>是在指定<code>BUFFER</code>中追加内容。</p>\n<p>首先来看看<code>copy-to-buffer</code>的函数定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun copy-to-buffer-t (BUFFER START END)</span><br><span class=\"line\">  &quot;docutments...&quot;</span><br><span class=\"line\">  (interactive &quot;BCopy to buffer: \\nr&quot;)</span><br><span class=\"line\">  (let ((oldbuf (get-buffer-create BUFFER)))</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (set-buffer BUFFER)</span><br><span class=\"line\">      (save-excursion</span><br><span class=\"line\">        (insert-buffer-substring oldbuf START END)))))</span><br></pre></td></tr></table></figure>\n<p>略过函数名与文档不看，可以看到这个函数被定义为交互式函数，并且这个函数的参量要求<br>是一个BUFFER对象，以及两个表示位置的数字。这三个参量都由<code>interactive</code>所解决，其<br>使得让用户选择一个BUFFER，然后获取当前<code>Buffer</code>的<code>point</code>和<code>mark</code>，作为<code>START</code>和<br><code>END</code>。</p>\n<p>随后是一个<code>let</code>表达式，其在它的<code>varlist</code>部分将<code>BUFFER</code>参量通过<br><code>get-buffer-create</code>函数获取了其对象(就算<code>BUFFER</code>参量的值不存在也会创建一个)，并<br>且将这个BUFFER对象赋值给<code>oldbuf</code>。在<code>let</code>表达式的<code>BODY</code>部分，出现了一个<br><code>save-excursion</code>函数，这个函数用于记录当前<code>point</code>和<code>mark</code>的位置，然后在其参量求<br>值完毕后恢复记录的位置，这个参量也就是<code>set-buffer</code>，这个函数用于改变当前BUFFER为<br>  参量<code>BUFFER</code>。随后又是一个<code>save-excursion</code>函数，其参量<br>  <code>insert-buffer-substring</code>函数我们也了解过，其用于将当前BUFFER的START到END之间<br>  的区间插入到<code>oldbuf</code>内。</p>\n<h2 id=\"insert-buffer函数的定义\"><a href=\"#insert-buffer函数的定义\" class=\"headerlink\" title=\"insert-buffer函数的定义\"></a>insert-buffer函数的定义</h2><p>前面我们用过<code>append-to-buffer</code>以及<code>copy-to-buffer</code>，他们都是将当前<code>BUFFER</code>的内容<br>拷贝或追加到某一个<code>BUFFER</code>中，而<code>insert-buffer</code>可以将当前<code>BUFFER</code>的内容，拷贝至<br>一个已存在的<code>BUFFER</code>当中。</p>\n<p>先来看看其函数定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun insert-buffer-t (buffer)</span><br><span class=\"line\">  &quot;docutmens..&quot;</span><br><span class=\"line\">  (interactive &quot;*bInsert buffer: &quot;)</span><br><span class=\"line\">  (or (bufferp buffer)</span><br><span class=\"line\">      (setq buffer (get-buffer buffer)))</span><br><span class=\"line\">  (let (start end newmark)</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (save-excursion</span><br><span class=\"line\">        (set-buffer buffer)</span><br><span class=\"line\">        (setq start (point-min) end (point-max)))</span><br><span class=\"line\">      (insert-buffer-substring buffer start end)</span><br><span class=\"line\">      (setq newmark (point)))</span><br><span class=\"line\">    (push-mark newmark)))</span><br></pre></td></tr></table></figure>\n<p>先简单整理一下这个函数都包含了什么东西:</p>\n<ul>\n<li>一个参量</li>\n<li>函数文档</li>\n<li>定义交互式函数</li>\n<li><code>interactive</code>参量说明有*和 <code>b</code></li>\n<li>以及一个<code>or</code>函数，这个函数内有两个参量</li>\n<li>第一个参量是<code>bufferp</code>函数</li>\n<li>第二个参量是<code>setq</code>函数，<code>setq</code>的第二个参量是<code>get-buffer</code>函数。</li>\n<li>随后是一个<code>let</code>表达式</li>\n<li><code>let</code>表达式中先是初始化了三个空变量</li>\n<li>一个外层<code>save-excursion</code>函数</li>\n<li>一个内层<code>save-excursion</code>函数</li>\n<li>其第一个参量是一个<code>set-buffer</code>函数</li>\n<li>第二个参量是<code>setq</code>函数</li>\n<li>外层<code>save-excursion</code>的第二个参量是一个<code>insert-buffer-substring</code>函数</li>\n<li>第三个参量是一个<code>setq</code>函数。</li>\n<li>最后是一个<code>push-mark</code>函数。 </li>\n</ul>\n<h3 id=\"insert-buffer函数中的交互表达式\"><a href=\"#insert-buffer函数中的交互表达式\" class=\"headerlink\" title=\"insert-buffer函数中的交互表达式\"></a>insert-buffer函数中的交互表达式</h3><p>让我们先从<code>interactive</code>表达式说起，首先起表达式说明分为三个部分：</p>\n<ol>\n<li><code>*</code>代表只读缓冲区，这个说明会在当<code>b</code>说明返回的buffer是一个只读缓冲区时在回显<br>区提示错误。也就是说当这个<code>insert-buffer</code>函数当在一个只读缓冲区被调用时，将不<br>被允许。</li>\n<li><p><code>b</code>代表要求是一个存在的缓冲区或者是缓冲区名，它与<code>B</code>说明不同。</p>\n</li>\n<li><p><code>Insert buffer:</code>是友好的提示。</p>\n</li>\n</ol>\n<p><strong>提示:*控制符无需后接一个换行符来分割不同的参量。</strong></p>\n<h3 id=\"insert-buffer函数体\"><a href=\"#insert-buffer函数体\" class=\"headerlink\" title=\"insert-buffer函数体\"></a>insert-buffer函数体</h3><p>主要有两个部分，分别是<code>or</code>函数和<code>let</code>函数。</p>\n<p>先让我们来看看<code>or</code>函数，其第一个参量是一个<code>bufferp</code>函数，这个函数用于当其参量是<br>是一个已存在的buffer或buffer的名称才会返回<code>non-nil</code>的值，也就是真/非假，其第二个<br>参量是一个<code>setq</code>函数，里面有一个<code>get-buffer</code>函数，这个函数是用于获取一个已存在的<br>buffer对象根据buffer对象或buffer的名称，并将buffer绑定到<code>get-buffer</code>的值之上。</p>\n<p>其实这个函数的意思是，要让<code>buffer</code>参量确定是一个已存在的buffer，我们可以用<code>if</code>函<br>数重写一遍。</p>\n<h3 id=\"用if表达式编写insert-buffer函数\"><a href=\"#用if表达式编写insert-buffer函数\" class=\"headerlink\" title=\"用if表达式编写insert-buffer函数\"></a>用if表达式编写insert-buffer函数</h3><p>我们的需求是，必须确保<code>buffer</code>的值是一个已存在的buffer或buffer的名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (not (bufferp buffer)</span><br><span class=\"line\">         (setq buffer (get-buffer buffer))))</span><br></pre></td></tr></table></figure>\n<p>就可以这样写，当<code>bufferp</code>函数的值为nil时，那么就会尝试获取<code>buffer</code>的对象并且保存，<br>否则则报错。</p>\n<h3 id=\"insert-buffer函数中的let表达式\"><a href=\"#insert-buffer函数中的let表达式\" class=\"headerlink\" title=\"insert-buffer函数中的let表达式\"></a>insert-buffer函数中的let表达式</h3><p>在我们确保<code>buffer</code>参量是一个非只读缓冲区后，可以开始写拷贝内容的代码了。</p>\n<p>首先我们初始化三个空变量: start end newmark</p>\n<p>  <code>let</code>表达式体中有一个外层<code>save-excursion</code>函数，其记录了我们的<code>point</code>和<code>mark</code>，<br>其第一个参量又是一个<code>save-excursion</code>函数，我们称为内层<code>save-excursion</code>。内层<br><code>save-excursion</code>主要做了两件事，首先是将Emacs的注意力转移到<code>buffer</code>之上，随后为<br><code>start</code>以及<code>end</code>附上<code>buffer</code>的<code>point-min</code>和<code>point-max</code>的值，并且由于内层<br><code>save-excursion</code>已经求值完毕，那么会恢复在求值过程中可能变动的位点和标记的值。随<br>后外层<code>save-excursion</code>函数的第二个参量是将<code>buffer</code>参量的内容插入到当前buffer从<br><code>start</code>到<code>end</code>结束的内容，这个<code>start</code>和<code>end</code>也就是<code>buffer</code>参量所有的内容。随后又<br>把<code>newmark</code>变量绑定到值<code>point</code>之上，最后将<code>newmark</code>记录为<code>标记</code>。</p>\n<h2 id=\"beginning-of-buffer函数的完整定义\"><a href=\"#beginning-of-buffer函数的完整定义\" class=\"headerlink\" title=\"beginning-of-buffer函数的完整定义\"></a>beginning-of-buffer函数的完整定义</h2><p>前面我们尝试写了<code>beginning-of-buffer</code>函数的部分定义，它是一个无参量的函数，那么<br>这次我们来写一个有参量的<code>beginning-of-buffer</code>函数。</p>\n<p>这个带参量的<code>beginning-of-buffer</code>函数可以指定在当前缓冲区的几分之几标记位置。</p>\n<p>那么现来说下需求:<code>beginning-of-buffer</code>函数接受一个可选参量，这个参量的返回是1-10<br>之间，这个参量作为标记点的位置。</p>\n<h3 id=\"可选参量\"><a href=\"#可选参量\" class=\"headerlink\" title=\"可选参量\"></a>可选参量</h3><p>在需求里我们提到: </p>\n<blockquote>\n<p><code>beginning-of-buffer</code>函数接受一个可选参量</p>\n</blockquote>\n<p>除非特别声明，否则Lisp会认为函数的参量是必须在函数被调用时传递一个值给该参量的。<br>如果不传入参量，则该函数就会出错:<code>Wrong number of arguments</code>。</p>\n<p>而如果需要使一个或多个参量变为可选参数只需要在参量前加上<code>&amp;optional</code>关键字，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun beginning-of-defun-function-t (&amp;optional arg1 arg2)</span><br><span class=\"line\">  &quot;documentation&quot;</span><br><span class=\"line\">  (interactive &quot;P&quot;)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char</span><br><span class=\"line\">   ;; if-there-is-an-argument</span><br><span class=\"line\">   ;;   xxxx</span><br><span class=\"line\">   ;; else-go-to</span><br><span class=\"line\">   (point-min)))</span><br></pre></td></tr></table></figure>\n<p>对比前面的<code>simple-beginning-to-buffer</code>函数，好像唯一多的地方是在<code>goto-char</code>函数<br>的第一个参量，变成了<code>if</code>特殊表。这个<code>if</code>函数判断由<code>interactive</code>的<code>P</code>参量获得到的前<br>缀参量是否为一个非nil值，如果是则执行<code>if then</code>部分，否则执行跟<br><code>simple-beginning-to-buffer</code>一样的操作。</p>\n<h3 id=\"带参量的beginning-of-buffer函数\"><a href=\"#带参量的beginning-of-buffer函数\" class=\"headerlink\" title=\"带参量的beginning-of-buffer函数\"></a>带参量的beginning-of-buffer函数</h3><p><code>goto-char</code>函数中有一个<code>if</code>表达式，这个表达式做了很多关于算术的操作。 </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun beginning-of-defun-function-t (&amp;optional arg)</span><br><span class=\"line\">  &quot;documentation&quot;</span><br><span class=\"line\">  (interactive &quot;P&quot;)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char</span><br><span class=\"line\">   (if (&gt; (buffer-size) 10000)</span><br><span class=\"line\">       (/ (prefix-numeric-value arg) 10)</span><br><span class=\"line\">     (/</span><br><span class=\"line\">      (+ 10</span><br><span class=\"line\">         (*</span><br><span class=\"line\">          (buffer-size) (prefix-numeric-value arg))) 10))</span><br><span class=\"line\">   (point-min)))</span><br></pre></td></tr></table></figure>\n<p> 一眼看上去有些复杂，其实我们通过函数模板来揭开其中的奥秘，十分简单。</p>\n<p>我们看将<code>if</code>函数的结构看成这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (buffer-is-large</span><br><span class=\"line\">     divide-buffer-size-by-10-and-multiply-by-arg)</span><br><span class=\"line\">    else-use-alternate-calculation)</span><br></pre></td></tr></table></figure>\n<p>要吃饭了</p>\n<p>这里的<code>if</code>函数用于检查缓冲区的大小，这是因为书中使用的是第18版本的Elisp，其使用<br>了不大于800w的数字来描述缓冲区的大小，如果有在某次求值中遇到更大的缓冲区，Emacs</p>\n","site":{"data":{}},"excerpt":"<p>借了本Elisp的书，不厚，200多页，大概一周(两周)就能看完吧!</p>","more":"<h1 id=\"第一章-列表处理\"><a href=\"#第一章-列表处理\" class=\"headerlink\" title=\"第一章 列表处理\"></a>第一章 列表处理</h1><p>列表是Lisp的基础。</p>\n<h2 id=\"Lisp列表\"><a href=\"#Lisp列表\" class=\"headerlink\" title=\"Lisp列表\"></a>Lisp列表</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>简单的Lisp列表书写形式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(rose violet daisy buttercup) ;; =&gt; (rose violet daisy buttercup)</span><br></pre></td></tr></table></figure>\n<p>这个简单的列表中的四个元素时四种不同花的名称。<strong>元素之间用空格隔开，并且被括号包住。</strong></p>\n<p>另有一种在elisp中常用到的写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 2) ;; =&gt; 4</span><br></pre></td></tr></table></figure>\n<p>这种写法是Lisp的一个特性————<strong>数据和代码都用相同的方式表示</strong>。</p>\n<p><strong>列表还允许嵌套列表，也就是说列表的元素也可以是列表</strong>。</p>\n<h3 id=\"Lisp原子\"><a href=\"#Lisp原子\" class=\"headerlink\" title=\"Lisp原子\"></a>Lisp原子</h3><p>原子意味着”不可再分”。例如刚刚列表内的’2’或者是’rose’等等，这些都是原子。</p>\n<p>而列表却不是原子，因为<strong>列表是由CAR和CDR与CONS构成的</strong>。</p>\n<p>技术上说，Lisp的列表有三种组合方式:</p>\n<ul>\n<li>括号和括号中由空格分隔的原子</li>\n<li>括号和括号中的其他列表</li>\n<li>括号和括号中的其他列表和原子</li>\n</ul>\n<p><strong>一个列表可以仅有一个原子或完全没有原子</strong></p>\n<p>无任何原子的列表称作空列表: <code>()</code>。你可以把空列表看为原子或列表。</p>\n<p><em>原子和列表可以被称为<strong>符号表达式</strong>(symbolic expression)，又可称为<strong>S-表达式</strong> </em>。</p>\n<p>Lisp编程几乎都是关于列表中的符号的(且有时是关于数字的).</p>\n<p><strong>双引号中的文本，都是单个原子</strong>:<code>&#39;(Info &quot;Name:EvanMeek Age:18 Sex:Men**)</code></p>\n<p>这种被双引号括起来的文本叫做<strong>字符串(string)</strong>。</p>\n<h3 id=\"列表中的空格\"><a href=\"#列表中的空格\" class=\"headerlink\" title=\"列表中的空格\"></a>列表中的空格</h3><p>Lisp中括号的数量无关紧要。下面两个的列表是完全相同的。</p>\n<p>括号多<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(1 2 3 4      5       6) ;; =&gt; (1 2 3 4 5 6)</span><br></pre></td></tr></table></figure></p>\n<p>括号少<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(1 2 3 4 5 6) ;; =&gt; (1 2 3 4 5 6)</span><br></pre></td></tr></table></figure></p>\n<p>适当的在列表中加入一些空格以及换行符可以提高可读性。</p>\n<h3 id=\"GNU-Emacs帮助你输入列表\"><a href=\"#GNU-Emacs帮助你输入列表\" class=\"headerlink\" title=\"GNU Emacs帮助你输入列表\"></a>GNU Emacs帮助你输入列表</h3><p>在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用<code>Tab</code>按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是<code>C-M-\\</code></p>\n<p>并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。</p>\n<p>有兴趣的可以看下这个知乎提问。<a href=\"https://www.zhihu.com/question/356026550\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/356026550</a></p>\n<h2 id=\"运行一个程序\"><a href=\"#运行一个程序\" class=\"headerlink\" title=\"运行一个程序\"></a>运行一个程序</h2><p>如果你想运行一段Lisp程序，那么计算机可能会做三种事:</p>\n<ul>\n<li>只返回列表本身;</li>\n<li>提示出错信息;</li>\n<li>将列表中第一个符号作为要执行的命令;<br>大多数情况，我们希望计算机做的是第三件事</li>\n</ul>\n<p>前面我们看到过一些列表的前面有一个单引号”‘“，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;(只是返回本身 即可) ;; =&gt; (只是返回本身 即可)</span><br></pre></td></tr></table></figure>\n<p>而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 1 2 3 4) ;; =&gt; 10</span><br></pre></td></tr></table></figure>\n<p>Emacs中可以将光标放置一对S-表达式后按 <code>C-x C-e</code>就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 <code>mini buffer</code>。</p>\n<p>也可以对原子(没有被括号括起来)求值</p>\n<h2 id=\"产生错误消息\"><a href=\"#产生错误消息\" class=\"headerlink\" title=\"产生错误消息\"></a>产生错误消息</h2><p>编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。</p>\n<p>下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Just Error!) ;; =&gt; Symbol&apos;s function definition is void: Just</span><br></pre></td></tr></table></figure>\n<p>这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将<code>(Just Error!)</code>当成类似<code>(+ 1 2)</code>这种列表进行求值，但由于后者的第一个元素”+”是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素”Just”是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。</p>\n<p> ##</p>\n<p>我们已经讨论过一些符号或函数，例如”+”。就以”+”为例子，当我们对<code>(+ 2 2)</code>表达式求值时，计算机并不是执行的”+”这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把”+”改为”Plus”。</p>\n<h2 id=\"Lisp解释器\"><a href=\"#Lisp解释器\" class=\"headerlink\" title=\"Lisp解释器\"></a>Lisp解释器</h2><p>下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。</p>\n<ul>\n<li>首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。</li>\n<li>若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。</li>\n<li><p>若没有则提示错误消息。<br>以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。</p>\n</li>\n<li><p>第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。</p>\n</li>\n<li>第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。</li>\n<li>第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。</li>\n</ul>\n<p>否则Lisp解释器将会从左往右依次执行。</p>\n<h3 id=\"字节编译\"><a href=\"#字节编译\" class=\"headerlink\" title=\"字节编译\"></a>字节编译</h3><p>Lisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。</p>\n<p>被编译成字节码后的源码叫做elc，可以通过命令<code>(byte-compile-file)</code>进行编译。</p>\n<h2 id=\"求值\"><a href=\"#求值\" class=\"headerlink\" title=\"求值\"></a>求值</h2><p>前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。</p>\n<p>解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。</p>\n<p>解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。</p>\n<h3 id=\"对一个内部列表求值\"><a href=\"#对一个内部列表求值\" class=\"headerlink\" title=\"对一个内部列表求值\"></a>对一个内部列表求值</h3><p>上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。</p>\n<p>下面通过一个例子了解这个求值的过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 1 (+ 2 3))</span><br></pre></td></tr></table></figure>\n<p>我们知道使用快捷键<code>C-x C-e</code>可以对一个表达式求值，那么我们将光标放置<code>(+ 2 3)</code>表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值<code>5</code>，那么再将光标放置整个表达式之后，按下快捷键得到返回值<code>6</code>。这就很好的解释了Lisp解释器对嵌套列表的求值过程。</p>\n<p>我们可以通过快捷键<code>C-h k</code>然后键入<code>C-x C-e</code>查看这个快捷键所对应的符号(命令\\函数)，也就是<code>eval-last-sexp</code>。 这个函数的作用是<strong>对最近的一个表达式进行求值，并且将结果打印至输出区域</strong>。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)?</p>\n<p><strong>在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)</strong>，并且符号的值是可变的，我们把一个有值的符号称为变量。</p>\n<p>前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。<strong>Lisp的符号可以同时具有一个函数定义和一个值。</strong>我们可以把这种概念想象成具有多个抽屉的柜子。</p>\n<p>例如变量<code>fill-column</code>是一个有值的符号，对它求值可以获取自动换行的字符数。</p>\n<p>任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。</p>\n<p><code>fill-column</code>只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(fill-column) ;; =&gt; Symbol&apos;s function definition is void: fill-column</span><br></pre></td></tr></table></figure>\n<p>这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。</p>\n<h3 id=\"符号无值时的错误信息\"><a href=\"#符号无值时的错误信息\" class=\"headerlink\" title=\"符号无值时的错误信息\"></a>符号无值时的错误信息</h3><p>下面我对一个没有赋值的符号进行求值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 2) ;; =&gt; 4</span><br></pre></td></tr></table></figure></p>\n<p>很显然，如果是在这个表达式右括号后执行<code>eval-last-sexp</code>将不会有任何问题，但我们现在将光标移动至<code>+</code>后，执行<code>eval-last-sexp</code>，会引发这个报错提示:<code>Symbol&#39;s value as variable void: +</code>。</p>\n<p>这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于<code>+</code>的变量，只找到了函数定义，因为就报错了。</p>\n<h2 id=\"参量\"><a href=\"#参量\" class=\"headerlink\" title=\"参量\"></a>参量</h2><p>参量对应着<code>argument</code>，也就是其他语言中参数的意思。例如<code>(+ 2 3**</code>这个列表的参数就是<code>2</code>和<code>3</code>，而这个<code>+</code>则是函数，<code>+</code>允许由多个参量。</p>\n<p><strong>不同的函数需要不同数目的参量，有些函数甚至不需要参量。</strong></p>\n<h3 id=\"参量的数据类型\"><a href=\"#参量的数据类型\" class=\"headerlink\" title=\"参量的数据类型\"></a>参量的数据类型</h3><p>函数所接收的参量也是有数据类型的限制的，例如<code>+</code>函数就规定其参量的值必须是数字。</p>\n<p>有些函数允许有任意数量个参量，例如<code>concat</code>函数，它将任意多个字符串类型的参量合并为一个字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(concat &quot;My name is:&quot; &quot;EvanMeek&quot;) ;; =&gt; &quot;My name is: EvanMeek&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>请注意，<code>concat</code>函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。</strong></p>\n<p>例如我们可以在<code>concat</code>的参量中写上<code>substring</code>函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(concat &quot;Nice to meet &quot; (substring &quot;fuck you&quot; 5 8))</span><br></pre></td></tr></table></figure>\n<p>上面的<code>concat</code>是一个参量必须都为字符串类型且任意数量的函数，而<code>substring</code>是一个可变数量参量且有多种参量类型的函数。<br><code>substring</code>是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称<code>原子分裂机</code>。</p>\n<h3 id=\"作为变量和列表的值的参量\"><a href=\"#作为变量和列表的值的参量\" class=\"headerlink\" title=\"作为变量和列表的值的参量\"></a>作为变量和列表的值的参量</h3><blockquote>\n<p>上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。</p>\n</blockquote>\n<p>这一节，我们将谈谈函数的参量还支持那些。</p>\n<p>函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; 结果可能不同，取决于你的Emacs配置。</span><br><span class=\"line\">(+ 2 fill-column) ;; =&gt; 82</span><br></pre></td></tr></table></figure>\n<p>并且参量还可以是一个列表，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 (+ 3 (+ 4))) ;; =&gt;  9</span><br></pre></td></tr></table></figure>\n<h3 id=\"数目可变的参量\"><a href=\"#数目可变的参量\" class=\"headerlink\" title=\"数目可变的参量\"></a>数目可变的参量</h3><p>前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的<code>+</code>函数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+) ;; =&gt; 0</span><br><span class=\"line\">(+ 2) ;; =&gt; 2</span><br></pre></td></tr></table></figure>\n<p>又或是<code>\\*</code>函数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*) ;; =&gt; 1</span><br><span class=\"line\">(* 2) ;; =&gt; 2</span><br></pre></td></tr></table></figure>\n<p>所以它们都具有一个特性————参量数量可变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(* 1 2 3) ;; =&gt; 66</span><br><span class=\"line\">(+ 1 2 3) ;; =&gt; 6</span><br></pre></td></tr></table></figure>\n<h3 id=\"用一个错误类型的数据对象作为参量\"><a href=\"#用一个错误类型的数据对象作为参量\" class=\"headerlink\" title=\"用一个错误类型的数据对象作为参量\"></a>用一个错误类型的数据对象作为参量</h3><p>试想下，如果我们对函数提供了错误类型的参量会发生什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(+ 2 &apos;hello) ;; =&gt; Wrong type argument: number-or-marker-p,hello</span><br></pre></td></tr></table></figure>\n<p>我们知道<code>+</code>函数的参量必须是数字，而我们传入的参量2的<code>&#39;hello</code>被Lisp解释器操作时会试图将<code>2</code>和<code>&#39;hello</code>的返回值相加，但是<code>&#39;hello</code>的返回值不是一个数字，所以就会引发这个错误。</p>\n<p>让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号<code>number-or-marker-p</code>这个符号意味着:Lisp解释器提示我们<code>+</code>函数的参量所需的数据类型，<code>number</code>也就是数字，而<code>marker</code>是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而<code>p</code>则是Lisp的一个历史问题(早期Lisp程序员中用”p”替代”predicate”用于表示是否为真)，类似的有<code>zerop</code>用于判断参量值是否为零。最后的<code>hello</code>则是我们传给<code>+</code>函数出错的参量的值。</p>\n<h3 id=\"message函数\"><a href=\"#message函数\" class=\"headerlink\" title=\"message函数\"></a>message函数</h3><p><code>message</code>函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个<code>FORMAT STRING</code>(可格式化字符串)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;Should you sleep now?&quot;) ;; =&gt; Should you sleep now?</span><br></pre></td></tr></table></figure>\n<p>双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;The name of this buffer is: %s&quot; (buffer-name)) ;; =&gt; &quot;The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<p>这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串<code>%s</code>，<code>message</code>函数的第二个参量的值将用于它，这个<code>%s</code>代表了接收一段字符传，类似的还有<code>%d</code>用于接收一个十进制数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;The value of fill-column is %d&quot; fill-column) ;; =&gt; &quot;The value of fill-column is 80&quot;</span><br></pre></td></tr></table></figure>\n<p>这些特殊子串都支持变量、列表或符号，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;我想吃%s，各来%d斤!&quot; (concat &quot;苹果、&quot; &quot;梨子、&quot; &quot;葡萄&quot;) (+ 1 1)) ;; =&gt; &quot;我想吃苹果、梨子、葡萄，各来2斤!&quot;</span><br></pre></td></tr></table></figure>\n<p>从第二个参量开始将会一次取代第一个参量中特殊子串的位置。</p>\n<h2 id=\"给一个变量赋值\"><a href=\"#给一个变量赋值\" class=\"headerlink\" title=\"给一个变量赋值\"></a>给一个变量赋值</h2><p>这一小节学习为一个变量赋值，常用的操作有<code>set</code>、<code>setq</code>、<code>let</code>，在这节主要将<code>set</code>和<code>setq</code>。并且描述这两个函数是如何工作的。</p>\n<h3 id=\"使用set函数\"><a href=\"#使用set函数\" class=\"headerlink\" title=\"使用set函数\"></a>使用set函数</h3><p>我们要为<code>flowers</code>符号附上一个列表值，那么可以这么写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(set &apos;flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰)</span><br></pre></td></tr></table></figure></p>\n<p>这意味着我们将列表<code>菊花 百合...</code>绑定给了<code>flowers</code>符号。</p>\n<p>两个参量的引用是为了让其不要求值，所以你可以知道<code>set</code>函数的第一个参量最好要加上引用，这大概是很常用的搭配。</p>\n<h3 id=\"使用setq函数\"><a href=\"#使用setq函数\" class=\"headerlink\" title=\"使用setq函数\"></a>使用setq函数</h3><p><code>setq</code>函数与<code>set</code>函数很相似，它们只有一个区别，就是<code>setq</code>函数会自动给第一个参量加上引用，例如用<code>setq</code>完成上一小节的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰)</span><br></pre></td></tr></table></figure>\n<p>并且它们俩都是可以为多个变量绑定多个值的，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq 学生 &apos;(学号 地址 姓名 电话)</span><br><span class=\"line\">      老师 &apos;(教师号 地址 姓名 电话))</span><br><span class=\"line\">学生 ;; =&gt; (学号 地址 姓名 电话)</span><br><span class=\"line\">老师 ;; =&gt; (教师号 地址 姓名 电话)</span><br></pre></td></tr></table></figure>\n<p>其中参量二绑定给参量一，参量四绑定给参量三，以此类推。</p>\n<h3 id=\"计数\"><a href=\"#计数\" class=\"headerlink\" title=\"计数\"></a>计数</h3><p>就是用<code>setq</code>函数完成了一个递增的操作。</p>\n<p>首先生成一个初始化器，再生成一个递增器，再进行输出数值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq count 0) ;; 初始器</span><br><span class=\"line\">(setq count (1+ count)) ;; 递增器</span><br><span class=\"line\">count ;;输出</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>记录一下，加油努力，毕竟书中都说了，我已经跨过了最陡峭的那段山路。</p>\n<ul>\n<li>Lisp程序由表达式组成，表达式是列表或单个原子。</li>\n<li>列表由0个或更多的原子或内部列表组成，原子或列表之间由空格隔开，并由括号括起来，列表可为空。</li>\n<li>原子是多字符的符号(如fill-column)，单字符的符号(如+号)，双引号之间的字符串或者数字。</li>\n<li>对数字求值就是其本身</li>\n<li>对双引号之间的字符串求值也是其本身</li>\n<li>当对一个符号求值时，将返回它的值。</li>\n<li>当对一个列表求值时，Lisp解释器查看列表首符号绑定在其上的函数定义，并执行其指令。</li>\n<li>单引号告诉Lisp解释器返回后续表达式的书写形式，而不是像没有单引号时那样对其求值。</li>\n<li>参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。</li>\n<li><p>当对一个函数求值时总是返回一个值(除非得到错误信息)。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。</p>\n<p><strong>最后，希望这篇博客可以记录好第一章所讲。</strong></p>\n</li>\n</ul>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>一个一个来，题目写在博客内吧…</p>\n<ul>\n<li>通过对一个不在括号内的适当符号求值，产生一个错误信息。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个不存在的变量 ;; =&gt; Symbol&apos;s value as variable is void: 一个不存在的变量</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过对一个在括号内的适当符号求值，产生一个错误信息。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(又一个不存在的符号) ;; =&gt; Symbol&apos;s function definition is void: 又一个不存在的符号</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个每次增加2而不是1的计数器。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(setq count 0) ;; 初始器 </span><br><span class=\"line\">(setq count (+ 2 count)) ;; 递增器</span><br><span class=\"line\">count ;;输出</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写一个表达式，当对它求值时，它在回显区输出一条消息。</li>\n</ul>\n<p>解答:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(message &quot;这段消息是要输出至%s%s的&quot; &apos;回显 &quot;区&quot;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二章-求值实践\"><a href=\"#第二章-求值实践\" class=\"headerlink\" title=\"第二章 求值实践\"></a>第二章 求值实践</h1><p>这一章主要讲了关于buffer的一些知识，讲了一些关于buffer的函数，并且讲解了一些buffer的注意事项。</p>\n<h2 id=\"缓冲区名\"><a href=\"#缓冲区名\" class=\"headerlink\" title=\"缓冲区名\"></a>缓冲区名</h2><p>讲了两个函数，分别是<code>(buffer-name)</code>以及<code>(buffer-file-name)</code>。</p>\n<p>首先得清楚buffer和文件的概念，buffer的中文翻译叫做缓冲区，它其实是将文件中的内容拷贝到Emacs中，所以在我们修改buffer时，文件并不会改动，只有当我们进行保存修改时才会。而文件是保存在磁盘上的信息，人们常常在修改buffer时说成”我在修改xx文件”，这严格意义上讲是错误的，但人们都知道其实我只是在修改buffer，而不是那个文件，只不过说成文件罢了，所以各位小伙伴不要误解。</p>\n<p>计算机没有人类那么聪明，所以大家在写代码时要分清楚这两个的不同。</p>\n<figure class=\"highlight plain\"><figcaption><span>(buffer-name) ;; </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-file-name) ;; =&gt;&quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>表达式<code>(buffer-name)</code>用于获取当前buffer的名称而<code>(buffer-file-name)</code>用于获取当前buffer所对应文件的完整路径</strong>，还要说明一点，并不是所有的buffer都有所对应的文件，例如<code>\\*scratch\\*</code>buffer就没有所对应的文件。</p>\n<h2 id=\"获得缓冲区\"><a href=\"#获得缓冲区\" class=\"headerlink\" title=\"获得缓冲区\"></a>获得缓冲区</h2><p>如果想获得缓冲区本身，那么可以使用<code>current-buffer</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br><span class=\"line\">(current-buffer) ;; =&gt; #&lt;buffer 《GNU-Emacs-Lisp编程入门》读书笔记.md&gt;</span><br></pre></td></tr></table></figure>\n<p>我们发现这两个函数的返回值挺相似的，但实际上他们却完全不同，<code>buffer-name</code>获取到的只是一个名称罢了，而<code>current-buffer</code>函数获取到的是一个名称所指向的对象或实体。举个生活上的例子:你对小明说:”小明，帮我拿个苹果”，然后小明就拿给了你”苹”和”果”字，显然这不是你真正想要的，你想要的是叫苹果的那个实体，可以吃的，有维生素的水果。经过这个例子，希望大家都能理解。 </p>\n<h2 id=\"切换缓冲区\"><a href=\"#切换缓冲区\" class=\"headerlink\" title=\"切换缓冲区\"></a>切换缓冲区</h2><p>先介绍一个函数————<code>other-buffer</code>，这个函数用于发挥最近常打开过的buffer对象。例如最近常在<code>\\*scratch\\*</code>与<code>test.el</code>之间切换buffer，那么当前buffer为<code>\\*scratch\\*</code>时调用<code>(other-buffer)</code>时将会返回<code>test.el</code>的buffer对象。</p>\n<p>再介绍一个函数————<code>switch-to-buffer</code>，这个函数接收一个<code>Buffer</code>对象的参量，可以切换当前buffer为<code>Buffer</code>参量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br><span class=\"line\">(other-buffer) ;; =&gt; #&lt;buffer *Backtrace*&gt;</span><br><span class=\"line\">;; 根据最近最常打开过的buffer对象切换buffer</span><br><span class=\"line\">(switch-to-buffer (other-buffer))</span><br><span class=\"line\">(buffer-name) ;; =&gt; &quot;*Backtrace*&quot;</span><br></pre></td></tr></table></figure>\n<p>如果想要回到上一个buffer可以键入键序列<code>C-x b RET</code>，RET是回车。</p>\n<p>前面几次提到<code>调用(call)</code>这个概念，实际上Lisp解释器对一个列表的首元素为一个函数进行处理时，就是在调用那个函数。</p>\n<h2 id=\"缓冲区大小和位点的定位\"><a href=\"#缓冲区大小和位点的定位\" class=\"headerlink\" title=\"缓冲区大小和位点的定位\"></a>缓冲区大小和位点的定位</h2><p>先为大家介绍下四个函数:</p>\n<ul>\n<li><code>(point)</code><br>;; 获取当前光标在当前buffer的位点。</li>\n<li><code>(buffer-size)</code><br>;; 获取当前buffer的字符数(包括空格)</li>\n<li><code>(point-min)</code><br>;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始</li>\n<li><code>(point-max)</code><br>;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; 获取当前buffer的字符数(包括空格)</span><br><span class=\"line\">(buffer-size) ;; =&gt; 10636</span><br><span class=\"line\">;; 获取当前光标在当前buffer的位点。</span><br><span class=\"line\">(point) ;; =&gt; 10525</span><br><span class=\"line\">;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始</span><br><span class=\"line\">(point-min) ;; =&gt; 1</span><br><span class=\"line\"></span><br><span class=\"line\">;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。</span><br><span class=\"line\">(point-max) ;; =&gt; 10670</span><br></pre></td></tr></table></figure>\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>找一个文件，对它进行操作，将光标移动到缓冲区的中间部分。找出它的缓冲区名、文件名、长度、和你在文件中的位置。</p>\n<ul>\n<li>缓冲区名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-file-name) ;; =&gt; &quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>长度</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(buffer-size) ;; =&gt; 11005</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在文件中的位置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(point) ;; =&gt; 11033</span><br></pre></td></tr></table></figure>\n<h1 id=\"第三章-如何编写函数定义\"><a href=\"#第三章-如何编写函数定义\" class=\"headerlink\" title=\"第三章 如何编写函数定义\"></a>第三章 如何编写函数定义</h1><p>本章内容较多，不止于函数定义，还介绍了一些常用的函数。</p>\n<h2 id=\"defun-特殊表\"><a href=\"#defun-特殊表\" class=\"headerlink\" title=\"defun 特殊表\"></a>defun 特殊表</h2><p><code>defun</code>不以通常的方式对它的参量求值，因为它是特殊表。</p>\n<p>这节将简单描述函数定义的过程。</p>\n<p>一个函数定义在<code>defun</code>之后最多可有5个部分:</p>\n<ul>\n<li>符号名，这个符号指向了这个函数的定义。</li>\n<li>一个列表，包含了要传给函数的参量。若没有任何参量要传递，那么可以写空列表。</li>\n<li>这个函数的文档，由双引号括住，此选项为可选。</li>\n<li>使当前函数成为一个交互式函数的列表，此选项为可选。交互式函数将会在后的小节讲到。</li>\n<li>函数的主题，也就是一系列的命令。<br>下面是一个包含了五个部分的函数模板:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun funciton-name (arguments...)</span><br><span class=\"line\">  &quot;optional-documentation&quot;</span><br><span class=\"line\">  (interactive argument-passing-info) ;; optional</span><br><span class=\"line\">  body...)</span><br></pre></td></tr></table></figure>\n<p>我们通过这个模板写一个简单的函数吧，这个函数的功能呢是让其参量乘以7。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun multiply-by-seven (number)</span><br><span class=\"line\">  &quot;使number(参量)乘以7&quot;</span><br><span class=\"line\">  (* number 7))</span><br></pre></td></tr></table></figure>\n<p>这个函数的函数名就是<code>multiply-by-seven</code>，而函数名后面的列表也就是函数的参量，当我们调用函数时，传递给函数的参量的值就会被绑定到这个<code>number</code>上。并且<code>number</code>也可以为其他的名称，这取决于写代码的人，你可以改为<code>multiplicand</code>，这可能更符合函数定义的意思。并且这里的<code>number</code>的范围是仅在函数定义内才有效的，如果我们在函数定义外对<code>number</code>求值，可能会返回个错误信息。所以说，参量列表内的参量名可以是任意的，只要不与参量列表内的其他参量相同即可。这就比如：你班上的外号叫李大头，那么在这个班里的李大头代表的人就是你，而如果是在学校中，也有人的名字叫李大头，这时这个李大头就不代表你了。</p>\n<p>跟随参量列表后的叫做函数文档，它的作用是当我们或任何人使用<code>C-h f</code>并键入函数名时所查看的函数帮助文档中的文本。这里还要注意一点，有些函数例如<code>apropos</code>在查看函数文档时会只显示文档的第一行，所以我们要在第一行就尽量写清楚这个函数的作用。通过<code>C-h f</code>查看函数文档将会弹出一个<code>\\*Help\\*</code>Buffer。</p>\n<p>而这个例子的第三行就是函数的主体(往往比例子里多很多**，它是一个列表，功能是将<code>number</code>乘以7。</p>\n<p>函数定义好了，但我们不要直接尝试调用，我先告诉你们调用的方式吧，<strong>把函数名作为一个列表的首元素，其余的作为参量</strong>最后eval即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(multiply-by-seven 7)</span><br></pre></td></tr></table></figure></p>\n<p>但可千万不要急着求值，因为肯定会报错。这主要是因为你只是写好了函数定义，并没有把函数定义给安装上。</p>\n<h2 id=\"安装函数定义\"><a href=\"#安装函数定义\" class=\"headerlink\" title=\"安装函数定义\"></a>安装函数定义</h2><p>将光标移动到我们写好的函数定义之后，eval一下即可安装好函数。安装完成后的函数就被包含在Emacs之中了，直到退出Emacs之前。如果已经尝试安装函数定义的童鞋应该已经发现了，在我们eval函数定义后，会在回显区显示函数名，这就代表我们成功安装了这个函数。</p>\n<h3 id=\"改变函数定义\"><a href=\"#改变函数定义\" class=\"headerlink\" title=\"改变函数定义\"></a>改变函数定义</h3><p>想要修改已经安装好的函数定义很简单，我们只需要重新安装一遍即可，例如我们想要将<code>multiply-by-seven</code>函数改为用<code>+</code>来实现，这样做:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun multiply-by-seven (number)</span><br><span class=\"line\">  &quot;使number(参量)加7次&quot;</span><br><span class=\"line\">  (+ number number number number number number number)) ;; =&gt; multiply-by-seven</span><br><span class=\"line\"></span><br><span class=\"line\">(multiply-by-seven 7) ;; =&gt; 49</span><br></pre></td></tr></table></figure>\n<p>所以编写Emacs Lisp代码时的流程通常是:<strong>写函数，装函数，测函数，改函数，装函数</strong>。</p>\n<h2 id=\"使函数成为交互式函数\"><a href=\"#使函数成为交互式函数\" class=\"headerlink\" title=\"使函数成为交互式函数\"></a>使函数成为交互式函数</h2><p>交互式函数的特点是可以通过<code>M-x</code>调用，还可以通过键序列调用，例如常用的移动光标<code>C-n</code>就是一个交互式函数，并且交互式函数是不会自动将返回值输出至回显区的，因为让一个函数称为交互式函数通常被认为是想得到函数的附加效果，而不是返回值。</p>\n<p>想要使一个函数称为交互式函数，可以在函数定义时，将<code>defun</code>特殊表开头的列表的第四个元素写成一个<code>interactive</code>特殊表开头的列表。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun multiply-by-seven-interactive (number)</span><br><span class=\"line\">  &quot;打印 number(参量) 乘以 7</span><br><span class=\"line\">这是个交互式函数&quot;</span><br><span class=\"line\">  (interactive &quot;p&quot;)</span><br><span class=\"line\">  (message &quot;7 * %d = %d&quot; number (* number 7))) ;; =&gt; multiply-by-seven-interactive</span><br></pre></td></tr></table></figure>\n<p>安装好这个函数后，可以有三种方式调用它:</p>\n<ul>\n<li>对表达式<code>(multiply-by-seven-interactive 7**</code>求值</li>\n<li>键入<code>C-u</code>然后输入一个数字作为函数的参量，键入<code>M-x</code>然后键入函数名最后键入<code>RET</code>。</li>\n<li>还有一种暂时没搞成功，等学到16章的第7节就知道了。</li>\n</ul>\n<p><strong>交互式函数不会自动将返回值打印至回显区</strong> 并且当使用第二种调用方式时，没有在<code>C-u</code>之后键入数字的话将会以默认值4来替代。</p>\n<h3 id=\"交互的multiply-by-seven函数\"><a href=\"#交互的multiply-by-seven函数\" class=\"headerlink\" title=\"交互的multiply-by-seven函数\"></a>交互的multiply-by-seven函数</h3><p>我们为<code>multiply-by-seven</code>函数定义了交互式版本，但没有解释其中的<code>(interactive &quot;p&quot;)</code>列表是个什么东西，这里就说一下。</p>\n<p>首先<code>(interactive &quot;p&quot;)</code>中的<code>p</code>代表将接收一个前缀参量，这个前缀参量也就是我们通过<code>C-u 数字 M-x 函数名</code>这种方式调用时的<code>数字</code>了，例如这个数字是<code>5</code>那么就会把<code>5</code>传递给<code>number</code>参量，然后在<code>message</code>函数中的<code>(* 7 5)</code>求值，最终由于函数是一个交互式函数，所以函数不会自动将返回值输出到回显区中，而<code>message</code>函数的返回值原本是带双引号的，由于是交互式函数，我们要的只是函数带来的附加效果，而不是返回值。</p>\n<h3 id=\"interactive函数的不同选项\"><a href=\"#interactive函数的不同选项\" class=\"headerlink\" title=\"interactive函数的不同选项\"></a>interactive函数的不同选项</h3><p>前面已经解释过<code>interactive</code>函数的<code>p</code>选项，其实<code>interactive</code>特殊表有20多个预定义的选项，我们可以结合多个选项使得将信息正确交互地选送给函数。</p>\n<p>下面介绍两个选项，首先是<code>r</code>，<strong>它可以让Emacs将位点所在区域的开始值和结束值作为函数的两个参量</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(interactive &quot;r&quot;) ;; =&gt; (13945 13978)</span><br></pre></td></tr></table></figure>\n<p>再则是<code>B</code>选项，<strong>它可告诉Emacs用缓冲区的名字作为函数的参量</strong>，它会让Emacs在小缓冲区提示用户输入缓冲区名字，并将跟在<code>B</code>后面的字符串作为提示，而且Emacs还会进行函数名的补全（按TAB）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; 会出来一个交互式的窗口</span><br><span class=\"line\">(interactive &quot;B请输入Buffer名称:&quot;) ;; =&gt; (&quot;test.el&quot;)</span><br></pre></td></tr></table></figure>\n<p>下面再看一个例子，可以获取任意Buffer所对应的文件路径以及位点的开始及结束点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun get-buffer_name-point_start-point_end (buffer start end)</span><br><span class=\"line\">  &quot;获取buffer所对应的文件以及位点的开始结束值&quot;</span><br><span class=\"line\">  (interactive &quot;B请输入Buffer名称: \\nr&quot;)</span><br><span class=\"line\">  (message &quot;Buffer-file:%s\\npoint-start:%d\\npoint-end:%d&quot;(buffer-file-name (get-buffer buffer)) start end))</span><br></pre></td></tr></table></figure>\n<p>通过<code>interactive</code>的<code>B</code>选项获取任意buffer的名称，再通过<code>r</code>选项后去位点的开始和结束值。最后在输出时通过<code>get-buffer</code>获取Buffer对象，从而达到目的。</p>\n<p><strong><code>interactive</code>是支持控制字符的，例如上个例子中用到的<code>\\n</code>。并且<code>interactive</code>还可以无参量，这样的话跟<code>mark-whole-buffer</code>函数差不多。如果<code>interactive</code>的选项不能满足你的要求，那么你可以将参量传递给<code>nteractive</code>做为一个列表。</strong></p>\n<h3 id=\"永久地安装代码\"><a href=\"#永久地安装代码\" class=\"headerlink\" title=\"永久地安装代码\"></a>永久地安装代码</h3><p>前面我们写了那么多的函数，在我们没有关闭Emacs之前这些函数都是可以被我们随意求值的，但是当我们关闭Emacs之后再打开就必须重新安装函数才能求值了。所以有几种方式可以永久地安装函数或其他的代码。</p>\n<ul>\n<li>如果代码作为个人使用，可以把函数定义的代码放到<code>.emacs</code>初始化文件中，当启动Emacs时，将会自动对<code>.emacs</code>文件中的代码求值。</li>\n<li>如果代码很多，可以将函数定义存放至多个文件，然后使用<code>load</code>函数使得emacs对单独存放函数的文件求值。</li>\n<li>如果是当前计算机其他用户需要使用的代码，可以将代码放入<code>site-init.el</code>文件中，这样使得所有的用户都可以使用你的代码。</li>\n<li>如果你想让你的作为全世界的人使用，那么你可以将代码放到互联网上，或着给自由软件基金会发送一份拷贝，它有可能被加入下一个发行版本中。</li>\n</ul>\n<p><strong>Emacs在过去的年代里成长的道路————奉献。</strong></p>\n<h2 id=\"let函数\"><a href=\"#let函数\" class=\"headerlink\" title=\"let函数\"></a>let函数</h2><p><code>let</code>函数与<code>defun</code>函数一样，都是EmacsLisp中的特殊表。</p>\n<p><code>let</code>函数将一个符号附着到或者绑定到一个值上。这些被绑定的值是只能在<code>let</code>函数之内使用，就像说<code>defun</code>特殊表举的例子，两个同名的事物在不同的场景下代表了不同的意思，例如你的房子和你朋友的房子都是房子，你对你朋友说，你要粉刷房子，在你听来是要粉刷你家的房子，但你朋友有可能会认为你要粉刷他的房子。</p>\n<p>而<code>let</code>函数就避免了这种问题，在<code>let</code>函数中绑定的变量都只能在<code>let</code>函数中访问，这就是局部变量的概念。</p>\n<p><code>let</code>函数跟<code>setq</code>以及<code>set</code>函数有个很大的区别就在于:</p>\n<ul>\n<li><code>let</code>函数绑定的变量可有任意个 <code>setq</code>和<code>set</code>只能有一个</li>\n<li><code>let</code>函数可以执行一个或多个列表。</li>\n<li><code>let</code>函数绑定的变量都是局部的。</li>\n</ul>\n<h3 id=\"let表达式的各个部分\"><a href=\"#let表达式的各个部分\" class=\"headerlink\" title=\"let表达式的各个部分\"></a>let表达式的各个部分</h3><p><code>let</code>表达式分为三个部分，第一个就是<code>let</code>符号，第二个是变量列表，第三个是主体。</p>\n<p><strong>第二个部分的变量列表是由一个列表组成的，这个列表内可以是任意多个符号或任意多个由两个元素组成且第一个元素必定是符号的列表。*</strong></p>\n<p><strong>第三个部分是<code>let</code>表达式主体，由任意多个列表组成。</strong></p>\n<p><code>let</code>表达式的模板看起来像:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(let varlist body...)</span><br></pre></td></tr></table></figure>\n<p>其中变量列表的符号是由<code>let</code>特殊表赋初始化值的变量.符号本身的初始值是nil.而作为两元素列表的首元素的每一个符号被绑定到对第二个元素求值后的返回值.</p>\n<p>所以一个简单的变量列表看起来可能是这样的:<code>(apple (pear 10))</code>.在这个例子中,<code>apple</code>的值是nil,因为我们没有为其赋予初始值.而<code>pear</code>的值为10.</p>\n<p>那么当变量是由两个元素的列表组成,就可以是下面这样的模板:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(let ((variable value) (variable value) variable...)</span><br><span class=\"line\">  (body1)</span><br><span class=\"line\">  (body2)...)</span><br></pre></td></tr></table></figure>\n<h3 id=\"let表达式例子\"><a href=\"#let表达式例子\" class=\"headerlink\" title=\"let表达式例子\"></a>let表达式例子</h3><p>现在需要创建一些关于水果的栗子,不同的水果有不同的数量.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(let (apple (pear 10) (banana &apos;4斤) watermelon)</span><br><span class=\"line\">  (message &quot;苹果数量:%S\\t梨子数量:%d\\t香蕉数量:%s\\t西瓜数量:%S&quot; apple pear banana watermelon)) ;; =&gt; &quot;苹果数量:nil\t梨子数量:10\t香蕉数量:4斤\t西瓜数量:nil&quot;</span><br></pre></td></tr></table></figure>\n<p>我们创建了两个初始值为nil的变量<code>apple</code>和<code>watermelon</code>,以及一个绑定到10的变量pear,还有一个绑定到<code>4斤</code>的变量banana.随后在<code>let</code>主体中将创建的变量都用<code>message</code>函数打印在回显区.</p>\n<h3 id=\"let语句中的未初始化变量\"><a href=\"#let语句中的未初始化变量\" class=\"headerlink\" title=\"let语句中的未初始化变量\"></a>let语句中的未初始化变量</h3><p>在<code>let</code>表达式的变量列表中,允许不给予变量初始化值,那么Lisp解释器将会为其默认绑定到nil值上.</p>\n<p>并且,如果没有给予初始值,那么它可以称作:<code>作为独立的原子出现</code>.</p>\n<h2 id=\"if特殊表\"><a href=\"#if特殊表\" class=\"headerlink\" title=\"if特殊表\"></a>if特殊表</h2><p><code>if</code>函数是除了<code>defun</code>/<code>let</code>特殊表之外的一个特殊表,它用于让计算机做一些判断的工作.</p>\n<p>首先来看<code>if</code>函数的模板:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if if-part</span><br><span class=\"line\">    then)</span><br></pre></td></tr></table></figure>\n<p>其工作方式是：首先测试<code>if-part</code>的返回值是否不为nil，如果不为nil，那么就执行<code>then</code>的表达式。</p>\n<p><strong>通常会把then部分放在if-part的下一行，这样更有利于阅读。</strong></p>\n<p>下面做一个简单的栗子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (&gt; 5 4)</span><br><span class=\"line\">    (message &quot;5 比 4 大!&quot;)) ;; =&gt; &quot;5 比 4 大!&quot;</span><br></pre></td></tr></table></figure>\n<p>其中<code>&gt;</code>函数测试它的第一个参量和第二个参量进行比较大小，如果第一个参量大于第二个参量则返回“真”，否则返回nil。</p>\n<p>可往往在日常编码中，<code>if-part</code>的值不能直接确定，它可能是一个表达式，又可能是一个函数调用。</p>\n<p>例如测试参量可能被绑定在函数定义的参量上:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun type-of-animal (animal-name)</span><br><span class=\"line\">  &quot;根据animal-name打印信息到回显区</span><br><span class=\"line\">如果animal-name是符号&apos;fierce则返回&apos;tiger&quot;</span><br><span class=\"line\">  (if (equal animal-name &apos;fierce)</span><br><span class=\"line\">      (message &quot;It&apos;s a tiger&quot;)))</span><br><span class=\"line\">(type-of-animal &apos;fierce) ;; =&gt; &quot;It’s a tiger&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>type-of-animal函数详解</strong></p>\n<p>首先<code>type-of-animal</code>是包含了两个特殊表模板，分别是<code>defun</code>和<code>if</code>。<code>type-of-animal</code>是函数名，紧跟着函数名的是函数参量列表，然后跟着的是函数的文档。最后函数的主体内是一个if函数，if函数的的一个参量是一个列表，这个列表的首元素的符号是一个函数<code>equal</code>，在Lisp中，<code>equal</code>函数用于比较参量一和参量二是否相等，如果相等则输出<code>if</code>函数的第二个参量，也是一个列表，这个列表的首元素是符号且是函数<code>message</code>，将<code>It&#39;s a tiger</code>打印至回显区。</p>\n<h2 id=\"if-then-else表达式\"><a href=\"#if-then-else表达式\" class=\"headerlink\" title=\"if-then-else表达式\"></a>if-then-else表达式</h2><p>其实<code>if-then-else</code>表达式就是在<code>if</code>特殊表之上加了一个参量，其他没什么不同，新增的参量是当参量一的值为nil时，对参量三求值。</p>\n<p>它的函数模板可以写成这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if true-or-false-test</span><br><span class=\"line\">    action-to-carry-out-if-the-test-returns-true</span><br><span class=\"line\">  action-to-carry-out-if-the-test-returns-false)</span><br></pre></td></tr></table></figure>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (&gt; 4 5)</span><br><span class=\"line\">  (message &quot;5 大于 4!&quot;)</span><br><span class=\"line\">(message &quot;4 小于 5&quot;)) ;; =&gt; &quot;4 小于 5&quot;</span><br></pre></td></tr></table></figure>\n<p>通过这个例子，我们发现当<code>if</code>函数的第一参量值为nil时就会对第三参量求值。并且第三参量的缩进也要少于第二参量。</p>\n<p>那我们现在将<code>type-of-animal</code>函数改造成:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun type-of-animal (animal-name) ;second version</span><br><span class=\"line\">  &quot;根据animal-name打印信息到回显区</span><br><span class=\"line\">如果animal-name是符号&apos;fierce则输出&apos;It&apos;s tiger!否则输出Tt not fierce&quot;</span><br><span class=\"line\">  (if (equal animal-name &apos;fierce)</span><br><span class=\"line\">      (message &quot;It&apos;s tiger&quot;)</span><br><span class=\"line\">    (message &quot;It not fierce&quot;)))</span><br><span class=\"line\">(type-of-animal &apos;fierce) ;; =&gt;&quot;It’s tiger&quot;</span><br><span class=\"line\">(type-of-animal &apos;notfierce)  ;; =&gt; &quot;It not fierce&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lisp中的真与假\"><a href=\"#Lisp中的真与假\" class=\"headerlink\" title=\"Lisp中的真与假\"></a>Lisp中的真与假</h2><p>Lisp中所有除了nil的都是真，nil也就是我们常说的假，nil有多种意思，一种就是nil代表假，另一种则是代表空列表，但往往都把空列表写成<code>()</code>，而当Lisp解释器对表达式求值时，只要值不是nil或空列表那么都是真，不管得到的值为一个数字或字符串或列表，它都代表真。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if nil</span><br><span class=\"line\">    &apos;true</span><br><span class=\"line\">  &apos;false) ;; =&gt; false</span><br><span class=\"line\">(if t</span><br><span class=\"line\">    &apos;true</span><br><span class=\"line\">  &apos;false) ;; =&gt; true</span><br></pre></td></tr></table></figure>\n<p>真也有另外一种表示方式，在表达式求值后没什么可返回时就会返回<code>t</code>，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&gt; 5 4) ;; =&gt; t</span><br></pre></td></tr></table></figure>\n<h2 id=\"save-excursion函数\"><a href=\"#save-excursion函数\" class=\"headerlink\" title=\"save-excursion函数\"></a>save-excursion函数</h2><p>各位还记得什么是位点(point)，什么是标记(mark)吗?</p>\n<p>Emacs是一个文本编辑器，主要还是与文本打交道，那么<code>save-excursion函数</code>就是与文本打交道的一个经典函数。</p>\n<p>先让我们来回顾一下位点与标记:</p>\n<ul>\n<li><p>位点(point)：及当前buffer中光标所在字符位置，例如当光标置于buffer的开头，那么point应该是1，若置于buffer的末尾，那么point就是当前buffer的字符数了。</p>\n</li>\n<li><p>标记(mark)：标记是buffer的另外一个位置，其中一个就是位点。在buffer中可以自定义很多标记，这样可以方便我们跳转至某个位点。设置标记的函数是<code>(set-mark-command)</code>，它绑定了一个键序列<code>C-SPC</code>，如果此时想要快速跳转至某个标记点，就可以使用命令<code>(exehange-point-and-mark</code>快速回到标记处，它绑定了一个键序列<code>C-x C-x</code>，并且还会将当初的位点设置一个标记，方便来回跳转。</p>\n</li>\n</ul>\n<p><strong>位点与标记之间的缓冲区叫做现域(region)</strong>，有很多条命令是专用于操作现域的，例如:<code>center-region|count-lines-region|kill-region|print-region</code></p>\n<p>前面将了很多关于位点与标记的知识，下面正式介绍<code>save-excursion</code>函数，这个函数的作用主要是将位点和标记的当前位置保存，然后当其他会影响位点或标记的函数执行完后，再将标记的位点复原。 </p>\n<p><code>save-excursion</code>函数模板:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(save-excursion</span><br><span class=\"line\">  body...)</span><br></pre></td></tr></table></figure>\n<p><strong>注意，<code>save-excursion</code>函数的函数体允许有多条表达式，但是只返回最后一条表达式的值。</strong></p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>这一章学的东西还是挺多的，下面我就把书中的所有文字一字不差的抄下来。</p>\n<p>先说几个提到但是没有过多解释的函数:</p>\n<ul>\n<li><p>eval-last-sexp<br>对光标所处的位点前的最后一个符号表达式求值。如果这个函数激活时没有参量，那么将返回值输出在回显区，否则将打印在当前缓冲区中。</p>\n</li>\n<li><p>defun<br>定义函数。这个特殊表最多可有五个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。</p>\n</li>\n<li><p>interactiv<br>向解释器声明这个函数可以被交互的使用，并且这个特殊表还可以用一个字符串，分成单个或多个部分，依次传送信息至这个函数的参量。 </p>\n</li>\n<li><p>let<br>声明在<code>let</code>表达式主体中使用的变量列表并且给它们赋初始值，初始值要么是nil，要么是一个指定的值，然后对<code>let</code>表达式主体的其他表达式求值并返回最后一个表达式的值。</p>\n</li>\n<li><p>save-excursion<br>对这个函数主体求值前，记录位点和标记的值以及当前缓冲区。求值后恢复位点和标记。</p>\n</li>\n<li><p>if<br>对函数的第一个参量求值，如果值为真，则对第二个参量求值，否则对第三个参量求值。</p>\n</li>\n<li><p>equal、eq<br>测试两个对象的结构或内容是否相等用equal，测试两个对象是否完全相当用eq</p>\n</li>\n<li><p>&lt; &gt; &lt;= &gt;=<br>用于判断第一个参量的值是否大于/小于/大于或等于/小于或等于第二个参量的值，如果是则返回真，否则返回nil</p>\n</li>\n<li><p>message<br>用于往回显区内打印消息</p>\n</li>\n<li><p>setq set<br>setq 用于将第一个参量的值绑定到第二个参量的值，而第一个参量的值由<code>setq</code>自动加上引用。<br>set 用于将第一个参量的值绑定到第二个参量的值，但是不会自动为第一个参量加上引用。</p>\n</li>\n<li><p>buffer-name<br>这个函数用于获取一个缓冲区的名字</p>\n</li>\n<li><p>buffer-file-name<br>这个函数用于获取缓冲区所对饮的名字</p>\n</li>\n<li><p>current-buffer<br>这个函数用于获取当前缓冲区的buffer对象</p>\n</li>\n<li><p>other-buffer<br>返回最近选择过的缓冲区</p>\n</li>\n<li><p>switch-to-buffer<br>选择一个缓冲区</p>\n</li>\n<li><p>set-buffer<br>设置当前缓冲区为某一个缓冲区</p>\n</li>\n<li><p>buffer-size<br>返回当前缓冲区的字符数</p>\n</li>\n<li><p>point<br>返回当前光标所对应缓冲区的位置</p>\n</li>\n<li><p>point-min<br>返回当前缓冲区最小的字符数</p>\n</li>\n<li><p>point-max<br>返回当前缓冲区最大的字符数</p>\n</li>\n</ul>\n<h2 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ul>\n<li>编写一个非交互的函数，这个函数将其第一个参量(是一个数)的值翻倍。然后使这个函数成为一个交互函数</li>\n</ul>\n<p>非交互:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun double(number)</span><br><span class=\"line\">  &quot;使number翻倍&quot;</span><br><span class=\"line\">  (setq number (* number 2)))</span><br><span class=\"line\"></span><br><span class=\"line\">(double 10) ;; =&gt; 20</span><br></pre></td></tr></table></figure>\n<p>交互式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun double(number)</span><br><span class=\"line\">  &quot;使number翻倍&quot;</span><br><span class=\"line\">  (interactive &quot;n请输入要翻倍的数字: &quot;)</span><br><span class=\"line\">  (setq number (* number 2))</span><br><span class=\"line\">  (message &quot;翻倍后:%d&quot; number))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个函数，测试<code>fill-column</code>的当前值是否大于传送给函数参量的值，如果是则打印适当的信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun is-bigger-to-fill-column (number)</span><br><span class=\"line\">  &quot;判断number是否比fill-column大&quot;</span><br><span class=\"line\">  (if (&gt; number fill-column)</span><br><span class=\"line\">      (message &quot;%d比fill-column要大&quot; number)</span><br><span class=\"line\">    (message &quot;%d比fill-column要小&quot; number)))</span><br><span class=\"line\"></span><br><span class=\"line\">(is-bigger-to-fill-column 79) ;; =&gt; &quot;79比fill-column要小&quot;</span><br><span class=\"line\">(is-bigger-to-fill-column 81) ;; =&gt; &quot;81比fill-column要大&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第四章-与缓冲区有关的函数\"><a href=\"#第四章-与缓冲区有关的函数\" class=\"headerlink\" title=\"第四章 与缓冲区有关的函数\"></a>第四章 与缓冲区有关的函数</h1><p>本章将会介绍大量的函数定义。</p>\n<h2 id=\"查找更多的信息\"><a href=\"#查找更多的信息\" class=\"headerlink\" title=\"查找更多的信息\"></a>查找更多的信息</h2><p>可以使用<code>C-h f</code>查看一个函数所对应的文档，使用<code>C-h v</code>查看一个变量所对应的文档，如果要在源代码文件中查看函数定义，可以使用函数<code>find-tags</code>，跳到相应的位置。</p>\n<p>Lisp代码可以分为多个模块或包，如果想要查看某个模块的帮助，可以键入<code>C-h p</code>。</p>\n<h2 id=\"简化的beginning-of-buffer函数定义\"><a href=\"#简化的beginning-of-buffer函数定义\" class=\"headerlink\" title=\"简化的beginning-of-buffer函数定义\"></a>简化的beginning-of-buffer函数定义</h2><p>对于<code>beginning-of-buffer</code>函数你们可能已经使用过了，其绑定的键序列是<code>M-&lt;</code>。其作用是将当前光标移动至buffer的起始处。</p>\n<p>下面我们将自己实现一个简单的<code>beginning-of-buffer</code>函数。</p>\n<p>让我们来看看我们需要做什么事:</p>\n<ol>\n<li>首先这个函数得是个交互式函数，以便我们能通过键序列调用或用<code>M-x</code>调用。</li>\n<li>其次我们需要记录个位点为标记</li>\n<li>最后我们再跳转到buffer起始处</li>\n</ol>\n<p>相比与真正的<code>beginning-of-buffer</code>函数定义，没有考虑一些复杂的选项，但是我们先完成这个简化版本吧!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun simple-beginning-of-buffer ()</span><br><span class=\"line\">  &quot;移动光标至buffer开始处&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char (point-min)))</span><br></pre></td></tr></table></figure>\n<p>这个<code>defun</code>函数包含了5个部分:</p>\n<ol>\n<li>首先是这个函数的函数名————<code>simple-beginning-of-buffer</code></li>\n<li>再就是函数的文档</li>\n<li>随后是交互式表达式</li>\n<li>然后记录位点为标记</li>\n<li>最后跳转至buffer的起始处 </li>\n</ol>\n<p>由于这个函数是无参量的，所以交互式表达式内也不用写任何字符串，而<code>push-mark</code>函数默认将<code>point</code>加入到标记中，最后通过<code>goto-char</code>跳转至<code>point-min</code>的位置。如果想要回到原来的位置可以使用<code>C-x C-x</code>。</p>\n<p>既然已经写了一个<code>simple-beginning-of-buffer</code>那我们也可以写一个<code>simple-end-of-buffer</code>吧!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun simple-end-of-buffer()</span><br><span class=\"line\">  &quot;移动光标至buffer结束处&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char (point-max)))</span><br></pre></td></tr></table></figure>\n<p>最后则是，如果遇到不了解的函数，可以将光标放置函数之上，键入键序列<code>C-h f RET</code>即可。 </p>\n<h2 id=\"mark-whole-buffer函数定义\"><a href=\"#mark-whole-buffer函数定义\" class=\"headerlink\" title=\"mark-whole-buffer函数定义\"></a>mark-whole-buffer函数定义</h2><p><code>mark-whole-buffer</code> 不比<code>simple-end-of-buffer</code>复杂多少。</p>\n<p>这次我们来看一个函数的完整定义</p>\n<p>这是书中的定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun mark-whole-buffer ()</span><br><span class=\"line\">  &quot;Put point at beginning and mark at end of buffer.&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark (point))</span><br><span class=\"line\">  (push-mark (point-max))</span><br><span class=\"line\">  (goto-char (point-min)))</span><br></pre></td></tr></table></figure>\n<p>书中讲不知道为啥函数体内的第一条表达式<code>push-mark</code>内还需要写<code>(point)</code>，但我现在再去看，这个函数已经改变了，并且也改掉了这个冗余的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun mark-whole-buffer ()</span><br><span class=\"line\">  &quot;Put point at beginning and mark at end of buffer.</span><br><span class=\"line\">If narrowing is in effect, only uses the accessible part of the buffer.</span><br><span class=\"line\">You probably should not use this function in Lisp programs;</span><br><span class=\"line\">it is usually a mistake for a Lisp function to use any subroutine</span><br><span class=\"line\">that uses or sets the mark.&quot;</span><br><span class=\"line\">  (declare (interactive-only t))</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (push-mark (point-max) nil t)</span><br><span class=\"line\">  ;; This is really `point-min&apos; in most cases, but if we&apos;re in the</span><br><span class=\"line\">  ;; minibuffer, this is at the end of the prompt.</span><br><span class=\"line\">  (goto-char (minibuffer-prompt-end)))</span><br></pre></td></tr></table></figure>\n<p>并且还改了一些代码，先不看<code>declare</code>，我们发现变化的有<code>(push-mark (point-max))</code>，最新的<code>mark-whole-buffer</code>函数中函数体第二个表达式多了两个参量，第二个参量代表如果值不为nil则显示<code>Mark set</code>。第三个参量代表如果在瞬时标记模式下，值不为nil则激活。</p>\n<p>并且最后一条表达式也修改过了，原本是<code>point-min</code>但改为<code>minibuffer-prompt-end</code>，其区别在于:</p>\n<p><code>minibuffer-prompt-end会在返回buffer位置时输出信息至minibuffer</code></p>\n<p>在是如果当前buffer不是minibuffer那么就返回<code>point-min</code></p>\n<h2 id=\"append-to-buffer函数定义\"><a href=\"#append-to-buffer函数定义\" class=\"headerlink\" title=\"append-to-buffer函数定义\"></a>append-to-buffer函数定义</h2><p>由于我看的这本书年代久远(2001)，现在是2019年，整整过去18年，Emacs也已经发生了巨大的变化。</p>\n<p>所以我将先试着记录书中所讲的<code>append-to-buffer</code>函数再对Emacs 26.3版本的<code>append-to-buffer</code>函数进行讲解，希望对看到这篇博客的同仁们提供一些微薄的帮助。</p>\n<blockquote>\n<p>这个计划已经鸽了，我发现用我现在所学还是很难解释清楚26.3版本的append-to-buffer函数的工作方式。所以后面的26.版 append-to-buffer会在以后完成，十分抱歉。</p>\n</blockquote>\n<p>首先<code>append-to-buffer</code>函数的作用是将指定buffer区域(region)中的文本追加到当前Buffer的point前。</p>\n<h3 id=\"旧版append-to-buffer\"><a href=\"#旧版append-to-buffer\" class=\"headerlink\" title=\"旧版append-to-buffer\"></a>旧版append-to-buffer</h3><p>先让我们看看书中的<code>append-to-buffer</code>函数定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun append-to-buffer (buffer start end)</span><br><span class=\"line\">  &quot;Append to specified buffer the text of the region.</span><br><span class=\"line\">It is inserted into that buffer before its point.</span><br><span class=\"line\">When alling from a program, give three arguments:</span><br><span class=\"line\">a buffer or the name of one, and two character numbers</span><br><span class=\"line\">specifying the portion of the current buffer to be copied.&quot;</span><br><span class=\"line\">  (interactive &quot;BAppend to buffer: \\nr&quot;)</span><br><span class=\"line\">  (let ((oldbuf (current-buffer)))</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (set-buffer (get-buffer-create buffer))</span><br><span class=\"line\">      (insert-buffer-substring oldbuf start end))))</span><br></pre></td></tr></table></figure>\n<p>通过阅读这个函数的文档就能很清晰的了解这个函数的工作方式。</p>\n<p>略过函数名和文档，我们直接来看<code>interactive</code>。<code>interative</code>中的<code>B</code>代表让用户选择一个Buffer(可能不存在)并将buffer名称传给函数参量一，其次是一些友好的文本<code>Append to buffer:</code>，紧跟其后的<code>\\n</code>用于控制换行，最后的<code>r</code>获取当前区域(point和mark)，并将其传给函数的参量二和参量三。 </p>\n<p>随后是一个<code>let</code>特殊表，在<code>let</code>的变量列表中，定义了一个<code>oldbuf</code>，其绑定的值是<code>(current-buffer)</code>的返回值，也就是当前Buffer对象。在<code>let</code>的表达式体中有一个<code>save-excursion</code>函数。</p>\n<p><code>save-excursion</code>函数体中有两条表达式，第一条表达式<code>(set-buffer)</code>用于将当前缓冲区变换到另外一个缓冲区，而其参量又是一个函数<code>get-buffer-create</code>，这个函数的作用是获取指定BUFFER对象或名(称为BUFFER-OR-NAME)，如果这个BUFFER-OR-NAME不存在，将会自动创建。</p>\n<p><code>save-excursion</code>函数体的第二条表达式是一个<code>(insert-buffer-substring)</code>函数这个函数将参量一从参量二到参量三的区域的字符串插入到当前Buffer的point之前。</p>\n<h3 id=\"26-3版append-to-buffer\"><a href=\"#26-3版append-to-buffer\" class=\"headerlink\" title=\"26.3版append-to-buffer\"></a>26.3版append-to-buffer</h3><p>由于本人水平有限，如有错误，欢迎提出issue.</p>\n<p>先让我们看函数定义原型:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun append-to-buffer (buffer start end)</span><br><span class=\"line\">  &quot;Append to specified BUFFER the text of the region.</span><br><span class=\"line\">The text is inserted into that buffer before its point.</span><br><span class=\"line\">BUFFER can be a buffer or the name of a buffer; this</span><br><span class=\"line\">function will create BUFFER if it doesn&apos;t already exist.</span><br><span class=\"line\"></span><br><span class=\"line\">When calling from a program, give three arguments:</span><br><span class=\"line\">BUFFER (or buffer name), START and END.</span><br><span class=\"line\">START and END specify the portion of the current buffer to be copied.&quot;</span><br><span class=\"line\">  (interactive</span><br><span class=\"line\">   (list (read-buffer &quot;Append to buffer: &quot; (other-buffer (current-buffer) t))</span><br><span class=\"line\">\t (region-beginning) (region-end)))</span><br><span class=\"line\">  (let* ((oldbuf (current-buffer))</span><br><span class=\"line\">         (append-to (get-buffer-create buffer))</span><br><span class=\"line\">         (windows (get-buffer-window-list append-to t t))</span><br><span class=\"line\">         point)</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (with-current-buffer append-to</span><br><span class=\"line\">        (setq point (point))</span><br><span class=\"line\">        (barf-if-buffer-read-only)</span><br><span class=\"line\">        (insert-buffer-substring oldbuf start end)</span><br><span class=\"line\">        (dolist (window windows)</span><br><span class=\"line\">          (when (= (window-point window) point)</span><br><span class=\"line\">            (set-window-point window (point))))))))</span><br></pre></td></tr></table></figure>\n<p>我们发现函数参量没有变化，并且注释也没有大的变化，只是函数体内发生了较大的变化。</p>\n<p>首先是<code>interactive</code>函数参量发生了变化，变成了一个<code>list</code>函数，回想一下，<code>list</code>函数是用于构造一个列表的函数，这个<code>list</code>函数的第一个参量是<code>(read-buffer)</code>函数。</p>\n<p><code>read-buffer</code>函数可以通过buffer名称读取buffer中的字符串并返回。其第一个参量是用于提示用户的友好信息，并且特意指出这个提示信息必须是由冒号和空格结尾且被双引号包围的字符串。第二个参量用于也就是返回值，它的默认值为列表</p>\n<h2 id=\"回顾-1\"><a href=\"#回顾-1\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>惯例抄书</p>\n<ul>\n<li><p>describe-function\\describe-variable<br>打印一个函数或一个变量的文档。通常将其绑定到<code>C-h f</code>和<code>C-h v</code></p>\n</li>\n<li><p>find-tag<br>找到存放某个函数或变量的源代码的文件，并切换到这个缓冲区，将位点(光标)置于相应函数或这变量的开始处。习惯上将其绑定到<code>M--</code>。</p>\n</li>\n<li><p>save-excursion<br>保存位点和标记的位置，并在对<code>save-excursion</code>参量求值之后恢复这些值。它也保存当前缓冲区并返回到该缓冲区。</p>\n</li>\n<li><p>push-mark<br>在指定位置设置一个标记，并在标记环中记录原来标记的值。标记是缓冲区中的一个位置，即使由一些文本被从缓冲区删除或者增加到缓冲区，标记仍将保持它的相对位置。</p>\n</li>\n<li><p>goto-char<br>将位点设置为由参量指定的位置。参量值可以是一个数，也可以是一个标记，甚至可以是一个返回一个位置数字的表达式(point-min)</p>\n</li>\n<li><p>insert-buffer-substring<br>将来自一个缓冲区（这是被作为一个参量而传递给函数的）的文本域拷贝到当前缓冲区</p>\n</li>\n<li><p>mark-whole-buffer<br>将整个缓冲区标记为一个域。一般将这个函数绑定到<code>C-x h</code>。</p>\n</li>\n<li><p>set-buffer<br>将Emacs的注意力转移到另一个缓冲区，但是不该便显示的窗口。 </p>\n</li>\n<li><p>get-buffer-create\\get-buffer<br>寻找一个已指定名字的缓冲区，或当指定名字的缓冲区不存在时就创建它。如果指定名称的缓冲区不存在，get-buffer函数就返回nil。</p>\n</li>\n</ul>\n<h2 id=\"练习-3\"><a href=\"#练习-3\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ul>\n<li>编写自己的<code>simplified-end-of-buffer</code>函数定义，然后测试它是否能工作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun simple-end-of-buffer()</span><br><span class=\"line\">  &quot;移动光标至buffer结束处&quot;</span><br><span class=\"line\">  (interactive)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char (point-max)))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用if和get-buffer编写一个函数，这个函数要打印一个说明某个缓冲区是否存在的消息 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun is-exist-buffer (buffer-or-name)</span><br><span class=\"line\">  &quot;判断buffer-or-name是否为一个已存在的buffer&quot;</span><br><span class=\"line\">  (if (bufferp (get-buffer buffer-or-name))</span><br><span class=\"line\">      (message &quot;%s存在!&quot; buffer-or-name)</span><br><span class=\"line\">    (message &quot;此缓冲区不存在!&quot;)))</span><br><span class=\"line\">    </span><br><span class=\"line\">(is-exist-buffer &quot;test.el&quot;) ;; =&gt; &quot;test.el存在!&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用find-tag找到copy-to-buffer函数的源代码</li>\n</ul>\n<p>不会…</p>\n<h1 id=\"第五章-更复杂的函数\"><a href=\"#第五章-更复杂的函数\" class=\"headerlink\" title=\"第五章 更复杂的函数\"></a>第五章 更复杂的函数</h1><p>本章我们将在已学内容的基础之上学习更复杂的函数，例如有使用两次<code>save-excursion</code>的<br><code>copy-to-buffer</code>函数，以及一个在<code>interactive</code>中使用<code>*</code>和<code>or</code>函数的函数。</p>\n<h2 id=\"copy-to-buffer函数的定义\"><a href=\"#copy-to-buffer函数的定义\" class=\"headerlink\" title=\"copy-to-buffer函数的定义\"></a>copy-to-buffer函数的定义</h2><p><code>copy-to-buffer</code>函数与前面学过的<code>append-to-buffer</code>的定义很类似。</p>\n<p><code>copy-to-buffer</code>是替换指定<code>BUFFER</code>的内容，而<code>append-to-buffer</code>是在指定<code>BUFFER</code>中追加内容。</p>\n<p>首先来看看<code>copy-to-buffer</code>的函数定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun copy-to-buffer-t (BUFFER START END)</span><br><span class=\"line\">  &quot;docutments...&quot;</span><br><span class=\"line\">  (interactive &quot;BCopy to buffer: \\nr&quot;)</span><br><span class=\"line\">  (let ((oldbuf (get-buffer-create BUFFER)))</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (set-buffer BUFFER)</span><br><span class=\"line\">      (save-excursion</span><br><span class=\"line\">        (insert-buffer-substring oldbuf START END)))))</span><br></pre></td></tr></table></figure>\n<p>略过函数名与文档不看，可以看到这个函数被定义为交互式函数，并且这个函数的参量要求<br>是一个BUFFER对象，以及两个表示位置的数字。这三个参量都由<code>interactive</code>所解决，其<br>使得让用户选择一个BUFFER，然后获取当前<code>Buffer</code>的<code>point</code>和<code>mark</code>，作为<code>START</code>和<br><code>END</code>。</p>\n<p>随后是一个<code>let</code>表达式，其在它的<code>varlist</code>部分将<code>BUFFER</code>参量通过<br><code>get-buffer-create</code>函数获取了其对象(就算<code>BUFFER</code>参量的值不存在也会创建一个)，并<br>且将这个BUFFER对象赋值给<code>oldbuf</code>。在<code>let</code>表达式的<code>BODY</code>部分，出现了一个<br><code>save-excursion</code>函数，这个函数用于记录当前<code>point</code>和<code>mark</code>的位置，然后在其参量求<br>值完毕后恢复记录的位置，这个参量也就是<code>set-buffer</code>，这个函数用于改变当前BUFFER为<br>  参量<code>BUFFER</code>。随后又是一个<code>save-excursion</code>函数，其参量<br>  <code>insert-buffer-substring</code>函数我们也了解过，其用于将当前BUFFER的START到END之间<br>  的区间插入到<code>oldbuf</code>内。</p>\n<h2 id=\"insert-buffer函数的定义\"><a href=\"#insert-buffer函数的定义\" class=\"headerlink\" title=\"insert-buffer函数的定义\"></a>insert-buffer函数的定义</h2><p>前面我们用过<code>append-to-buffer</code>以及<code>copy-to-buffer</code>，他们都是将当前<code>BUFFER</code>的内容<br>拷贝或追加到某一个<code>BUFFER</code>中，而<code>insert-buffer</code>可以将当前<code>BUFFER</code>的内容，拷贝至<br>一个已存在的<code>BUFFER</code>当中。</p>\n<p>先来看看其函数定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun insert-buffer-t (buffer)</span><br><span class=\"line\">  &quot;docutmens..&quot;</span><br><span class=\"line\">  (interactive &quot;*bInsert buffer: &quot;)</span><br><span class=\"line\">  (or (bufferp buffer)</span><br><span class=\"line\">      (setq buffer (get-buffer buffer)))</span><br><span class=\"line\">  (let (start end newmark)</span><br><span class=\"line\">    (save-excursion</span><br><span class=\"line\">      (save-excursion</span><br><span class=\"line\">        (set-buffer buffer)</span><br><span class=\"line\">        (setq start (point-min) end (point-max)))</span><br><span class=\"line\">      (insert-buffer-substring buffer start end)</span><br><span class=\"line\">      (setq newmark (point)))</span><br><span class=\"line\">    (push-mark newmark)))</span><br></pre></td></tr></table></figure>\n<p>先简单整理一下这个函数都包含了什么东西:</p>\n<ul>\n<li>一个参量</li>\n<li>函数文档</li>\n<li>定义交互式函数</li>\n<li><code>interactive</code>参量说明有*和 <code>b</code></li>\n<li>以及一个<code>or</code>函数，这个函数内有两个参量</li>\n<li>第一个参量是<code>bufferp</code>函数</li>\n<li>第二个参量是<code>setq</code>函数，<code>setq</code>的第二个参量是<code>get-buffer</code>函数。</li>\n<li>随后是一个<code>let</code>表达式</li>\n<li><code>let</code>表达式中先是初始化了三个空变量</li>\n<li>一个外层<code>save-excursion</code>函数</li>\n<li>一个内层<code>save-excursion</code>函数</li>\n<li>其第一个参量是一个<code>set-buffer</code>函数</li>\n<li>第二个参量是<code>setq</code>函数</li>\n<li>外层<code>save-excursion</code>的第二个参量是一个<code>insert-buffer-substring</code>函数</li>\n<li>第三个参量是一个<code>setq</code>函数。</li>\n<li>最后是一个<code>push-mark</code>函数。 </li>\n</ul>\n<h3 id=\"insert-buffer函数中的交互表达式\"><a href=\"#insert-buffer函数中的交互表达式\" class=\"headerlink\" title=\"insert-buffer函数中的交互表达式\"></a>insert-buffer函数中的交互表达式</h3><p>让我们先从<code>interactive</code>表达式说起，首先起表达式说明分为三个部分：</p>\n<ol>\n<li><code>*</code>代表只读缓冲区，这个说明会在当<code>b</code>说明返回的buffer是一个只读缓冲区时在回显<br>区提示错误。也就是说当这个<code>insert-buffer</code>函数当在一个只读缓冲区被调用时，将不<br>被允许。</li>\n<li><p><code>b</code>代表要求是一个存在的缓冲区或者是缓冲区名，它与<code>B</code>说明不同。</p>\n</li>\n<li><p><code>Insert buffer:</code>是友好的提示。</p>\n</li>\n</ol>\n<p><strong>提示:*控制符无需后接一个换行符来分割不同的参量。</strong></p>\n<h3 id=\"insert-buffer函数体\"><a href=\"#insert-buffer函数体\" class=\"headerlink\" title=\"insert-buffer函数体\"></a>insert-buffer函数体</h3><p>主要有两个部分，分别是<code>or</code>函数和<code>let</code>函数。</p>\n<p>先让我们来看看<code>or</code>函数，其第一个参量是一个<code>bufferp</code>函数，这个函数用于当其参量是<br>是一个已存在的buffer或buffer的名称才会返回<code>non-nil</code>的值，也就是真/非假，其第二个<br>参量是一个<code>setq</code>函数，里面有一个<code>get-buffer</code>函数，这个函数是用于获取一个已存在的<br>buffer对象根据buffer对象或buffer的名称，并将buffer绑定到<code>get-buffer</code>的值之上。</p>\n<p>其实这个函数的意思是，要让<code>buffer</code>参量确定是一个已存在的buffer，我们可以用<code>if</code>函<br>数重写一遍。</p>\n<h3 id=\"用if表达式编写insert-buffer函数\"><a href=\"#用if表达式编写insert-buffer函数\" class=\"headerlink\" title=\"用if表达式编写insert-buffer函数\"></a>用if表达式编写insert-buffer函数</h3><p>我们的需求是，必须确保<code>buffer</code>的值是一个已存在的buffer或buffer的名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (not (bufferp buffer)</span><br><span class=\"line\">         (setq buffer (get-buffer buffer))))</span><br></pre></td></tr></table></figure>\n<p>就可以这样写，当<code>bufferp</code>函数的值为nil时，那么就会尝试获取<code>buffer</code>的对象并且保存，<br>否则则报错。</p>\n<h3 id=\"insert-buffer函数中的let表达式\"><a href=\"#insert-buffer函数中的let表达式\" class=\"headerlink\" title=\"insert-buffer函数中的let表达式\"></a>insert-buffer函数中的let表达式</h3><p>在我们确保<code>buffer</code>参量是一个非只读缓冲区后，可以开始写拷贝内容的代码了。</p>\n<p>首先我们初始化三个空变量: start end newmark</p>\n<p>  <code>let</code>表达式体中有一个外层<code>save-excursion</code>函数，其记录了我们的<code>point</code>和<code>mark</code>，<br>其第一个参量又是一个<code>save-excursion</code>函数，我们称为内层<code>save-excursion</code>。内层<br><code>save-excursion</code>主要做了两件事，首先是将Emacs的注意力转移到<code>buffer</code>之上，随后为<br><code>start</code>以及<code>end</code>附上<code>buffer</code>的<code>point-min</code>和<code>point-max</code>的值，并且由于内层<br><code>save-excursion</code>已经求值完毕，那么会恢复在求值过程中可能变动的位点和标记的值。随<br>后外层<code>save-excursion</code>函数的第二个参量是将<code>buffer</code>参量的内容插入到当前buffer从<br><code>start</code>到<code>end</code>结束的内容，这个<code>start</code>和<code>end</code>也就是<code>buffer</code>参量所有的内容。随后又<br>把<code>newmark</code>变量绑定到值<code>point</code>之上，最后将<code>newmark</code>记录为<code>标记</code>。</p>\n<h2 id=\"beginning-of-buffer函数的完整定义\"><a href=\"#beginning-of-buffer函数的完整定义\" class=\"headerlink\" title=\"beginning-of-buffer函数的完整定义\"></a>beginning-of-buffer函数的完整定义</h2><p>前面我们尝试写了<code>beginning-of-buffer</code>函数的部分定义，它是一个无参量的函数，那么<br>这次我们来写一个有参量的<code>beginning-of-buffer</code>函数。</p>\n<p>这个带参量的<code>beginning-of-buffer</code>函数可以指定在当前缓冲区的几分之几标记位置。</p>\n<p>那么现来说下需求:<code>beginning-of-buffer</code>函数接受一个可选参量，这个参量的返回是1-10<br>之间，这个参量作为标记点的位置。</p>\n<h3 id=\"可选参量\"><a href=\"#可选参量\" class=\"headerlink\" title=\"可选参量\"></a>可选参量</h3><p>在需求里我们提到: </p>\n<blockquote>\n<p><code>beginning-of-buffer</code>函数接受一个可选参量</p>\n</blockquote>\n<p>除非特别声明，否则Lisp会认为函数的参量是必须在函数被调用时传递一个值给该参量的。<br>如果不传入参量，则该函数就会出错:<code>Wrong number of arguments</code>。</p>\n<p>而如果需要使一个或多个参量变为可选参数只需要在参量前加上<code>&amp;optional</code>关键字，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun beginning-of-defun-function-t (&amp;optional arg1 arg2)</span><br><span class=\"line\">  &quot;documentation&quot;</span><br><span class=\"line\">  (interactive &quot;P&quot;)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char</span><br><span class=\"line\">   ;; if-there-is-an-argument</span><br><span class=\"line\">   ;;   xxxx</span><br><span class=\"line\">   ;; else-go-to</span><br><span class=\"line\">   (point-min)))</span><br></pre></td></tr></table></figure>\n<p>对比前面的<code>simple-beginning-to-buffer</code>函数，好像唯一多的地方是在<code>goto-char</code>函数<br>的第一个参量，变成了<code>if</code>特殊表。这个<code>if</code>函数判断由<code>interactive</code>的<code>P</code>参量获得到的前<br>缀参量是否为一个非nil值，如果是则执行<code>if then</code>部分，否则执行跟<br><code>simple-beginning-to-buffer</code>一样的操作。</p>\n<h3 id=\"带参量的beginning-of-buffer函数\"><a href=\"#带参量的beginning-of-buffer函数\" class=\"headerlink\" title=\"带参量的beginning-of-buffer函数\"></a>带参量的beginning-of-buffer函数</h3><p><code>goto-char</code>函数中有一个<code>if</code>表达式，这个表达式做了很多关于算术的操作。 </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(defun beginning-of-defun-function-t (&amp;optional arg)</span><br><span class=\"line\">  &quot;documentation&quot;</span><br><span class=\"line\">  (interactive &quot;P&quot;)</span><br><span class=\"line\">  (push-mark)</span><br><span class=\"line\">  (goto-char</span><br><span class=\"line\">   (if (&gt; (buffer-size) 10000)</span><br><span class=\"line\">       (/ (prefix-numeric-value arg) 10)</span><br><span class=\"line\">     (/</span><br><span class=\"line\">      (+ 10</span><br><span class=\"line\">         (*</span><br><span class=\"line\">          (buffer-size) (prefix-numeric-value arg))) 10))</span><br><span class=\"line\">   (point-min)))</span><br></pre></td></tr></table></figure>\n<p> 一眼看上去有些复杂，其实我们通过函数模板来揭开其中的奥秘，十分简单。</p>\n<p>我们看将<code>if</code>函数的结构看成这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(if (buffer-is-large</span><br><span class=\"line\">     divide-buffer-size-by-10-and-multiply-by-arg)</span><br><span class=\"line\">    else-use-alternate-calculation)</span><br></pre></td></tr></table></figure>\n<p>要吃饭了</p>\n<p>这里的<code>if</code>函数用于检查缓冲区的大小，这是因为书中使用的是第18版本的Elisp，其使用<br>了不大于800w的数字来描述缓冲区的大小，如果有在某次求值中遇到更大的缓冲区，Emacs</p>"},{"title":"常用算法-1","copyright":true,"date":"2019-05-27T04:14:16.000Z","_content":"\n这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.\n\n<!--more-->\n\n# 常用算法\n\n> 本页理解几个常用的算法\n\n---\n\n## 冒泡排序\n\n**冒泡排序是一种稳定的排序算法**\n> 稳定即是，如果相邻的元素相同，不会再去进行调换位置\n\n冒排的运作是(从后往前)。\n\n我们操作数组来进行演示。\n\n我们首先定义一个整型数组里面存储几个整型数据\n\n```Java\n//待排序的数列\nint[] nums = {9,6,4,3,10,25};\n```\n\n>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。\n\n**每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。**\n\n我们尝试先用大脑来演示排序的过程\n```\n//未排序时\n9 6 4 3 10 25\n\n6 9 3 4 10 25 //第一轮 调换了2次\n6 3 4 9 10 //第二轮 调换了2次\n3 4 6 9 //第三轮 调换了2次\n3 4 6 //第四轮 调换了0次\n3 4 //第五轮 调换了0次\n```\n\n我们可以看到我们这组数据只需要排序三轮就可以排序成功，**排序轮数是数组长度-1轮**，调换次数是看数组相邻元素的大小关系，这个我们不用知道，__我们只需要记住，排序轮数是数组长度-1就好。__\n\n那么在代码中我们要如何将其进行调换呢？\n\n有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。\n\n> 了解了基本思路，我们直接进行代码编写吧！\n\n```Java\npublic class Demo{\n    public static void main(String args[]){\n        //待排序的数列\n        int[] nums = {9,6,4,3,10,25};\n        //临时变量，用于调换位置\n        int temp;\n        //第一层循环，控制轮数\n        for(int i = 0;i <nums.length;i++){\n            //第二层，控制每轮要进行排序的元素数量\n            for(int j = 0;j<nums.length-1-i;j++){\n                //如果当前元素比后一个元素大那么则调换元素值\n                if(nums[j]>nums[j+1]){\n                    //我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖\n                    temp = nums[j+1];\n                    //把当前元素的值覆盖后一个元素\n                    nums[j+1] = nums[j];\n                    //再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)\n                    nums[j] = temp;\n                }\n            }\n        }\n        //遍历输出\n        for(int num:nums){\n            System.out.println(num);\n        }\n    }\n}\n```\n\n刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。\n\n**引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码**\n\n```Java\n    /*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/\n\n    //这个if不用加，我只是让你们知道是哪些代码\n    if(nums[j]>nums[j+1]){\n        //当前元素的值是与后一个元素值的和\n        nums[j] = nums[j]+nums[j+1];\n\n        //上一行代码等同于 nums[j] = 9 + 6\n        //执行完上一行代码，nums[j] = 15;\n\n        //执行完此行代码nums[j+1] = 9\n        //等价于 nums[j+1]= 15 - 6\n        nums[j+1] = nums[j]-nums[j+1];\n\n        //执行完此行代码nums[j] = 6\n        //等价于 nums[j] = 15 - 9\n        nums[j] = nums[j] - nums[j+1];\n    }\n```\n\n第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！\n\n\n下一记: **选择排序算法**\n\n---\n\n## 选择排序算法\n\n> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。\n\n上面这个引用是网上随便抄的一个思路。\n\n这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。\n\n我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。\n\n下面我们直接看代码\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        //需要排序的数组\n        int[] nums = {6, 9, 4, 4, 25, 10};\n        //记录每轮排序时最小元素的下标\n        int minIndex;\n        //第一层循环控制轮数\n        for (int i = 0; i < nums.length - 1; i++) {\n            minIndex = i;//假设当前轮最小元素下标为i\n            //内层循环要记录出当前轮最小元素的下标\n            for (int j = i + 1; j < nums.length; j++) {\n                //比较两个相邻元素的大小\n                if (nums[minIndex] > nums[j]) {\n                    //由于找到新的最小值，所以记录一下\n                    minIndex = j;\n                }\n            }\n            //如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置\n            if (minIndex != i) {\n                //下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大\n                nums[minIndex] += nums[i];\n                nums[i] = nums[minIndex] - nums[i];\n                nums[minIndex] -= nums[i];\n            }\n        }\n        //遍历输出排序后的结果\n        for (int num : nums) {\n            System.out.println(num);\n        }\n    }\n}\n```\n\n小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。\n\n下一节，二分查找算法\n\n---\n\n## 二分查找法\n\n> 这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。\n\n二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:\n\n- 定义起始查找位，结束查找位\n- 求得数组长度中间值都\n- 如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。\n- 如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。\n- 如果要查找的值等于中间值，那么直接返回中间值的下标即可\n- 如果都没找到，那么返回-1.\n\n看了这个概念，我们还得注意几点\n\n需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。\n\n好了，我们直接看代码吧！\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        int nums[] = {1,3,5,78,90,100,300};\n        System.out.println(binarySearch(nums,1));\n    }\n    /**\n     * 二分查找法\n     * @param nums　要查找的数列\n     * @param key　要查找的值\n     * @return\n     */\n    static int binarySearch(int[] nums,int key){\n        //起始下标\n        int start = 0;\n        //结束下标\n        int end = nums.length-1;\n        //起始查询的下标不能超过结束下标\n        while(start<=end){\n            //中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值\n            int middle = (start+end)/2;\n            //如果中间下标的值比要查找的值大\n            if(nums[middle]>key){\n                //要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找\n                end = middle-1;\n            }else if(nums[middle]<key){\n                //二分的右边开始查找\n                start = middle+1;\n            }else{\n                //如果要查找的值就是二分下标的值，那么直接返回即可\n                return middle;\n            }\n        }\n        //如果没有查找到那么则返回-1代表没有查找到\n        return -1;\n    }\n}\n```\n\n---\n","source":"_posts/常用算法-1.md","raw":"---\ntitle: 常用算法-1\ncopyright: true\ndate: 2019-05-27 12:14:16\ncategories: 学习笔记\ntags:\n  - 算法\n---\n\n这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.\n\n<!--more-->\n\n# 常用算法\n\n> 本页理解几个常用的算法\n\n---\n\n## 冒泡排序\n\n**冒泡排序是一种稳定的排序算法**\n> 稳定即是，如果相邻的元素相同，不会再去进行调换位置\n\n冒排的运作是(从后往前)。\n\n我们操作数组来进行演示。\n\n我们首先定义一个整型数组里面存储几个整型数据\n\n```Java\n//待排序的数列\nint[] nums = {9,6,4,3,10,25};\n```\n\n>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。\n\n**每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。**\n\n我们尝试先用大脑来演示排序的过程\n```\n//未排序时\n9 6 4 3 10 25\n\n6 9 3 4 10 25 //第一轮 调换了2次\n6 3 4 9 10 //第二轮 调换了2次\n3 4 6 9 //第三轮 调换了2次\n3 4 6 //第四轮 调换了0次\n3 4 //第五轮 调换了0次\n```\n\n我们可以看到我们这组数据只需要排序三轮就可以排序成功，**排序轮数是数组长度-1轮**，调换次数是看数组相邻元素的大小关系，这个我们不用知道，__我们只需要记住，排序轮数是数组长度-1就好。__\n\n那么在代码中我们要如何将其进行调换呢？\n\n有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。\n\n> 了解了基本思路，我们直接进行代码编写吧！\n\n```Java\npublic class Demo{\n    public static void main(String args[]){\n        //待排序的数列\n        int[] nums = {9,6,4,3,10,25};\n        //临时变量，用于调换位置\n        int temp;\n        //第一层循环，控制轮数\n        for(int i = 0;i <nums.length;i++){\n            //第二层，控制每轮要进行排序的元素数量\n            for(int j = 0;j<nums.length-1-i;j++){\n                //如果当前元素比后一个元素大那么则调换元素值\n                if(nums[j]>nums[j+1]){\n                    //我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖\n                    temp = nums[j+1];\n                    //把当前元素的值覆盖后一个元素\n                    nums[j+1] = nums[j];\n                    //再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)\n                    nums[j] = temp;\n                }\n            }\n        }\n        //遍历输出\n        for(int num:nums){\n            System.out.println(num);\n        }\n    }\n}\n```\n\n刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。\n\n**引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码**\n\n```Java\n    /*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/\n\n    //这个if不用加，我只是让你们知道是哪些代码\n    if(nums[j]>nums[j+1]){\n        //当前元素的值是与后一个元素值的和\n        nums[j] = nums[j]+nums[j+1];\n\n        //上一行代码等同于 nums[j] = 9 + 6\n        //执行完上一行代码，nums[j] = 15;\n\n        //执行完此行代码nums[j+1] = 9\n        //等价于 nums[j+1]= 15 - 6\n        nums[j+1] = nums[j]-nums[j+1];\n\n        //执行完此行代码nums[j] = 6\n        //等价于 nums[j] = 15 - 9\n        nums[j] = nums[j] - nums[j+1];\n    }\n```\n\n第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！\n\n\n下一记: **选择排序算法**\n\n---\n\n## 选择排序算法\n\n> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。\n\n上面这个引用是网上随便抄的一个思路。\n\n这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。\n\n我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。\n\n下面我们直接看代码\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        //需要排序的数组\n        int[] nums = {6, 9, 4, 4, 25, 10};\n        //记录每轮排序时最小元素的下标\n        int minIndex;\n        //第一层循环控制轮数\n        for (int i = 0; i < nums.length - 1; i++) {\n            minIndex = i;//假设当前轮最小元素下标为i\n            //内层循环要记录出当前轮最小元素的下标\n            for (int j = i + 1; j < nums.length; j++) {\n                //比较两个相邻元素的大小\n                if (nums[minIndex] > nums[j]) {\n                    //由于找到新的最小值，所以记录一下\n                    minIndex = j;\n                }\n            }\n            //如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置\n            if (minIndex != i) {\n                //下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大\n                nums[minIndex] += nums[i];\n                nums[i] = nums[minIndex] - nums[i];\n                nums[minIndex] -= nums[i];\n            }\n        }\n        //遍历输出排序后的结果\n        for (int num : nums) {\n            System.out.println(num);\n        }\n    }\n}\n```\n\n小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。\n\n下一节，二分查找算法\n\n---\n\n## 二分查找法\n\n> 这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。\n\n二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:\n\n- 定义起始查找位，结束查找位\n- 求得数组长度中间值都\n- 如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。\n- 如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。\n- 如果要查找的值等于中间值，那么直接返回中间值的下标即可\n- 如果都没找到，那么返回-1.\n\n看了这个概念，我们还得注意几点\n\n需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。\n\n好了，我们直接看代码吧！\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        int nums[] = {1,3,5,78,90,100,300};\n        System.out.println(binarySearch(nums,1));\n    }\n    /**\n     * 二分查找法\n     * @param nums　要查找的数列\n     * @param key　要查找的值\n     * @return\n     */\n    static int binarySearch(int[] nums,int key){\n        //起始下标\n        int start = 0;\n        //结束下标\n        int end = nums.length-1;\n        //起始查询的下标不能超过结束下标\n        while(start<=end){\n            //中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值\n            int middle = (start+end)/2;\n            //如果中间下标的值比要查找的值大\n            if(nums[middle]>key){\n                //要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找\n                end = middle-1;\n            }else if(nums[middle]<key){\n                //二分的右边开始查找\n                start = middle+1;\n            }else{\n                //如果要查找的值就是二分下标的值，那么直接返回即可\n                return middle;\n            }\n        }\n        //如果没有查找到那么则返回-1代表没有查找到\n        return -1;\n    }\n}\n```\n\n---\n","slug":"常用算法-1","published":1,"updated":"2020-01-19T03:49:51.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod8005nomoos0u39re1","content":"<p>这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.</p>\n<a id=\"more\"></a>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><blockquote>\n<p>本页理解几个常用的算法</p>\n</blockquote>\n<hr>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p><strong>冒泡排序是一种稳定的排序算法</strong></p>\n<blockquote>\n<p>稳定即是，如果相邻的元素相同，不会再去进行调换位置</p>\n</blockquote>\n<p>冒排的运作是(从后往前)。</p>\n<p>我们操作数组来进行演示。</p>\n<p>我们首先定义一个整型数组里面存储几个整型数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//待排序的数列</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] nums = &#123;<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">25</span>&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。</p>\n</blockquote>\n<p><strong>每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。</strong></p>\n<p>我们尝试先用大脑来演示排序的过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//未排序时</span><br><span class=\"line\">9 6 4 3 10 25</span><br><span class=\"line\"></span><br><span class=\"line\">6 9 3 4 10 25 //第一轮 调换了2次</span><br><span class=\"line\">6 3 4 9 10 //第二轮 调换了2次</span><br><span class=\"line\">3 4 6 9 //第三轮 调换了2次</span><br><span class=\"line\">3 4 6 //第四轮 调换了0次</span><br><span class=\"line\">3 4 //第五轮 调换了0次</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到我们这组数据只需要排序三轮就可以排序成功，<strong>排序轮数是数组长度-1轮</strong>，调换次数是看数组相邻元素的大小关系，这个我们不用知道，<strong>我们只需要记住，排序轮数是数组长度-1就好。</strong></p>\n<p>那么在代码中我们要如何将其进行调换呢？</p>\n<p>有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。</p>\n<blockquote>\n<p>了解了基本思路，我们直接进行代码编写吧！</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//待排序的数列</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = &#123;<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">25</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//临时变量，用于调换位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"comment\">//第一层循环，控制轮数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//第二层，控制每轮要进行排序的元素数量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;nums.length-<span class=\"number\">1</span>-i;j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果当前元素比后一个元素大那么则调换元素值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]&gt;nums[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖</span></span><br><span class=\"line\">                    temp = nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"comment\">//把当前元素的值覆盖后一个元素</span></span><br><span class=\"line\">                    nums[j+<span class=\"number\">1</span>] = nums[j];</span><br><span class=\"line\">                    <span class=\"comment\">//再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)</span></span><br><span class=\"line\">                    nums[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num:nums)&#123;</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。</p>\n<p><strong>引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个if不用加，我只是让你们知道是哪些代码</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(nums[j]&gt;nums[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前元素的值是与后一个元素值的和</span></span><br><span class=\"line\">    nums[j] = nums[j]+nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//上一行代码等同于 nums[j] = 9 + 6</span></span><br><span class=\"line\">    <span class=\"comment\">//执行完上一行代码，nums[j] = 15;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行完此行代码nums[j+1] = 9</span></span><br><span class=\"line\">    <span class=\"comment\">//等价于 nums[j+1]= 15 - 6</span></span><br><span class=\"line\">    nums[j+<span class=\"number\">1</span>] = nums[j]-nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行完此行代码nums[j] = 6</span></span><br><span class=\"line\">    <span class=\"comment\">//等价于 nums[j] = 15 - 9</span></span><br><span class=\"line\">    nums[j] = nums[j] - nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！</p>\n<p>下一记: <strong>选择排序算法</strong></p>\n<hr>\n<h2 id=\"选择排序算法\"><a href=\"#选择排序算法\" class=\"headerlink\" title=\"选择排序算法\"></a>选择排序算法</h2><blockquote>\n<p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。</p>\n</blockquote>\n<p>上面这个引用是网上随便抄的一个思路。</p>\n<p>这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。</p>\n<p>我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。</p>\n<p>下面我们直接看代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//需要排序的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = &#123;<span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">25</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//记录每轮排序时最小元素的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> minIndex;</span><br><span class=\"line\">        <span class=\"comment\">//第一层循环控制轮数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            minIndex = i;<span class=\"comment\">//假设当前轮最小元素下标为i</span></span><br><span class=\"line\">            <span class=\"comment\">//内层循环要记录出当前轮最小元素的下标</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//比较两个相邻元素的大小</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//由于找到新的最小值，所以记录一下</span></span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大</span></span><br><span class=\"line\">                nums[minIndex] += nums[i];</span><br><span class=\"line\">                nums[i] = nums[minIndex] - nums[i];</span><br><span class=\"line\">                nums[minIndex] -= nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历输出排序后的结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。</p>\n<p>下一节，二分查找算法</p>\n<hr>\n<h2 id=\"二分查找法\"><a href=\"#二分查找法\" class=\"headerlink\" title=\"二分查找法\"></a>二分查找法</h2><blockquote>\n<p>这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。</p>\n</blockquote>\n<p>二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:</p>\n<ul>\n<li>定义起始查找位，结束查找位</li>\n<li>求得数组长度中间值都</li>\n<li>如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。</li>\n<li>如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。</li>\n<li>如果要查找的值等于中间值，那么直接返回中间值的下标即可</li>\n<li>如果都没找到，那么返回-1.</li>\n</ul>\n<p>看了这个概念，我们还得注意几点</p>\n<p>需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。</p>\n<p>好了，我们直接看代码吧！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nums[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">78</span>,<span class=\"number\">90</span>,<span class=\"number\">100</span>,<span class=\"number\">300</span>&#125;;</span><br><span class=\"line\">        System.out.println(binarySearch(nums,<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二分查找法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nums　要查找的数列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key　要查找的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> key)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//起始下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//结束下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//起始查询的下标不能超过结束下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start&lt;=end)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (start+end)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果中间下标的值比要查找的值大</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[middle]&gt;key)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找</span></span><br><span class=\"line\">                end = middle-<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[middle]&lt;key)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//二分的右边开始查找</span></span><br><span class=\"line\">                start = middle+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果要查找的值就是二分下标的值，那么直接返回即可</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有查找到那么则返回-1代表没有查找到</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<p>这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来.</p>","more":"<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><blockquote>\n<p>本页理解几个常用的算法</p>\n</blockquote>\n<hr>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p><strong>冒泡排序是一种稳定的排序算法</strong></p>\n<blockquote>\n<p>稳定即是，如果相邻的元素相同，不会再去进行调换位置</p>\n</blockquote>\n<p>冒排的运作是(从后往前)。</p>\n<p>我们操作数组来进行演示。</p>\n<p>我们首先定义一个整型数组里面存储几个整型数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//待排序的数列</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] nums = &#123;<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">25</span>&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。</p>\n</blockquote>\n<p><strong>每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。</strong></p>\n<p>我们尝试先用大脑来演示排序的过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//未排序时</span><br><span class=\"line\">9 6 4 3 10 25</span><br><span class=\"line\"></span><br><span class=\"line\">6 9 3 4 10 25 //第一轮 调换了2次</span><br><span class=\"line\">6 3 4 9 10 //第二轮 调换了2次</span><br><span class=\"line\">3 4 6 9 //第三轮 调换了2次</span><br><span class=\"line\">3 4 6 //第四轮 调换了0次</span><br><span class=\"line\">3 4 //第五轮 调换了0次</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到我们这组数据只需要排序三轮就可以排序成功，<strong>排序轮数是数组长度-1轮</strong>，调换次数是看数组相邻元素的大小关系，这个我们不用知道，<strong>我们只需要记住，排序轮数是数组长度-1就好。</strong></p>\n<p>那么在代码中我们要如何将其进行调换呢？</p>\n<p>有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。</p>\n<blockquote>\n<p>了解了基本思路，我们直接进行代码编写吧！</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//待排序的数列</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = &#123;<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">25</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//临时变量，用于调换位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"comment\">//第一层循环，控制轮数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//第二层，控制每轮要进行排序的元素数量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;nums.length-<span class=\"number\">1</span>-i;j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果当前元素比后一个元素大那么则调换元素值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]&gt;nums[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖</span></span><br><span class=\"line\">                    temp = nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"comment\">//把当前元素的值覆盖后一个元素</span></span><br><span class=\"line\">                    nums[j+<span class=\"number\">1</span>] = nums[j];</span><br><span class=\"line\">                    <span class=\"comment\">//再把当前元素存入后一个元素的值(刚刚保存在temp变量里的)</span></span><br><span class=\"line\">                    nums[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num:nums)&#123;</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。</p>\n<p><strong>引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个if不用加，我只是让你们知道是哪些代码</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(nums[j]&gt;nums[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前元素的值是与后一个元素值的和</span></span><br><span class=\"line\">    nums[j] = nums[j]+nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//上一行代码等同于 nums[j] = 9 + 6</span></span><br><span class=\"line\">    <span class=\"comment\">//执行完上一行代码，nums[j] = 15;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行完此行代码nums[j+1] = 9</span></span><br><span class=\"line\">    <span class=\"comment\">//等价于 nums[j+1]= 15 - 6</span></span><br><span class=\"line\">    nums[j+<span class=\"number\">1</span>] = nums[j]-nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行完此行代码nums[j] = 6</span></span><br><span class=\"line\">    <span class=\"comment\">//等价于 nums[j] = 15 - 9</span></span><br><span class=\"line\">    nums[j] = nums[j] - nums[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！</p>\n<p>下一记: <strong>选择排序算法</strong></p>\n<hr>\n<h2 id=\"选择排序算法\"><a href=\"#选择排序算法\" class=\"headerlink\" title=\"选择排序算法\"></a>选择排序算法</h2><blockquote>\n<p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。</p>\n</blockquote>\n<p>上面这个引用是网上随便抄的一个思路。</p>\n<p>这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。</p>\n<p>我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。</p>\n<p>下面我们直接看代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//需要排序的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = &#123;<span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">25</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//记录每轮排序时最小元素的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> minIndex;</span><br><span class=\"line\">        <span class=\"comment\">//第一层循环控制轮数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            minIndex = i;<span class=\"comment\">//假设当前轮最小元素下标为i</span></span><br><span class=\"line\">            <span class=\"comment\">//内层循环要记录出当前轮最小元素的下标</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//比较两个相邻元素的大小</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//由于找到新的最小值，所以记录一下</span></span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大</span></span><br><span class=\"line\">                nums[minIndex] += nums[i];</span><br><span class=\"line\">                nums[i] = nums[minIndex] - nums[i];</span><br><span class=\"line\">                nums[minIndex] -= nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历输出排序后的结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。</p>\n<p>下一节，二分查找算法</p>\n<hr>\n<h2 id=\"二分查找法\"><a href=\"#二分查找法\" class=\"headerlink\" title=\"二分查找法\"></a>二分查找法</h2><blockquote>\n<p>这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。</p>\n</blockquote>\n<p>二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是:</p>\n<ul>\n<li>定义起始查找位，结束查找位</li>\n<li>求得数组长度中间值都</li>\n<li>如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。</li>\n<li>如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。</li>\n<li>如果要查找的值等于中间值，那么直接返回中间值的下标即可</li>\n<li>如果都没找到，那么返回-1.</li>\n</ul>\n<p>看了这个概念，我们还得注意几点</p>\n<p>需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。</p>\n<p>好了，我们直接看代码吧！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nums[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">78</span>,<span class=\"number\">90</span>,<span class=\"number\">100</span>,<span class=\"number\">300</span>&#125;;</span><br><span class=\"line\">        System.out.println(binarySearch(nums,<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二分查找法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nums　要查找的数列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key　要查找的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> key)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//起始下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//结束下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//起始查询的下标不能超过结束下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start&lt;=end)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (start+end)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果中间下标的值比要查找的值大</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[middle]&gt;key)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找</span></span><br><span class=\"line\">                end = middle-<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[middle]&lt;key)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//二分的右边开始查找</span></span><br><span class=\"line\">                start = middle+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果要查找的值就是二分下标的值，那么直接返回即可</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有查找到那么则返回-1代表没有查找到</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"如何自学编程?","copyright":true,"date":"2019-05-23T14:19:59.000Z","_content":"\n前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。\n\n今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，\n\n为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。\n\n<!--more-->\n\n# 0x0 制定目标\n\n这个目标最好是十分远大的，并且必须是准确的。\n\n例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险...然后开始学习销售方面的才能。\n\n制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。\n\n# 0x1 选择方向\n\n你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。\n\n当然，我这里是推荐学习C++，虽然它曾经被我的偶像`Linus Torvalds`臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种`hack`玩法。\n\n# 0x2 学习过程\n\n在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。\n\n## 0x21学习心态\n我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。\n\n## 0x22学习方法\n\n`不要问，去调试，去反编译`\n\n这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。\n\n`多写代码，多讨论，尝试新想法`\n\n多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。\n\n多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。\n\n尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。\n\n# 0x3 充分利用互联网\n\n虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。\n\n不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下`原子弹制作从入门到精通`。这边推荐一个更好的利用搜索引擎的文章[点击访问](https://www.zhihu.com/question/23622803)\n\n# 0x4 读书\n\n在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。\n\n推荐书籍以后会写。\n\n\n# 0x5 推荐学习\n\n[C++视频教程](https://www.bilibili.com/video/av41559729)\n\n[C++书籍](http://bestcbooks.com/recommended-cpp-books/)\n\n[Git视频教程](https://www.bilibili.com/video/av24736323)\n\n# 0x6 其他\n\n如果你是Windows系统，那么推荐[Visual Studio](https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F)作为你的编程工具。\n\n如果你是Linux系统，那么推荐[CLion](https://www.jetbrains.com/clion/download/download-thanks.html)作为你的编程工具。\n\n如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。\n\n推荐学习资源:[点击访问](https://www.codedream.xin/archives/learning-material-list)\n\n# 0x7 讨论群组\n\n![群组](如何自学编程/群组.png)\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何自学编程.md","raw":"---\ntitle: 如何自学编程?\ncopyright: true\ndate: 2019-05-23 22:19:59\ncategories: 个人感想\ntags:\n - 个人感想\n---\n\n前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。\n\n今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，\n\n为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。\n\n<!--more-->\n\n# 0x0 制定目标\n\n这个目标最好是十分远大的，并且必须是准确的。\n\n例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险...然后开始学习销售方面的才能。\n\n制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。\n\n# 0x1 选择方向\n\n你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。\n\n当然，我这里是推荐学习C++，虽然它曾经被我的偶像`Linus Torvalds`臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种`hack`玩法。\n\n# 0x2 学习过程\n\n在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。\n\n## 0x21学习心态\n我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。\n\n## 0x22学习方法\n\n`不要问，去调试，去反编译`\n\n这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。\n\n`多写代码，多讨论，尝试新想法`\n\n多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。\n\n多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。\n\n尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。\n\n# 0x3 充分利用互联网\n\n虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。\n\n不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下`原子弹制作从入门到精通`。这边推荐一个更好的利用搜索引擎的文章[点击访问](https://www.zhihu.com/question/23622803)\n\n# 0x4 读书\n\n在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。\n\n推荐书籍以后会写。\n\n\n# 0x5 推荐学习\n\n[C++视频教程](https://www.bilibili.com/video/av41559729)\n\n[C++书籍](http://bestcbooks.com/recommended-cpp-books/)\n\n[Git视频教程](https://www.bilibili.com/video/av24736323)\n\n# 0x6 其他\n\n如果你是Windows系统，那么推荐[Visual Studio](https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F)作为你的编程工具。\n\n如果你是Linux系统，那么推荐[CLion](https://www.jetbrains.com/clion/download/download-thanks.html)作为你的编程工具。\n\n如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。\n\n推荐学习资源:[点击访问](https://www.codedream.xin/archives/learning-material-list)\n\n# 0x7 讨论群组\n\n![群组](如何自学编程/群组.png)\n\n\n\n\n\n\n\n\n\n","slug":"如何自学编程","published":1,"updated":"2020-01-19T03:49:51.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozod9005qomoouvjt6as2","content":"<p>前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。</p>\n<p>今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，</p>\n<p>为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。</p>\n<a id=\"more\"></a>\n<h1 id=\"0x0-制定目标\"><a href=\"#0x0-制定目标\" class=\"headerlink\" title=\"0x0 制定目标\"></a>0x0 制定目标</h1><p>这个目标最好是十分远大的，并且必须是准确的。</p>\n<p>例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。</p>\n<p>制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。</p>\n<h1 id=\"0x1-选择方向\"><a href=\"#0x1-选择方向\" class=\"headerlink\" title=\"0x1 选择方向\"></a>0x1 选择方向</h1><p>你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。</p>\n<p>当然，我这里是推荐学习C++，虽然它曾经被我的偶像<code>Linus Torvalds</code>臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种<code>hack</code>玩法。</p>\n<h1 id=\"0x2-学习过程\"><a href=\"#0x2-学习过程\" class=\"headerlink\" title=\"0x2 学习过程\"></a>0x2 学习过程</h1><p>在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。</p>\n<h2 id=\"0x21学习心态\"><a href=\"#0x21学习心态\" class=\"headerlink\" title=\"0x21学习心态\"></a>0x21学习心态</h2><p>我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。</p>\n<h2 id=\"0x22学习方法\"><a href=\"#0x22学习方法\" class=\"headerlink\" title=\"0x22学习方法\"></a>0x22学习方法</h2><p><code>不要问，去调试，去反编译</code></p>\n<p>这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。</p>\n<p><code>多写代码，多讨论，尝试新想法</code></p>\n<p>多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。</p>\n<p>多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。</p>\n<p>尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。</p>\n<h1 id=\"0x3-充分利用互联网\"><a href=\"#0x3-充分利用互联网\" class=\"headerlink\" title=\"0x3 充分利用互联网\"></a>0x3 充分利用互联网</h1><p>虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。</p>\n<p>不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下<code>原子弹制作从入门到精通</code>。这边推荐一个更好的利用搜索引擎的文章<a href=\"https://www.zhihu.com/question/23622803\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x4-读书\"><a href=\"#0x4-读书\" class=\"headerlink\" title=\"0x4 读书\"></a>0x4 读书</h1><p>在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。</p>\n<p>推荐书籍以后会写。</p>\n<h1 id=\"0x5-推荐学习\"><a href=\"#0x5-推荐学习\" class=\"headerlink\" title=\"0x5 推荐学习\"></a>0x5 推荐学习</h1><p><a href=\"https://www.bilibili.com/video/av41559729\" target=\"_blank\" rel=\"noopener\">C++视频教程</a></p>\n<p><a href=\"http://bestcbooks.com/recommended-cpp-books/\" target=\"_blank\" rel=\"noopener\">C++书籍</a></p>\n<p><a href=\"https://www.bilibili.com/video/av24736323\" target=\"_blank\" rel=\"noopener\">Git视频教程</a></p>\n<h1 id=\"0x6-其他\"><a href=\"#0x6-其他\" class=\"headerlink\" title=\"0x6 其他\"></a>0x6 其他</h1><p>如果你是Windows系统，那么推荐<a href=\"https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F\" target=\"_blank\" rel=\"noopener\">Visual Studio</a>作为你的编程工具。</p>\n<p>如果你是Linux系统，那么推荐<a href=\"https://www.jetbrains.com/clion/download/download-thanks.html\" target=\"_blank\" rel=\"noopener\">CLion</a>作为你的编程工具。</p>\n<p>如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。</p>\n<p>推荐学习资源:<a href=\"https://www.codedream.xin/archives/learning-material-list\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x7-讨论群组\"><a href=\"#0x7-讨论群组\" class=\"headerlink\" title=\"0x7 讨论群组\"></a>0x7 讨论群组</h1><p><img src=\"/2019/05/23/如何自学编程/群组.png\" alt=\"群组\"></p>\n","site":{"data":{}},"excerpt":"<p>前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。</p>\n<p>今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，</p>\n<p>为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。</p>","more":"<h1 id=\"0x0-制定目标\"><a href=\"#0x0-制定目标\" class=\"headerlink\" title=\"0x0 制定目标\"></a>0x0 制定目标</h1><p>这个目标最好是十分远大的，并且必须是准确的。</p>\n<p>例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。</p>\n<p>制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。</p>\n<h1 id=\"0x1-选择方向\"><a href=\"#0x1-选择方向\" class=\"headerlink\" title=\"0x1 选择方向\"></a>0x1 选择方向</h1><p>你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。</p>\n<p>当然，我这里是推荐学习C++，虽然它曾经被我的偶像<code>Linus Torvalds</code>臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种<code>hack</code>玩法。</p>\n<h1 id=\"0x2-学习过程\"><a href=\"#0x2-学习过程\" class=\"headerlink\" title=\"0x2 学习过程\"></a>0x2 学习过程</h1><p>在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。</p>\n<h2 id=\"0x21学习心态\"><a href=\"#0x21学习心态\" class=\"headerlink\" title=\"0x21学习心态\"></a>0x21学习心态</h2><p>我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。</p>\n<h2 id=\"0x22学习方法\"><a href=\"#0x22学习方法\" class=\"headerlink\" title=\"0x22学习方法\"></a>0x22学习方法</h2><p><code>不要问，去调试，去反编译</code></p>\n<p>这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。</p>\n<p><code>多写代码，多讨论，尝试新想法</code></p>\n<p>多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。</p>\n<p>多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。</p>\n<p>尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。</p>\n<h1 id=\"0x3-充分利用互联网\"><a href=\"#0x3-充分利用互联网\" class=\"headerlink\" title=\"0x3 充分利用互联网\"></a>0x3 充分利用互联网</h1><p>虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。</p>\n<p>不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下<code>原子弹制作从入门到精通</code>。这边推荐一个更好的利用搜索引擎的文章<a href=\"https://www.zhihu.com/question/23622803\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x4-读书\"><a href=\"#0x4-读书\" class=\"headerlink\" title=\"0x4 读书\"></a>0x4 读书</h1><p>在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。</p>\n<p>推荐书籍以后会写。</p>\n<h1 id=\"0x5-推荐学习\"><a href=\"#0x5-推荐学习\" class=\"headerlink\" title=\"0x5 推荐学习\"></a>0x5 推荐学习</h1><p><a href=\"https://www.bilibili.com/video/av41559729\" target=\"_blank\" rel=\"noopener\">C++视频教程</a></p>\n<p><a href=\"http://bestcbooks.com/recommended-cpp-books/\" target=\"_blank\" rel=\"noopener\">C++书籍</a></p>\n<p><a href=\"https://www.bilibili.com/video/av24736323\" target=\"_blank\" rel=\"noopener\">Git视频教程</a></p>\n<h1 id=\"0x6-其他\"><a href=\"#0x6-其他\" class=\"headerlink\" title=\"0x6 其他\"></a>0x6 其他</h1><p>如果你是Windows系统，那么推荐<a href=\"https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F\" target=\"_blank\" rel=\"noopener\">Visual Studio</a>作为你的编程工具。</p>\n<p>如果你是Linux系统，那么推荐<a href=\"https://www.jetbrains.com/clion/download/download-thanks.html\" target=\"_blank\" rel=\"noopener\">CLion</a>作为你的编程工具。</p>\n<p>如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。</p>\n<p>推荐学习资源:<a href=\"https://www.codedream.xin/archives/learning-material-list\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x7-讨论群组\"><a href=\"#0x7-讨论群组\" class=\"headerlink\" title=\"0x7 讨论群组\"></a>0x7 讨论群组</h1><p><img src=\"/2019/05/23/如何自学编程/群组.png\" alt=\"群组\"></p>"},{"title":"我儿子的博客","copyright":true,"date":"2019-05-21T08:06:54.000Z","_content":"\n自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。\n\n<!--more-->\n\n随便截取一个片段，这哥们咋那么傻的可爱。\n\n![预览](我儿子的博客/预览.png)\n\n想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。\n\n```PS:痔疮，你看到了别打我```\n\n\n# [EvanShady的博客](https://evanshady.github.io/)\n\n\n","source":"_posts/我儿子的博客.md","raw":"---\ntitle: 我儿子的博客\ncopyright: true\ndate: 2019-05-21 16:06:54\ncategories: 分享\ntags:\n - 欢乐时光\n---\n\n自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。\n\n<!--more-->\n\n随便截取一个片段，这哥们咋那么傻的可爱。\n\n![预览](我儿子的博客/预览.png)\n\n想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。\n\n```PS:痔疮，你看到了别打我```\n\n\n# [EvanShady的博客](https://evanshady.github.io/)\n\n\n","slug":"我儿子的博客","published":1,"updated":"2020-01-19T03:49:51.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozoda005uomoo3zq55hwc","content":"<p>自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。</p>\n<a id=\"more\"></a>\n<p>随便截取一个片段，这哥们咋那么傻的可爱。</p>\n<p><img src=\"/2019/05/21/我儿子的博客/预览.png\" alt=\"预览\"></p>\n<p>想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。</p>\n<p><code>PS:痔疮，你看到了别打我</code></p>\n<h1 id=\"EvanShady的博客\"><a href=\"#EvanShady的博客\" class=\"headerlink\" title=\"EvanShady的博客\"></a><a href=\"https://evanshady.github.io/\" target=\"_blank\" rel=\"noopener\">EvanShady的博客</a></h1>","site":{"data":{}},"excerpt":"<p>自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。</p>","more":"<p>随便截取一个片段，这哥们咋那么傻的可爱。</p>\n<p><img src=\"/2019/05/21/我儿子的博客/预览.png\" alt=\"预览\"></p>\n<p>想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。</p>\n<p><code>PS:痔疮，你看到了别打我</code></p>\n<h1 id=\"EvanShady的博客\"><a href=\"#EvanShady的博客\" class=\"headerlink\" title=\"EvanShady的博客\"></a><a href=\"https://evanshady.github.io/\" target=\"_blank\" rel=\"noopener\">EvanShady的博客</a></h1>"},{"title":"平铺式桌面-从入门到入坟","copyright":true,"date":"2019-07-12T14:22:03.000Z","_content":"\n本文章详细地介绍了我目前的桌面.通过此文章，你可以做到让i3成为你的一把利刃。\n\n<!--more-->\n\n# 暂时未完成\n\n首先上图，我的i3桌面.\n\n![桌面预览](平铺式桌面-从入门到入坟/桌面预览.png)\n\n# 0x0 i3\n\n## 一、安装i3\n\n安装i3很简单，我们直接输入下面这条命令即可\n\n~~~\n> sudo pacman -S i3 compton polybar\n~~~\n\n此时你可能会看到`i3-gaps`和`i3-wm`，选择哪个都可以，推荐`i3-gpas`，但如果你想拥有一个没有配置过的i3，那么你就直接安装`i3-wm`即可\n\n## 二、配置i3\n\n配置i3通过编辑`~/.config/i3/config`这个文件进行配置。\n\n我这里已经有配置好的i3，你们可以直接使用\n\n~~~\n\n# i3 config file (v4)\n#\n# Please see https://i3wm.org/docs/userguide.html for a complete reference!\n#\n# This config file uses keycodes (bindsym) and was written for the QWERTY\n# layout.\n#\n# To get a config file with the same key positions, but for your current\n# layout, use the i3-config-wizard\n#\n\n# Font for window titles. Will also be used by the bar unless a different font\n# is used in the bar {} block below.\nfont pango:monospace 8\n\n# This font is widely installed, provides lots of unicode glyphs, right-to-left\n# text rendering and scalability on retina/hidpi displays (thanks to pango).\n#font pango:DejaVu Sans Mono 8\n\n# Before i3 v4.8, we used to recommend this one as the default:\n# font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1\n# The font above is very space-efficient, that is, it looks good, sharp and\n# clear in small sizes. However, its unicode glyph coverage is limited, the old\n# X core fonts rendering does not support right-to-left and this being a bitmap\n# font, it doesn't scale on retina/hidpi displays.\n\n# use these keys for focus, movement, and resize directions when reaching for\n# the arrows is not convenient\nset $up l\nset $down k\nset $left j\nset $right semicolon\n\n# use Mouse+Mod1 to drag floating windows to their wanted position\nfloating_modifier Mod1\n\n# start a terminal\nbindsym Mod1+Return exec i3-sensible-terminal\n\n# kill focused window\nbindsym Mod1+Shift+q kill\n\n# start dmenu (a program launcher)\nbindsym Mod1+d exec dmenu_run\n# There also is the (new) i3-dmenu-desktop which only displays applications\n# shipping a .desktop file. It is a wrapper around dmenu, so you need that\n# installed.\n# bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop\n\n# change focus\nbindsym Mod1+$left focus left\nbindsym Mod1+$down focus down\nbindsym Mod1+$up focus up\nbindsym Mod1+$right focus right\n\n# alternatively, you can use the cursor keys:\nbindsym Mod1+Left focus left\nbindsym Mod1+Down focus down\nbindsym Mod1+Up focus up\nbindsym Mod1+Right focus right\n\n# move focused window\nbindsym Mod1+Shift+$left move left\nbindsym Mod1+Shift+$down move down\nbindsym Mod1+Shift+$up move up\nbindsym Mod1+Shift+$right move right\n\n# alternatively, you can use the cursor keys:\nbindsym Mod1+Shift+Left move left\nbindsym Mod1+Shift+Down move down\nbindsym Mod1+Shift+Up move up\nbindsym Mod1+Shift+Right move right\n\n# split in horizontal orientation\nbindsym Mod1+h split h\n\n# split in vertical orientation\nbindsym Mod1+v split v\n\n# enter fullscreen mode for the focused container\nbindsym Mod1+f fullscreen toggle\n\n# change container layout (stacked, tabbed, toggle split)\nbindsym Mod1+s layout stacking\nbindsym Mod1+w layout tabbed\nbindsym Mod1+e layout toggle split\n\n# toggle tiling / floating\nbindsym Mod1+Shift+space floating toggle\n\n# change focus between tiling / floating windows\nbindsym Mod1+space focus mode_toggle\n\n# focus the parent container\nbindsym Mod1+a focus parent\n\n# focus the child container\n#bindsym Mod1+d focus child\n\n# move the currently focused window to the scratchpad\nbindsym Mod1+Shift+minus move scratchpad\n\n# Show the next scratchpad window or hide the focused scratchpad window.\n# If there are multiple scratchpad windows, this command cycles through them.\nbindsym Mod1+minus scratchpad show\n\n# Define names for default workspaces for which we configure key bindings later on.\n# We use variables to avoid repeating the names in multiple places.\nset $ws1 \"1\"\nset $ws2 \"2\"\nset $ws3 \"3\"\nset $ws4 \"4\"\nset $ws5 \"5\"\nset $ws6 \"6\"\nset $ws7 \"7\"\nset $ws8 \"8\"\nset $ws9 \"9\"\nset $ws10 \"10\"\n\n\n# switch to workspace\nbindsym Mod1+1 workspace $ws1\nbindsym Mod1+2 workspace $ws2\nbindsym Mod1+3 workspace $ws3\nbindsym Mod1+4 workspace $ws4\nbindsym Mod1+5 workspace $ws5\nbindsym Mod1+6 workspace $ws6\nbindsym Mod1+7 workspace $ws7\nbindsym Mod1+8 workspace $ws8\nbindsym Mod1+9 workspace $ws9\nbindsym Mod1+0 workspace $ws10\n\n# move focused container to workspace\nbindsym Mod1+Shift+1 move container to workspace $ws1\nbindsym Mod1+Shift+2 move container to workspace $ws2\nbindsym Mod1+Shift+3 move container to workspace $ws3\nbindsym Mod1+Shift+4 move container to workspace $ws4\nbindsym Mod1+Shift+5 move container to workspace $ws5\nbindsym Mod1+Shift+6 move container to workspace $ws6\nbindsym Mod1+Shift+7 move container to workspace $ws7\nbindsym Mod1+Shift+8 move container to workspace $ws8\nbindsym Mod1+Shift+9 move container to workspace $ws9\nbindsym Mod1+Shift+0 move container to workspace $ws10\n\n# reload the configuration file\nbindsym Mod1+Shift+c reload\n# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)\nbindsym Mod1+Shift+r restart\n# exit i3 (logs you out of your X session)\nbindsym Mod1+Shift+e exec \"i3-nagbar -t warning -m 'You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.' -B 'Yes, exit i3' 'i3-msg exit'\"\n\n# resize window (you can also use the mouse for that)\nmode \"resize\" {\n        # These bindings trigger as soon as you enter the resize mode\n\n        # Pressing left will shrink the window’s width.\n        # Pressing right will grow the window’s width.\n        # Pressing up will shrink the window’s height.\n        # Pressing down will grow the window’s height.\n        bindsym $left       resize shrink width 10 px or 10 ppt\n        bindsym $down       resize grow height 10 px or 10 ppt\n        bindsym $up         resize shrink height 10 px or 10 ppt\n        bindsym $right      resize grow width 10 px or 10 ppt\n\n        # same bindings, but for the arrow keys\n        bindsym Left        resize shrink width 10 px or 10 ppt\n        bindsym Down        resize grow height 10 px or 10 ppt\n        bindsym Up          resize shrink height 10 px or 10 ppt\n        bindsym Right       resize grow width 10 px or 10 ppt\n\n        # back to normal: Enter or Escape or Mod1+r\n        bindsym Return mode \"default\"\n        bindsym Escape mode \"default\"\n        bindsym Mod1+r mode \"default\"\n}\n\nbindsym Mod1+r mode \"resize\"\n\n# Start i3bar to display a workspace bar (plus the system information i3status\n# finds out, if available)\nbar {\n        status_command i3status\n}\n\n#######################################################################\n# automatically start i3-config-wizard to offer the user to create a\n# keysym-based config which used their favorite modifier (alt or windows)\n#\n# i3-config-wizard will not launch if there already is a config file\n# in ~/.i3/config.\n#\n# Please remove the following exec line:\n#######################################################################\nexec i3-config-wizard\n~~~\n\n将上面的内容粘贴到i3的配置文件内即可\n\n## 四、美化i3-polybar\n\n`polybar`是一个快速并且易用的状态显示栏\n\n就如同你们看到的桌面预览图一般，上面的状态栏就是通过`polybar`实现的\n\n我的polybar已经配置完成了，可以方便的显示工作区的数字，以及窗口的标题，以及CPU,RAM,CPU温度,时间,系统托盘等功能。\n\n~~~\n\n\n;==========================================================\n;\n;\n;   ██████╗  ██████╗ ██╗  ██╗   ██╗██████╗  █████╗ ██████╗\n;   ██╔══██╗██╔═══██╗██║  ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗\n;   ██████╔╝██║   ██║██║   ╚████╔╝ ██████╔╝███████║██████╔╝\n;   ██╔═══╝ ██║   ██║██║    ╚██╔╝  ██╔══██╗██╔══██║██╔══██╗\n;   ██║     ╚██████╔╝███████╗██║   ██████╔╝██║  ██║██║  ██║\n;   ╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝\n;\n;\n;   To learn more about how to configure Polybar\n;   go to https://github.com/polybar/polybar\n;\n;   The README contains a lot of information\n;\n;==========================================================\n\n[colors]\nbackground = #cc222222\nbackground-alt = #444\n;foreground = ${xrdb:color7:#222}\nforeground = #dfdfdf\nforeground-alt = #555\nprimary = #ffb52a\nsecondary = #e60053\nalert = #bd2c40\n\n[bar/example]\n;monitor = ${env:MONITOR:HDMI1}\nmonitor = ${env:MONITOR:eDP1}\nwidth = 100%\nheight = 30\n;offset-x = 1%\n;offset-y = 1%\nradius = 6.0\nfixed-center = true\n\nbackground = ${colors.background}\nforeground = ${colors.foreground}\n\nline-size = 3\nline-color = #f00\n\nborder-top-size = 0\nborder-left-size = 0\nborder-right-size = 0\nborder-color = #00000000\n\npadding-left = 0\npadding-right = 2\n\nmodule-margin-left = 1\nmodule-margin-right = 2\n\n\nfont-0 = ttf-liberation-sans:fixed:pixelsize=12;1\nfont-1 = source han sans cn:pixelsize=12:antialias=false;1\nfont-2 = \"Font Awesome 5 Free:style=Solid:pixelsize=12;1\"\nfont-3 = \"Font Awesome 5 Brands:style=Regular:pixelsize=12;1\"\nfont-4 = \"material icons:pixelsize=16;3\"\n\nmodules-left = i3\nmodules-center = xwindow\n;modules-center = \nmodules-right = cpu memory temperature battery date \n\ntray-position = right\ntray-padding = 2\ntray-background = ${colors.background}\n\ncursor-click = pointer\ncursor-scroll = ns-resize\n\n[module/xwindow]\ntype = internal/xwindow\nlabel = %title%\nwidth = 50\nlabel-maxlen = 45\n\n[module/xkeyboard]\ntype = internal/xkeyboard\nblacklist-0 = num lock\n\nformat-prefix = \"\"\nformat-prefix-foreground = ${colors.foreground-alt}\nformat-prefix-underline = ${colors.secondary}\n\nlabel-layout = %layout%\nlabel-layout-underline = ${colors.secondary}\n\nlabel-indicator-padding = 2\nlabel-indicator-margin = 1\nlabel-indicator-background = ${colors.secondary}\nlabel-indicator-underline = ${colors.secondary}\n\n[module/filesystem]\ntype = internal/fs\ninterval = 25\n\nmount-0 = /\n\nlabel-mounted = %{F#0a81f5}%mountpoint%%{F-}: %percentage_used%%\nlabel-unmounted = %mountpoint% not mounted\nlabel-unmounted-foreground = ${colors.foreground-alt}\n\n[module/bspwm]\ntype = internal/bspwm\n\nlabel-focused = %index%\nlabel-focused-background = ${colors.background-alt}\nlabel-focused-underline= ${colors.primary}\nlabel-focused-padding = 2\n\nlabel-occupied = %index%\nlabel-occupied-padding = 2\n\nlabel-urgent = %index%!\nlabel-urgent-background = ${colors.alert}\nlabel-urgent-padding = 2\n\nlabel-empty = %index%\nlabel-empty-foreground = ${colors.foreground-alt}\nlabel-empty-padding = 2\n\n[module/i3]\ntype = internal/i3\nformat = <label-state> <label-mode>\nindex-sort = true\nwrapping-scroll = false\n\nlabel-focused = %name%\nlabel-unfocused = %name%\nlabel-visible = %name%\nlabel-urgent = %name%\n\nlabel-mode-padding = 2\nlabel-mode-foreground = #000\nlabel-mode-background = ${colors.primary}\n\nlabel-focused-background = ${module/bspwm.label-focused-background}\nlabel-focused-underline = ${module/bspwm.label-focused-underline}\nlabel-focused-padding = ${module/bspwm.label-focused-padding}\n\nlabel-unfocused-padding = ${module/bspwm.label-occupied-padding}\n\nlabel-visible-background = ${self.label-focused-background}\nlabel-visible-underline = ${self.label-focused-underline}\nlabel-visible-padding = ${self.label-focused-padding}\n\nlabel-urgent-background = ${module/bspwm.label-urgent-background}\nlabel-urgent-padding = ${module/bspwm.label-urgent-padding} |\n\n\n[module/xbacklight]\ntype = internal/xbacklight\n\nformat = <label> <bar>\nlabel = BL\n\nbar-width = 10\nbar-indicator = |\nbar-indicator-foreground = #ff\nbar-indicator-font = 2\nbar-fill = ─\nbar-fill-font = 2\nbar-fill-foreground = #9f78e1\nbar-empty = ─\nbar-empty-font = 2\nbar-empty-foreground = ${colors.foreground-alt}\n\n[module/backlight-acpi]\ninherit = module/xbacklight\ntype = internal/backlight\ncard = intel_backlight\n\n[module/cpu]\ntype = internal/cpu\ninterval = 2\nformat-prefix = \" \"\n;format-prefix-foreground = ${colors.foreground-alt}\n;format-underline = #f90000\nlabel = %percentage:2%%\n\n[module/memory]\ntype = internal/memory\ninterval = 2\nformat-prefix = \"  \"\n;format-prefix-foreground = ${colors.foreground-alt}\n;format-underline = #4bffdc\nlabel = %percentage_used%%\n\n[module/wlan]\ntype = internal/network\ninterface = wlp3s0\ninterval = 3.0\n\nformat-connected = <ramp-signal>\n;format-connected-underline = #9f78e1\nlabel-connected = \"%essid%\"\n\nformat-disconnected = \n;format-disconnected = <label-disconnected>\n;format-disconnected-underline = ${self.format-connected-underline}\nlabel-disconnected = %ifname% disconnected\nlabel-disconnected-foreground = #999999\n\nramp-signal-0 = \nramp-signal-1 = \nramp-signal-2 = \nramp-signal-3 = \nramp-signal-4 = \nanimation-packetloss-0 = ⚠\nanimation-packetloss-0-foreground = #ffa64c\n;ramp-signal-foreground = ${colors.foreground-alt}\n\n[module/eth]\ntype = internal/network\ninterface = enp0s31f6\ninterval = 3.0\n\nformat-connected-underline = #55aa55\nformat-connected-prefix = \"📶\"\nformat-connected-prefix-foreground = ${colors.foreground-alt}\nlabel-connected = %local_ip%\n\nformat-disconnected =\n;format-disconnected = <label-disconnected>\n;format-disconnected-underline = ${self.format-connected-underline}\n;label-disconnected = %ifname% disconnected\n;label-disconnected-foreground = ${colors.foreground-alt}\n\n[module/date]\ntype = internal/date\ninterval = 5\n\ndate = \" %Y-%m-%d\"\n;date-alt = \" %Y-%m-%d\"\n\ntime = %H:%M\n;time-alt = %H:%M:%S\n\nformat-prefix = \n;format-prefix-foreground = ${colors.foreground-alt}\n;format-underline = #0a6cf5\n\nlabel = %date% %time%\n\n\n[module/alsa]\ntype = internal/volume\n\nformat-volume = <label-volume> <bar-volume>\nlabel-volume = \nlabel-volume-foreground = ${root.foreground}\n\nformat-muted-prefix = \" \"\nformat-muted-foreground = ${colors.foreground-alt}\nlabel-muted = \n\nbar-volume-width = 5\nbar-volume-foreground-0 = #55aa55\nbar-volume-foreground-1 = #55aa55\nbar-volume-foreground-2 = #55aa55\nbar-volume-foreground-3 = #55aa55\nbar-volume-foreground-4 = #55aa55\nbar-volume-foreground-5 = #f5a70a\nbar-volume-foreground-6 = #ff5555\nbar-volume-gradient = false\nbar-volume-indicator = |\nbar-volume-indicator-font = 2\nbar-volume-fill = ─\nbar-volume-fill-font = 2\nbar-volume-empty = ─\nbar-volume-empty-font = 2\nbar-volume-empty-foreground = ${colors.foreground-alt}\n\n[module/battery]\ntype = internal/battery\nbattery = BAT0\nadapter = ADP1\nfull-at = 98\n\nformat-charging = <animation-charging> <label-charging>\nformat-charging-underline = #ffb52a\n\nformat-discharging = <ramp-capacity> <label-discharging>\n;format-discharging-underline = ${self.format-charging-underline}\n\nformat-full-prefix = \" \"\n;format-full-prefix-foreground = ${colors.foreground-alt}\nformat-full-underline = ${self.format-charging-underline}\n\nramp-capacity-0 = \nramp-capacity-1 = \nramp-capacity-2 = \nramp-capacity-3 = \n;ramp-capacity-foreground = ${colors.foreground-alt}\n\nanimation-charging-0 = \nanimation-charging-1 = \nanimation-charging-2 = \nanimation-charging-3 = \n;animation-charging-foreground = ${colors.foreground-alt}\nanimation-charging-framerate = 750\n\n[module/temperature]\ntype = internal/temperature\nthermal-zone = 0\nwarn-temperature = 60\n\nformat = <ramp> <label>\n;format-underline = #f50a4d\nformat-warn = <ramp> <label-warn>\n;format-warn-underline = ${self.format-underline}\n\nlabel = %temperature%\nlabel-warn = %temperature%\nlabel-warn-foreground = ${colors.secondary}\n\nramp-0 = \nramp-1 = \nramp-2 = \n;ramp-foreground = ${colors.foreground-alt}\n\n[module/powermenu]\ntype = custom/menu\nexpand-right = true\n\nformat-spacing = 1\n\nlabel-open = \nlabel-open-foreground = ${colors.secondary}\nlabel-close =  cancel\nlabel-close-foreground = ${colors.secondary}\nlabel-separator = |\nlabel-separator-foreground = ${colors.foreground-alt}\n\nmenu-0-0 = reboot\nmenu-0-0-exec = reboot\nmenu-0-1 = power off\nmenu-0-1-exec = poweroff\n\n\n[settings]\nscreenchange-reload = true\n\n\n[global/wm]\nmargin-top = 5\nmargin-bottom = 5\n~~~\n\n上面这段配置文件是polybar的配置文件，我们还需要一个启动polybar的脚本\n\n> launch.sh\n\n这里的`launch.sh`可以改名，但是不必须得放在`~/.config/polybar`目录下，改名后需要修改`i3`配置文件的第`33`行。\n\n~~~\n#!/usr/bin/env bash\n\n# Terminate already running bar instances\nkillall -q polybar\n\n# Wait until the processes have been shut down\nwhile pgrep -u $UID -x polybar >/dev/null; do sleep 1; done\n\n# Launch bar1 and bar2\npolybar example &\n~~~\n\n## 三、使用i3\n\n这一小节，我主要介绍我的配置文件所做的事。\n\n下面的说明并不是将我的配置文件全部进行解读，有些我觉得你们能看懂的我就没写。\n\n__set $mod Mod1__  设置i3的super为`Alt`键\n\n__new_window pixel 1__ 设置新窗口的窗口边缘的像素\n\n__new_float normal__ 设置浮动窗口，值为默认\n\n__hide_edge_borders__ 设置窗口边框隐藏\n\n\n| 按键                     | 说明                                     |\n|--------------------------|------------------------------------------|\n| $mod+u                   | 设置边框存在                             |\n| $mod+y                   | 设置边框像素为1                          |\n| $mod+n                   | 设置边框隐藏                             |\n| $mod+Return(回车键)      | 打开alacritty终端                        |\n| $mod+Shift+Return        | 通过alacritty打开ranger                  |\n| $mod+Control+g           | 打开Chrome                               |\n| $mod+Controll+f          | 打开Firefox                              |\n| $mod+Shift+q             | 杀死聚焦窗口                             |\n| $mod+d                   | 打开rofi                                 |\n| $mod+h+j+k+l             | 将聚焦在窗口之间切换                     |\n| $mdo+上下左右            | 同上，只不过用的是方向键                 |\n| $mod+Shift+h+j+k+l       | 将聚焦窗口改变排列位置                   |\n| $mod+Shift+上下左右      | 同上，只不过用的是方向键                 |\n| $mod+b                   | 切换至上一个工作区                       |\n| $mod+Shift+b             | 将上一个工作区的容器，移动至当前工作区内 |\n| $mod+q                   | 切换平铺方式                             |\n| $mod+f                   | 将聚焦窗口全屏                           |\n| $mod+s                   | 容器窗口排列方式为堆叠式                 |\n| $mod+w                   | 容器窗口排列方式为标签式                 |\n| $mod+e                   | 容器窗口排列方式为平铺式                 |\n| $mod+Shift+space(空格键) | 切换容器窗口为平铺还是浮动               |\n| $mod+space               | 在浮动或平铺窗口之间进行聚焦的切换       |\n| $mod+Ctrl+左或右         | 切换工作区，前或后                       |\n| $mod+1-8                 | 切换工作区                               |\n| $mod+Ctrl+1-8            | 将当前容器的窗口移动至某个工作区         |\n| $mod+Shift+1-8           | 将当前容器移动至某个工作区               |\n| $mod+Shift+r             | 重启i3                                   |\n| $mod+Shift+c             | 重载i3配置文件                           |\n| $mod+0                   | 进入系统模式                             |\n| l                        | 系统模式:锁屏                            |\n| s                        | 系统模式:挂出                            |\n| u                        | 系统模式:切换用户                        |\n| e                        | 系统模式:登出                            |\n| h                        | 系统模式:休眠                            |\n| r                        | 系统模式:重启                            |\n| Shift+s                  | 系统模式:关机                            |\n| $mod+r                   | 进入窗口大小设置模式                     |\n| h j k l                  | 设置窗口上下左右的大小                   |\n| 上下左右                 | 同上                                     |\n| Return                   | 退出窗口大小设置模式                     |\n| 触摸板开关               | 触摸板开关                               |\n\n# 0x2 rofi\n\n## 一、安装rofi\n\n> sudo pacman -S rofi\n\n## 二、配置rofi\n\n## 三、使用rofi\n\n# 0x1 ranger\n\n## 一、安装ranger\n\n## 二、配置ranger\n\n## 三、使用ranger\n\n# 0x2 alacritty\n\n## 一、安装alacritty\n\n## 二、配置alacritty\n\n## 三、使用alacritty\n\n# 0x3 vim\n\n## 一、配置vim\n\n# 0x4 zsh\n\n## 一、安装zsh\n\n## 二、配置zsh\n\n# 0x5 ssr+proxychains\n\n## 一、安装ssr\n\n## 二、配置ssr\n\n## 三、安装proxychains\n\n## 四、配置proxychains\n\n## 五、使用ssr+proxychains实现全应用走代理\n\n# 0x6 fcitx\n\n## 一、安装fcitx\n\n## 二、配置fcitx\n\n## 三、启动fcitx\n\n\n","source":"_posts/平铺式桌面-从入门到入坟.md","raw":"---\ntitle: 平铺式桌面-从入门到入坟\ncopyright: true\ndate: 2019-07-12 22:22:03\ncategories: 折腾日志\ntags:\n  - Linux\n  - i3\n---\n\n本文章详细地介绍了我目前的桌面.通过此文章，你可以做到让i3成为你的一把利刃。\n\n<!--more-->\n\n# 暂时未完成\n\n首先上图，我的i3桌面.\n\n![桌面预览](平铺式桌面-从入门到入坟/桌面预览.png)\n\n# 0x0 i3\n\n## 一、安装i3\n\n安装i3很简单，我们直接输入下面这条命令即可\n\n~~~\n> sudo pacman -S i3 compton polybar\n~~~\n\n此时你可能会看到`i3-gaps`和`i3-wm`，选择哪个都可以，推荐`i3-gpas`，但如果你想拥有一个没有配置过的i3，那么你就直接安装`i3-wm`即可\n\n## 二、配置i3\n\n配置i3通过编辑`~/.config/i3/config`这个文件进行配置。\n\n我这里已经有配置好的i3，你们可以直接使用\n\n~~~\n\n# i3 config file (v4)\n#\n# Please see https://i3wm.org/docs/userguide.html for a complete reference!\n#\n# This config file uses keycodes (bindsym) and was written for the QWERTY\n# layout.\n#\n# To get a config file with the same key positions, but for your current\n# layout, use the i3-config-wizard\n#\n\n# Font for window titles. Will also be used by the bar unless a different font\n# is used in the bar {} block below.\nfont pango:monospace 8\n\n# This font is widely installed, provides lots of unicode glyphs, right-to-left\n# text rendering and scalability on retina/hidpi displays (thanks to pango).\n#font pango:DejaVu Sans Mono 8\n\n# Before i3 v4.8, we used to recommend this one as the default:\n# font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1\n# The font above is very space-efficient, that is, it looks good, sharp and\n# clear in small sizes. However, its unicode glyph coverage is limited, the old\n# X core fonts rendering does not support right-to-left and this being a bitmap\n# font, it doesn't scale on retina/hidpi displays.\n\n# use these keys for focus, movement, and resize directions when reaching for\n# the arrows is not convenient\nset $up l\nset $down k\nset $left j\nset $right semicolon\n\n# use Mouse+Mod1 to drag floating windows to their wanted position\nfloating_modifier Mod1\n\n# start a terminal\nbindsym Mod1+Return exec i3-sensible-terminal\n\n# kill focused window\nbindsym Mod1+Shift+q kill\n\n# start dmenu (a program launcher)\nbindsym Mod1+d exec dmenu_run\n# There also is the (new) i3-dmenu-desktop which only displays applications\n# shipping a .desktop file. It is a wrapper around dmenu, so you need that\n# installed.\n# bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop\n\n# change focus\nbindsym Mod1+$left focus left\nbindsym Mod1+$down focus down\nbindsym Mod1+$up focus up\nbindsym Mod1+$right focus right\n\n# alternatively, you can use the cursor keys:\nbindsym Mod1+Left focus left\nbindsym Mod1+Down focus down\nbindsym Mod1+Up focus up\nbindsym Mod1+Right focus right\n\n# move focused window\nbindsym Mod1+Shift+$left move left\nbindsym Mod1+Shift+$down move down\nbindsym Mod1+Shift+$up move up\nbindsym Mod1+Shift+$right move right\n\n# alternatively, you can use the cursor keys:\nbindsym Mod1+Shift+Left move left\nbindsym Mod1+Shift+Down move down\nbindsym Mod1+Shift+Up move up\nbindsym Mod1+Shift+Right move right\n\n# split in horizontal orientation\nbindsym Mod1+h split h\n\n# split in vertical orientation\nbindsym Mod1+v split v\n\n# enter fullscreen mode for the focused container\nbindsym Mod1+f fullscreen toggle\n\n# change container layout (stacked, tabbed, toggle split)\nbindsym Mod1+s layout stacking\nbindsym Mod1+w layout tabbed\nbindsym Mod1+e layout toggle split\n\n# toggle tiling / floating\nbindsym Mod1+Shift+space floating toggle\n\n# change focus between tiling / floating windows\nbindsym Mod1+space focus mode_toggle\n\n# focus the parent container\nbindsym Mod1+a focus parent\n\n# focus the child container\n#bindsym Mod1+d focus child\n\n# move the currently focused window to the scratchpad\nbindsym Mod1+Shift+minus move scratchpad\n\n# Show the next scratchpad window or hide the focused scratchpad window.\n# If there are multiple scratchpad windows, this command cycles through them.\nbindsym Mod1+minus scratchpad show\n\n# Define names for default workspaces for which we configure key bindings later on.\n# We use variables to avoid repeating the names in multiple places.\nset $ws1 \"1\"\nset $ws2 \"2\"\nset $ws3 \"3\"\nset $ws4 \"4\"\nset $ws5 \"5\"\nset $ws6 \"6\"\nset $ws7 \"7\"\nset $ws8 \"8\"\nset $ws9 \"9\"\nset $ws10 \"10\"\n\n\n# switch to workspace\nbindsym Mod1+1 workspace $ws1\nbindsym Mod1+2 workspace $ws2\nbindsym Mod1+3 workspace $ws3\nbindsym Mod1+4 workspace $ws4\nbindsym Mod1+5 workspace $ws5\nbindsym Mod1+6 workspace $ws6\nbindsym Mod1+7 workspace $ws7\nbindsym Mod1+8 workspace $ws8\nbindsym Mod1+9 workspace $ws9\nbindsym Mod1+0 workspace $ws10\n\n# move focused container to workspace\nbindsym Mod1+Shift+1 move container to workspace $ws1\nbindsym Mod1+Shift+2 move container to workspace $ws2\nbindsym Mod1+Shift+3 move container to workspace $ws3\nbindsym Mod1+Shift+4 move container to workspace $ws4\nbindsym Mod1+Shift+5 move container to workspace $ws5\nbindsym Mod1+Shift+6 move container to workspace $ws6\nbindsym Mod1+Shift+7 move container to workspace $ws7\nbindsym Mod1+Shift+8 move container to workspace $ws8\nbindsym Mod1+Shift+9 move container to workspace $ws9\nbindsym Mod1+Shift+0 move container to workspace $ws10\n\n# reload the configuration file\nbindsym Mod1+Shift+c reload\n# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)\nbindsym Mod1+Shift+r restart\n# exit i3 (logs you out of your X session)\nbindsym Mod1+Shift+e exec \"i3-nagbar -t warning -m 'You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.' -B 'Yes, exit i3' 'i3-msg exit'\"\n\n# resize window (you can also use the mouse for that)\nmode \"resize\" {\n        # These bindings trigger as soon as you enter the resize mode\n\n        # Pressing left will shrink the window’s width.\n        # Pressing right will grow the window’s width.\n        # Pressing up will shrink the window’s height.\n        # Pressing down will grow the window’s height.\n        bindsym $left       resize shrink width 10 px or 10 ppt\n        bindsym $down       resize grow height 10 px or 10 ppt\n        bindsym $up         resize shrink height 10 px or 10 ppt\n        bindsym $right      resize grow width 10 px or 10 ppt\n\n        # same bindings, but for the arrow keys\n        bindsym Left        resize shrink width 10 px or 10 ppt\n        bindsym Down        resize grow height 10 px or 10 ppt\n        bindsym Up          resize shrink height 10 px or 10 ppt\n        bindsym Right       resize grow width 10 px or 10 ppt\n\n        # back to normal: Enter or Escape or Mod1+r\n        bindsym Return mode \"default\"\n        bindsym Escape mode \"default\"\n        bindsym Mod1+r mode \"default\"\n}\n\nbindsym Mod1+r mode \"resize\"\n\n# Start i3bar to display a workspace bar (plus the system information i3status\n# finds out, if available)\nbar {\n        status_command i3status\n}\n\n#######################################################################\n# automatically start i3-config-wizard to offer the user to create a\n# keysym-based config which used their favorite modifier (alt or windows)\n#\n# i3-config-wizard will not launch if there already is a config file\n# in ~/.i3/config.\n#\n# Please remove the following exec line:\n#######################################################################\nexec i3-config-wizard\n~~~\n\n将上面的内容粘贴到i3的配置文件内即可\n\n## 四、美化i3-polybar\n\n`polybar`是一个快速并且易用的状态显示栏\n\n就如同你们看到的桌面预览图一般，上面的状态栏就是通过`polybar`实现的\n\n我的polybar已经配置完成了，可以方便的显示工作区的数字，以及窗口的标题，以及CPU,RAM,CPU温度,时间,系统托盘等功能。\n\n~~~\n\n\n;==========================================================\n;\n;\n;   ██████╗  ██████╗ ██╗  ██╗   ██╗██████╗  █████╗ ██████╗\n;   ██╔══██╗██╔═══██╗██║  ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗\n;   ██████╔╝██║   ██║██║   ╚████╔╝ ██████╔╝███████║██████╔╝\n;   ██╔═══╝ ██║   ██║██║    ╚██╔╝  ██╔══██╗██╔══██║██╔══██╗\n;   ██║     ╚██████╔╝███████╗██║   ██████╔╝██║  ██║██║  ██║\n;   ╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝\n;\n;\n;   To learn more about how to configure Polybar\n;   go to https://github.com/polybar/polybar\n;\n;   The README contains a lot of information\n;\n;==========================================================\n\n[colors]\nbackground = #cc222222\nbackground-alt = #444\n;foreground = ${xrdb:color7:#222}\nforeground = #dfdfdf\nforeground-alt = #555\nprimary = #ffb52a\nsecondary = #e60053\nalert = #bd2c40\n\n[bar/example]\n;monitor = ${env:MONITOR:HDMI1}\nmonitor = ${env:MONITOR:eDP1}\nwidth = 100%\nheight = 30\n;offset-x = 1%\n;offset-y = 1%\nradius = 6.0\nfixed-center = true\n\nbackground = ${colors.background}\nforeground = ${colors.foreground}\n\nline-size = 3\nline-color = #f00\n\nborder-top-size = 0\nborder-left-size = 0\nborder-right-size = 0\nborder-color = #00000000\n\npadding-left = 0\npadding-right = 2\n\nmodule-margin-left = 1\nmodule-margin-right = 2\n\n\nfont-0 = ttf-liberation-sans:fixed:pixelsize=12;1\nfont-1 = source han sans cn:pixelsize=12:antialias=false;1\nfont-2 = \"Font Awesome 5 Free:style=Solid:pixelsize=12;1\"\nfont-3 = \"Font Awesome 5 Brands:style=Regular:pixelsize=12;1\"\nfont-4 = \"material icons:pixelsize=16;3\"\n\nmodules-left = i3\nmodules-center = xwindow\n;modules-center = \nmodules-right = cpu memory temperature battery date \n\ntray-position = right\ntray-padding = 2\ntray-background = ${colors.background}\n\ncursor-click = pointer\ncursor-scroll = ns-resize\n\n[module/xwindow]\ntype = internal/xwindow\nlabel = %title%\nwidth = 50\nlabel-maxlen = 45\n\n[module/xkeyboard]\ntype = internal/xkeyboard\nblacklist-0 = num lock\n\nformat-prefix = \"\"\nformat-prefix-foreground = ${colors.foreground-alt}\nformat-prefix-underline = ${colors.secondary}\n\nlabel-layout = %layout%\nlabel-layout-underline = ${colors.secondary}\n\nlabel-indicator-padding = 2\nlabel-indicator-margin = 1\nlabel-indicator-background = ${colors.secondary}\nlabel-indicator-underline = ${colors.secondary}\n\n[module/filesystem]\ntype = internal/fs\ninterval = 25\n\nmount-0 = /\n\nlabel-mounted = %{F#0a81f5}%mountpoint%%{F-}: %percentage_used%%\nlabel-unmounted = %mountpoint% not mounted\nlabel-unmounted-foreground = ${colors.foreground-alt}\n\n[module/bspwm]\ntype = internal/bspwm\n\nlabel-focused = %index%\nlabel-focused-background = ${colors.background-alt}\nlabel-focused-underline= ${colors.primary}\nlabel-focused-padding = 2\n\nlabel-occupied = %index%\nlabel-occupied-padding = 2\n\nlabel-urgent = %index%!\nlabel-urgent-background = ${colors.alert}\nlabel-urgent-padding = 2\n\nlabel-empty = %index%\nlabel-empty-foreground = ${colors.foreground-alt}\nlabel-empty-padding = 2\n\n[module/i3]\ntype = internal/i3\nformat = <label-state> <label-mode>\nindex-sort = true\nwrapping-scroll = false\n\nlabel-focused = %name%\nlabel-unfocused = %name%\nlabel-visible = %name%\nlabel-urgent = %name%\n\nlabel-mode-padding = 2\nlabel-mode-foreground = #000\nlabel-mode-background = ${colors.primary}\n\nlabel-focused-background = ${module/bspwm.label-focused-background}\nlabel-focused-underline = ${module/bspwm.label-focused-underline}\nlabel-focused-padding = ${module/bspwm.label-focused-padding}\n\nlabel-unfocused-padding = ${module/bspwm.label-occupied-padding}\n\nlabel-visible-background = ${self.label-focused-background}\nlabel-visible-underline = ${self.label-focused-underline}\nlabel-visible-padding = ${self.label-focused-padding}\n\nlabel-urgent-background = ${module/bspwm.label-urgent-background}\nlabel-urgent-padding = ${module/bspwm.label-urgent-padding} |\n\n\n[module/xbacklight]\ntype = internal/xbacklight\n\nformat = <label> <bar>\nlabel = BL\n\nbar-width = 10\nbar-indicator = |\nbar-indicator-foreground = #ff\nbar-indicator-font = 2\nbar-fill = ─\nbar-fill-font = 2\nbar-fill-foreground = #9f78e1\nbar-empty = ─\nbar-empty-font = 2\nbar-empty-foreground = ${colors.foreground-alt}\n\n[module/backlight-acpi]\ninherit = module/xbacklight\ntype = internal/backlight\ncard = intel_backlight\n\n[module/cpu]\ntype = internal/cpu\ninterval = 2\nformat-prefix = \" \"\n;format-prefix-foreground = ${colors.foreground-alt}\n;format-underline = #f90000\nlabel = %percentage:2%%\n\n[module/memory]\ntype = internal/memory\ninterval = 2\nformat-prefix = \"  \"\n;format-prefix-foreground = ${colors.foreground-alt}\n;format-underline = #4bffdc\nlabel = %percentage_used%%\n\n[module/wlan]\ntype = internal/network\ninterface = wlp3s0\ninterval = 3.0\n\nformat-connected = <ramp-signal>\n;format-connected-underline = #9f78e1\nlabel-connected = \"%essid%\"\n\nformat-disconnected = \n;format-disconnected = <label-disconnected>\n;format-disconnected-underline = ${self.format-connected-underline}\nlabel-disconnected = %ifname% disconnected\nlabel-disconnected-foreground = #999999\n\nramp-signal-0 = \nramp-signal-1 = \nramp-signal-2 = \nramp-signal-3 = \nramp-signal-4 = \nanimation-packetloss-0 = ⚠\nanimation-packetloss-0-foreground = #ffa64c\n;ramp-signal-foreground = ${colors.foreground-alt}\n\n[module/eth]\ntype = internal/network\ninterface = enp0s31f6\ninterval = 3.0\n\nformat-connected-underline = #55aa55\nformat-connected-prefix = \"📶\"\nformat-connected-prefix-foreground = ${colors.foreground-alt}\nlabel-connected = %local_ip%\n\nformat-disconnected =\n;format-disconnected = <label-disconnected>\n;format-disconnected-underline = ${self.format-connected-underline}\n;label-disconnected = %ifname% disconnected\n;label-disconnected-foreground = ${colors.foreground-alt}\n\n[module/date]\ntype = internal/date\ninterval = 5\n\ndate = \" %Y-%m-%d\"\n;date-alt = \" %Y-%m-%d\"\n\ntime = %H:%M\n;time-alt = %H:%M:%S\n\nformat-prefix = \n;format-prefix-foreground = ${colors.foreground-alt}\n;format-underline = #0a6cf5\n\nlabel = %date% %time%\n\n\n[module/alsa]\ntype = internal/volume\n\nformat-volume = <label-volume> <bar-volume>\nlabel-volume = \nlabel-volume-foreground = ${root.foreground}\n\nformat-muted-prefix = \" \"\nformat-muted-foreground = ${colors.foreground-alt}\nlabel-muted = \n\nbar-volume-width = 5\nbar-volume-foreground-0 = #55aa55\nbar-volume-foreground-1 = #55aa55\nbar-volume-foreground-2 = #55aa55\nbar-volume-foreground-3 = #55aa55\nbar-volume-foreground-4 = #55aa55\nbar-volume-foreground-5 = #f5a70a\nbar-volume-foreground-6 = #ff5555\nbar-volume-gradient = false\nbar-volume-indicator = |\nbar-volume-indicator-font = 2\nbar-volume-fill = ─\nbar-volume-fill-font = 2\nbar-volume-empty = ─\nbar-volume-empty-font = 2\nbar-volume-empty-foreground = ${colors.foreground-alt}\n\n[module/battery]\ntype = internal/battery\nbattery = BAT0\nadapter = ADP1\nfull-at = 98\n\nformat-charging = <animation-charging> <label-charging>\nformat-charging-underline = #ffb52a\n\nformat-discharging = <ramp-capacity> <label-discharging>\n;format-discharging-underline = ${self.format-charging-underline}\n\nformat-full-prefix = \" \"\n;format-full-prefix-foreground = ${colors.foreground-alt}\nformat-full-underline = ${self.format-charging-underline}\n\nramp-capacity-0 = \nramp-capacity-1 = \nramp-capacity-2 = \nramp-capacity-3 = \n;ramp-capacity-foreground = ${colors.foreground-alt}\n\nanimation-charging-0 = \nanimation-charging-1 = \nanimation-charging-2 = \nanimation-charging-3 = \n;animation-charging-foreground = ${colors.foreground-alt}\nanimation-charging-framerate = 750\n\n[module/temperature]\ntype = internal/temperature\nthermal-zone = 0\nwarn-temperature = 60\n\nformat = <ramp> <label>\n;format-underline = #f50a4d\nformat-warn = <ramp> <label-warn>\n;format-warn-underline = ${self.format-underline}\n\nlabel = %temperature%\nlabel-warn = %temperature%\nlabel-warn-foreground = ${colors.secondary}\n\nramp-0 = \nramp-1 = \nramp-2 = \n;ramp-foreground = ${colors.foreground-alt}\n\n[module/powermenu]\ntype = custom/menu\nexpand-right = true\n\nformat-spacing = 1\n\nlabel-open = \nlabel-open-foreground = ${colors.secondary}\nlabel-close =  cancel\nlabel-close-foreground = ${colors.secondary}\nlabel-separator = |\nlabel-separator-foreground = ${colors.foreground-alt}\n\nmenu-0-0 = reboot\nmenu-0-0-exec = reboot\nmenu-0-1 = power off\nmenu-0-1-exec = poweroff\n\n\n[settings]\nscreenchange-reload = true\n\n\n[global/wm]\nmargin-top = 5\nmargin-bottom = 5\n~~~\n\n上面这段配置文件是polybar的配置文件，我们还需要一个启动polybar的脚本\n\n> launch.sh\n\n这里的`launch.sh`可以改名，但是不必须得放在`~/.config/polybar`目录下，改名后需要修改`i3`配置文件的第`33`行。\n\n~~~\n#!/usr/bin/env bash\n\n# Terminate already running bar instances\nkillall -q polybar\n\n# Wait until the processes have been shut down\nwhile pgrep -u $UID -x polybar >/dev/null; do sleep 1; done\n\n# Launch bar1 and bar2\npolybar example &\n~~~\n\n## 三、使用i3\n\n这一小节，我主要介绍我的配置文件所做的事。\n\n下面的说明并不是将我的配置文件全部进行解读，有些我觉得你们能看懂的我就没写。\n\n__set $mod Mod1__  设置i3的super为`Alt`键\n\n__new_window pixel 1__ 设置新窗口的窗口边缘的像素\n\n__new_float normal__ 设置浮动窗口，值为默认\n\n__hide_edge_borders__ 设置窗口边框隐藏\n\n\n| 按键                     | 说明                                     |\n|--------------------------|------------------------------------------|\n| $mod+u                   | 设置边框存在                             |\n| $mod+y                   | 设置边框像素为1                          |\n| $mod+n                   | 设置边框隐藏                             |\n| $mod+Return(回车键)      | 打开alacritty终端                        |\n| $mod+Shift+Return        | 通过alacritty打开ranger                  |\n| $mod+Control+g           | 打开Chrome                               |\n| $mod+Controll+f          | 打开Firefox                              |\n| $mod+Shift+q             | 杀死聚焦窗口                             |\n| $mod+d                   | 打开rofi                                 |\n| $mod+h+j+k+l             | 将聚焦在窗口之间切换                     |\n| $mdo+上下左右            | 同上，只不过用的是方向键                 |\n| $mod+Shift+h+j+k+l       | 将聚焦窗口改变排列位置                   |\n| $mod+Shift+上下左右      | 同上，只不过用的是方向键                 |\n| $mod+b                   | 切换至上一个工作区                       |\n| $mod+Shift+b             | 将上一个工作区的容器，移动至当前工作区内 |\n| $mod+q                   | 切换平铺方式                             |\n| $mod+f                   | 将聚焦窗口全屏                           |\n| $mod+s                   | 容器窗口排列方式为堆叠式                 |\n| $mod+w                   | 容器窗口排列方式为标签式                 |\n| $mod+e                   | 容器窗口排列方式为平铺式                 |\n| $mod+Shift+space(空格键) | 切换容器窗口为平铺还是浮动               |\n| $mod+space               | 在浮动或平铺窗口之间进行聚焦的切换       |\n| $mod+Ctrl+左或右         | 切换工作区，前或后                       |\n| $mod+1-8                 | 切换工作区                               |\n| $mod+Ctrl+1-8            | 将当前容器的窗口移动至某个工作区         |\n| $mod+Shift+1-8           | 将当前容器移动至某个工作区               |\n| $mod+Shift+r             | 重启i3                                   |\n| $mod+Shift+c             | 重载i3配置文件                           |\n| $mod+0                   | 进入系统模式                             |\n| l                        | 系统模式:锁屏                            |\n| s                        | 系统模式:挂出                            |\n| u                        | 系统模式:切换用户                        |\n| e                        | 系统模式:登出                            |\n| h                        | 系统模式:休眠                            |\n| r                        | 系统模式:重启                            |\n| Shift+s                  | 系统模式:关机                            |\n| $mod+r                   | 进入窗口大小设置模式                     |\n| h j k l                  | 设置窗口上下左右的大小                   |\n| 上下左右                 | 同上                                     |\n| Return                   | 退出窗口大小设置模式                     |\n| 触摸板开关               | 触摸板开关                               |\n\n# 0x2 rofi\n\n## 一、安装rofi\n\n> sudo pacman -S rofi\n\n## 二、配置rofi\n\n## 三、使用rofi\n\n# 0x1 ranger\n\n## 一、安装ranger\n\n## 二、配置ranger\n\n## 三、使用ranger\n\n# 0x2 alacritty\n\n## 一、安装alacritty\n\n## 二、配置alacritty\n\n## 三、使用alacritty\n\n# 0x3 vim\n\n## 一、配置vim\n\n# 0x4 zsh\n\n## 一、安装zsh\n\n## 二、配置zsh\n\n# 0x5 ssr+proxychains\n\n## 一、安装ssr\n\n## 二、配置ssr\n\n## 三、安装proxychains\n\n## 四、配置proxychains\n\n## 五、使用ssr+proxychains实现全应用走代理\n\n# 0x6 fcitx\n\n## 一、安装fcitx\n\n## 二、配置fcitx\n\n## 三、启动fcitx\n\n\n","slug":"平铺式桌面-从入门到入坟","published":1,"updated":"2020-01-19T03:49:51.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodc005yomoo8drakipa","content":"<p>本文章详细地介绍了我目前的桌面.通过此文章，你可以做到让i3成为你的一把利刃。</p>\n<a id=\"more\"></a>\n<h1 id=\"暂时未完成\"><a href=\"#暂时未完成\" class=\"headerlink\" title=\"暂时未完成\"></a>暂时未完成</h1><p>首先上图，我的i3桌面.</p>\n<p><img src=\"/2019/07/12/平铺式桌面-从入门到入坟/桌面预览.png\" alt=\"桌面预览\"></p>\n<h1 id=\"0x0-i3\"><a href=\"#0x0-i3\" class=\"headerlink\" title=\"0x0 i3\"></a>0x0 i3</h1><h2 id=\"一、安装i3\"><a href=\"#一、安装i3\" class=\"headerlink\" title=\"一、安装i3\"></a>一、安装i3</h2><p>安装i3很简单，我们直接输入下面这条命令即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo pacman -S i3 compton polybar</span><br></pre></td></tr></table></figure>\n<p>此时你可能会看到<code>i3-gaps</code>和<code>i3-wm</code>，选择哪个都可以，推荐<code>i3-gpas</code>，但如果你想拥有一个没有配置过的i3，那么你就直接安装<code>i3-wm</code>即可</p>\n<h2 id=\"二、配置i3\"><a href=\"#二、配置i3\" class=\"headerlink\" title=\"二、配置i3\"></a>二、配置i3</h2><p>配置i3通过编辑<code>~/.config/i3/config</code>这个文件进行配置。</p>\n<p>我这里已经有配置好的i3，你们可以直接使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># i3 config file (v4)</span><br><span class=\"line\">#</span><br><span class=\"line\"># Please see https://i3wm.org/docs/userguide.html for a complete reference!</span><br><span class=\"line\">#</span><br><span class=\"line\"># This config file uses keycodes (bindsym) and was written for the QWERTY</span><br><span class=\"line\"># layout.</span><br><span class=\"line\">#</span><br><span class=\"line\"># To get a config file with the same key positions, but for your current</span><br><span class=\"line\"># layout, use the i3-config-wizard</span><br><span class=\"line\">#</span><br><span class=\"line\"></span><br><span class=\"line\"># Font for window titles. Will also be used by the bar unless a different font</span><br><span class=\"line\"># is used in the bar &#123;&#125; block below.</span><br><span class=\"line\">font pango:monospace 8</span><br><span class=\"line\"></span><br><span class=\"line\"># This font is widely installed, provides lots of unicode glyphs, right-to-left</span><br><span class=\"line\"># text rendering and scalability on retina/hidpi displays (thanks to pango).</span><br><span class=\"line\">#font pango:DejaVu Sans Mono 8</span><br><span class=\"line\"></span><br><span class=\"line\"># Before i3 v4.8, we used to recommend this one as the default:</span><br><span class=\"line\"># font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1</span><br><span class=\"line\"># The font above is very space-efficient, that is, it looks good, sharp and</span><br><span class=\"line\"># clear in small sizes. However, its unicode glyph coverage is limited, the old</span><br><span class=\"line\"># X core fonts rendering does not support right-to-left and this being a bitmap</span><br><span class=\"line\"># font, it doesn&apos;t scale on retina/hidpi displays.</span><br><span class=\"line\"></span><br><span class=\"line\"># use these keys for focus, movement, and resize directions when reaching for</span><br><span class=\"line\"># the arrows is not convenient</span><br><span class=\"line\">set $up l</span><br><span class=\"line\">set $down k</span><br><span class=\"line\">set $left j</span><br><span class=\"line\">set $right semicolon</span><br><span class=\"line\"></span><br><span class=\"line\"># use Mouse+Mod1 to drag floating windows to their wanted position</span><br><span class=\"line\">floating_modifier Mod1</span><br><span class=\"line\"></span><br><span class=\"line\"># start a terminal</span><br><span class=\"line\">bindsym Mod1+Return exec i3-sensible-terminal</span><br><span class=\"line\"></span><br><span class=\"line\"># kill focused window</span><br><span class=\"line\">bindsym Mod1+Shift+q kill</span><br><span class=\"line\"></span><br><span class=\"line\"># start dmenu (a program launcher)</span><br><span class=\"line\">bindsym Mod1+d exec dmenu_run</span><br><span class=\"line\"># There also is the (new) i3-dmenu-desktop which only displays applications</span><br><span class=\"line\"># shipping a .desktop file. It is a wrapper around dmenu, so you need that</span><br><span class=\"line\"># installed.</span><br><span class=\"line\"># bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop</span><br><span class=\"line\"></span><br><span class=\"line\"># change focus</span><br><span class=\"line\">bindsym Mod1+$left focus left</span><br><span class=\"line\">bindsym Mod1+$down focus down</span><br><span class=\"line\">bindsym Mod1+$up focus up</span><br><span class=\"line\">bindsym Mod1+$right focus right</span><br><span class=\"line\"></span><br><span class=\"line\"># alternatively, you can use the cursor keys:</span><br><span class=\"line\">bindsym Mod1+Left focus left</span><br><span class=\"line\">bindsym Mod1+Down focus down</span><br><span class=\"line\">bindsym Mod1+Up focus up</span><br><span class=\"line\">bindsym Mod1+Right focus right</span><br><span class=\"line\"></span><br><span class=\"line\"># move focused window</span><br><span class=\"line\">bindsym Mod1+Shift+$left move left</span><br><span class=\"line\">bindsym Mod1+Shift+$down move down</span><br><span class=\"line\">bindsym Mod1+Shift+$up move up</span><br><span class=\"line\">bindsym Mod1+Shift+$right move right</span><br><span class=\"line\"></span><br><span class=\"line\"># alternatively, you can use the cursor keys:</span><br><span class=\"line\">bindsym Mod1+Shift+Left move left</span><br><span class=\"line\">bindsym Mod1+Shift+Down move down</span><br><span class=\"line\">bindsym Mod1+Shift+Up move up</span><br><span class=\"line\">bindsym Mod1+Shift+Right move right</span><br><span class=\"line\"></span><br><span class=\"line\"># split in horizontal orientation</span><br><span class=\"line\">bindsym Mod1+h split h</span><br><span class=\"line\"></span><br><span class=\"line\"># split in vertical orientation</span><br><span class=\"line\">bindsym Mod1+v split v</span><br><span class=\"line\"></span><br><span class=\"line\"># enter fullscreen mode for the focused container</span><br><span class=\"line\">bindsym Mod1+f fullscreen toggle</span><br><span class=\"line\"></span><br><span class=\"line\"># change container layout (stacked, tabbed, toggle split)</span><br><span class=\"line\">bindsym Mod1+s layout stacking</span><br><span class=\"line\">bindsym Mod1+w layout tabbed</span><br><span class=\"line\">bindsym Mod1+e layout toggle split</span><br><span class=\"line\"></span><br><span class=\"line\"># toggle tiling / floating</span><br><span class=\"line\">bindsym Mod1+Shift+space floating toggle</span><br><span class=\"line\"></span><br><span class=\"line\"># change focus between tiling / floating windows</span><br><span class=\"line\">bindsym Mod1+space focus mode_toggle</span><br><span class=\"line\"></span><br><span class=\"line\"># focus the parent container</span><br><span class=\"line\">bindsym Mod1+a focus parent</span><br><span class=\"line\"></span><br><span class=\"line\"># focus the child container</span><br><span class=\"line\">#bindsym Mod1+d focus child</span><br><span class=\"line\"></span><br><span class=\"line\"># move the currently focused window to the scratchpad</span><br><span class=\"line\">bindsym Mod1+Shift+minus move scratchpad</span><br><span class=\"line\"></span><br><span class=\"line\"># Show the next scratchpad window or hide the focused scratchpad window.</span><br><span class=\"line\"># If there are multiple scratchpad windows, this command cycles through them.</span><br><span class=\"line\">bindsym Mod1+minus scratchpad show</span><br><span class=\"line\"></span><br><span class=\"line\"># Define names for default workspaces for which we configure key bindings later on.</span><br><span class=\"line\"># We use variables to avoid repeating the names in multiple places.</span><br><span class=\"line\">set $ws1 &quot;1&quot;</span><br><span class=\"line\">set $ws2 &quot;2&quot;</span><br><span class=\"line\">set $ws3 &quot;3&quot;</span><br><span class=\"line\">set $ws4 &quot;4&quot;</span><br><span class=\"line\">set $ws5 &quot;5&quot;</span><br><span class=\"line\">set $ws6 &quot;6&quot;</span><br><span class=\"line\">set $ws7 &quot;7&quot;</span><br><span class=\"line\">set $ws8 &quot;8&quot;</span><br><span class=\"line\">set $ws9 &quot;9&quot;</span><br><span class=\"line\">set $ws10 &quot;10&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># switch to workspace</span><br><span class=\"line\">bindsym Mod1+1 workspace $ws1</span><br><span class=\"line\">bindsym Mod1+2 workspace $ws2</span><br><span class=\"line\">bindsym Mod1+3 workspace $ws3</span><br><span class=\"line\">bindsym Mod1+4 workspace $ws4</span><br><span class=\"line\">bindsym Mod1+5 workspace $ws5</span><br><span class=\"line\">bindsym Mod1+6 workspace $ws6</span><br><span class=\"line\">bindsym Mod1+7 workspace $ws7</span><br><span class=\"line\">bindsym Mod1+8 workspace $ws8</span><br><span class=\"line\">bindsym Mod1+9 workspace $ws9</span><br><span class=\"line\">bindsym Mod1+0 workspace $ws10</span><br><span class=\"line\"></span><br><span class=\"line\"># move focused container to workspace</span><br><span class=\"line\">bindsym Mod1+Shift+1 move container to workspace $ws1</span><br><span class=\"line\">bindsym Mod1+Shift+2 move container to workspace $ws2</span><br><span class=\"line\">bindsym Mod1+Shift+3 move container to workspace $ws3</span><br><span class=\"line\">bindsym Mod1+Shift+4 move container to workspace $ws4</span><br><span class=\"line\">bindsym Mod1+Shift+5 move container to workspace $ws5</span><br><span class=\"line\">bindsym Mod1+Shift+6 move container to workspace $ws6</span><br><span class=\"line\">bindsym Mod1+Shift+7 move container to workspace $ws7</span><br><span class=\"line\">bindsym Mod1+Shift+8 move container to workspace $ws8</span><br><span class=\"line\">bindsym Mod1+Shift+9 move container to workspace $ws9</span><br><span class=\"line\">bindsym Mod1+Shift+0 move container to workspace $ws10</span><br><span class=\"line\"></span><br><span class=\"line\"># reload the configuration file</span><br><span class=\"line\">bindsym Mod1+Shift+c reload</span><br><span class=\"line\"># restart i3 inplace (preserves your layout/session, can be used to upgrade i3)</span><br><span class=\"line\">bindsym Mod1+Shift+r restart</span><br><span class=\"line\"># exit i3 (logs you out of your X session)</span><br><span class=\"line\">bindsym Mod1+Shift+e exec &quot;i3-nagbar -t warning -m &apos;You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.&apos; -B &apos;Yes, exit i3&apos; &apos;i3-msg exit&apos;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># resize window (you can also use the mouse for that)</span><br><span class=\"line\">mode &quot;resize&quot; &#123;</span><br><span class=\"line\">        # These bindings trigger as soon as you enter the resize mode</span><br><span class=\"line\"></span><br><span class=\"line\">        # Pressing left will shrink the window’s width.</span><br><span class=\"line\">        # Pressing right will grow the window’s width.</span><br><span class=\"line\">        # Pressing up will shrink the window’s height.</span><br><span class=\"line\">        # Pressing down will grow the window’s height.</span><br><span class=\"line\">        bindsym $left       resize shrink width 10 px or 10 ppt</span><br><span class=\"line\">        bindsym $down       resize grow height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym $up         resize shrink height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym $right      resize grow width 10 px or 10 ppt</span><br><span class=\"line\"></span><br><span class=\"line\">        # same bindings, but for the arrow keys</span><br><span class=\"line\">        bindsym Left        resize shrink width 10 px or 10 ppt</span><br><span class=\"line\">        bindsym Down        resize grow height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym Up          resize shrink height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym Right       resize grow width 10 px or 10 ppt</span><br><span class=\"line\"></span><br><span class=\"line\">        # back to normal: Enter or Escape or Mod1+r</span><br><span class=\"line\">        bindsym Return mode &quot;default&quot;</span><br><span class=\"line\">        bindsym Escape mode &quot;default&quot;</span><br><span class=\"line\">        bindsym Mod1+r mode &quot;default&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bindsym Mod1+r mode &quot;resize&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Start i3bar to display a workspace bar (plus the system information i3status</span><br><span class=\"line\"># finds out, if available)</span><br><span class=\"line\">bar &#123;</span><br><span class=\"line\">        status_command i3status</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#######################################################################</span><br><span class=\"line\"># automatically start i3-config-wizard to offer the user to create a</span><br><span class=\"line\"># keysym-based config which used their favorite modifier (alt or windows)</span><br><span class=\"line\">#</span><br><span class=\"line\"># i3-config-wizard will not launch if there already is a config file</span><br><span class=\"line\"># in ~/.i3/config.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Please remove the following exec line:</span><br><span class=\"line\">#######################################################################</span><br><span class=\"line\">exec i3-config-wizard</span><br></pre></td></tr></table></figure>\n<p>将上面的内容粘贴到i3的配置文件内即可</p>\n<h2 id=\"四、美化i3-polybar\"><a href=\"#四、美化i3-polybar\" class=\"headerlink\" title=\"四、美化i3-polybar\"></a>四、美化i3-polybar</h2><p><code>polybar</code>是一个快速并且易用的状态显示栏</p>\n<p>就如同你们看到的桌面预览图一般，上面的状态栏就是通过<code>polybar</code>实现的</p>\n<p>我的polybar已经配置完成了，可以方便的显示工作区的数字，以及窗口的标题，以及CPU,RAM,CPU温度,时间,系统托盘等功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">;==========================================================</span><br><span class=\"line\">;</span><br><span class=\"line\">;</span><br><span class=\"line\">;   ██████╗  ██████╗ ██╗  ██╗   ██╗██████╗  █████╗ ██████╗</span><br><span class=\"line\">;   ██╔══██╗██╔═══██╗██║  ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗</span><br><span class=\"line\">;   ██████╔╝██║   ██║██║   ╚████╔╝ ██████╔╝███████║██████╔╝</span><br><span class=\"line\">;   ██╔═══╝ ██║   ██║██║    ╚██╔╝  ██╔══██╗██╔══██║██╔══██╗</span><br><span class=\"line\">;   ██║     ╚██████╔╝███████╗██║   ██████╔╝██║  ██║██║  ██║</span><br><span class=\"line\">;   ╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝</span><br><span class=\"line\">;</span><br><span class=\"line\">;</span><br><span class=\"line\">;   To learn more about how to configure Polybar</span><br><span class=\"line\">;   go to https://github.com/polybar/polybar</span><br><span class=\"line\">;</span><br><span class=\"line\">;   The README contains a lot of information</span><br><span class=\"line\">;</span><br><span class=\"line\">;==========================================================</span><br><span class=\"line\"></span><br><span class=\"line\">[colors]</span><br><span class=\"line\">background = #cc222222</span><br><span class=\"line\">background-alt = #444</span><br><span class=\"line\">;foreground = $&#123;xrdb:color7:#222&#125;</span><br><span class=\"line\">foreground = #dfdfdf</span><br><span class=\"line\">foreground-alt = #555</span><br><span class=\"line\">primary = #ffb52a</span><br><span class=\"line\">secondary = #e60053</span><br><span class=\"line\">alert = #bd2c40</span><br><span class=\"line\"></span><br><span class=\"line\">[bar/example]</span><br><span class=\"line\">;monitor = $&#123;env:MONITOR:HDMI1&#125;</span><br><span class=\"line\">monitor = $&#123;env:MONITOR:eDP1&#125;</span><br><span class=\"line\">width = 100%</span><br><span class=\"line\">height = 30</span><br><span class=\"line\">;offset-x = 1%</span><br><span class=\"line\">;offset-y = 1%</span><br><span class=\"line\">radius = 6.0</span><br><span class=\"line\">fixed-center = true</span><br><span class=\"line\"></span><br><span class=\"line\">background = $&#123;colors.background&#125;</span><br><span class=\"line\">foreground = $&#123;colors.foreground&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">line-size = 3</span><br><span class=\"line\">line-color = #f00</span><br><span class=\"line\"></span><br><span class=\"line\">border-top-size = 0</span><br><span class=\"line\">border-left-size = 0</span><br><span class=\"line\">border-right-size = 0</span><br><span class=\"line\">border-color = #00000000</span><br><span class=\"line\"></span><br><span class=\"line\">padding-left = 0</span><br><span class=\"line\">padding-right = 2</span><br><span class=\"line\"></span><br><span class=\"line\">module-margin-left = 1</span><br><span class=\"line\">module-margin-right = 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">font-0 = ttf-liberation-sans:fixed:pixelsize=12;1</span><br><span class=\"line\">font-1 = source han sans cn:pixelsize=12:antialias=false;1</span><br><span class=\"line\">font-2 = &quot;Font Awesome 5 Free:style=Solid:pixelsize=12;1&quot;</span><br><span class=\"line\">font-3 = &quot;Font Awesome 5 Brands:style=Regular:pixelsize=12;1&quot;</span><br><span class=\"line\">font-4 = &quot;material icons:pixelsize=16;3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">modules-left = i3</span><br><span class=\"line\">modules-center = xwindow</span><br><span class=\"line\">;modules-center = </span><br><span class=\"line\">modules-right = cpu memory temperature battery date </span><br><span class=\"line\"></span><br><span class=\"line\">tray-position = right</span><br><span class=\"line\">tray-padding = 2</span><br><span class=\"line\">tray-background = $&#123;colors.background&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cursor-click = pointer</span><br><span class=\"line\">cursor-scroll = ns-resize</span><br><span class=\"line\"></span><br><span class=\"line\">[module/xwindow]</span><br><span class=\"line\">type = internal/xwindow</span><br><span class=\"line\">label = %title%</span><br><span class=\"line\">width = 50</span><br><span class=\"line\">label-maxlen = 45</span><br><span class=\"line\"></span><br><span class=\"line\">[module/xkeyboard]</span><br><span class=\"line\">type = internal/xkeyboard</span><br><span class=\"line\">blacklist-0 = num lock</span><br><span class=\"line\"></span><br><span class=\"line\">format-prefix = &quot;&quot;</span><br><span class=\"line\">format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">format-prefix-underline = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-layout = %layout%</span><br><span class=\"line\">label-layout-underline = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-indicator-padding = 2</span><br><span class=\"line\">label-indicator-margin = 1</span><br><span class=\"line\">label-indicator-background = $&#123;colors.secondary&#125;</span><br><span class=\"line\">label-indicator-underline = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/filesystem]</span><br><span class=\"line\">type = internal/fs</span><br><span class=\"line\">interval = 25</span><br><span class=\"line\"></span><br><span class=\"line\">mount-0 = /</span><br><span class=\"line\"></span><br><span class=\"line\">label-mounted = %&#123;F#0a81f5&#125;%mountpoint%%&#123;F-&#125;: %percentage_used%%</span><br><span class=\"line\">label-unmounted = %mountpoint% not mounted</span><br><span class=\"line\">label-unmounted-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/bspwm]</span><br><span class=\"line\">type = internal/bspwm</span><br><span class=\"line\"></span><br><span class=\"line\">label-focused = %index%</span><br><span class=\"line\">label-focused-background = $&#123;colors.background-alt&#125;</span><br><span class=\"line\">label-focused-underline= $&#123;colors.primary&#125;</span><br><span class=\"line\">label-focused-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">label-occupied = %index%</span><br><span class=\"line\">label-occupied-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">label-urgent = %index%!</span><br><span class=\"line\">label-urgent-background = $&#123;colors.alert&#125;</span><br><span class=\"line\">label-urgent-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">label-empty = %index%</span><br><span class=\"line\">label-empty-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">label-empty-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">[module/i3]</span><br><span class=\"line\">type = internal/i3</span><br><span class=\"line\">format = &lt;label-state&gt; &lt;label-mode&gt;</span><br><span class=\"line\">index-sort = true</span><br><span class=\"line\">wrapping-scroll = false</span><br><span class=\"line\"></span><br><span class=\"line\">label-focused = %name%</span><br><span class=\"line\">label-unfocused = %name%</span><br><span class=\"line\">label-visible = %name%</span><br><span class=\"line\">label-urgent = %name%</span><br><span class=\"line\"></span><br><span class=\"line\">label-mode-padding = 2</span><br><span class=\"line\">label-mode-foreground = #000</span><br><span class=\"line\">label-mode-background = $&#123;colors.primary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-focused-background = $&#123;module/bspwm.label-focused-background&#125;</span><br><span class=\"line\">label-focused-underline = $&#123;module/bspwm.label-focused-underline&#125;</span><br><span class=\"line\">label-focused-padding = $&#123;module/bspwm.label-focused-padding&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-unfocused-padding = $&#123;module/bspwm.label-occupied-padding&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-visible-background = $&#123;self.label-focused-background&#125;</span><br><span class=\"line\">label-visible-underline = $&#123;self.label-focused-underline&#125;</span><br><span class=\"line\">label-visible-padding = $&#123;self.label-focused-padding&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-urgent-background = $&#123;module/bspwm.label-urgent-background&#125;</span><br><span class=\"line\">label-urgent-padding = $&#123;module/bspwm.label-urgent-padding&#125; |</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[module/xbacklight]</span><br><span class=\"line\">type = internal/xbacklight</span><br><span class=\"line\"></span><br><span class=\"line\">format = &lt;label&gt; &lt;bar&gt;</span><br><span class=\"line\">label = BL</span><br><span class=\"line\"></span><br><span class=\"line\">bar-width = 10</span><br><span class=\"line\">bar-indicator = |</span><br><span class=\"line\">bar-indicator-foreground = #ff</span><br><span class=\"line\">bar-indicator-font = 2</span><br><span class=\"line\">bar-fill = ─</span><br><span class=\"line\">bar-fill-font = 2</span><br><span class=\"line\">bar-fill-foreground = #9f78e1</span><br><span class=\"line\">bar-empty = ─</span><br><span class=\"line\">bar-empty-font = 2</span><br><span class=\"line\">bar-empty-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/backlight-acpi]</span><br><span class=\"line\">inherit = module/xbacklight</span><br><span class=\"line\">type = internal/backlight</span><br><span class=\"line\">card = intel_backlight</span><br><span class=\"line\"></span><br><span class=\"line\">[module/cpu]</span><br><span class=\"line\">type = internal/cpu</span><br><span class=\"line\">interval = 2</span><br><span class=\"line\">format-prefix = &quot; &quot;</span><br><span class=\"line\">;format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">;format-underline = #f90000</span><br><span class=\"line\">label = %percentage:2%%</span><br><span class=\"line\"></span><br><span class=\"line\">[module/memory]</span><br><span class=\"line\">type = internal/memory</span><br><span class=\"line\">interval = 2</span><br><span class=\"line\">format-prefix = &quot;  &quot;</span><br><span class=\"line\">;format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">;format-underline = #4bffdc</span><br><span class=\"line\">label = %percentage_used%%</span><br><span class=\"line\"></span><br><span class=\"line\">[module/wlan]</span><br><span class=\"line\">type = internal/network</span><br><span class=\"line\">interface = wlp3s0</span><br><span class=\"line\">interval = 3.0</span><br><span class=\"line\"></span><br><span class=\"line\">format-connected = &lt;ramp-signal&gt;</span><br><span class=\"line\">;format-connected-underline = #9f78e1</span><br><span class=\"line\">label-connected = &quot;%essid%&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">format-disconnected = </span><br><span class=\"line\">;format-disconnected = &lt;label-disconnected&gt;</span><br><span class=\"line\">;format-disconnected-underline = $&#123;self.format-connected-underline&#125;</span><br><span class=\"line\">label-disconnected = %ifname% disconnected</span><br><span class=\"line\">label-disconnected-foreground = #999999</span><br><span class=\"line\"></span><br><span class=\"line\">ramp-signal-0 = </span><br><span class=\"line\">ramp-signal-1 = </span><br><span class=\"line\">ramp-signal-2 = </span><br><span class=\"line\">ramp-signal-3 = </span><br><span class=\"line\">ramp-signal-4 = </span><br><span class=\"line\">animation-packetloss-0 = ⚠</span><br><span class=\"line\">animation-packetloss-0-foreground = #ffa64c</span><br><span class=\"line\">;ramp-signal-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/eth]</span><br><span class=\"line\">type = internal/network</span><br><span class=\"line\">interface = enp0s31f6</span><br><span class=\"line\">interval = 3.0</span><br><span class=\"line\"></span><br><span class=\"line\">format-connected-underline = #55aa55</span><br><span class=\"line\">format-connected-prefix = &quot;📶&quot;</span><br><span class=\"line\">format-connected-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">label-connected = %local_ip%</span><br><span class=\"line\"></span><br><span class=\"line\">format-disconnected =</span><br><span class=\"line\">;format-disconnected = &lt;label-disconnected&gt;</span><br><span class=\"line\">;format-disconnected-underline = $&#123;self.format-connected-underline&#125;</span><br><span class=\"line\">;label-disconnected = %ifname% disconnected</span><br><span class=\"line\">;label-disconnected-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/date]</span><br><span class=\"line\">type = internal/date</span><br><span class=\"line\">interval = 5</span><br><span class=\"line\"></span><br><span class=\"line\">date = &quot; %Y-%m-%d&quot;</span><br><span class=\"line\">;date-alt = &quot; %Y-%m-%d&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">time = %H:%M</span><br><span class=\"line\">;time-alt = %H:%M:%S</span><br><span class=\"line\"></span><br><span class=\"line\">format-prefix = </span><br><span class=\"line\">;format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">;format-underline = #0a6cf5</span><br><span class=\"line\"></span><br><span class=\"line\">label = %date% %time%</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[module/alsa]</span><br><span class=\"line\">type = internal/volume</span><br><span class=\"line\"></span><br><span class=\"line\">format-volume = &lt;label-volume&gt; &lt;bar-volume&gt;</span><br><span class=\"line\">label-volume = </span><br><span class=\"line\">label-volume-foreground = $&#123;root.foreground&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">format-muted-prefix = &quot; &quot;</span><br><span class=\"line\">format-muted-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">label-muted = </span><br><span class=\"line\"></span><br><span class=\"line\">bar-volume-width = 5</span><br><span class=\"line\">bar-volume-foreground-0 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-1 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-2 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-3 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-4 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-5 = #f5a70a</span><br><span class=\"line\">bar-volume-foreground-6 = #ff5555</span><br><span class=\"line\">bar-volume-gradient = false</span><br><span class=\"line\">bar-volume-indicator = |</span><br><span class=\"line\">bar-volume-indicator-font = 2</span><br><span class=\"line\">bar-volume-fill = ─</span><br><span class=\"line\">bar-volume-fill-font = 2</span><br><span class=\"line\">bar-volume-empty = ─</span><br><span class=\"line\">bar-volume-empty-font = 2</span><br><span class=\"line\">bar-volume-empty-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/battery]</span><br><span class=\"line\">type = internal/battery</span><br><span class=\"line\">battery = BAT0</span><br><span class=\"line\">adapter = ADP1</span><br><span class=\"line\">full-at = 98</span><br><span class=\"line\"></span><br><span class=\"line\">format-charging = &lt;animation-charging&gt; &lt;label-charging&gt;</span><br><span class=\"line\">format-charging-underline = #ffb52a</span><br><span class=\"line\"></span><br><span class=\"line\">format-discharging = &lt;ramp-capacity&gt; &lt;label-discharging&gt;</span><br><span class=\"line\">;format-discharging-underline = $&#123;self.format-charging-underline&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">format-full-prefix = &quot; &quot;</span><br><span class=\"line\">;format-full-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">format-full-underline = $&#123;self.format-charging-underline&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ramp-capacity-0 = </span><br><span class=\"line\">ramp-capacity-1 = </span><br><span class=\"line\">ramp-capacity-2 = </span><br><span class=\"line\">ramp-capacity-3 = </span><br><span class=\"line\">;ramp-capacity-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">animation-charging-0 = </span><br><span class=\"line\">animation-charging-1 = </span><br><span class=\"line\">animation-charging-2 = </span><br><span class=\"line\">animation-charging-3 = </span><br><span class=\"line\">;animation-charging-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">animation-charging-framerate = 750</span><br><span class=\"line\"></span><br><span class=\"line\">[module/temperature]</span><br><span class=\"line\">type = internal/temperature</span><br><span class=\"line\">thermal-zone = 0</span><br><span class=\"line\">warn-temperature = 60</span><br><span class=\"line\"></span><br><span class=\"line\">format = &lt;ramp&gt; &lt;label&gt;</span><br><span class=\"line\">;format-underline = #f50a4d</span><br><span class=\"line\">format-warn = &lt;ramp&gt; &lt;label-warn&gt;</span><br><span class=\"line\">;format-warn-underline = $&#123;self.format-underline&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label = %temperature%</span><br><span class=\"line\">label-warn = %temperature%</span><br><span class=\"line\">label-warn-foreground = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ramp-0 = </span><br><span class=\"line\">ramp-1 = </span><br><span class=\"line\">ramp-2 = </span><br><span class=\"line\">;ramp-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/powermenu]</span><br><span class=\"line\">type = custom/menu</span><br><span class=\"line\">expand-right = true</span><br><span class=\"line\"></span><br><span class=\"line\">format-spacing = 1</span><br><span class=\"line\"></span><br><span class=\"line\">label-open = </span><br><span class=\"line\">label-open-foreground = $&#123;colors.secondary&#125;</span><br><span class=\"line\">label-close =  cancel</span><br><span class=\"line\">label-close-foreground = $&#123;colors.secondary&#125;</span><br><span class=\"line\">label-separator = |</span><br><span class=\"line\">label-separator-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">menu-0-0 = reboot</span><br><span class=\"line\">menu-0-0-exec = reboot</span><br><span class=\"line\">menu-0-1 = power off</span><br><span class=\"line\">menu-0-1-exec = poweroff</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[settings]</span><br><span class=\"line\">screenchange-reload = true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[global/wm]</span><br><span class=\"line\">margin-top = 5</span><br><span class=\"line\">margin-bottom = 5</span><br></pre></td></tr></table></figure>\n<p>上面这段配置文件是polybar的配置文件，我们还需要一个启动polybar的脚本</p>\n<blockquote>\n<p>launch.sh</p>\n</blockquote>\n<p>这里的<code>launch.sh</code>可以改名，但是不必须得放在<code>~/.config/polybar</code>目录下，改名后需要修改<code>i3</code>配置文件的第<code>33</code>行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env bash</span><br><span class=\"line\"></span><br><span class=\"line\"># Terminate already running bar instances</span><br><span class=\"line\">killall -q polybar</span><br><span class=\"line\"></span><br><span class=\"line\"># Wait until the processes have been shut down</span><br><span class=\"line\">while pgrep -u $UID -x polybar &gt;/dev/null; do sleep 1; done</span><br><span class=\"line\"></span><br><span class=\"line\"># Launch bar1 and bar2</span><br><span class=\"line\">polybar example &amp;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、使用i3\"><a href=\"#三、使用i3\" class=\"headerlink\" title=\"三、使用i3\"></a>三、使用i3</h2><p>这一小节，我主要介绍我的配置文件所做的事。</p>\n<p>下面的说明并不是将我的配置文件全部进行解读，有些我觉得你们能看懂的我就没写。</p>\n<p><strong>set $mod Mod1</strong>  设置i3的super为<code>Alt</code>键</p>\n<p><strong>new_window pixel 1</strong> 设置新窗口的窗口边缘的像素</p>\n<p><strong>new_float normal</strong> 设置浮动窗口，值为默认</p>\n<p><strong>hide_edge_borders</strong> 设置窗口边框隐藏</p>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$mod+u</td>\n<td>设置边框存在</td>\n</tr>\n<tr>\n<td>$mod+y</td>\n<td>设置边框像素为1</td>\n</tr>\n<tr>\n<td>$mod+n</td>\n<td>设置边框隐藏</td>\n</tr>\n<tr>\n<td>$mod+Return(回车键)</td>\n<td>打开alacritty终端</td>\n</tr>\n<tr>\n<td>$mod+Shift+Return</td>\n<td>通过alacritty打开ranger</td>\n</tr>\n<tr>\n<td>$mod+Control+g</td>\n<td>打开Chrome</td>\n</tr>\n<tr>\n<td>$mod+Controll+f</td>\n<td>打开Firefox</td>\n</tr>\n<tr>\n<td>$mod+Shift+q</td>\n<td>杀死聚焦窗口</td>\n</tr>\n<tr>\n<td>$mod+d</td>\n<td>打开rofi</td>\n</tr>\n<tr>\n<td>$mod+h+j+k+l</td>\n<td>将聚焦在窗口之间切换</td>\n</tr>\n<tr>\n<td>$mdo+上下左右</td>\n<td>同上，只不过用的是方向键</td>\n</tr>\n<tr>\n<td>$mod+Shift+h+j+k+l</td>\n<td>将聚焦窗口改变排列位置</td>\n</tr>\n<tr>\n<td>$mod+Shift+上下左右</td>\n<td>同上，只不过用的是方向键</td>\n</tr>\n<tr>\n<td>$mod+b</td>\n<td>切换至上一个工作区</td>\n</tr>\n<tr>\n<td>$mod+Shift+b</td>\n<td>将上一个工作区的容器，移动至当前工作区内</td>\n</tr>\n<tr>\n<td>$mod+q</td>\n<td>切换平铺方式</td>\n</tr>\n<tr>\n<td>$mod+f</td>\n<td>将聚焦窗口全屏</td>\n</tr>\n<tr>\n<td>$mod+s</td>\n<td>容器窗口排列方式为堆叠式</td>\n</tr>\n<tr>\n<td>$mod+w</td>\n<td>容器窗口排列方式为标签式</td>\n</tr>\n<tr>\n<td>$mod+e</td>\n<td>容器窗口排列方式为平铺式</td>\n</tr>\n<tr>\n<td>$mod+Shift+space(空格键)</td>\n<td>切换容器窗口为平铺还是浮动</td>\n</tr>\n<tr>\n<td>$mod+space</td>\n<td>在浮动或平铺窗口之间进行聚焦的切换</td>\n</tr>\n<tr>\n<td>$mod+Ctrl+左或右</td>\n<td>切换工作区，前或后</td>\n</tr>\n<tr>\n<td>$mod+1-8</td>\n<td>切换工作区</td>\n</tr>\n<tr>\n<td>$mod+Ctrl+1-8</td>\n<td>将当前容器的窗口移动至某个工作区</td>\n</tr>\n<tr>\n<td>$mod+Shift+1-8</td>\n<td>将当前容器移动至某个工作区</td>\n</tr>\n<tr>\n<td>$mod+Shift+r</td>\n<td>重启i3</td>\n</tr>\n<tr>\n<td>$mod+Shift+c</td>\n<td>重载i3配置文件</td>\n</tr>\n<tr>\n<td>$mod+0</td>\n<td>进入系统模式</td>\n</tr>\n<tr>\n<td>l</td>\n<td>系统模式:锁屏</td>\n</tr>\n<tr>\n<td>s</td>\n<td>系统模式:挂出</td>\n</tr>\n<tr>\n<td>u</td>\n<td>系统模式:切换用户</td>\n</tr>\n<tr>\n<td>e</td>\n<td>系统模式:登出</td>\n</tr>\n<tr>\n<td>h</td>\n<td>系统模式:休眠</td>\n</tr>\n<tr>\n<td>r</td>\n<td>系统模式:重启</td>\n</tr>\n<tr>\n<td>Shift+s</td>\n<td>系统模式:关机</td>\n</tr>\n<tr>\n<td>$mod+r</td>\n<td>进入窗口大小设置模式</td>\n</tr>\n<tr>\n<td>h j k l</td>\n<td>设置窗口上下左右的大小</td>\n</tr>\n<tr>\n<td>上下左右</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>Return</td>\n<td>退出窗口大小设置模式</td>\n</tr>\n<tr>\n<td>触摸板开关</td>\n<td>触摸板开关</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"0x2-rofi\"><a href=\"#0x2-rofi\" class=\"headerlink\" title=\"0x2 rofi\"></a>0x2 rofi</h1><h2 id=\"一、安装rofi\"><a href=\"#一、安装rofi\" class=\"headerlink\" title=\"一、安装rofi\"></a>一、安装rofi</h2><blockquote>\n<p>sudo pacman -S rofi</p>\n</blockquote>\n<h2 id=\"二、配置rofi\"><a href=\"#二、配置rofi\" class=\"headerlink\" title=\"二、配置rofi\"></a>二、配置rofi</h2><h2 id=\"三、使用rofi\"><a href=\"#三、使用rofi\" class=\"headerlink\" title=\"三、使用rofi\"></a>三、使用rofi</h2><h1 id=\"0x1-ranger\"><a href=\"#0x1-ranger\" class=\"headerlink\" title=\"0x1 ranger\"></a>0x1 ranger</h1><h2 id=\"一、安装ranger\"><a href=\"#一、安装ranger\" class=\"headerlink\" title=\"一、安装ranger\"></a>一、安装ranger</h2><h2 id=\"二、配置ranger\"><a href=\"#二、配置ranger\" class=\"headerlink\" title=\"二、配置ranger\"></a>二、配置ranger</h2><h2 id=\"三、使用ranger\"><a href=\"#三、使用ranger\" class=\"headerlink\" title=\"三、使用ranger\"></a>三、使用ranger</h2><h1 id=\"0x2-alacritty\"><a href=\"#0x2-alacritty\" class=\"headerlink\" title=\"0x2 alacritty\"></a>0x2 alacritty</h1><h2 id=\"一、安装alacritty\"><a href=\"#一、安装alacritty\" class=\"headerlink\" title=\"一、安装alacritty\"></a>一、安装alacritty</h2><h2 id=\"二、配置alacritty\"><a href=\"#二、配置alacritty\" class=\"headerlink\" title=\"二、配置alacritty\"></a>二、配置alacritty</h2><h2 id=\"三、使用alacritty\"><a href=\"#三、使用alacritty\" class=\"headerlink\" title=\"三、使用alacritty\"></a>三、使用alacritty</h2><h1 id=\"0x3-vim\"><a href=\"#0x3-vim\" class=\"headerlink\" title=\"0x3 vim\"></a>0x3 vim</h1><h2 id=\"一、配置vim\"><a href=\"#一、配置vim\" class=\"headerlink\" title=\"一、配置vim\"></a>一、配置vim</h2><h1 id=\"0x4-zsh\"><a href=\"#0x4-zsh\" class=\"headerlink\" title=\"0x4 zsh\"></a>0x4 zsh</h1><h2 id=\"一、安装zsh\"><a href=\"#一、安装zsh\" class=\"headerlink\" title=\"一、安装zsh\"></a>一、安装zsh</h2><h2 id=\"二、配置zsh\"><a href=\"#二、配置zsh\" class=\"headerlink\" title=\"二、配置zsh\"></a>二、配置zsh</h2><h1 id=\"0x5-ssr-proxychains\"><a href=\"#0x5-ssr-proxychains\" class=\"headerlink\" title=\"0x5 ssr+proxychains\"></a>0x5 ssr+proxychains</h1><h2 id=\"一、安装ssr\"><a href=\"#一、安装ssr\" class=\"headerlink\" title=\"一、安装ssr\"></a>一、安装ssr</h2><h2 id=\"二、配置ssr\"><a href=\"#二、配置ssr\" class=\"headerlink\" title=\"二、配置ssr\"></a>二、配置ssr</h2><h2 id=\"三、安装proxychains\"><a href=\"#三、安装proxychains\" class=\"headerlink\" title=\"三、安装proxychains\"></a>三、安装proxychains</h2><h2 id=\"四、配置proxychains\"><a href=\"#四、配置proxychains\" class=\"headerlink\" title=\"四、配置proxychains\"></a>四、配置proxychains</h2><h2 id=\"五、使用ssr-proxychains实现全应用走代理\"><a href=\"#五、使用ssr-proxychains实现全应用走代理\" class=\"headerlink\" title=\"五、使用ssr+proxychains实现全应用走代理\"></a>五、使用ssr+proxychains实现全应用走代理</h2><h1 id=\"0x6-fcitx\"><a href=\"#0x6-fcitx\" class=\"headerlink\" title=\"0x6 fcitx\"></a>0x6 fcitx</h1><h2 id=\"一、安装fcitx\"><a href=\"#一、安装fcitx\" class=\"headerlink\" title=\"一、安装fcitx\"></a>一、安装fcitx</h2><h2 id=\"二、配置fcitx\"><a href=\"#二、配置fcitx\" class=\"headerlink\" title=\"二、配置fcitx\"></a>二、配置fcitx</h2><h2 id=\"三、启动fcitx\"><a href=\"#三、启动fcitx\" class=\"headerlink\" title=\"三、启动fcitx\"></a>三、启动fcitx</h2>","site":{"data":{}},"excerpt":"<p>本文章详细地介绍了我目前的桌面.通过此文章，你可以做到让i3成为你的一把利刃。</p>","more":"<h1 id=\"暂时未完成\"><a href=\"#暂时未完成\" class=\"headerlink\" title=\"暂时未完成\"></a>暂时未完成</h1><p>首先上图，我的i3桌面.</p>\n<p><img src=\"/2019/07/12/平铺式桌面-从入门到入坟/桌面预览.png\" alt=\"桌面预览\"></p>\n<h1 id=\"0x0-i3\"><a href=\"#0x0-i3\" class=\"headerlink\" title=\"0x0 i3\"></a>0x0 i3</h1><h2 id=\"一、安装i3\"><a href=\"#一、安装i3\" class=\"headerlink\" title=\"一、安装i3\"></a>一、安装i3</h2><p>安装i3很简单，我们直接输入下面这条命令即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo pacman -S i3 compton polybar</span><br></pre></td></tr></table></figure>\n<p>此时你可能会看到<code>i3-gaps</code>和<code>i3-wm</code>，选择哪个都可以，推荐<code>i3-gpas</code>，但如果你想拥有一个没有配置过的i3，那么你就直接安装<code>i3-wm</code>即可</p>\n<h2 id=\"二、配置i3\"><a href=\"#二、配置i3\" class=\"headerlink\" title=\"二、配置i3\"></a>二、配置i3</h2><p>配置i3通过编辑<code>~/.config/i3/config</code>这个文件进行配置。</p>\n<p>我这里已经有配置好的i3，你们可以直接使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># i3 config file (v4)</span><br><span class=\"line\">#</span><br><span class=\"line\"># Please see https://i3wm.org/docs/userguide.html for a complete reference!</span><br><span class=\"line\">#</span><br><span class=\"line\"># This config file uses keycodes (bindsym) and was written for the QWERTY</span><br><span class=\"line\"># layout.</span><br><span class=\"line\">#</span><br><span class=\"line\"># To get a config file with the same key positions, but for your current</span><br><span class=\"line\"># layout, use the i3-config-wizard</span><br><span class=\"line\">#</span><br><span class=\"line\"></span><br><span class=\"line\"># Font for window titles. Will also be used by the bar unless a different font</span><br><span class=\"line\"># is used in the bar &#123;&#125; block below.</span><br><span class=\"line\">font pango:monospace 8</span><br><span class=\"line\"></span><br><span class=\"line\"># This font is widely installed, provides lots of unicode glyphs, right-to-left</span><br><span class=\"line\"># text rendering and scalability on retina/hidpi displays (thanks to pango).</span><br><span class=\"line\">#font pango:DejaVu Sans Mono 8</span><br><span class=\"line\"></span><br><span class=\"line\"># Before i3 v4.8, we used to recommend this one as the default:</span><br><span class=\"line\"># font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1</span><br><span class=\"line\"># The font above is very space-efficient, that is, it looks good, sharp and</span><br><span class=\"line\"># clear in small sizes. However, its unicode glyph coverage is limited, the old</span><br><span class=\"line\"># X core fonts rendering does not support right-to-left and this being a bitmap</span><br><span class=\"line\"># font, it doesn&apos;t scale on retina/hidpi displays.</span><br><span class=\"line\"></span><br><span class=\"line\"># use these keys for focus, movement, and resize directions when reaching for</span><br><span class=\"line\"># the arrows is not convenient</span><br><span class=\"line\">set $up l</span><br><span class=\"line\">set $down k</span><br><span class=\"line\">set $left j</span><br><span class=\"line\">set $right semicolon</span><br><span class=\"line\"></span><br><span class=\"line\"># use Mouse+Mod1 to drag floating windows to their wanted position</span><br><span class=\"line\">floating_modifier Mod1</span><br><span class=\"line\"></span><br><span class=\"line\"># start a terminal</span><br><span class=\"line\">bindsym Mod1+Return exec i3-sensible-terminal</span><br><span class=\"line\"></span><br><span class=\"line\"># kill focused window</span><br><span class=\"line\">bindsym Mod1+Shift+q kill</span><br><span class=\"line\"></span><br><span class=\"line\"># start dmenu (a program launcher)</span><br><span class=\"line\">bindsym Mod1+d exec dmenu_run</span><br><span class=\"line\"># There also is the (new) i3-dmenu-desktop which only displays applications</span><br><span class=\"line\"># shipping a .desktop file. It is a wrapper around dmenu, so you need that</span><br><span class=\"line\"># installed.</span><br><span class=\"line\"># bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop</span><br><span class=\"line\"></span><br><span class=\"line\"># change focus</span><br><span class=\"line\">bindsym Mod1+$left focus left</span><br><span class=\"line\">bindsym Mod1+$down focus down</span><br><span class=\"line\">bindsym Mod1+$up focus up</span><br><span class=\"line\">bindsym Mod1+$right focus right</span><br><span class=\"line\"></span><br><span class=\"line\"># alternatively, you can use the cursor keys:</span><br><span class=\"line\">bindsym Mod1+Left focus left</span><br><span class=\"line\">bindsym Mod1+Down focus down</span><br><span class=\"line\">bindsym Mod1+Up focus up</span><br><span class=\"line\">bindsym Mod1+Right focus right</span><br><span class=\"line\"></span><br><span class=\"line\"># move focused window</span><br><span class=\"line\">bindsym Mod1+Shift+$left move left</span><br><span class=\"line\">bindsym Mod1+Shift+$down move down</span><br><span class=\"line\">bindsym Mod1+Shift+$up move up</span><br><span class=\"line\">bindsym Mod1+Shift+$right move right</span><br><span class=\"line\"></span><br><span class=\"line\"># alternatively, you can use the cursor keys:</span><br><span class=\"line\">bindsym Mod1+Shift+Left move left</span><br><span class=\"line\">bindsym Mod1+Shift+Down move down</span><br><span class=\"line\">bindsym Mod1+Shift+Up move up</span><br><span class=\"line\">bindsym Mod1+Shift+Right move right</span><br><span class=\"line\"></span><br><span class=\"line\"># split in horizontal orientation</span><br><span class=\"line\">bindsym Mod1+h split h</span><br><span class=\"line\"></span><br><span class=\"line\"># split in vertical orientation</span><br><span class=\"line\">bindsym Mod1+v split v</span><br><span class=\"line\"></span><br><span class=\"line\"># enter fullscreen mode for the focused container</span><br><span class=\"line\">bindsym Mod1+f fullscreen toggle</span><br><span class=\"line\"></span><br><span class=\"line\"># change container layout (stacked, tabbed, toggle split)</span><br><span class=\"line\">bindsym Mod1+s layout stacking</span><br><span class=\"line\">bindsym Mod1+w layout tabbed</span><br><span class=\"line\">bindsym Mod1+e layout toggle split</span><br><span class=\"line\"></span><br><span class=\"line\"># toggle tiling / floating</span><br><span class=\"line\">bindsym Mod1+Shift+space floating toggle</span><br><span class=\"line\"></span><br><span class=\"line\"># change focus between tiling / floating windows</span><br><span class=\"line\">bindsym Mod1+space focus mode_toggle</span><br><span class=\"line\"></span><br><span class=\"line\"># focus the parent container</span><br><span class=\"line\">bindsym Mod1+a focus parent</span><br><span class=\"line\"></span><br><span class=\"line\"># focus the child container</span><br><span class=\"line\">#bindsym Mod1+d focus child</span><br><span class=\"line\"></span><br><span class=\"line\"># move the currently focused window to the scratchpad</span><br><span class=\"line\">bindsym Mod1+Shift+minus move scratchpad</span><br><span class=\"line\"></span><br><span class=\"line\"># Show the next scratchpad window or hide the focused scratchpad window.</span><br><span class=\"line\"># If there are multiple scratchpad windows, this command cycles through them.</span><br><span class=\"line\">bindsym Mod1+minus scratchpad show</span><br><span class=\"line\"></span><br><span class=\"line\"># Define names for default workspaces for which we configure key bindings later on.</span><br><span class=\"line\"># We use variables to avoid repeating the names in multiple places.</span><br><span class=\"line\">set $ws1 &quot;1&quot;</span><br><span class=\"line\">set $ws2 &quot;2&quot;</span><br><span class=\"line\">set $ws3 &quot;3&quot;</span><br><span class=\"line\">set $ws4 &quot;4&quot;</span><br><span class=\"line\">set $ws5 &quot;5&quot;</span><br><span class=\"line\">set $ws6 &quot;6&quot;</span><br><span class=\"line\">set $ws7 &quot;7&quot;</span><br><span class=\"line\">set $ws8 &quot;8&quot;</span><br><span class=\"line\">set $ws9 &quot;9&quot;</span><br><span class=\"line\">set $ws10 &quot;10&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># switch to workspace</span><br><span class=\"line\">bindsym Mod1+1 workspace $ws1</span><br><span class=\"line\">bindsym Mod1+2 workspace $ws2</span><br><span class=\"line\">bindsym Mod1+3 workspace $ws3</span><br><span class=\"line\">bindsym Mod1+4 workspace $ws4</span><br><span class=\"line\">bindsym Mod1+5 workspace $ws5</span><br><span class=\"line\">bindsym Mod1+6 workspace $ws6</span><br><span class=\"line\">bindsym Mod1+7 workspace $ws7</span><br><span class=\"line\">bindsym Mod1+8 workspace $ws8</span><br><span class=\"line\">bindsym Mod1+9 workspace $ws9</span><br><span class=\"line\">bindsym Mod1+0 workspace $ws10</span><br><span class=\"line\"></span><br><span class=\"line\"># move focused container to workspace</span><br><span class=\"line\">bindsym Mod1+Shift+1 move container to workspace $ws1</span><br><span class=\"line\">bindsym Mod1+Shift+2 move container to workspace $ws2</span><br><span class=\"line\">bindsym Mod1+Shift+3 move container to workspace $ws3</span><br><span class=\"line\">bindsym Mod1+Shift+4 move container to workspace $ws4</span><br><span class=\"line\">bindsym Mod1+Shift+5 move container to workspace $ws5</span><br><span class=\"line\">bindsym Mod1+Shift+6 move container to workspace $ws6</span><br><span class=\"line\">bindsym Mod1+Shift+7 move container to workspace $ws7</span><br><span class=\"line\">bindsym Mod1+Shift+8 move container to workspace $ws8</span><br><span class=\"line\">bindsym Mod1+Shift+9 move container to workspace $ws9</span><br><span class=\"line\">bindsym Mod1+Shift+0 move container to workspace $ws10</span><br><span class=\"line\"></span><br><span class=\"line\"># reload the configuration file</span><br><span class=\"line\">bindsym Mod1+Shift+c reload</span><br><span class=\"line\"># restart i3 inplace (preserves your layout/session, can be used to upgrade i3)</span><br><span class=\"line\">bindsym Mod1+Shift+r restart</span><br><span class=\"line\"># exit i3 (logs you out of your X session)</span><br><span class=\"line\">bindsym Mod1+Shift+e exec &quot;i3-nagbar -t warning -m &apos;You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.&apos; -B &apos;Yes, exit i3&apos; &apos;i3-msg exit&apos;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># resize window (you can also use the mouse for that)</span><br><span class=\"line\">mode &quot;resize&quot; &#123;</span><br><span class=\"line\">        # These bindings trigger as soon as you enter the resize mode</span><br><span class=\"line\"></span><br><span class=\"line\">        # Pressing left will shrink the window’s width.</span><br><span class=\"line\">        # Pressing right will grow the window’s width.</span><br><span class=\"line\">        # Pressing up will shrink the window’s height.</span><br><span class=\"line\">        # Pressing down will grow the window’s height.</span><br><span class=\"line\">        bindsym $left       resize shrink width 10 px or 10 ppt</span><br><span class=\"line\">        bindsym $down       resize grow height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym $up         resize shrink height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym $right      resize grow width 10 px or 10 ppt</span><br><span class=\"line\"></span><br><span class=\"line\">        # same bindings, but for the arrow keys</span><br><span class=\"line\">        bindsym Left        resize shrink width 10 px or 10 ppt</span><br><span class=\"line\">        bindsym Down        resize grow height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym Up          resize shrink height 10 px or 10 ppt</span><br><span class=\"line\">        bindsym Right       resize grow width 10 px or 10 ppt</span><br><span class=\"line\"></span><br><span class=\"line\">        # back to normal: Enter or Escape or Mod1+r</span><br><span class=\"line\">        bindsym Return mode &quot;default&quot;</span><br><span class=\"line\">        bindsym Escape mode &quot;default&quot;</span><br><span class=\"line\">        bindsym Mod1+r mode &quot;default&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bindsym Mod1+r mode &quot;resize&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Start i3bar to display a workspace bar (plus the system information i3status</span><br><span class=\"line\"># finds out, if available)</span><br><span class=\"line\">bar &#123;</span><br><span class=\"line\">        status_command i3status</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#######################################################################</span><br><span class=\"line\"># automatically start i3-config-wizard to offer the user to create a</span><br><span class=\"line\"># keysym-based config which used their favorite modifier (alt or windows)</span><br><span class=\"line\">#</span><br><span class=\"line\"># i3-config-wizard will not launch if there already is a config file</span><br><span class=\"line\"># in ~/.i3/config.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Please remove the following exec line:</span><br><span class=\"line\">#######################################################################</span><br><span class=\"line\">exec i3-config-wizard</span><br></pre></td></tr></table></figure>\n<p>将上面的内容粘贴到i3的配置文件内即可</p>\n<h2 id=\"四、美化i3-polybar\"><a href=\"#四、美化i3-polybar\" class=\"headerlink\" title=\"四、美化i3-polybar\"></a>四、美化i3-polybar</h2><p><code>polybar</code>是一个快速并且易用的状态显示栏</p>\n<p>就如同你们看到的桌面预览图一般，上面的状态栏就是通过<code>polybar</code>实现的</p>\n<p>我的polybar已经配置完成了，可以方便的显示工作区的数字，以及窗口的标题，以及CPU,RAM,CPU温度,时间,系统托盘等功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">;==========================================================</span><br><span class=\"line\">;</span><br><span class=\"line\">;</span><br><span class=\"line\">;   ██████╗  ██████╗ ██╗  ██╗   ██╗██████╗  █████╗ ██████╗</span><br><span class=\"line\">;   ██╔══██╗██╔═══██╗██║  ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗</span><br><span class=\"line\">;   ██████╔╝██║   ██║██║   ╚████╔╝ ██████╔╝███████║██████╔╝</span><br><span class=\"line\">;   ██╔═══╝ ██║   ██║██║    ╚██╔╝  ██╔══██╗██╔══██║██╔══██╗</span><br><span class=\"line\">;   ██║     ╚██████╔╝███████╗██║   ██████╔╝██║  ██║██║  ██║</span><br><span class=\"line\">;   ╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝</span><br><span class=\"line\">;</span><br><span class=\"line\">;</span><br><span class=\"line\">;   To learn more about how to configure Polybar</span><br><span class=\"line\">;   go to https://github.com/polybar/polybar</span><br><span class=\"line\">;</span><br><span class=\"line\">;   The README contains a lot of information</span><br><span class=\"line\">;</span><br><span class=\"line\">;==========================================================</span><br><span class=\"line\"></span><br><span class=\"line\">[colors]</span><br><span class=\"line\">background = #cc222222</span><br><span class=\"line\">background-alt = #444</span><br><span class=\"line\">;foreground = $&#123;xrdb:color7:#222&#125;</span><br><span class=\"line\">foreground = #dfdfdf</span><br><span class=\"line\">foreground-alt = #555</span><br><span class=\"line\">primary = #ffb52a</span><br><span class=\"line\">secondary = #e60053</span><br><span class=\"line\">alert = #bd2c40</span><br><span class=\"line\"></span><br><span class=\"line\">[bar/example]</span><br><span class=\"line\">;monitor = $&#123;env:MONITOR:HDMI1&#125;</span><br><span class=\"line\">monitor = $&#123;env:MONITOR:eDP1&#125;</span><br><span class=\"line\">width = 100%</span><br><span class=\"line\">height = 30</span><br><span class=\"line\">;offset-x = 1%</span><br><span class=\"line\">;offset-y = 1%</span><br><span class=\"line\">radius = 6.0</span><br><span class=\"line\">fixed-center = true</span><br><span class=\"line\"></span><br><span class=\"line\">background = $&#123;colors.background&#125;</span><br><span class=\"line\">foreground = $&#123;colors.foreground&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">line-size = 3</span><br><span class=\"line\">line-color = #f00</span><br><span class=\"line\"></span><br><span class=\"line\">border-top-size = 0</span><br><span class=\"line\">border-left-size = 0</span><br><span class=\"line\">border-right-size = 0</span><br><span class=\"line\">border-color = #00000000</span><br><span class=\"line\"></span><br><span class=\"line\">padding-left = 0</span><br><span class=\"line\">padding-right = 2</span><br><span class=\"line\"></span><br><span class=\"line\">module-margin-left = 1</span><br><span class=\"line\">module-margin-right = 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">font-0 = ttf-liberation-sans:fixed:pixelsize=12;1</span><br><span class=\"line\">font-1 = source han sans cn:pixelsize=12:antialias=false;1</span><br><span class=\"line\">font-2 = &quot;Font Awesome 5 Free:style=Solid:pixelsize=12;1&quot;</span><br><span class=\"line\">font-3 = &quot;Font Awesome 5 Brands:style=Regular:pixelsize=12;1&quot;</span><br><span class=\"line\">font-4 = &quot;material icons:pixelsize=16;3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">modules-left = i3</span><br><span class=\"line\">modules-center = xwindow</span><br><span class=\"line\">;modules-center = </span><br><span class=\"line\">modules-right = cpu memory temperature battery date </span><br><span class=\"line\"></span><br><span class=\"line\">tray-position = right</span><br><span class=\"line\">tray-padding = 2</span><br><span class=\"line\">tray-background = $&#123;colors.background&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cursor-click = pointer</span><br><span class=\"line\">cursor-scroll = ns-resize</span><br><span class=\"line\"></span><br><span class=\"line\">[module/xwindow]</span><br><span class=\"line\">type = internal/xwindow</span><br><span class=\"line\">label = %title%</span><br><span class=\"line\">width = 50</span><br><span class=\"line\">label-maxlen = 45</span><br><span class=\"line\"></span><br><span class=\"line\">[module/xkeyboard]</span><br><span class=\"line\">type = internal/xkeyboard</span><br><span class=\"line\">blacklist-0 = num lock</span><br><span class=\"line\"></span><br><span class=\"line\">format-prefix = &quot;&quot;</span><br><span class=\"line\">format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">format-prefix-underline = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-layout = %layout%</span><br><span class=\"line\">label-layout-underline = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-indicator-padding = 2</span><br><span class=\"line\">label-indicator-margin = 1</span><br><span class=\"line\">label-indicator-background = $&#123;colors.secondary&#125;</span><br><span class=\"line\">label-indicator-underline = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/filesystem]</span><br><span class=\"line\">type = internal/fs</span><br><span class=\"line\">interval = 25</span><br><span class=\"line\"></span><br><span class=\"line\">mount-0 = /</span><br><span class=\"line\"></span><br><span class=\"line\">label-mounted = %&#123;F#0a81f5&#125;%mountpoint%%&#123;F-&#125;: %percentage_used%%</span><br><span class=\"line\">label-unmounted = %mountpoint% not mounted</span><br><span class=\"line\">label-unmounted-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/bspwm]</span><br><span class=\"line\">type = internal/bspwm</span><br><span class=\"line\"></span><br><span class=\"line\">label-focused = %index%</span><br><span class=\"line\">label-focused-background = $&#123;colors.background-alt&#125;</span><br><span class=\"line\">label-focused-underline= $&#123;colors.primary&#125;</span><br><span class=\"line\">label-focused-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">label-occupied = %index%</span><br><span class=\"line\">label-occupied-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">label-urgent = %index%!</span><br><span class=\"line\">label-urgent-background = $&#123;colors.alert&#125;</span><br><span class=\"line\">label-urgent-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">label-empty = %index%</span><br><span class=\"line\">label-empty-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">label-empty-padding = 2</span><br><span class=\"line\"></span><br><span class=\"line\">[module/i3]</span><br><span class=\"line\">type = internal/i3</span><br><span class=\"line\">format = &lt;label-state&gt; &lt;label-mode&gt;</span><br><span class=\"line\">index-sort = true</span><br><span class=\"line\">wrapping-scroll = false</span><br><span class=\"line\"></span><br><span class=\"line\">label-focused = %name%</span><br><span class=\"line\">label-unfocused = %name%</span><br><span class=\"line\">label-visible = %name%</span><br><span class=\"line\">label-urgent = %name%</span><br><span class=\"line\"></span><br><span class=\"line\">label-mode-padding = 2</span><br><span class=\"line\">label-mode-foreground = #000</span><br><span class=\"line\">label-mode-background = $&#123;colors.primary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-focused-background = $&#123;module/bspwm.label-focused-background&#125;</span><br><span class=\"line\">label-focused-underline = $&#123;module/bspwm.label-focused-underline&#125;</span><br><span class=\"line\">label-focused-padding = $&#123;module/bspwm.label-focused-padding&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-unfocused-padding = $&#123;module/bspwm.label-occupied-padding&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-visible-background = $&#123;self.label-focused-background&#125;</span><br><span class=\"line\">label-visible-underline = $&#123;self.label-focused-underline&#125;</span><br><span class=\"line\">label-visible-padding = $&#123;self.label-focused-padding&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label-urgent-background = $&#123;module/bspwm.label-urgent-background&#125;</span><br><span class=\"line\">label-urgent-padding = $&#123;module/bspwm.label-urgent-padding&#125; |</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[module/xbacklight]</span><br><span class=\"line\">type = internal/xbacklight</span><br><span class=\"line\"></span><br><span class=\"line\">format = &lt;label&gt; &lt;bar&gt;</span><br><span class=\"line\">label = BL</span><br><span class=\"line\"></span><br><span class=\"line\">bar-width = 10</span><br><span class=\"line\">bar-indicator = |</span><br><span class=\"line\">bar-indicator-foreground = #ff</span><br><span class=\"line\">bar-indicator-font = 2</span><br><span class=\"line\">bar-fill = ─</span><br><span class=\"line\">bar-fill-font = 2</span><br><span class=\"line\">bar-fill-foreground = #9f78e1</span><br><span class=\"line\">bar-empty = ─</span><br><span class=\"line\">bar-empty-font = 2</span><br><span class=\"line\">bar-empty-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/backlight-acpi]</span><br><span class=\"line\">inherit = module/xbacklight</span><br><span class=\"line\">type = internal/backlight</span><br><span class=\"line\">card = intel_backlight</span><br><span class=\"line\"></span><br><span class=\"line\">[module/cpu]</span><br><span class=\"line\">type = internal/cpu</span><br><span class=\"line\">interval = 2</span><br><span class=\"line\">format-prefix = &quot; &quot;</span><br><span class=\"line\">;format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">;format-underline = #f90000</span><br><span class=\"line\">label = %percentage:2%%</span><br><span class=\"line\"></span><br><span class=\"line\">[module/memory]</span><br><span class=\"line\">type = internal/memory</span><br><span class=\"line\">interval = 2</span><br><span class=\"line\">format-prefix = &quot;  &quot;</span><br><span class=\"line\">;format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">;format-underline = #4bffdc</span><br><span class=\"line\">label = %percentage_used%%</span><br><span class=\"line\"></span><br><span class=\"line\">[module/wlan]</span><br><span class=\"line\">type = internal/network</span><br><span class=\"line\">interface = wlp3s0</span><br><span class=\"line\">interval = 3.0</span><br><span class=\"line\"></span><br><span class=\"line\">format-connected = &lt;ramp-signal&gt;</span><br><span class=\"line\">;format-connected-underline = #9f78e1</span><br><span class=\"line\">label-connected = &quot;%essid%&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">format-disconnected = </span><br><span class=\"line\">;format-disconnected = &lt;label-disconnected&gt;</span><br><span class=\"line\">;format-disconnected-underline = $&#123;self.format-connected-underline&#125;</span><br><span class=\"line\">label-disconnected = %ifname% disconnected</span><br><span class=\"line\">label-disconnected-foreground = #999999</span><br><span class=\"line\"></span><br><span class=\"line\">ramp-signal-0 = </span><br><span class=\"line\">ramp-signal-1 = </span><br><span class=\"line\">ramp-signal-2 = </span><br><span class=\"line\">ramp-signal-3 = </span><br><span class=\"line\">ramp-signal-4 = </span><br><span class=\"line\">animation-packetloss-0 = ⚠</span><br><span class=\"line\">animation-packetloss-0-foreground = #ffa64c</span><br><span class=\"line\">;ramp-signal-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/eth]</span><br><span class=\"line\">type = internal/network</span><br><span class=\"line\">interface = enp0s31f6</span><br><span class=\"line\">interval = 3.0</span><br><span class=\"line\"></span><br><span class=\"line\">format-connected-underline = #55aa55</span><br><span class=\"line\">format-connected-prefix = &quot;📶&quot;</span><br><span class=\"line\">format-connected-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">label-connected = %local_ip%</span><br><span class=\"line\"></span><br><span class=\"line\">format-disconnected =</span><br><span class=\"line\">;format-disconnected = &lt;label-disconnected&gt;</span><br><span class=\"line\">;format-disconnected-underline = $&#123;self.format-connected-underline&#125;</span><br><span class=\"line\">;label-disconnected = %ifname% disconnected</span><br><span class=\"line\">;label-disconnected-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/date]</span><br><span class=\"line\">type = internal/date</span><br><span class=\"line\">interval = 5</span><br><span class=\"line\"></span><br><span class=\"line\">date = &quot; %Y-%m-%d&quot;</span><br><span class=\"line\">;date-alt = &quot; %Y-%m-%d&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">time = %H:%M</span><br><span class=\"line\">;time-alt = %H:%M:%S</span><br><span class=\"line\"></span><br><span class=\"line\">format-prefix = </span><br><span class=\"line\">;format-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">;format-underline = #0a6cf5</span><br><span class=\"line\"></span><br><span class=\"line\">label = %date% %time%</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[module/alsa]</span><br><span class=\"line\">type = internal/volume</span><br><span class=\"line\"></span><br><span class=\"line\">format-volume = &lt;label-volume&gt; &lt;bar-volume&gt;</span><br><span class=\"line\">label-volume = </span><br><span class=\"line\">label-volume-foreground = $&#123;root.foreground&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">format-muted-prefix = &quot; &quot;</span><br><span class=\"line\">format-muted-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">label-muted = </span><br><span class=\"line\"></span><br><span class=\"line\">bar-volume-width = 5</span><br><span class=\"line\">bar-volume-foreground-0 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-1 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-2 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-3 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-4 = #55aa55</span><br><span class=\"line\">bar-volume-foreground-5 = #f5a70a</span><br><span class=\"line\">bar-volume-foreground-6 = #ff5555</span><br><span class=\"line\">bar-volume-gradient = false</span><br><span class=\"line\">bar-volume-indicator = |</span><br><span class=\"line\">bar-volume-indicator-font = 2</span><br><span class=\"line\">bar-volume-fill = ─</span><br><span class=\"line\">bar-volume-fill-font = 2</span><br><span class=\"line\">bar-volume-empty = ─</span><br><span class=\"line\">bar-volume-empty-font = 2</span><br><span class=\"line\">bar-volume-empty-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/battery]</span><br><span class=\"line\">type = internal/battery</span><br><span class=\"line\">battery = BAT0</span><br><span class=\"line\">adapter = ADP1</span><br><span class=\"line\">full-at = 98</span><br><span class=\"line\"></span><br><span class=\"line\">format-charging = &lt;animation-charging&gt; &lt;label-charging&gt;</span><br><span class=\"line\">format-charging-underline = #ffb52a</span><br><span class=\"line\"></span><br><span class=\"line\">format-discharging = &lt;ramp-capacity&gt; &lt;label-discharging&gt;</span><br><span class=\"line\">;format-discharging-underline = $&#123;self.format-charging-underline&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">format-full-prefix = &quot; &quot;</span><br><span class=\"line\">;format-full-prefix-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">format-full-underline = $&#123;self.format-charging-underline&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ramp-capacity-0 = </span><br><span class=\"line\">ramp-capacity-1 = </span><br><span class=\"line\">ramp-capacity-2 = </span><br><span class=\"line\">ramp-capacity-3 = </span><br><span class=\"line\">;ramp-capacity-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">animation-charging-0 = </span><br><span class=\"line\">animation-charging-1 = </span><br><span class=\"line\">animation-charging-2 = </span><br><span class=\"line\">animation-charging-3 = </span><br><span class=\"line\">;animation-charging-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\">animation-charging-framerate = 750</span><br><span class=\"line\"></span><br><span class=\"line\">[module/temperature]</span><br><span class=\"line\">type = internal/temperature</span><br><span class=\"line\">thermal-zone = 0</span><br><span class=\"line\">warn-temperature = 60</span><br><span class=\"line\"></span><br><span class=\"line\">format = &lt;ramp&gt; &lt;label&gt;</span><br><span class=\"line\">;format-underline = #f50a4d</span><br><span class=\"line\">format-warn = &lt;ramp&gt; &lt;label-warn&gt;</span><br><span class=\"line\">;format-warn-underline = $&#123;self.format-underline&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label = %temperature%</span><br><span class=\"line\">label-warn = %temperature%</span><br><span class=\"line\">label-warn-foreground = $&#123;colors.secondary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ramp-0 = </span><br><span class=\"line\">ramp-1 = </span><br><span class=\"line\">ramp-2 = </span><br><span class=\"line\">;ramp-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[module/powermenu]</span><br><span class=\"line\">type = custom/menu</span><br><span class=\"line\">expand-right = true</span><br><span class=\"line\"></span><br><span class=\"line\">format-spacing = 1</span><br><span class=\"line\"></span><br><span class=\"line\">label-open = </span><br><span class=\"line\">label-open-foreground = $&#123;colors.secondary&#125;</span><br><span class=\"line\">label-close =  cancel</span><br><span class=\"line\">label-close-foreground = $&#123;colors.secondary&#125;</span><br><span class=\"line\">label-separator = |</span><br><span class=\"line\">label-separator-foreground = $&#123;colors.foreground-alt&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">menu-0-0 = reboot</span><br><span class=\"line\">menu-0-0-exec = reboot</span><br><span class=\"line\">menu-0-1 = power off</span><br><span class=\"line\">menu-0-1-exec = poweroff</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[settings]</span><br><span class=\"line\">screenchange-reload = true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[global/wm]</span><br><span class=\"line\">margin-top = 5</span><br><span class=\"line\">margin-bottom = 5</span><br></pre></td></tr></table></figure>\n<p>上面这段配置文件是polybar的配置文件，我们还需要一个启动polybar的脚本</p>\n<blockquote>\n<p>launch.sh</p>\n</blockquote>\n<p>这里的<code>launch.sh</code>可以改名，但是不必须得放在<code>~/.config/polybar</code>目录下，改名后需要修改<code>i3</code>配置文件的第<code>33</code>行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env bash</span><br><span class=\"line\"></span><br><span class=\"line\"># Terminate already running bar instances</span><br><span class=\"line\">killall -q polybar</span><br><span class=\"line\"></span><br><span class=\"line\"># Wait until the processes have been shut down</span><br><span class=\"line\">while pgrep -u $UID -x polybar &gt;/dev/null; do sleep 1; done</span><br><span class=\"line\"></span><br><span class=\"line\"># Launch bar1 and bar2</span><br><span class=\"line\">polybar example &amp;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、使用i3\"><a href=\"#三、使用i3\" class=\"headerlink\" title=\"三、使用i3\"></a>三、使用i3</h2><p>这一小节，我主要介绍我的配置文件所做的事。</p>\n<p>下面的说明并不是将我的配置文件全部进行解读，有些我觉得你们能看懂的我就没写。</p>\n<p><strong>set $mod Mod1</strong>  设置i3的super为<code>Alt</code>键</p>\n<p><strong>new_window pixel 1</strong> 设置新窗口的窗口边缘的像素</p>\n<p><strong>new_float normal</strong> 设置浮动窗口，值为默认</p>\n<p><strong>hide_edge_borders</strong> 设置窗口边框隐藏</p>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$mod+u</td>\n<td>设置边框存在</td>\n</tr>\n<tr>\n<td>$mod+y</td>\n<td>设置边框像素为1</td>\n</tr>\n<tr>\n<td>$mod+n</td>\n<td>设置边框隐藏</td>\n</tr>\n<tr>\n<td>$mod+Return(回车键)</td>\n<td>打开alacritty终端</td>\n</tr>\n<tr>\n<td>$mod+Shift+Return</td>\n<td>通过alacritty打开ranger</td>\n</tr>\n<tr>\n<td>$mod+Control+g</td>\n<td>打开Chrome</td>\n</tr>\n<tr>\n<td>$mod+Controll+f</td>\n<td>打开Firefox</td>\n</tr>\n<tr>\n<td>$mod+Shift+q</td>\n<td>杀死聚焦窗口</td>\n</tr>\n<tr>\n<td>$mod+d</td>\n<td>打开rofi</td>\n</tr>\n<tr>\n<td>$mod+h+j+k+l</td>\n<td>将聚焦在窗口之间切换</td>\n</tr>\n<tr>\n<td>$mdo+上下左右</td>\n<td>同上，只不过用的是方向键</td>\n</tr>\n<tr>\n<td>$mod+Shift+h+j+k+l</td>\n<td>将聚焦窗口改变排列位置</td>\n</tr>\n<tr>\n<td>$mod+Shift+上下左右</td>\n<td>同上，只不过用的是方向键</td>\n</tr>\n<tr>\n<td>$mod+b</td>\n<td>切换至上一个工作区</td>\n</tr>\n<tr>\n<td>$mod+Shift+b</td>\n<td>将上一个工作区的容器，移动至当前工作区内</td>\n</tr>\n<tr>\n<td>$mod+q</td>\n<td>切换平铺方式</td>\n</tr>\n<tr>\n<td>$mod+f</td>\n<td>将聚焦窗口全屏</td>\n</tr>\n<tr>\n<td>$mod+s</td>\n<td>容器窗口排列方式为堆叠式</td>\n</tr>\n<tr>\n<td>$mod+w</td>\n<td>容器窗口排列方式为标签式</td>\n</tr>\n<tr>\n<td>$mod+e</td>\n<td>容器窗口排列方式为平铺式</td>\n</tr>\n<tr>\n<td>$mod+Shift+space(空格键)</td>\n<td>切换容器窗口为平铺还是浮动</td>\n</tr>\n<tr>\n<td>$mod+space</td>\n<td>在浮动或平铺窗口之间进行聚焦的切换</td>\n</tr>\n<tr>\n<td>$mod+Ctrl+左或右</td>\n<td>切换工作区，前或后</td>\n</tr>\n<tr>\n<td>$mod+1-8</td>\n<td>切换工作区</td>\n</tr>\n<tr>\n<td>$mod+Ctrl+1-8</td>\n<td>将当前容器的窗口移动至某个工作区</td>\n</tr>\n<tr>\n<td>$mod+Shift+1-8</td>\n<td>将当前容器移动至某个工作区</td>\n</tr>\n<tr>\n<td>$mod+Shift+r</td>\n<td>重启i3</td>\n</tr>\n<tr>\n<td>$mod+Shift+c</td>\n<td>重载i3配置文件</td>\n</tr>\n<tr>\n<td>$mod+0</td>\n<td>进入系统模式</td>\n</tr>\n<tr>\n<td>l</td>\n<td>系统模式:锁屏</td>\n</tr>\n<tr>\n<td>s</td>\n<td>系统模式:挂出</td>\n</tr>\n<tr>\n<td>u</td>\n<td>系统模式:切换用户</td>\n</tr>\n<tr>\n<td>e</td>\n<td>系统模式:登出</td>\n</tr>\n<tr>\n<td>h</td>\n<td>系统模式:休眠</td>\n</tr>\n<tr>\n<td>r</td>\n<td>系统模式:重启</td>\n</tr>\n<tr>\n<td>Shift+s</td>\n<td>系统模式:关机</td>\n</tr>\n<tr>\n<td>$mod+r</td>\n<td>进入窗口大小设置模式</td>\n</tr>\n<tr>\n<td>h j k l</td>\n<td>设置窗口上下左右的大小</td>\n</tr>\n<tr>\n<td>上下左右</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>Return</td>\n<td>退出窗口大小设置模式</td>\n</tr>\n<tr>\n<td>触摸板开关</td>\n<td>触摸板开关</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"0x2-rofi\"><a href=\"#0x2-rofi\" class=\"headerlink\" title=\"0x2 rofi\"></a>0x2 rofi</h1><h2 id=\"一、安装rofi\"><a href=\"#一、安装rofi\" class=\"headerlink\" title=\"一、安装rofi\"></a>一、安装rofi</h2><blockquote>\n<p>sudo pacman -S rofi</p>\n</blockquote>\n<h2 id=\"二、配置rofi\"><a href=\"#二、配置rofi\" class=\"headerlink\" title=\"二、配置rofi\"></a>二、配置rofi</h2><h2 id=\"三、使用rofi\"><a href=\"#三、使用rofi\" class=\"headerlink\" title=\"三、使用rofi\"></a>三、使用rofi</h2><h1 id=\"0x1-ranger\"><a href=\"#0x1-ranger\" class=\"headerlink\" title=\"0x1 ranger\"></a>0x1 ranger</h1><h2 id=\"一、安装ranger\"><a href=\"#一、安装ranger\" class=\"headerlink\" title=\"一、安装ranger\"></a>一、安装ranger</h2><h2 id=\"二、配置ranger\"><a href=\"#二、配置ranger\" class=\"headerlink\" title=\"二、配置ranger\"></a>二、配置ranger</h2><h2 id=\"三、使用ranger\"><a href=\"#三、使用ranger\" class=\"headerlink\" title=\"三、使用ranger\"></a>三、使用ranger</h2><h1 id=\"0x2-alacritty\"><a href=\"#0x2-alacritty\" class=\"headerlink\" title=\"0x2 alacritty\"></a>0x2 alacritty</h1><h2 id=\"一、安装alacritty\"><a href=\"#一、安装alacritty\" class=\"headerlink\" title=\"一、安装alacritty\"></a>一、安装alacritty</h2><h2 id=\"二、配置alacritty\"><a href=\"#二、配置alacritty\" class=\"headerlink\" title=\"二、配置alacritty\"></a>二、配置alacritty</h2><h2 id=\"三、使用alacritty\"><a href=\"#三、使用alacritty\" class=\"headerlink\" title=\"三、使用alacritty\"></a>三、使用alacritty</h2><h1 id=\"0x3-vim\"><a href=\"#0x3-vim\" class=\"headerlink\" title=\"0x3 vim\"></a>0x3 vim</h1><h2 id=\"一、配置vim\"><a href=\"#一、配置vim\" class=\"headerlink\" title=\"一、配置vim\"></a>一、配置vim</h2><h1 id=\"0x4-zsh\"><a href=\"#0x4-zsh\" class=\"headerlink\" title=\"0x4 zsh\"></a>0x4 zsh</h1><h2 id=\"一、安装zsh\"><a href=\"#一、安装zsh\" class=\"headerlink\" title=\"一、安装zsh\"></a>一、安装zsh</h2><h2 id=\"二、配置zsh\"><a href=\"#二、配置zsh\" class=\"headerlink\" title=\"二、配置zsh\"></a>二、配置zsh</h2><h1 id=\"0x5-ssr-proxychains\"><a href=\"#0x5-ssr-proxychains\" class=\"headerlink\" title=\"0x5 ssr+proxychains\"></a>0x5 ssr+proxychains</h1><h2 id=\"一、安装ssr\"><a href=\"#一、安装ssr\" class=\"headerlink\" title=\"一、安装ssr\"></a>一、安装ssr</h2><h2 id=\"二、配置ssr\"><a href=\"#二、配置ssr\" class=\"headerlink\" title=\"二、配置ssr\"></a>二、配置ssr</h2><h2 id=\"三、安装proxychains\"><a href=\"#三、安装proxychains\" class=\"headerlink\" title=\"三、安装proxychains\"></a>三、安装proxychains</h2><h2 id=\"四、配置proxychains\"><a href=\"#四、配置proxychains\" class=\"headerlink\" title=\"四、配置proxychains\"></a>四、配置proxychains</h2><h2 id=\"五、使用ssr-proxychains实现全应用走代理\"><a href=\"#五、使用ssr-proxychains实现全应用走代理\" class=\"headerlink\" title=\"五、使用ssr+proxychains实现全应用走代理\"></a>五、使用ssr+proxychains实现全应用走代理</h2><h1 id=\"0x6-fcitx\"><a href=\"#0x6-fcitx\" class=\"headerlink\" title=\"0x6 fcitx\"></a>0x6 fcitx</h1><h2 id=\"一、安装fcitx\"><a href=\"#一、安装fcitx\" class=\"headerlink\" title=\"一、安装fcitx\"></a>一、安装fcitx</h2><h2 id=\"二、配置fcitx\"><a href=\"#二、配置fcitx\" class=\"headerlink\" title=\"二、配置fcitx\"></a>二、配置fcitx</h2><h2 id=\"三、启动fcitx\"><a href=\"#三、启动fcitx\" class=\"headerlink\" title=\"三、启动fcitx\"></a>三、启动fcitx</h2>"},{"title":"我的Linux之路","copyright":true,"date":"2019-05-14T16:04:56.000Z","_content":"\n这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.\n\n<!--more-->\n\n先说说一些题外话\n\n\n我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。\n\n\n第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)... 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。\n\n\n我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了\"驱动\" 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法...还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决...后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了....\n\n\n好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。\n\n\n身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 \"xxx可能是最好的Linux发行版\"，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。\n\n\n终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。\n\n\n自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!\n\n\n下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么... 毛玻璃效果非常漂亮，社区还是挺活跃的。\n\n\n说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）\n\n我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。\n\n\n我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。\n\n\n下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!\n\n\n解决了上面提到的所有问题，并且电脑还省电多了...并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。\n\n\n但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。\n\n\n总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。\n","source":"_posts/我的Linux之路.md","raw":"---\ntitle: 我的Linux之路\ncopyright: true\ndate: 2019-05-15 00:04:56\ncategories: 个人感想\ntags:\n - Linux\n---\n\n这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.\n\n<!--more-->\n\n先说说一些题外话\n\n\n我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。\n\n\n第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)... 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。\n\n\n我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了\"驱动\" 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法...还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决...后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了....\n\n\n好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。\n\n\n身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 \"xxx可能是最好的Linux发行版\"，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。\n\n\n终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。\n\n\n自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!\n\n\n下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么... 毛玻璃效果非常漂亮，社区还是挺活跃的。\n\n\n说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）\n\n我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。\n\n\n我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。\n\n\n下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!\n\n\n解决了上面提到的所有问题，并且电脑还省电多了...并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。\n\n\n但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。\n\n\n总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。\n","slug":"我的Linux之路","published":1,"updated":"2020-01-19T03:49:51.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodd0061omooj6q4ks0w","content":"<p>这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.</p>\n<a id=\"more\"></a>\n<p>先说说一些题外话</p>\n<p>我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。</p>\n<p>第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。</p>\n<p>我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了….</p>\n<p>好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。</p>\n<p>身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。</p>\n<p>终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。</p>\n<p>自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!</p>\n<p>下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。</p>\n<p>说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）</p>\n<p>我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。</p>\n<p>我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。</p>\n<p>下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!</p>\n<p>解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。</p>\n<p>但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。</p>\n<p>总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。</p>\n","site":{"data":{}},"excerpt":"<p>这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.</p>","more":"<p>先说说一些题外话</p>\n<p>我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。</p>\n<p>第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。</p>\n<p>我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了….</p>\n<p>好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。</p>\n<p>身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。</p>\n<p>终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。</p>\n<p>自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!</p>\n<p>下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。</p>\n<p>说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）</p>\n<p>我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。</p>\n<p>我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。</p>\n<p>下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!</p>\n<p>解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。</p>\n<p>但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。</p>\n<p>总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。</p>"},{"title":"我的VIM配置详解","copyright":true,"date":"2019-06-21T09:35:54.000Z","_content":"\n最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。\n<!--more-->\n\n我已经把我的配置文件上传到了Github上了，[点击访问](https://github.com/EvanMeek/Vanilla)\n\n基本都有写中文注释，哪里有不懂的，可以问我，[点击查看我的联系方式](https://evanmeek.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/)\n\n~~~\n\n\" 设置vi与vim兼容\nset nocompatible\n\" 设置使vim识别不同的文件格式\nfiletype on\nfiletype indent on\nfiletype plugin on\nfiletype plugin indent on\n\" 设置使vim能用鼠标操作\nset mouse=a\n\" 设置字符编码\nset encoding=utf-8\n\" 使配色更加兼容你的终端\nlet &t_ut=''\n\" 设置缩进距离\nset expandtab\nset tabstop=2\nset shiftwidth=2\nset softtabstop=2\n\" 设置空格的显示\nset list\nset listchars=tab:▸\\ ,trail:▫\nset tw=0\nset indentexpr=\n\" 退格键到行首后自动跳转到上行行尾\nset backspace=indent,eol,start\n\" 收起代码\nset foldmethod=indent\nset foldlevel=99\n\" 设置终端的光标在不同模式下用不同的样式,实测Konsole可用\nlet &t_SI = \"\\<Esc>]50;CursorShape=1\\x7\"\nlet &t_SR = \"\\<Esc>]50;CursorShape=2\\x7\"\nlet &t_EI = \"\\<Esc>]50;CursorShape=0\\x7\"\n\" 状态栏等于２？？？\nset laststatus=2\n\" vim执行的外部命令会在当前目录下执行\nset autochdir\n\" 关闭文件又打开光标会自动回到关闭前的位置\nau BufReadPost * if line(\"'\\\"\") > 1 && line(\"'\\\"\") <= line(\"$\") | exe \"normal! g'\\\"\" | endif\n\" 设置leader键为空格\nlet mapleader=\" \"\n\" 代码高亮\nsyntax on\n\n\" 设置行号\nset number\n\" 设置更好的行号\nset relativenumber\n\" 设置光标线\nset cursorline\n\" 自动换行\nset wrap\n\" 显示命令\nset showcmd\n\" tab多选项菜单\nset wildmenu\n\" 设置搜索关键词高亮\nset hlsearch\nexec \"nohlsearch\"\n\" 设置搜索输入时高亮\nset incsearch\n\" 搜索时忽略大小写\nset ignorecase \n\" 只能搜索忽略大小写\nset smartcase\n\n\" 搜索跳转结果改为=/-并且使搜索结果在屏幕中间\nnoremap = nzz\nnoremap - Nzz\n\n\" 大写JKHL重复五次执行\nnoremap J 5j\nnoremap K 5k\nnoremap H 5h\nnoremap L 5l\n\" 设置取消高亮\nnoremap <LEADER><CR> :nohlsearch<CR>\n\n\" 设置光标回到行首\nnoremap <LEADER>a 0\n\n\" 设置光标回到行尾\nnoremap <LEADER>e $\n\n\" 取消s删除字符的功能\nmap s <nop>\n\n\" 快速保存\nmap S :w<CR>\n\n\" 按大写Q直接退出\nmap Q :q<CR>\n\n\" R快速source vimrc\nmap R :source ~/.vim/vimrc<CR>\n\n\"分屏操作\n\"向右分屏\nmap <LEADER>l :set splitright<CR>:vsplit<CR>\n\"向左分屏\nmap <LEADER>h :set nosplitright<CR>:vsplit<CR>\n\"向上分屏\nmap <LEADER>k :set nosplitbelow<CR>:split<CR>\n\"向下分屏\nmap <LEADER>j :set splitbelow<CR>:split<CR>\n\"光标移动至左分屏\nmap sh <C-w>h\n\"光标移动至右分屏\nmap sl <C-w>l\n\"光标移动至下分屏\nmap sj <C-w>j\n\"光标移动至上分屏\nmap sk <C-w>k\n\"增加纵向分屏大小\nmap <up> :res +5<CR>\n\"减少纵向分屏大小\nmap <down> :res -5<CR>\n\"减少横向分屏大小\nmap <left> :vertical resize-5<CR>\n\"增加横横分屏大小\nmap <right> :vertical resize+5<CR>\n\"将分屏设置为横向分屏\nmap <LEADER>H <C-w>t<C-w>H\n\"将分屏设置为纵向分屏\nmap <LEADER>K <C-w>t<C-w>K\n\n\"标签\n\"打开新标签\nmap tn :tabe<CR>\n\" 跳转至上一个标签\nmap th :-tabnext<CR>\n\" 跳转至下一个标签\nmap tl :+tabnext<CR>\n  \" 关闭当前标签\nmap td :tabclose<CR>\n\n\"插件安装vim-plug\ncall plug#begin('~/.vim/plugged')\nPlug 'endel/vim-github-colorscheme'\nPlug 'morhetz/gruvbox'\n\nPlug 'vim-airline/vim-airline'\n\n\" File navigation\nPlug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }\nPlug 'Xuyuanp/nerdtree-git-plugin'\n\n\" Taglist\nPlug 'majutsushi/tagbar', { 'on': 'TagbarOpenAutoClose' }\n\n\" Error checking\nPlug 'w0rp/ale'\n\n\" Auto Complete\nPlug 'Valloric/YouCompleteMe'\n\n\" Undo Tree\nPlug 'mbbill/undotree/'\n\n\" Other visual enhancement\nPlug 'nathanaelkane/vim-indent-guides'\nPlug 'itchyny/vim-cursorword'\n\n\" Git\nPlug 'rhysd/conflict-marker.vim'\nPlug 'tpope/vim-fugitive'\nPlug 'mhinz/vim-signify'\nPlug 'gisphm/vim-gitignore', { 'for': ['gitignore', 'vim-plug'] }\n\n\" HTML, CSS, JavaScript, PHP, JSON, etc.\nPlug 'elzr/vim-json'\nPlug 'hail2u/vim-css3-syntax'\nPlug 'spf13/PIV', { 'for' :['php', 'vim-plug'] }\nPlug 'gko/vim-coloresque', { 'for': ['vim-plug', 'php', 'html', 'javascript', 'css', 'less'] }\nPlug 'pangloss/vim-javascript', { 'for' :['javascript', 'vim-plug'] }\nPlug 'mattn/emmet-vim'\n\n\" Python\nPlug 'vim-scripts/indentpython.vim'\n\n\" Markdown\nPlug 'iamcco/markdown-preview.nvim', { 'do': 'cd app & yarn install'  }\nPlug 'dhruvasagar/vim-table-mode', { 'on': 'TableModeToggle' }\nPlug 'vimwiki/vimwiki'\n\n\" Bookmarks\nPlug 'kshenoy/vim-signature'\n\n\" Other useful utilities\nPlug 'terryma/vim-multiple-cursors'\nPlug 'junegunn/goyo.vim' \" distraction free writing mode\nPlug 'tpope/vim-surround' \" type ysks' to wrap the word with '' or type cs'` to change 'word' to `word`\nPlug 'godlygeek/tabular' \" type ;Tabularize /= to align the =\nPlug 'gcmt/wildfire.vim' \" in Visual mode, type i' to select all text in '', or type i) i] i} ip\nPlug 'scrooloose/nerdcommenter' \" in <space>cc to comment a line\n\n\" Dependencies\nPlug 'MarcWeber/vim-addon-mw-utils'\nPlug 'kana/vim-textobj-user'\nPlug 'fadein/vim-FIGlet'\n\n\ncall plug#end()\n\n\" 设置透明\nlet g:SnazzyTransparent = 1\n\n\" 设置主题\n\" 可选项\n\" github/snazzy/inkstained\nlet g:grubvbox_termcolors='256'\nlet g:grubvbox_contrast_light = 'soft'\ncolor gruvbox\nset background =light\n\n\" 插件配置\n\n\" ==== NERDTree\nmap ff :NERDTreeToggle<CR>\n\n\" ==== NERDTree-git\n\nlet g:NERDTreeIndicatorMapCustom = {\n    \\ \"Modified\"  : \"✹\",\n    \\ \"Staged\"    : \"✚\",\n    \\ \"Untracked\" : \"✭\",\n    \\ \"Renamed\"   : \"➜\",\n    \\ \"Unmerged\"  : \"═\",\n    \\ \"Deleted\"   : \"✖\",\n    \\ \"Dirty\"     : \"✗\",\n    \\ \"Clean\"     : \"✔︎\",\n    \\ \"Unknown\"   : \"?\"\n    \\ }\n\n\" ==== You Complete ME\n\" 跳转至其他的声明\nnnoremap gd :YcmCompleter GoToDefinitionElseDeclaration<CR>\n\" 跳转至文档\nnnoremap g/ :YcmCompleter GetDoc<CR>\n\" 获取类型\nnnoremap gt :YcmCompleter GetType<CR>\n\" 获取参考\nnnoremap gr :YcmCompleter GoToReferences<CR>\nlet g:ycm_autoclose_preview_window_after_completion=0\nlet g:ycm_autoclose_preview_window_after_insertion=1\nlet g:ycm_use_clangd = 0\nlet g:ycm_python_interpreter_path = \"/bin/python3\"\nlet g:ycm_python_binary_path = \"/bin/python3\"\n\n\" ==== ale\nlet b:ale_linters = ['pylint']\nlet b:ale_fixers = ['autopep8', 'yapf']\n\n\" ==== TagList\nmap <silent> T :TagbarOpenAutoClose<CR>\n\n\" ==== MarkdownPreview\nnmap <LEADER>mp :MarkdownPreview<CR>\n\n\" ==== vim-table-mode\n\nmap <LEADER>tm :TableModeToggle<CR>\n\n\" ==== vim-indent-guide\nlet g:indent_guides_guide_size = 0\nlet g:indent_guides_start_level = 2\nlet g:indent_guides_enable_on_vim_startup = 1\nlet g:indent_guides_color_change_percent = 0\nautocmd WinEnter * silent! unmap <LEADER>ig\n\n\" ====Goyo\nmap <LEADER>gy :Goyo<CR>\n\n\" ==== vim-signiture\nlet g:SignatureMap = {\n        \\ 'Leader'             :  \"m\",\n        \\ 'PlaceNextMark'      :  \"m,\",\n        \\ 'ToggleMarkAtLine'   :  \"m.\",\n        \\ 'PurgeMarksAtLine'   :  \"dm-\",\n        \\ 'DeleteMark'         :  \"dm\",\n        \\ 'PurgeMarks'         :  \"dm/\",\n        \\ 'PurgeMarkers'       :  \"dm?\",\n        \\ 'GotoNextLineAlpha'  :  \"m<LEADER>\",\n        \\ 'GotoPrevLineAlpha'  :  \"\",\n        \\ 'GotoNextSpotAlpha'  :  \"m<LEADER>\",\n        \\ 'GotoPrevSpotAlpha'  :  \"\",\n        \\ 'GotoNextLineByPos'  :  \"\",\n        \\ 'GotoPrevLineByPos'  :  \"\",\n        \\ 'GotoNextSpotByPos'  :  \"mn\",\n        \\ 'GotoPrevSpotByPos'  :  \"mp\",\n        \\ 'GotoNextMarker'     :  \"\",\n        \\ 'GotoPrevMarker'     :  \"\",\n        \\ 'GotoNextMarkerAny'  :  \"\",\n        \\ 'GotoPrevMarkerAny'  :  \"\",\n        \\ 'ListLocalMarks'     :  \"m/\",\n        \\ 'ListLocalMarkers'   :  \"m?\"\n        \\ }\n\n\n\" === Undotree\nlet g:undotree_DiffAutoOpen = 0\nmap <LEADER>ut :UndotreeToggle<CR>\n~~~\n","source":"_posts/我的VIM配置详解.md","raw":"---\ntitle: 我的VIM配置详解\ncopyright: true\ndate: 2019-06-21 17:35:54\ncategories: 学习笔记\ntags:\n  - VIM\n---\n\n最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。\n<!--more-->\n\n我已经把我的配置文件上传到了Github上了，[点击访问](https://github.com/EvanMeek/Vanilla)\n\n基本都有写中文注释，哪里有不懂的，可以问我，[点击查看我的联系方式](https://evanmeek.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/)\n\n~~~\n\n\" 设置vi与vim兼容\nset nocompatible\n\" 设置使vim识别不同的文件格式\nfiletype on\nfiletype indent on\nfiletype plugin on\nfiletype plugin indent on\n\" 设置使vim能用鼠标操作\nset mouse=a\n\" 设置字符编码\nset encoding=utf-8\n\" 使配色更加兼容你的终端\nlet &t_ut=''\n\" 设置缩进距离\nset expandtab\nset tabstop=2\nset shiftwidth=2\nset softtabstop=2\n\" 设置空格的显示\nset list\nset listchars=tab:▸\\ ,trail:▫\nset tw=0\nset indentexpr=\n\" 退格键到行首后自动跳转到上行行尾\nset backspace=indent,eol,start\n\" 收起代码\nset foldmethod=indent\nset foldlevel=99\n\" 设置终端的光标在不同模式下用不同的样式,实测Konsole可用\nlet &t_SI = \"\\<Esc>]50;CursorShape=1\\x7\"\nlet &t_SR = \"\\<Esc>]50;CursorShape=2\\x7\"\nlet &t_EI = \"\\<Esc>]50;CursorShape=0\\x7\"\n\" 状态栏等于２？？？\nset laststatus=2\n\" vim执行的外部命令会在当前目录下执行\nset autochdir\n\" 关闭文件又打开光标会自动回到关闭前的位置\nau BufReadPost * if line(\"'\\\"\") > 1 && line(\"'\\\"\") <= line(\"$\") | exe \"normal! g'\\\"\" | endif\n\" 设置leader键为空格\nlet mapleader=\" \"\n\" 代码高亮\nsyntax on\n\n\" 设置行号\nset number\n\" 设置更好的行号\nset relativenumber\n\" 设置光标线\nset cursorline\n\" 自动换行\nset wrap\n\" 显示命令\nset showcmd\n\" tab多选项菜单\nset wildmenu\n\" 设置搜索关键词高亮\nset hlsearch\nexec \"nohlsearch\"\n\" 设置搜索输入时高亮\nset incsearch\n\" 搜索时忽略大小写\nset ignorecase \n\" 只能搜索忽略大小写\nset smartcase\n\n\" 搜索跳转结果改为=/-并且使搜索结果在屏幕中间\nnoremap = nzz\nnoremap - Nzz\n\n\" 大写JKHL重复五次执行\nnoremap J 5j\nnoremap K 5k\nnoremap H 5h\nnoremap L 5l\n\" 设置取消高亮\nnoremap <LEADER><CR> :nohlsearch<CR>\n\n\" 设置光标回到行首\nnoremap <LEADER>a 0\n\n\" 设置光标回到行尾\nnoremap <LEADER>e $\n\n\" 取消s删除字符的功能\nmap s <nop>\n\n\" 快速保存\nmap S :w<CR>\n\n\" 按大写Q直接退出\nmap Q :q<CR>\n\n\" R快速source vimrc\nmap R :source ~/.vim/vimrc<CR>\n\n\"分屏操作\n\"向右分屏\nmap <LEADER>l :set splitright<CR>:vsplit<CR>\n\"向左分屏\nmap <LEADER>h :set nosplitright<CR>:vsplit<CR>\n\"向上分屏\nmap <LEADER>k :set nosplitbelow<CR>:split<CR>\n\"向下分屏\nmap <LEADER>j :set splitbelow<CR>:split<CR>\n\"光标移动至左分屏\nmap sh <C-w>h\n\"光标移动至右分屏\nmap sl <C-w>l\n\"光标移动至下分屏\nmap sj <C-w>j\n\"光标移动至上分屏\nmap sk <C-w>k\n\"增加纵向分屏大小\nmap <up> :res +5<CR>\n\"减少纵向分屏大小\nmap <down> :res -5<CR>\n\"减少横向分屏大小\nmap <left> :vertical resize-5<CR>\n\"增加横横分屏大小\nmap <right> :vertical resize+5<CR>\n\"将分屏设置为横向分屏\nmap <LEADER>H <C-w>t<C-w>H\n\"将分屏设置为纵向分屏\nmap <LEADER>K <C-w>t<C-w>K\n\n\"标签\n\"打开新标签\nmap tn :tabe<CR>\n\" 跳转至上一个标签\nmap th :-tabnext<CR>\n\" 跳转至下一个标签\nmap tl :+tabnext<CR>\n  \" 关闭当前标签\nmap td :tabclose<CR>\n\n\"插件安装vim-plug\ncall plug#begin('~/.vim/plugged')\nPlug 'endel/vim-github-colorscheme'\nPlug 'morhetz/gruvbox'\n\nPlug 'vim-airline/vim-airline'\n\n\" File navigation\nPlug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }\nPlug 'Xuyuanp/nerdtree-git-plugin'\n\n\" Taglist\nPlug 'majutsushi/tagbar', { 'on': 'TagbarOpenAutoClose' }\n\n\" Error checking\nPlug 'w0rp/ale'\n\n\" Auto Complete\nPlug 'Valloric/YouCompleteMe'\n\n\" Undo Tree\nPlug 'mbbill/undotree/'\n\n\" Other visual enhancement\nPlug 'nathanaelkane/vim-indent-guides'\nPlug 'itchyny/vim-cursorword'\n\n\" Git\nPlug 'rhysd/conflict-marker.vim'\nPlug 'tpope/vim-fugitive'\nPlug 'mhinz/vim-signify'\nPlug 'gisphm/vim-gitignore', { 'for': ['gitignore', 'vim-plug'] }\n\n\" HTML, CSS, JavaScript, PHP, JSON, etc.\nPlug 'elzr/vim-json'\nPlug 'hail2u/vim-css3-syntax'\nPlug 'spf13/PIV', { 'for' :['php', 'vim-plug'] }\nPlug 'gko/vim-coloresque', { 'for': ['vim-plug', 'php', 'html', 'javascript', 'css', 'less'] }\nPlug 'pangloss/vim-javascript', { 'for' :['javascript', 'vim-plug'] }\nPlug 'mattn/emmet-vim'\n\n\" Python\nPlug 'vim-scripts/indentpython.vim'\n\n\" Markdown\nPlug 'iamcco/markdown-preview.nvim', { 'do': 'cd app & yarn install'  }\nPlug 'dhruvasagar/vim-table-mode', { 'on': 'TableModeToggle' }\nPlug 'vimwiki/vimwiki'\n\n\" Bookmarks\nPlug 'kshenoy/vim-signature'\n\n\" Other useful utilities\nPlug 'terryma/vim-multiple-cursors'\nPlug 'junegunn/goyo.vim' \" distraction free writing mode\nPlug 'tpope/vim-surround' \" type ysks' to wrap the word with '' or type cs'` to change 'word' to `word`\nPlug 'godlygeek/tabular' \" type ;Tabularize /= to align the =\nPlug 'gcmt/wildfire.vim' \" in Visual mode, type i' to select all text in '', or type i) i] i} ip\nPlug 'scrooloose/nerdcommenter' \" in <space>cc to comment a line\n\n\" Dependencies\nPlug 'MarcWeber/vim-addon-mw-utils'\nPlug 'kana/vim-textobj-user'\nPlug 'fadein/vim-FIGlet'\n\n\ncall plug#end()\n\n\" 设置透明\nlet g:SnazzyTransparent = 1\n\n\" 设置主题\n\" 可选项\n\" github/snazzy/inkstained\nlet g:grubvbox_termcolors='256'\nlet g:grubvbox_contrast_light = 'soft'\ncolor gruvbox\nset background =light\n\n\" 插件配置\n\n\" ==== NERDTree\nmap ff :NERDTreeToggle<CR>\n\n\" ==== NERDTree-git\n\nlet g:NERDTreeIndicatorMapCustom = {\n    \\ \"Modified\"  : \"✹\",\n    \\ \"Staged\"    : \"✚\",\n    \\ \"Untracked\" : \"✭\",\n    \\ \"Renamed\"   : \"➜\",\n    \\ \"Unmerged\"  : \"═\",\n    \\ \"Deleted\"   : \"✖\",\n    \\ \"Dirty\"     : \"✗\",\n    \\ \"Clean\"     : \"✔︎\",\n    \\ \"Unknown\"   : \"?\"\n    \\ }\n\n\" ==== You Complete ME\n\" 跳转至其他的声明\nnnoremap gd :YcmCompleter GoToDefinitionElseDeclaration<CR>\n\" 跳转至文档\nnnoremap g/ :YcmCompleter GetDoc<CR>\n\" 获取类型\nnnoremap gt :YcmCompleter GetType<CR>\n\" 获取参考\nnnoremap gr :YcmCompleter GoToReferences<CR>\nlet g:ycm_autoclose_preview_window_after_completion=0\nlet g:ycm_autoclose_preview_window_after_insertion=1\nlet g:ycm_use_clangd = 0\nlet g:ycm_python_interpreter_path = \"/bin/python3\"\nlet g:ycm_python_binary_path = \"/bin/python3\"\n\n\" ==== ale\nlet b:ale_linters = ['pylint']\nlet b:ale_fixers = ['autopep8', 'yapf']\n\n\" ==== TagList\nmap <silent> T :TagbarOpenAutoClose<CR>\n\n\" ==== MarkdownPreview\nnmap <LEADER>mp :MarkdownPreview<CR>\n\n\" ==== vim-table-mode\n\nmap <LEADER>tm :TableModeToggle<CR>\n\n\" ==== vim-indent-guide\nlet g:indent_guides_guide_size = 0\nlet g:indent_guides_start_level = 2\nlet g:indent_guides_enable_on_vim_startup = 1\nlet g:indent_guides_color_change_percent = 0\nautocmd WinEnter * silent! unmap <LEADER>ig\n\n\" ====Goyo\nmap <LEADER>gy :Goyo<CR>\n\n\" ==== vim-signiture\nlet g:SignatureMap = {\n        \\ 'Leader'             :  \"m\",\n        \\ 'PlaceNextMark'      :  \"m,\",\n        \\ 'ToggleMarkAtLine'   :  \"m.\",\n        \\ 'PurgeMarksAtLine'   :  \"dm-\",\n        \\ 'DeleteMark'         :  \"dm\",\n        \\ 'PurgeMarks'         :  \"dm/\",\n        \\ 'PurgeMarkers'       :  \"dm?\",\n        \\ 'GotoNextLineAlpha'  :  \"m<LEADER>\",\n        \\ 'GotoPrevLineAlpha'  :  \"\",\n        \\ 'GotoNextSpotAlpha'  :  \"m<LEADER>\",\n        \\ 'GotoPrevSpotAlpha'  :  \"\",\n        \\ 'GotoNextLineByPos'  :  \"\",\n        \\ 'GotoPrevLineByPos'  :  \"\",\n        \\ 'GotoNextSpotByPos'  :  \"mn\",\n        \\ 'GotoPrevSpotByPos'  :  \"mp\",\n        \\ 'GotoNextMarker'     :  \"\",\n        \\ 'GotoPrevMarker'     :  \"\",\n        \\ 'GotoNextMarkerAny'  :  \"\",\n        \\ 'GotoPrevMarkerAny'  :  \"\",\n        \\ 'ListLocalMarks'     :  \"m/\",\n        \\ 'ListLocalMarkers'   :  \"m?\"\n        \\ }\n\n\n\" === Undotree\nlet g:undotree_DiffAutoOpen = 0\nmap <LEADER>ut :UndotreeToggle<CR>\n~~~\n","slug":"我的VIM配置详解","published":1,"updated":"2020-01-19T03:49:51.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodd0064omoocr03o98l","content":"<p>最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。<br><a id=\"more\"></a></p>\n<p>我已经把我的配置文件上传到了Github上了，<a href=\"https://github.com/EvanMeek/Vanilla\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<p>基本都有写中文注释，哪里有不懂的，可以问我，<a href=\"https://evanmeek.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/\">点击查看我的联系方式</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&quot; 设置vi与vim兼容</span><br><span class=\"line\">set nocompatible</span><br><span class=\"line\">&quot; 设置使vim识别不同的文件格式</span><br><span class=\"line\">filetype on</span><br><span class=\"line\">filetype indent on</span><br><span class=\"line\">filetype plugin on</span><br><span class=\"line\">filetype plugin indent on</span><br><span class=\"line\">&quot; 设置使vim能用鼠标操作</span><br><span class=\"line\">set mouse=a</span><br><span class=\"line\">&quot; 设置字符编码</span><br><span class=\"line\">set encoding=utf-8</span><br><span class=\"line\">&quot; 使配色更加兼容你的终端</span><br><span class=\"line\">let &amp;t_ut=&apos;&apos;</span><br><span class=\"line\">&quot; 设置缩进距离</span><br><span class=\"line\">set expandtab</span><br><span class=\"line\">set tabstop=2</span><br><span class=\"line\">set shiftwidth=2</span><br><span class=\"line\">set softtabstop=2</span><br><span class=\"line\">&quot; 设置空格的显示</span><br><span class=\"line\">set list</span><br><span class=\"line\">set listchars=tab:▸\\ ,trail:▫</span><br><span class=\"line\">set tw=0</span><br><span class=\"line\">set indentexpr=</span><br><span class=\"line\">&quot; 退格键到行首后自动跳转到上行行尾</span><br><span class=\"line\">set backspace=indent,eol,start</span><br><span class=\"line\">&quot; 收起代码</span><br><span class=\"line\">set foldmethod=indent</span><br><span class=\"line\">set foldlevel=99</span><br><span class=\"line\">&quot; 设置终端的光标在不同模式下用不同的样式,实测Konsole可用</span><br><span class=\"line\">let &amp;t_SI = &quot;\\&lt;Esc&gt;]50;CursorShape=1\\x7&quot;</span><br><span class=\"line\">let &amp;t_SR = &quot;\\&lt;Esc&gt;]50;CursorShape=2\\x7&quot;</span><br><span class=\"line\">let &amp;t_EI = &quot;\\&lt;Esc&gt;]50;CursorShape=0\\x7&quot;</span><br><span class=\"line\">&quot; 状态栏等于２？？？</span><br><span class=\"line\">set laststatus=2</span><br><span class=\"line\">&quot; vim执行的外部命令会在当前目录下执行</span><br><span class=\"line\">set autochdir</span><br><span class=\"line\">&quot; 关闭文件又打开光标会自动回到关闭前的位置</span><br><span class=\"line\">au BufReadPost * if line(&quot;&apos;\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&apos;\\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&apos;\\&quot;&quot; | endif</span><br><span class=\"line\">&quot; 设置leader键为空格</span><br><span class=\"line\">let mapleader=&quot; &quot;</span><br><span class=\"line\">&quot; 代码高亮</span><br><span class=\"line\">syntax on</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置行号</span><br><span class=\"line\">set number</span><br><span class=\"line\">&quot; 设置更好的行号</span><br><span class=\"line\">set relativenumber</span><br><span class=\"line\">&quot; 设置光标线</span><br><span class=\"line\">set cursorline</span><br><span class=\"line\">&quot; 自动换行</span><br><span class=\"line\">set wrap</span><br><span class=\"line\">&quot; 显示命令</span><br><span class=\"line\">set showcmd</span><br><span class=\"line\">&quot; tab多选项菜单</span><br><span class=\"line\">set wildmenu</span><br><span class=\"line\">&quot; 设置搜索关键词高亮</span><br><span class=\"line\">set hlsearch</span><br><span class=\"line\">exec &quot;nohlsearch&quot;</span><br><span class=\"line\">&quot; 设置搜索输入时高亮</span><br><span class=\"line\">set incsearch</span><br><span class=\"line\">&quot; 搜索时忽略大小写</span><br><span class=\"line\">set ignorecase </span><br><span class=\"line\">&quot; 只能搜索忽略大小写</span><br><span class=\"line\">set smartcase</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 搜索跳转结果改为=/-并且使搜索结果在屏幕中间</span><br><span class=\"line\">noremap = nzz</span><br><span class=\"line\">noremap - Nzz</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 大写JKHL重复五次执行</span><br><span class=\"line\">noremap J 5j</span><br><span class=\"line\">noremap K 5k</span><br><span class=\"line\">noremap H 5h</span><br><span class=\"line\">noremap L 5l</span><br><span class=\"line\">&quot; 设置取消高亮</span><br><span class=\"line\">noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置光标回到行首</span><br><span class=\"line\">noremap &lt;LEADER&gt;a 0</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置光标回到行尾</span><br><span class=\"line\">noremap &lt;LEADER&gt;e $</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 取消s删除字符的功能</span><br><span class=\"line\">map s &lt;nop&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 快速保存</span><br><span class=\"line\">map S :w&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 按大写Q直接退出</span><br><span class=\"line\">map Q :q&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; R快速source vimrc</span><br><span class=\"line\">map R :source ~/.vim/vimrc&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;分屏操作</span><br><span class=\"line\">&quot;向右分屏</span><br><span class=\"line\">map &lt;LEADER&gt;l :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class=\"line\">&quot;向左分屏</span><br><span class=\"line\">map &lt;LEADER&gt;h :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class=\"line\">&quot;向上分屏</span><br><span class=\"line\">map &lt;LEADER&gt;k :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class=\"line\">&quot;向下分屏</span><br><span class=\"line\">map &lt;LEADER&gt;j :set splitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class=\"line\">&quot;光标移动至左分屏</span><br><span class=\"line\">map sh &lt;C-w&gt;h</span><br><span class=\"line\">&quot;光标移动至右分屏</span><br><span class=\"line\">map sl &lt;C-w&gt;l</span><br><span class=\"line\">&quot;光标移动至下分屏</span><br><span class=\"line\">map sj &lt;C-w&gt;j</span><br><span class=\"line\">&quot;光标移动至上分屏</span><br><span class=\"line\">map sk &lt;C-w&gt;k</span><br><span class=\"line\">&quot;增加纵向分屏大小</span><br><span class=\"line\">map &lt;up&gt; :res +5&lt;CR&gt;</span><br><span class=\"line\">&quot;减少纵向分屏大小</span><br><span class=\"line\">map &lt;down&gt; :res -5&lt;CR&gt;</span><br><span class=\"line\">&quot;减少横向分屏大小</span><br><span class=\"line\">map &lt;left&gt; :vertical resize-5&lt;CR&gt;</span><br><span class=\"line\">&quot;增加横横分屏大小</span><br><span class=\"line\">map &lt;right&gt; :vertical resize+5&lt;CR&gt;</span><br><span class=\"line\">&quot;将分屏设置为横向分屏</span><br><span class=\"line\">map &lt;LEADER&gt;H &lt;C-w&gt;t&lt;C-w&gt;H</span><br><span class=\"line\">&quot;将分屏设置为纵向分屏</span><br><span class=\"line\">map &lt;LEADER&gt;K &lt;C-w&gt;t&lt;C-w&gt;K</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;标签</span><br><span class=\"line\">&quot;打开新标签</span><br><span class=\"line\">map tn :tabe&lt;CR&gt;</span><br><span class=\"line\">&quot; 跳转至上一个标签</span><br><span class=\"line\">map th :-tabnext&lt;CR&gt;</span><br><span class=\"line\">&quot; 跳转至下一个标签</span><br><span class=\"line\">map tl :+tabnext&lt;CR&gt;</span><br><span class=\"line\">  &quot; 关闭当前标签</span><br><span class=\"line\">map td :tabclose&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;插件安装vim-plug</span><br><span class=\"line\">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class=\"line\">Plug &apos;endel/vim-github-colorscheme&apos;</span><br><span class=\"line\">Plug &apos;morhetz/gruvbox&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Plug &apos;vim-airline/vim-airline&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; File navigation</span><br><span class=\"line\">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;: &apos;NERDTreeToggle&apos; &#125;</span><br><span class=\"line\">Plug &apos;Xuyuanp/nerdtree-git-plugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Taglist</span><br><span class=\"line\">Plug &apos;majutsushi/tagbar&apos;, &#123; &apos;on&apos;: &apos;TagbarOpenAutoClose&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Error checking</span><br><span class=\"line\">Plug &apos;w0rp/ale&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Auto Complete</span><br><span class=\"line\">Plug &apos;Valloric/YouCompleteMe&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Undo Tree</span><br><span class=\"line\">Plug &apos;mbbill/undotree/&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Other visual enhancement</span><br><span class=\"line\">Plug &apos;nathanaelkane/vim-indent-guides&apos;</span><br><span class=\"line\">Plug &apos;itchyny/vim-cursorword&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Git</span><br><span class=\"line\">Plug &apos;rhysd/conflict-marker.vim&apos;</span><br><span class=\"line\">Plug &apos;tpope/vim-fugitive&apos;</span><br><span class=\"line\">Plug &apos;mhinz/vim-signify&apos;</span><br><span class=\"line\">Plug &apos;gisphm/vim-gitignore&apos;, &#123; &apos;for&apos;: [&apos;gitignore&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; HTML, CSS, JavaScript, PHP, JSON, etc.</span><br><span class=\"line\">Plug &apos;elzr/vim-json&apos;</span><br><span class=\"line\">Plug &apos;hail2u/vim-css3-syntax&apos;</span><br><span class=\"line\">Plug &apos;spf13/PIV&apos;, &#123; &apos;for&apos; :[&apos;php&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class=\"line\">Plug &apos;gko/vim-coloresque&apos;, &#123; &apos;for&apos;: [&apos;vim-plug&apos;, &apos;php&apos;, &apos;html&apos;, &apos;javascript&apos;, &apos;css&apos;, &apos;less&apos;] &#125;</span><br><span class=\"line\">Plug &apos;pangloss/vim-javascript&apos;, &#123; &apos;for&apos; :[&apos;javascript&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class=\"line\">Plug &apos;mattn/emmet-vim&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Python</span><br><span class=\"line\">Plug &apos;vim-scripts/indentpython.vim&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Markdown</span><br><span class=\"line\">Plug &apos;iamcco/markdown-preview.nvim&apos;, &#123; &apos;do&apos;: &apos;cd app &amp; yarn install&apos;  &#125;</span><br><span class=\"line\">Plug &apos;dhruvasagar/vim-table-mode&apos;, &#123; &apos;on&apos;: &apos;TableModeToggle&apos; &#125;</span><br><span class=\"line\">Plug &apos;vimwiki/vimwiki&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Bookmarks</span><br><span class=\"line\">Plug &apos;kshenoy/vim-signature&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Other useful utilities</span><br><span class=\"line\">Plug &apos;terryma/vim-multiple-cursors&apos;</span><br><span class=\"line\">Plug &apos;junegunn/goyo.vim&apos; &quot; distraction free writing mode</span><br><span class=\"line\">Plug &apos;tpope/vim-surround&apos; &quot; type ysks&apos; to wrap the word with &apos;&apos; or type cs&apos;` to change &apos;word&apos; to `word`</span><br><span class=\"line\">Plug &apos;godlygeek/tabular&apos; &quot; type ;Tabularize /= to align the =</span><br><span class=\"line\">Plug &apos;gcmt/wildfire.vim&apos; &quot; in Visual mode, type i&apos; to select all text in &apos;&apos;, or type i) i] i&#125; ip</span><br><span class=\"line\">Plug &apos;scrooloose/nerdcommenter&apos; &quot; in &lt;space&gt;cc to comment a line</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Dependencies</span><br><span class=\"line\">Plug &apos;MarcWeber/vim-addon-mw-utils&apos;</span><br><span class=\"line\">Plug &apos;kana/vim-textobj-user&apos;</span><br><span class=\"line\">Plug &apos;fadein/vim-FIGlet&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">call plug#end()</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置透明</span><br><span class=\"line\">let g:SnazzyTransparent = 1</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置主题</span><br><span class=\"line\">&quot; 可选项</span><br><span class=\"line\">&quot; github/snazzy/inkstained</span><br><span class=\"line\">let g:grubvbox_termcolors=&apos;256&apos;</span><br><span class=\"line\">let g:grubvbox_contrast_light = &apos;soft&apos;</span><br><span class=\"line\">color gruvbox</span><br><span class=\"line\">set background =light</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 插件配置</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== NERDTree</span><br><span class=\"line\">map ff :NERDTreeToggle&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== NERDTree-git</span><br><span class=\"line\"></span><br><span class=\"line\">let g:NERDTreeIndicatorMapCustom = &#123;</span><br><span class=\"line\">    \\ &quot;Modified&quot;  : &quot;✹&quot;,</span><br><span class=\"line\">    \\ &quot;Staged&quot;    : &quot;✚&quot;,</span><br><span class=\"line\">    \\ &quot;Untracked&quot; : &quot;✭&quot;,</span><br><span class=\"line\">    \\ &quot;Renamed&quot;   : &quot;➜&quot;,</span><br><span class=\"line\">    \\ &quot;Unmerged&quot;  : &quot;═&quot;,</span><br><span class=\"line\">    \\ &quot;Deleted&quot;   : &quot;✖&quot;,</span><br><span class=\"line\">    \\ &quot;Dirty&quot;     : &quot;✗&quot;,</span><br><span class=\"line\">    \\ &quot;Clean&quot;     : &quot;✔︎&quot;,</span><br><span class=\"line\">    \\ &quot;Unknown&quot;   : &quot;?&quot;</span><br><span class=\"line\">    \\ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== You Complete ME</span><br><span class=\"line\">&quot; 跳转至其他的声明</span><br><span class=\"line\">nnoremap gd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class=\"line\">&quot; 跳转至文档</span><br><span class=\"line\">nnoremap g/ :YcmCompleter GetDoc&lt;CR&gt;</span><br><span class=\"line\">&quot; 获取类型</span><br><span class=\"line\">nnoremap gt :YcmCompleter GetType&lt;CR&gt;</span><br><span class=\"line\">&quot; 获取参考</span><br><span class=\"line\">nnoremap gr :YcmCompleter GoToReferences&lt;CR&gt;</span><br><span class=\"line\">let g:ycm_autoclose_preview_window_after_completion=0</span><br><span class=\"line\">let g:ycm_autoclose_preview_window_after_insertion=1</span><br><span class=\"line\">let g:ycm_use_clangd = 0</span><br><span class=\"line\">let g:ycm_python_interpreter_path = &quot;/bin/python3&quot;</span><br><span class=\"line\">let g:ycm_python_binary_path = &quot;/bin/python3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== ale</span><br><span class=\"line\">let b:ale_linters = [&apos;pylint&apos;]</span><br><span class=\"line\">let b:ale_fixers = [&apos;autopep8&apos;, &apos;yapf&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== TagList</span><br><span class=\"line\">map &lt;silent&gt; T :TagbarOpenAutoClose&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== MarkdownPreview</span><br><span class=\"line\">nmap &lt;LEADER&gt;mp :MarkdownPreview&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== vim-table-mode</span><br><span class=\"line\"></span><br><span class=\"line\">map &lt;LEADER&gt;tm :TableModeToggle&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== vim-indent-guide</span><br><span class=\"line\">let g:indent_guides_guide_size = 0</span><br><span class=\"line\">let g:indent_guides_start_level = 2</span><br><span class=\"line\">let g:indent_guides_enable_on_vim_startup = 1</span><br><span class=\"line\">let g:indent_guides_color_change_percent = 0</span><br><span class=\"line\">autocmd WinEnter * silent! unmap &lt;LEADER&gt;ig</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ====Goyo</span><br><span class=\"line\">map &lt;LEADER&gt;gy :Goyo&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== vim-signiture</span><br><span class=\"line\">let g:SignatureMap = &#123;</span><br><span class=\"line\">        \\ &apos;Leader&apos;             :  &quot;m&quot;,</span><br><span class=\"line\">        \\ &apos;PlaceNextMark&apos;      :  &quot;m,&quot;,</span><br><span class=\"line\">        \\ &apos;ToggleMarkAtLine&apos;   :  &quot;m.&quot;,</span><br><span class=\"line\">        \\ &apos;PurgeMarksAtLine&apos;   :  &quot;dm-&quot;,</span><br><span class=\"line\">        \\ &apos;DeleteMark&apos;         :  &quot;dm&quot;,</span><br><span class=\"line\">        \\ &apos;PurgeMarks&apos;         :  &quot;dm/&quot;,</span><br><span class=\"line\">        \\ &apos;PurgeMarkers&apos;       :  &quot;dm?&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextLineAlpha&apos;  :  &quot;m&lt;LEADER&gt;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevLineAlpha&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextSpotAlpha&apos;  :  &quot;m&lt;LEADER&gt;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevSpotAlpha&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextLineByPos&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevLineByPos&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextSpotByPos&apos;  :  &quot;mn&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevSpotByPos&apos;  :  &quot;mp&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextMarker&apos;     :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevMarker&apos;     :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextMarkerAny&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevMarkerAny&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;ListLocalMarks&apos;     :  &quot;m/&quot;,</span><br><span class=\"line\">        \\ &apos;ListLocalMarkers&apos;   :  &quot;m?&quot;</span><br><span class=\"line\">        \\ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot; === Undotree</span><br><span class=\"line\">let g:undotree_DiffAutoOpen = 0</span><br><span class=\"line\">map &lt;LEADER&gt;ut :UndotreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。<br></p>","more":"<p></p>\n<p>我已经把我的配置文件上传到了Github上了，<a href=\"https://github.com/EvanMeek/Vanilla\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<p>基本都有写中文注释，哪里有不懂的，可以问我，<a href=\"https://evanmeek.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/\">点击查看我的联系方式</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&quot; 设置vi与vim兼容</span><br><span class=\"line\">set nocompatible</span><br><span class=\"line\">&quot; 设置使vim识别不同的文件格式</span><br><span class=\"line\">filetype on</span><br><span class=\"line\">filetype indent on</span><br><span class=\"line\">filetype plugin on</span><br><span class=\"line\">filetype plugin indent on</span><br><span class=\"line\">&quot; 设置使vim能用鼠标操作</span><br><span class=\"line\">set mouse=a</span><br><span class=\"line\">&quot; 设置字符编码</span><br><span class=\"line\">set encoding=utf-8</span><br><span class=\"line\">&quot; 使配色更加兼容你的终端</span><br><span class=\"line\">let &amp;t_ut=&apos;&apos;</span><br><span class=\"line\">&quot; 设置缩进距离</span><br><span class=\"line\">set expandtab</span><br><span class=\"line\">set tabstop=2</span><br><span class=\"line\">set shiftwidth=2</span><br><span class=\"line\">set softtabstop=2</span><br><span class=\"line\">&quot; 设置空格的显示</span><br><span class=\"line\">set list</span><br><span class=\"line\">set listchars=tab:▸\\ ,trail:▫</span><br><span class=\"line\">set tw=0</span><br><span class=\"line\">set indentexpr=</span><br><span class=\"line\">&quot; 退格键到行首后自动跳转到上行行尾</span><br><span class=\"line\">set backspace=indent,eol,start</span><br><span class=\"line\">&quot; 收起代码</span><br><span class=\"line\">set foldmethod=indent</span><br><span class=\"line\">set foldlevel=99</span><br><span class=\"line\">&quot; 设置终端的光标在不同模式下用不同的样式,实测Konsole可用</span><br><span class=\"line\">let &amp;t_SI = &quot;\\&lt;Esc&gt;]50;CursorShape=1\\x7&quot;</span><br><span class=\"line\">let &amp;t_SR = &quot;\\&lt;Esc&gt;]50;CursorShape=2\\x7&quot;</span><br><span class=\"line\">let &amp;t_EI = &quot;\\&lt;Esc&gt;]50;CursorShape=0\\x7&quot;</span><br><span class=\"line\">&quot; 状态栏等于２？？？</span><br><span class=\"line\">set laststatus=2</span><br><span class=\"line\">&quot; vim执行的外部命令会在当前目录下执行</span><br><span class=\"line\">set autochdir</span><br><span class=\"line\">&quot; 关闭文件又打开光标会自动回到关闭前的位置</span><br><span class=\"line\">au BufReadPost * if line(&quot;&apos;\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&apos;\\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&apos;\\&quot;&quot; | endif</span><br><span class=\"line\">&quot; 设置leader键为空格</span><br><span class=\"line\">let mapleader=&quot; &quot;</span><br><span class=\"line\">&quot; 代码高亮</span><br><span class=\"line\">syntax on</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置行号</span><br><span class=\"line\">set number</span><br><span class=\"line\">&quot; 设置更好的行号</span><br><span class=\"line\">set relativenumber</span><br><span class=\"line\">&quot; 设置光标线</span><br><span class=\"line\">set cursorline</span><br><span class=\"line\">&quot; 自动换行</span><br><span class=\"line\">set wrap</span><br><span class=\"line\">&quot; 显示命令</span><br><span class=\"line\">set showcmd</span><br><span class=\"line\">&quot; tab多选项菜单</span><br><span class=\"line\">set wildmenu</span><br><span class=\"line\">&quot; 设置搜索关键词高亮</span><br><span class=\"line\">set hlsearch</span><br><span class=\"line\">exec &quot;nohlsearch&quot;</span><br><span class=\"line\">&quot; 设置搜索输入时高亮</span><br><span class=\"line\">set incsearch</span><br><span class=\"line\">&quot; 搜索时忽略大小写</span><br><span class=\"line\">set ignorecase </span><br><span class=\"line\">&quot; 只能搜索忽略大小写</span><br><span class=\"line\">set smartcase</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 搜索跳转结果改为=/-并且使搜索结果在屏幕中间</span><br><span class=\"line\">noremap = nzz</span><br><span class=\"line\">noremap - Nzz</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 大写JKHL重复五次执行</span><br><span class=\"line\">noremap J 5j</span><br><span class=\"line\">noremap K 5k</span><br><span class=\"line\">noremap H 5h</span><br><span class=\"line\">noremap L 5l</span><br><span class=\"line\">&quot; 设置取消高亮</span><br><span class=\"line\">noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置光标回到行首</span><br><span class=\"line\">noremap &lt;LEADER&gt;a 0</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置光标回到行尾</span><br><span class=\"line\">noremap &lt;LEADER&gt;e $</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 取消s删除字符的功能</span><br><span class=\"line\">map s &lt;nop&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 快速保存</span><br><span class=\"line\">map S :w&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 按大写Q直接退出</span><br><span class=\"line\">map Q :q&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; R快速source vimrc</span><br><span class=\"line\">map R :source ~/.vim/vimrc&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;分屏操作</span><br><span class=\"line\">&quot;向右分屏</span><br><span class=\"line\">map &lt;LEADER&gt;l :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class=\"line\">&quot;向左分屏</span><br><span class=\"line\">map &lt;LEADER&gt;h :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class=\"line\">&quot;向上分屏</span><br><span class=\"line\">map &lt;LEADER&gt;k :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class=\"line\">&quot;向下分屏</span><br><span class=\"line\">map &lt;LEADER&gt;j :set splitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class=\"line\">&quot;光标移动至左分屏</span><br><span class=\"line\">map sh &lt;C-w&gt;h</span><br><span class=\"line\">&quot;光标移动至右分屏</span><br><span class=\"line\">map sl &lt;C-w&gt;l</span><br><span class=\"line\">&quot;光标移动至下分屏</span><br><span class=\"line\">map sj &lt;C-w&gt;j</span><br><span class=\"line\">&quot;光标移动至上分屏</span><br><span class=\"line\">map sk &lt;C-w&gt;k</span><br><span class=\"line\">&quot;增加纵向分屏大小</span><br><span class=\"line\">map &lt;up&gt; :res +5&lt;CR&gt;</span><br><span class=\"line\">&quot;减少纵向分屏大小</span><br><span class=\"line\">map &lt;down&gt; :res -5&lt;CR&gt;</span><br><span class=\"line\">&quot;减少横向分屏大小</span><br><span class=\"line\">map &lt;left&gt; :vertical resize-5&lt;CR&gt;</span><br><span class=\"line\">&quot;增加横横分屏大小</span><br><span class=\"line\">map &lt;right&gt; :vertical resize+5&lt;CR&gt;</span><br><span class=\"line\">&quot;将分屏设置为横向分屏</span><br><span class=\"line\">map &lt;LEADER&gt;H &lt;C-w&gt;t&lt;C-w&gt;H</span><br><span class=\"line\">&quot;将分屏设置为纵向分屏</span><br><span class=\"line\">map &lt;LEADER&gt;K &lt;C-w&gt;t&lt;C-w&gt;K</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;标签</span><br><span class=\"line\">&quot;打开新标签</span><br><span class=\"line\">map tn :tabe&lt;CR&gt;</span><br><span class=\"line\">&quot; 跳转至上一个标签</span><br><span class=\"line\">map th :-tabnext&lt;CR&gt;</span><br><span class=\"line\">&quot; 跳转至下一个标签</span><br><span class=\"line\">map tl :+tabnext&lt;CR&gt;</span><br><span class=\"line\">  &quot; 关闭当前标签</span><br><span class=\"line\">map td :tabclose&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;插件安装vim-plug</span><br><span class=\"line\">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class=\"line\">Plug &apos;endel/vim-github-colorscheme&apos;</span><br><span class=\"line\">Plug &apos;morhetz/gruvbox&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Plug &apos;vim-airline/vim-airline&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; File navigation</span><br><span class=\"line\">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;: &apos;NERDTreeToggle&apos; &#125;</span><br><span class=\"line\">Plug &apos;Xuyuanp/nerdtree-git-plugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Taglist</span><br><span class=\"line\">Plug &apos;majutsushi/tagbar&apos;, &#123; &apos;on&apos;: &apos;TagbarOpenAutoClose&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Error checking</span><br><span class=\"line\">Plug &apos;w0rp/ale&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Auto Complete</span><br><span class=\"line\">Plug &apos;Valloric/YouCompleteMe&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Undo Tree</span><br><span class=\"line\">Plug &apos;mbbill/undotree/&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Other visual enhancement</span><br><span class=\"line\">Plug &apos;nathanaelkane/vim-indent-guides&apos;</span><br><span class=\"line\">Plug &apos;itchyny/vim-cursorword&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Git</span><br><span class=\"line\">Plug &apos;rhysd/conflict-marker.vim&apos;</span><br><span class=\"line\">Plug &apos;tpope/vim-fugitive&apos;</span><br><span class=\"line\">Plug &apos;mhinz/vim-signify&apos;</span><br><span class=\"line\">Plug &apos;gisphm/vim-gitignore&apos;, &#123; &apos;for&apos;: [&apos;gitignore&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; HTML, CSS, JavaScript, PHP, JSON, etc.</span><br><span class=\"line\">Plug &apos;elzr/vim-json&apos;</span><br><span class=\"line\">Plug &apos;hail2u/vim-css3-syntax&apos;</span><br><span class=\"line\">Plug &apos;spf13/PIV&apos;, &#123; &apos;for&apos; :[&apos;php&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class=\"line\">Plug &apos;gko/vim-coloresque&apos;, &#123; &apos;for&apos;: [&apos;vim-plug&apos;, &apos;php&apos;, &apos;html&apos;, &apos;javascript&apos;, &apos;css&apos;, &apos;less&apos;] &#125;</span><br><span class=\"line\">Plug &apos;pangloss/vim-javascript&apos;, &#123; &apos;for&apos; :[&apos;javascript&apos;, &apos;vim-plug&apos;] &#125;</span><br><span class=\"line\">Plug &apos;mattn/emmet-vim&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Python</span><br><span class=\"line\">Plug &apos;vim-scripts/indentpython.vim&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Markdown</span><br><span class=\"line\">Plug &apos;iamcco/markdown-preview.nvim&apos;, &#123; &apos;do&apos;: &apos;cd app &amp; yarn install&apos;  &#125;</span><br><span class=\"line\">Plug &apos;dhruvasagar/vim-table-mode&apos;, &#123; &apos;on&apos;: &apos;TableModeToggle&apos; &#125;</span><br><span class=\"line\">Plug &apos;vimwiki/vimwiki&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Bookmarks</span><br><span class=\"line\">Plug &apos;kshenoy/vim-signature&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Other useful utilities</span><br><span class=\"line\">Plug &apos;terryma/vim-multiple-cursors&apos;</span><br><span class=\"line\">Plug &apos;junegunn/goyo.vim&apos; &quot; distraction free writing mode</span><br><span class=\"line\">Plug &apos;tpope/vim-surround&apos; &quot; type ysks&apos; to wrap the word with &apos;&apos; or type cs&apos;` to change &apos;word&apos; to `word`</span><br><span class=\"line\">Plug &apos;godlygeek/tabular&apos; &quot; type ;Tabularize /= to align the =</span><br><span class=\"line\">Plug &apos;gcmt/wildfire.vim&apos; &quot; in Visual mode, type i&apos; to select all text in &apos;&apos;, or type i) i] i&#125; ip</span><br><span class=\"line\">Plug &apos;scrooloose/nerdcommenter&apos; &quot; in &lt;space&gt;cc to comment a line</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Dependencies</span><br><span class=\"line\">Plug &apos;MarcWeber/vim-addon-mw-utils&apos;</span><br><span class=\"line\">Plug &apos;kana/vim-textobj-user&apos;</span><br><span class=\"line\">Plug &apos;fadein/vim-FIGlet&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">call plug#end()</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置透明</span><br><span class=\"line\">let g:SnazzyTransparent = 1</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 设置主题</span><br><span class=\"line\">&quot; 可选项</span><br><span class=\"line\">&quot; github/snazzy/inkstained</span><br><span class=\"line\">let g:grubvbox_termcolors=&apos;256&apos;</span><br><span class=\"line\">let g:grubvbox_contrast_light = &apos;soft&apos;</span><br><span class=\"line\">color gruvbox</span><br><span class=\"line\">set background =light</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 插件配置</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== NERDTree</span><br><span class=\"line\">map ff :NERDTreeToggle&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== NERDTree-git</span><br><span class=\"line\"></span><br><span class=\"line\">let g:NERDTreeIndicatorMapCustom = &#123;</span><br><span class=\"line\">    \\ &quot;Modified&quot;  : &quot;✹&quot;,</span><br><span class=\"line\">    \\ &quot;Staged&quot;    : &quot;✚&quot;,</span><br><span class=\"line\">    \\ &quot;Untracked&quot; : &quot;✭&quot;,</span><br><span class=\"line\">    \\ &quot;Renamed&quot;   : &quot;➜&quot;,</span><br><span class=\"line\">    \\ &quot;Unmerged&quot;  : &quot;═&quot;,</span><br><span class=\"line\">    \\ &quot;Deleted&quot;   : &quot;✖&quot;,</span><br><span class=\"line\">    \\ &quot;Dirty&quot;     : &quot;✗&quot;,</span><br><span class=\"line\">    \\ &quot;Clean&quot;     : &quot;✔︎&quot;,</span><br><span class=\"line\">    \\ &quot;Unknown&quot;   : &quot;?&quot;</span><br><span class=\"line\">    \\ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== You Complete ME</span><br><span class=\"line\">&quot; 跳转至其他的声明</span><br><span class=\"line\">nnoremap gd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class=\"line\">&quot; 跳转至文档</span><br><span class=\"line\">nnoremap g/ :YcmCompleter GetDoc&lt;CR&gt;</span><br><span class=\"line\">&quot; 获取类型</span><br><span class=\"line\">nnoremap gt :YcmCompleter GetType&lt;CR&gt;</span><br><span class=\"line\">&quot; 获取参考</span><br><span class=\"line\">nnoremap gr :YcmCompleter GoToReferences&lt;CR&gt;</span><br><span class=\"line\">let g:ycm_autoclose_preview_window_after_completion=0</span><br><span class=\"line\">let g:ycm_autoclose_preview_window_after_insertion=1</span><br><span class=\"line\">let g:ycm_use_clangd = 0</span><br><span class=\"line\">let g:ycm_python_interpreter_path = &quot;/bin/python3&quot;</span><br><span class=\"line\">let g:ycm_python_binary_path = &quot;/bin/python3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== ale</span><br><span class=\"line\">let b:ale_linters = [&apos;pylint&apos;]</span><br><span class=\"line\">let b:ale_fixers = [&apos;autopep8&apos;, &apos;yapf&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== TagList</span><br><span class=\"line\">map &lt;silent&gt; T :TagbarOpenAutoClose&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== MarkdownPreview</span><br><span class=\"line\">nmap &lt;LEADER&gt;mp :MarkdownPreview&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== vim-table-mode</span><br><span class=\"line\"></span><br><span class=\"line\">map &lt;LEADER&gt;tm :TableModeToggle&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== vim-indent-guide</span><br><span class=\"line\">let g:indent_guides_guide_size = 0</span><br><span class=\"line\">let g:indent_guides_start_level = 2</span><br><span class=\"line\">let g:indent_guides_enable_on_vim_startup = 1</span><br><span class=\"line\">let g:indent_guides_color_change_percent = 0</span><br><span class=\"line\">autocmd WinEnter * silent! unmap &lt;LEADER&gt;ig</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ====Goyo</span><br><span class=\"line\">map &lt;LEADER&gt;gy :Goyo&lt;CR&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; ==== vim-signiture</span><br><span class=\"line\">let g:SignatureMap = &#123;</span><br><span class=\"line\">        \\ &apos;Leader&apos;             :  &quot;m&quot;,</span><br><span class=\"line\">        \\ &apos;PlaceNextMark&apos;      :  &quot;m,&quot;,</span><br><span class=\"line\">        \\ &apos;ToggleMarkAtLine&apos;   :  &quot;m.&quot;,</span><br><span class=\"line\">        \\ &apos;PurgeMarksAtLine&apos;   :  &quot;dm-&quot;,</span><br><span class=\"line\">        \\ &apos;DeleteMark&apos;         :  &quot;dm&quot;,</span><br><span class=\"line\">        \\ &apos;PurgeMarks&apos;         :  &quot;dm/&quot;,</span><br><span class=\"line\">        \\ &apos;PurgeMarkers&apos;       :  &quot;dm?&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextLineAlpha&apos;  :  &quot;m&lt;LEADER&gt;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevLineAlpha&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextSpotAlpha&apos;  :  &quot;m&lt;LEADER&gt;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevSpotAlpha&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextLineByPos&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevLineByPos&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextSpotByPos&apos;  :  &quot;mn&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevSpotByPos&apos;  :  &quot;mp&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextMarker&apos;     :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevMarker&apos;     :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoNextMarkerAny&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;GotoPrevMarkerAny&apos;  :  &quot;&quot;,</span><br><span class=\"line\">        \\ &apos;ListLocalMarks&apos;     :  &quot;m/&quot;,</span><br><span class=\"line\">        \\ &apos;ListLocalMarkers&apos;   :  &quot;m?&quot;</span><br><span class=\"line\">        \\ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot; === Undotree</span><br><span class=\"line\">let g:undotree_DiffAutoOpen = 0</span><br><span class=\"line\">map &lt;LEADER&gt;ut :UndotreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>"},{"title":"最快-GPU加速-Alacritty终端","copyright":true,"date":"2019-07-02T23:06:11.000Z","_content":"\n<!--more-->\n\n![ponysay](最快-GPU加速-Alacritty终端/ponysay.png)\n\n# 0x0 Alacritty是什么?\n\n`Alacritty`是一个终端仿真器。\n\n在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。\n\n# 0x1 为什么选择Alacritty?\n\n`Alacritty`是目前性能最强的终端之一.\n\n它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。\n\n`Alacritty`的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过`Alacritty`仍然提供了很多配置终端的方面。\n\n# 0x2 Alacritty的配置\n\n`Alacritty`的配置文件在:`~/.config/alacritty/alacritty.yml`\n\n## 0 字体\n\n打开`alacritty.yml`文件，找到`Font configuration`这行注释，即可修改。\n\n例如:\n\n~~~yml\n# Font configuration (changes require restart)\nfont:\n  normal:\n    family: Droid Sans Mono\n    style: Regular\n\n  bold:\n    family: Droid Sans Mono\n\n  italic:\n    family: Droid Sans Mono\n~~~\n\n## 1 配色方案\n\n`Alacritty`官方提供了超多种的配置方案，[点击我获取](https://github.com/jwilm/alacritty/wiki/Color-schemes)\n\n我们只需要找一个自己喜欢的配色方案将配色代码复制\n\n然后粘贴到`alacritty.yml`配置文件内即可.\n\n例如:\n~~~\n# Colors (Solarized Dark)\ncolors:\n  # Default colors\n  primary:\n    background: '0x002b36' # base03\n    foreground: '0x839496' # base0\n\n  # Normal colors\n  normal:\n    black:   '0x073642' # base02\n    red:     '0xdc322f' # red\n    green:   '0x859900' # green\n    yellow:  '0xb58900' # yellow\n    blue:    '0x268bd2' # blue\n    magenta: '0xd33682' # magenta\n    cyan:    '0x2aa198' # cyan\n    white:   '0xeee8d5' # base2\n\n  # Bright colors\n  bright:\n    black:   '0x002b36' # base03\n    red:     '0xcb4b16' # orange\n    green:   '0x586e75' # base01\n    yellow:  '0x657b83' # base00\n    blue:    '0x839496' # base0\n    magenta: '0x6c71c4' # violet\n    cyan:    '0x93a1a1' # base1\n    white:   '0xfdf6e3' # base3\n~~~\n\n## 2 快捷键\n\n默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在`alacritty.yml`内的`Key bindings`项下进行修改\n\n并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按`Paste`键和`Copy`键位改为`Ctrl+C`和`Ctrl+V`。\n\n例子：\n\n~~~\n  - { key: V,        mods: Control, action: Paste                            }\n  - { key: C,        mods: Control, action: Copy                             }\n~~~\n\n__注意不要漏写`,`号,不然可能会出现如下情况__\n\n![error](最快-GPU加速-Alacritty终端/error.png)\n\n# 0x3 我的Alacritty配置\n\n已经上传至Github，[点击我获取](https://github.com/EvanMeek/Vanilla/tree/master/alacritty)\n\n# 0x4 其他\n\n[Alacritty-Github页面](https://github.com/jwilm/alacritty)\n\nArch系一键安装:\n\n~~~\n> pacman -S alacritty\n~~~\n","source":"_posts/最快-GPU加速-Alacritty终端.md","raw":"---\ntitle: 最快-GPU加速-Alacritty终端\ncopyright: true\ndate: 2019-07-03 07:06:11\ncategories: 折腾日记\ntags:\n  - Linux\n  - 软件折腾\n---\n\n<!--more-->\n\n![ponysay](最快-GPU加速-Alacritty终端/ponysay.png)\n\n# 0x0 Alacritty是什么?\n\n`Alacritty`是一个终端仿真器。\n\n在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。\n\n# 0x1 为什么选择Alacritty?\n\n`Alacritty`是目前性能最强的终端之一.\n\n它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。\n\n`Alacritty`的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过`Alacritty`仍然提供了很多配置终端的方面。\n\n# 0x2 Alacritty的配置\n\n`Alacritty`的配置文件在:`~/.config/alacritty/alacritty.yml`\n\n## 0 字体\n\n打开`alacritty.yml`文件，找到`Font configuration`这行注释，即可修改。\n\n例如:\n\n~~~yml\n# Font configuration (changes require restart)\nfont:\n  normal:\n    family: Droid Sans Mono\n    style: Regular\n\n  bold:\n    family: Droid Sans Mono\n\n  italic:\n    family: Droid Sans Mono\n~~~\n\n## 1 配色方案\n\n`Alacritty`官方提供了超多种的配置方案，[点击我获取](https://github.com/jwilm/alacritty/wiki/Color-schemes)\n\n我们只需要找一个自己喜欢的配色方案将配色代码复制\n\n然后粘贴到`alacritty.yml`配置文件内即可.\n\n例如:\n~~~\n# Colors (Solarized Dark)\ncolors:\n  # Default colors\n  primary:\n    background: '0x002b36' # base03\n    foreground: '0x839496' # base0\n\n  # Normal colors\n  normal:\n    black:   '0x073642' # base02\n    red:     '0xdc322f' # red\n    green:   '0x859900' # green\n    yellow:  '0xb58900' # yellow\n    blue:    '0x268bd2' # blue\n    magenta: '0xd33682' # magenta\n    cyan:    '0x2aa198' # cyan\n    white:   '0xeee8d5' # base2\n\n  # Bright colors\n  bright:\n    black:   '0x002b36' # base03\n    red:     '0xcb4b16' # orange\n    green:   '0x586e75' # base01\n    yellow:  '0x657b83' # base00\n    blue:    '0x839496' # base0\n    magenta: '0x6c71c4' # violet\n    cyan:    '0x93a1a1' # base1\n    white:   '0xfdf6e3' # base3\n~~~\n\n## 2 快捷键\n\n默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在`alacritty.yml`内的`Key bindings`项下进行修改\n\n并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按`Paste`键和`Copy`键位改为`Ctrl+C`和`Ctrl+V`。\n\n例子：\n\n~~~\n  - { key: V,        mods: Control, action: Paste                            }\n  - { key: C,        mods: Control, action: Copy                             }\n~~~\n\n__注意不要漏写`,`号,不然可能会出现如下情况__\n\n![error](最快-GPU加速-Alacritty终端/error.png)\n\n# 0x3 我的Alacritty配置\n\n已经上传至Github，[点击我获取](https://github.com/EvanMeek/Vanilla/tree/master/alacritty)\n\n# 0x4 其他\n\n[Alacritty-Github页面](https://github.com/jwilm/alacritty)\n\nArch系一键安装:\n\n~~~\n> pacman -S alacritty\n~~~\n","slug":"最快-GPU加速-Alacritty终端","published":1,"updated":"2020-01-19T03:49:51.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozode0068omooso0wmqzt","content":"<a id=\"more\"></a>\n<p><img src=\"/2019/07/03/最快-GPU加速-Alacritty终端/ponysay.png\" alt=\"ponysay\"></p>\n<h1 id=\"0x0-Alacritty是什么\"><a href=\"#0x0-Alacritty是什么\" class=\"headerlink\" title=\"0x0 Alacritty是什么?\"></a>0x0 Alacritty是什么?</h1><p><code>Alacritty</code>是一个终端仿真器。</p>\n<p>在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。</p>\n<h1 id=\"0x1-为什么选择Alacritty\"><a href=\"#0x1-为什么选择Alacritty\" class=\"headerlink\" title=\"0x1 为什么选择Alacritty?\"></a>0x1 为什么选择Alacritty?</h1><p><code>Alacritty</code>是目前性能最强的终端之一.</p>\n<p>它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。</p>\n<p><code>Alacritty</code>的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过<code>Alacritty</code>仍然提供了很多配置终端的方面。</p>\n<h1 id=\"0x2-Alacritty的配置\"><a href=\"#0x2-Alacritty的配置\" class=\"headerlink\" title=\"0x2 Alacritty的配置\"></a>0x2 Alacritty的配置</h1><p><code>Alacritty</code>的配置文件在:<code>~/.config/alacritty/alacritty.yml</code></p>\n<h2 id=\"0-字体\"><a href=\"#0-字体\" class=\"headerlink\" title=\"0 字体\"></a>0 字体</h2><p>打开<code>alacritty.yml</code>文件，找到<code>Font configuration</code>这行注释，即可修改。</p>\n<p>例如:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Font configuration (changes require restart)</span></span><br><span class=\"line\"><span class=\"attr\">font:</span></span><br><span class=\"line\"><span class=\"attr\">  normal:</span></span><br><span class=\"line\"><span class=\"attr\">    family:</span> <span class=\"string\">Droid</span> <span class=\"string\">Sans</span> <span class=\"string\">Mono</span></span><br><span class=\"line\"><span class=\"attr\">    style:</span> <span class=\"string\">Regular</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  bold:</span></span><br><span class=\"line\"><span class=\"attr\">    family:</span> <span class=\"string\">Droid</span> <span class=\"string\">Sans</span> <span class=\"string\">Mono</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  italic:</span></span><br><span class=\"line\"><span class=\"attr\">    family:</span> <span class=\"string\">Droid</span> <span class=\"string\">Sans</span> <span class=\"string\">Mono</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"1-配色方案\"><a href=\"#1-配色方案\" class=\"headerlink\" title=\"1 配色方案\"></a>1 配色方案</h2><p><code>Alacritty</code>官方提供了超多种的配置方案，<a href=\"https://github.com/jwilm/alacritty/wiki/Color-schemes\" target=\"_blank\" rel=\"noopener\">点击我获取</a></p>\n<p>我们只需要找一个自己喜欢的配色方案将配色代码复制</p>\n<p>然后粘贴到<code>alacritty.yml</code>配置文件内即可.</p>\n<p>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Colors (Solarized Dark)</span><br><span class=\"line\">colors:</span><br><span class=\"line\">  # Default colors</span><br><span class=\"line\">  primary:</span><br><span class=\"line\">    background: &apos;0x002b36&apos; # base03</span><br><span class=\"line\">    foreground: &apos;0x839496&apos; # base0</span><br><span class=\"line\"></span><br><span class=\"line\">  # Normal colors</span><br><span class=\"line\">  normal:</span><br><span class=\"line\">    black:   &apos;0x073642&apos; # base02</span><br><span class=\"line\">    red:     &apos;0xdc322f&apos; # red</span><br><span class=\"line\">    green:   &apos;0x859900&apos; # green</span><br><span class=\"line\">    yellow:  &apos;0xb58900&apos; # yellow</span><br><span class=\"line\">    blue:    &apos;0x268bd2&apos; # blue</span><br><span class=\"line\">    magenta: &apos;0xd33682&apos; # magenta</span><br><span class=\"line\">    cyan:    &apos;0x2aa198&apos; # cyan</span><br><span class=\"line\">    white:   &apos;0xeee8d5&apos; # base2</span><br><span class=\"line\"></span><br><span class=\"line\">  # Bright colors</span><br><span class=\"line\">  bright:</span><br><span class=\"line\">    black:   &apos;0x002b36&apos; # base03</span><br><span class=\"line\">    red:     &apos;0xcb4b16&apos; # orange</span><br><span class=\"line\">    green:   &apos;0x586e75&apos; # base01</span><br><span class=\"line\">    yellow:  &apos;0x657b83&apos; # base00</span><br><span class=\"line\">    blue:    &apos;0x839496&apos; # base0</span><br><span class=\"line\">    magenta: &apos;0x6c71c4&apos; # violet</span><br><span class=\"line\">    cyan:    &apos;0x93a1a1&apos; # base1</span><br><span class=\"line\">    white:   &apos;0xfdf6e3&apos; # base3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-快捷键\"><a href=\"#2-快捷键\" class=\"headerlink\" title=\"2 快捷键\"></a>2 快捷键</h2><p>默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在<code>alacritty.yml</code>内的<code>Key bindings</code>项下进行修改</p>\n<p>并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按<code>Paste</code>键和<code>Copy</code>键位改为<code>Ctrl+C</code>和<code>Ctrl+V</code>。</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- &#123; key: V,        mods: Control, action: Paste                            &#125;</span><br><span class=\"line\">- &#123; key: C,        mods: Control, action: Copy                             &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意不要漏写<code>,</code>号,不然可能会出现如下情况</strong></p>\n<p><img src=\"/2019/07/03/最快-GPU加速-Alacritty终端/error.png\" alt=\"error\"></p>\n<h1 id=\"0x3-我的Alacritty配置\"><a href=\"#0x3-我的Alacritty配置\" class=\"headerlink\" title=\"0x3 我的Alacritty配置\"></a>0x3 我的Alacritty配置</h1><p>已经上传至Github，<a href=\"https://github.com/EvanMeek/Vanilla/tree/master/alacritty\" target=\"_blank\" rel=\"noopener\">点击我获取</a></p>\n<h1 id=\"0x4-其他\"><a href=\"#0x4-其他\" class=\"headerlink\" title=\"0x4 其他\"></a>0x4 其他</h1><p><a href=\"https://github.com/jwilm/alacritty\" target=\"_blank\" rel=\"noopener\">Alacritty-Github页面</a></p>\n<p>Arch系一键安装:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; pacman -S alacritty</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/07/03/最快-GPU加速-Alacritty终端/ponysay.png\" alt=\"ponysay\"></p>\n<h1 id=\"0x0-Alacritty是什么\"><a href=\"#0x0-Alacritty是什么\" class=\"headerlink\" title=\"0x0 Alacritty是什么?\"></a>0x0 Alacritty是什么?</h1><p><code>Alacritty</code>是一个终端仿真器。</p>\n<p>在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。</p>\n<h1 id=\"0x1-为什么选择Alacritty\"><a href=\"#0x1-为什么选择Alacritty\" class=\"headerlink\" title=\"0x1 为什么选择Alacritty?\"></a>0x1 为什么选择Alacritty?</h1><p><code>Alacritty</code>是目前性能最强的终端之一.</p>\n<p>它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。</p>\n<p><code>Alacritty</code>的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过<code>Alacritty</code>仍然提供了很多配置终端的方面。</p>\n<h1 id=\"0x2-Alacritty的配置\"><a href=\"#0x2-Alacritty的配置\" class=\"headerlink\" title=\"0x2 Alacritty的配置\"></a>0x2 Alacritty的配置</h1><p><code>Alacritty</code>的配置文件在:<code>~/.config/alacritty/alacritty.yml</code></p>\n<h2 id=\"0-字体\"><a href=\"#0-字体\" class=\"headerlink\" title=\"0 字体\"></a>0 字体</h2><p>打开<code>alacritty.yml</code>文件，找到<code>Font configuration</code>这行注释，即可修改。</p>\n<p>例如:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Font configuration (changes require restart)</span></span><br><span class=\"line\"><span class=\"attr\">font:</span></span><br><span class=\"line\"><span class=\"attr\">  normal:</span></span><br><span class=\"line\"><span class=\"attr\">    family:</span> <span class=\"string\">Droid</span> <span class=\"string\">Sans</span> <span class=\"string\">Mono</span></span><br><span class=\"line\"><span class=\"attr\">    style:</span> <span class=\"string\">Regular</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  bold:</span></span><br><span class=\"line\"><span class=\"attr\">    family:</span> <span class=\"string\">Droid</span> <span class=\"string\">Sans</span> <span class=\"string\">Mono</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  italic:</span></span><br><span class=\"line\"><span class=\"attr\">    family:</span> <span class=\"string\">Droid</span> <span class=\"string\">Sans</span> <span class=\"string\">Mono</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"1-配色方案\"><a href=\"#1-配色方案\" class=\"headerlink\" title=\"1 配色方案\"></a>1 配色方案</h2><p><code>Alacritty</code>官方提供了超多种的配置方案，<a href=\"https://github.com/jwilm/alacritty/wiki/Color-schemes\" target=\"_blank\" rel=\"noopener\">点击我获取</a></p>\n<p>我们只需要找一个自己喜欢的配色方案将配色代码复制</p>\n<p>然后粘贴到<code>alacritty.yml</code>配置文件内即可.</p>\n<p>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Colors (Solarized Dark)</span><br><span class=\"line\">colors:</span><br><span class=\"line\">  # Default colors</span><br><span class=\"line\">  primary:</span><br><span class=\"line\">    background: &apos;0x002b36&apos; # base03</span><br><span class=\"line\">    foreground: &apos;0x839496&apos; # base0</span><br><span class=\"line\"></span><br><span class=\"line\">  # Normal colors</span><br><span class=\"line\">  normal:</span><br><span class=\"line\">    black:   &apos;0x073642&apos; # base02</span><br><span class=\"line\">    red:     &apos;0xdc322f&apos; # red</span><br><span class=\"line\">    green:   &apos;0x859900&apos; # green</span><br><span class=\"line\">    yellow:  &apos;0xb58900&apos; # yellow</span><br><span class=\"line\">    blue:    &apos;0x268bd2&apos; # blue</span><br><span class=\"line\">    magenta: &apos;0xd33682&apos; # magenta</span><br><span class=\"line\">    cyan:    &apos;0x2aa198&apos; # cyan</span><br><span class=\"line\">    white:   &apos;0xeee8d5&apos; # base2</span><br><span class=\"line\"></span><br><span class=\"line\">  # Bright colors</span><br><span class=\"line\">  bright:</span><br><span class=\"line\">    black:   &apos;0x002b36&apos; # base03</span><br><span class=\"line\">    red:     &apos;0xcb4b16&apos; # orange</span><br><span class=\"line\">    green:   &apos;0x586e75&apos; # base01</span><br><span class=\"line\">    yellow:  &apos;0x657b83&apos; # base00</span><br><span class=\"line\">    blue:    &apos;0x839496&apos; # base0</span><br><span class=\"line\">    magenta: &apos;0x6c71c4&apos; # violet</span><br><span class=\"line\">    cyan:    &apos;0x93a1a1&apos; # base1</span><br><span class=\"line\">    white:   &apos;0xfdf6e3&apos; # base3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-快捷键\"><a href=\"#2-快捷键\" class=\"headerlink\" title=\"2 快捷键\"></a>2 快捷键</h2><p>默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在<code>alacritty.yml</code>内的<code>Key bindings</code>项下进行修改</p>\n<p>并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按<code>Paste</code>键和<code>Copy</code>键位改为<code>Ctrl+C</code>和<code>Ctrl+V</code>。</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- &#123; key: V,        mods: Control, action: Paste                            &#125;</span><br><span class=\"line\">- &#123; key: C,        mods: Control, action: Copy                             &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意不要漏写<code>,</code>号,不然可能会出现如下情况</strong></p>\n<p><img src=\"/2019/07/03/最快-GPU加速-Alacritty终端/error.png\" alt=\"error\"></p>\n<h1 id=\"0x3-我的Alacritty配置\"><a href=\"#0x3-我的Alacritty配置\" class=\"headerlink\" title=\"0x3 我的Alacritty配置\"></a>0x3 我的Alacritty配置</h1><p>已经上传至Github，<a href=\"https://github.com/EvanMeek/Vanilla/tree/master/alacritty\" target=\"_blank\" rel=\"noopener\">点击我获取</a></p>\n<h1 id=\"0x4-其他\"><a href=\"#0x4-其他\" class=\"headerlink\" title=\"0x4 其他\"></a>0x4 其他</h1><p><a href=\"https://github.com/jwilm/alacritty\" target=\"_blank\" rel=\"noopener\">Alacritty-Github页面</a></p>\n<p>Arch系一键安装:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; pacman -S alacritty</span><br></pre></td></tr></table></figure>"},{"title":"深拷贝和浅拷贝的区别","copyright":true,"date":"2019-05-14T14:55:24.000Z","_content":"\n虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。\n\n<!--more-->\n\n# 浅拷贝\n\n我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。\n\n**那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。**\n\n那什么是拷贝构造函数呢?\n\n**拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象**\n\n下面看个例子:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        age = f_age;\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" << h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" << h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，**这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。**\n\n浅拷贝的具体代码实现是怎样的呢？请看下面的代码:\n\n~~~C++\n    //默认的拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        age = h.age;\n    }\n~~~\n\n可与看出，它只是简单的将对象属性的值，进行拷贝。\n\n大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？\n\n答案是否定的，下面看下深拷贝。\n\n\n# 深拷贝\n\n什么是深拷贝?\n\n**深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.**\n\n下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nfree(): double free detected in tcache 2\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\n\nProcess finished with exit code 134 (interrupted by signal 6: SIGABRT)\n~~~\n\n通过输出结果，我们发现，程序发生了错误。\n\n因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。\n\n上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。\n\n由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。\n\n然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。\n\n既然问题找到了，我们就需要进行修改，将这个问题解决。\n\n下面通过深拷贝的方式，让这个bug被修复:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        //新开辟内存空间到堆区，存放age所指向的数据。\n        age = new int(*h.age);\n        cout<<\"Human拷贝构造函数调用.\"<<endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\nHuman拷贝构造函数调用.\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n程序没有报错，说明我们的bug成功解决了。\n\n上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。\n\n深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。\n\n为什么能避免？\n\n原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。\n\n# 两者该如何选择?\n\n**说得绝对点：**\n\n若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。\n\n这时需要使用深拷贝。\n\n**说的不那么绝对:**\n\n若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。\n","source":"_posts/深拷贝和浅拷贝的区别.md","raw":"---\ntitle: 深拷贝和浅拷贝的区别\ncopyright: true\ndate: 2019-05-14 22:55:24\ncategories: 学习笔记\ntags:\n - C++\n - 经典案例\n---\n\n虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。\n\n<!--more-->\n\n# 浅拷贝\n\n我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。\n\n**那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。**\n\n那什么是拷贝构造函数呢?\n\n**拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象**\n\n下面看个例子:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        age = f_age;\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" << h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" << h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，**这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。**\n\n浅拷贝的具体代码实现是怎样的呢？请看下面的代码:\n\n~~~C++\n    //默认的拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        age = h.age;\n    }\n~~~\n\n可与看出，它只是简单的将对象属性的值，进行拷贝。\n\n大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？\n\n答案是否定的，下面看下深拷贝。\n\n\n# 深拷贝\n\n什么是深拷贝?\n\n**深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.**\n\n下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nfree(): double free detected in tcache 2\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\n\nProcess finished with exit code 134 (interrupted by signal 6: SIGABRT)\n~~~\n\n通过输出结果，我们发现，程序发生了错误。\n\n因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。\n\n上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。\n\n由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。\n\n然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。\n\n既然问题找到了，我们就需要进行修改，将这个问题解决。\n\n下面通过深拷贝的方式，让这个bug被修复:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        //新开辟内存空间到堆区，存放age所指向的数据。\n        age = new int(*h.age);\n        cout<<\"Human拷贝构造函数调用.\"<<endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\nHuman拷贝构造函数调用.\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n程序没有报错，说明我们的bug成功解决了。\n\n上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。\n\n深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。\n\n为什么能避免？\n\n原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。\n\n# 两者该如何选择?\n\n**说得绝对点：**\n\n若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。\n\n这时需要使用深拷贝。\n\n**说的不那么绝对:**\n\n若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。\n","slug":"深拷贝和浅拷贝的区别","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodf006aomooa0pax6ac","content":"<p>虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。</p>\n<a id=\"more\"></a>\n<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><p>我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。</p>\n<p><strong>那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。</strong></p>\n<p>那什么是拷贝构造函数呢?</p>\n<p><strong>拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象</strong></p>\n<p>下面看个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        age = f_age;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，<strong>这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。</strong></p>\n<p>浅拷贝的具体代码实现是怎样的呢？请看下面的代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认的拷贝构造函数</span></span><br><span class=\"line\">Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">    name = h.name;</span><br><span class=\"line\">    age = h.age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可与看出，它只是简单的将对象属性的值，进行拷贝。</p>\n<p>大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？</p>\n<p>答案是否定的，下面看下深拷贝。</p>\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><p>什么是深拷贝?</p>\n<p><strong>深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.</strong></p>\n<p>下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free(): double free detected in tcache 2</span><br><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></table></figure>\n<p>通过输出结果，我们发现，程序发生了错误。</p>\n<p>因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。</p>\n<p>上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。</p>\n<p>由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。</p>\n<p>然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。</p>\n<p>既然问题找到了，我们就需要进行修改，将这个问题解决。</p>\n<p>下面通过深拷贝的方式，让这个bug被修复:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">        name = h.name;</span><br><span class=\"line\">        <span class=\"comment\">//新开辟内存空间到堆区，存放age所指向的数据。</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*h.age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Human拷贝构造函数调用.\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human拷贝构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>程序没有报错，说明我们的bug成功解决了。</p>\n<p>上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。</p>\n<p>深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。</p>\n<p>为什么能避免？</p>\n<p>原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。</p>\n<h1 id=\"两者该如何选择\"><a href=\"#两者该如何选择\" class=\"headerlink\" title=\"两者该如何选择?\"></a>两者该如何选择?</h1><p><strong>说得绝对点：</strong></p>\n<p>若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。</p>\n<p>这时需要使用深拷贝。</p>\n<p><strong>说的不那么绝对:</strong></p>\n<p>若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。</p>\n","site":{"data":{}},"excerpt":"<p>虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。</p>","more":"<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><p>我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。</p>\n<p><strong>那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。</strong></p>\n<p>那什么是拷贝构造函数呢?</p>\n<p><strong>拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象</strong></p>\n<p>下面看个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        age = f_age;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，<strong>这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。</strong></p>\n<p>浅拷贝的具体代码实现是怎样的呢？请看下面的代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认的拷贝构造函数</span></span><br><span class=\"line\">Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">    name = h.name;</span><br><span class=\"line\">    age = h.age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可与看出，它只是简单的将对象属性的值，进行拷贝。</p>\n<p>大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？</p>\n<p>答案是否定的，下面看下深拷贝。</p>\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><p>什么是深拷贝?</p>\n<p><strong>深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.</strong></p>\n<p>下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free(): double free detected in tcache 2</span><br><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></table></figure>\n<p>通过输出结果，我们发现，程序发生了错误。</p>\n<p>因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。</p>\n<p>上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。</p>\n<p>由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。</p>\n<p>然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。</p>\n<p>既然问题找到了，我们就需要进行修改，将这个问题解决。</p>\n<p>下面通过深拷贝的方式，让这个bug被修复:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">        name = h.name;</span><br><span class=\"line\">        <span class=\"comment\">//新开辟内存空间到堆区，存放age所指向的数据。</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*h.age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Human拷贝构造函数调用.\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human拷贝构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>程序没有报错，说明我们的bug成功解决了。</p>\n<p>上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。</p>\n<p>深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。</p>\n<p>为什么能避免？</p>\n<p>原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。</p>\n<h1 id=\"两者该如何选择\"><a href=\"#两者该如何选择\" class=\"headerlink\" title=\"两者该如何选择?\"></a>两者该如何选择?</h1><p><strong>说得绝对点：</strong></p>\n<p>若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。</p>\n<p>这时需要使用深拷贝。</p>\n<p><strong>说的不那么绝对:</strong></p>\n<p>若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。</p>"},{"title":"终端多窗口神器——Screen","date":"2019-05-09T08:56:08.000Z","copyright":true,"_content":"\n曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。\n\n曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。\n\n有了Screen,你就可以获得更好的使用终端多窗口的体验。\n\n<!--more-->\n\n我想你肯定遇到以下几种情况:\n\n- ftp传输\n\n- 系统备份\n\n- 长时间运行任务\n\n好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了...只能重新来过。\n\n# 凶手 SIGHUP 信号\n\n> 以下资料来自维基百科 \n>> SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。\n\n简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。\n\n## 发送信号\n\n在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。\n\n- Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。\n\n- Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。\n\n- Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。\n\n## 前因后果\n\n相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。\n\n**更多有关SIGHUP信号的资料，我会在后面的文章进行更新。**\n\n---\n\n# 开始使用Screen\n\n先简单说说什么是Screen:\n\nScreen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。\n\nScreen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。\n\n**1.创建一个screen窗口**\n\n~~~shell\n[evanmeek@Evan-PC]# screen\n~~~\n\n这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。\n\n**2.创建窗口+执行命令**\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim \n~~~\n\nscreen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。\n\n**3.一个窗口中再有一个窗口中再有一个窗口中...**\n\n你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。\n\n**4.screen的暂时断开(detach)和重新链接(attach)**\n\n比如在screen窗口下用vim编辑C++源文件\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim test.cpp \n~~~\n\n但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).\n\n![挂起提示](终端多窗口神器——Screen/detachedInfo.png)\n\n当你做完其他事你就可以找回该会话，进行重新连接:\n\n找到会话\n\n~~~shell\n[evanmeek@Evan-PC]# screen -ls\nThere are screens on:\n        17944.pts-4.EvanLinux   (Detached)\n        14290.server    (Detached)\n2 Sockets in /run/screens/S-evanmeek.\n~~~\n\n重新连接\n\n~~~shell\n[evanmeek＠Evan-PC]# screen- r 17944\n~~~\n\n这样就可以恢复pts这个会话的窗口了．\n\n---\n\n# 配置你的Screen\n\n前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.\n\n可通过如下键绑定查看所有键绑定．\n\n**C-a ?**\n\n常用的键绑定有：\n\n|键绑定|描述|\n|:---:|:---:|---|\n|C-a ?|显示所有键绑定信息|\n|C-a w|显示所有窗口列表|\n|C-a C-a|切换到之前显示的窗口|\n|C-a c|创建一个新的运行shell的窗口并切换到该窗口|\n|C-a n|切换到下一个窗口|\n|C-a p|切换到前一个窗口|\n|C-a 0~9|切换到0~9窗口|\n|C-a a|发送C-a到当前窗口|\n|C-a d|暂时断开screen会话|\n|C-a k|杀掉当前窗口|\n|C-a [|进入拷贝/回滚模式\n\n我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;\n\n![默认的命令字符](终端多窗口神器——Screen/DefalutCommandKey.png);\n\n我们可以修改它，通过如下格式:\n\n**-exy**\n\nx:命令字符\n\ny:转义字符\n\n~~~shell\n[evanmeek@Evan-PC]# screen -e^oo\n~~~\n\n这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．\n\n---","source":"_posts/终端多窗口神器——Screen.md","raw":"---\ntitle: 终端多窗口神器——Screen\ndate: 2019-05-09 16:56:08\ncategories: 折腾日记\ntags:\n  - Linux\n  - 软件折腾\ncopyright: true\n---\n\n曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。\n\n曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。\n\n有了Screen,你就可以获得更好的使用终端多窗口的体验。\n\n<!--more-->\n\n我想你肯定遇到以下几种情况:\n\n- ftp传输\n\n- 系统备份\n\n- 长时间运行任务\n\n好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了...只能重新来过。\n\n# 凶手 SIGHUP 信号\n\n> 以下资料来自维基百科 \n>> SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。\n\n简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。\n\n## 发送信号\n\n在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。\n\n- Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。\n\n- Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。\n\n- Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。\n\n## 前因后果\n\n相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。\n\n**更多有关SIGHUP信号的资料，我会在后面的文章进行更新。**\n\n---\n\n# 开始使用Screen\n\n先简单说说什么是Screen:\n\nScreen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。\n\nScreen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。\n\n**1.创建一个screen窗口**\n\n~~~shell\n[evanmeek@Evan-PC]# screen\n~~~\n\n这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。\n\n**2.创建窗口+执行命令**\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim \n~~~\n\nscreen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。\n\n**3.一个窗口中再有一个窗口中再有一个窗口中...**\n\n你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。\n\n**4.screen的暂时断开(detach)和重新链接(attach)**\n\n比如在screen窗口下用vim编辑C++源文件\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim test.cpp \n~~~\n\n但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).\n\n![挂起提示](终端多窗口神器——Screen/detachedInfo.png)\n\n当你做完其他事你就可以找回该会话，进行重新连接:\n\n找到会话\n\n~~~shell\n[evanmeek@Evan-PC]# screen -ls\nThere are screens on:\n        17944.pts-4.EvanLinux   (Detached)\n        14290.server    (Detached)\n2 Sockets in /run/screens/S-evanmeek.\n~~~\n\n重新连接\n\n~~~shell\n[evanmeek＠Evan-PC]# screen- r 17944\n~~~\n\n这样就可以恢复pts这个会话的窗口了．\n\n---\n\n# 配置你的Screen\n\n前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.\n\n可通过如下键绑定查看所有键绑定．\n\n**C-a ?**\n\n常用的键绑定有：\n\n|键绑定|描述|\n|:---:|:---:|---|\n|C-a ?|显示所有键绑定信息|\n|C-a w|显示所有窗口列表|\n|C-a C-a|切换到之前显示的窗口|\n|C-a c|创建一个新的运行shell的窗口并切换到该窗口|\n|C-a n|切换到下一个窗口|\n|C-a p|切换到前一个窗口|\n|C-a 0~9|切换到0~9窗口|\n|C-a a|发送C-a到当前窗口|\n|C-a d|暂时断开screen会话|\n|C-a k|杀掉当前窗口|\n|C-a [|进入拷贝/回滚模式\n\n我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;\n\n![默认的命令字符](终端多窗口神器——Screen/DefalutCommandKey.png);\n\n我们可以修改它，通过如下格式:\n\n**-exy**\n\nx:命令字符\n\ny:转义字符\n\n~~~shell\n[evanmeek@Evan-PC]# screen -e^oo\n~~~\n\n这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．\n\n---","slug":"终端多窗口神器——Screen","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodg006eomooa5taq734","content":"<p>曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。</p>\n<p>曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。</p>\n<p>有了Screen,你就可以获得更好的使用终端多窗口的体验。</p>\n<a id=\"more\"></a>\n<p>我想你肯定遇到以下几种情况:</p>\n<ul>\n<li><p>ftp传输</p>\n</li>\n<li><p>系统备份</p>\n</li>\n<li><p>长时间运行任务</p>\n</li>\n</ul>\n<p>好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。</p>\n<h1 id=\"凶手-SIGHUP-信号\"><a href=\"#凶手-SIGHUP-信号\" class=\"headerlink\" title=\"凶手 SIGHUP 信号\"></a>凶手 SIGHUP 信号</h1><blockquote>\n<p>以下资料来自维基百科 </p>\n<blockquote>\n<p>SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p>\n</blockquote>\n</blockquote>\n<p>简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。</p>\n<h2 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h2><p>在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。</p>\n<ul>\n<li><p>Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。</p>\n</li>\n<li><p>Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。</p>\n</li>\n<li><p>Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。</p>\n</li>\n</ul>\n<h2 id=\"前因后果\"><a href=\"#前因后果\" class=\"headerlink\" title=\"前因后果\"></a>前因后果</h2><p>相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。</p>\n<p><strong>更多有关SIGHUP信号的资料，我会在后面的文章进行更新。</strong></p>\n<hr>\n<h1 id=\"开始使用Screen\"><a href=\"#开始使用Screen\" class=\"headerlink\" title=\"开始使用Screen\"></a>开始使用Screen</h1><p>先简单说说什么是Screen:</p>\n<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。</p>\n<p>Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。</p>\n<p><strong>1.创建一个screen窗口</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen</span><br></pre></td></tr></table></figure>\n<p>这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。</p>\n<p><strong>2.创建窗口+执行命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim</span><br></pre></td></tr></table></figure>\n<p>screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。</p>\n<p><strong>3.一个窗口中再有一个窗口中再有一个窗口中…</strong></p>\n<p>你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。</p>\n<p><strong>4.screen的暂时断开(detach)和重新链接(attach)</strong></p>\n<p>比如在screen窗口下用vim编辑C++源文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim test.cpp</span><br></pre></td></tr></table></figure>\n<p>但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/detachedInfo.png\" alt=\"挂起提示\"></p>\n<p>当你做完其他事你就可以找回该会话，进行重新连接:</p>\n<p>找到会话</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -ls</span><br><span class=\"line\">There are screens on:</span><br><span class=\"line\">        17944.pts-4.EvanLinux   (Detached)</span><br><span class=\"line\">        14290.server    (Detached)</span><br><span class=\"line\">2 Sockets in /run/screens/S-evanmeek.</span><br></pre></td></tr></table></figure>\n<p>重新连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek＠Evan-PC]# screen- r 17944</span><br></pre></td></tr></table></figure>\n<p>这样就可以恢复pts这个会话的窗口了．</p>\n<hr>\n<h1 id=\"配置你的Screen\"><a href=\"#配置你的Screen\" class=\"headerlink\" title=\"配置你的Screen\"></a>配置你的Screen</h1><p>前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.</p>\n<p>可通过如下键绑定查看所有键绑定．</p>\n<p><strong>C-a ?</strong></p>\n<p>常用的键绑定有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">键绑定</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">C-a ?</td>\n<td style=\"text-align:center\">显示所有键绑定信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a w</td>\n<td style=\"text-align:center\">显示所有窗口列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a C-a</td>\n<td style=\"text-align:center\">切换到之前显示的窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a c</td>\n<td style=\"text-align:center\">创建一个新的运行shell的窗口并切换到该窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a n</td>\n<td style=\"text-align:center\">切换到下一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a p</td>\n<td style=\"text-align:center\">切换到前一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a 0~9</td>\n<td style=\"text-align:center\">切换到0~9窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a a</td>\n<td style=\"text-align:center\">发送C-a到当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a d</td>\n<td style=\"text-align:center\">暂时断开screen会话</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a k</td>\n<td style=\"text-align:center\">杀掉当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a [</td>\n<td style=\"text-align:center\">进入拷贝/回滚模式</td>\n</tr>\n</tbody>\n</table>\n<p>我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png\" alt=\"默认的命令字符\">;</p>\n<p>我们可以修改它，通过如下格式:</p>\n<p><strong>-exy</strong></p>\n<p>x:命令字符</p>\n<p>y:转义字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -e^oo</span><br></pre></td></tr></table></figure>\n<p>这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。</p>\n<p>曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。</p>\n<p>有了Screen,你就可以获得更好的使用终端多窗口的体验。</p>","more":"<p>我想你肯定遇到以下几种情况:</p>\n<ul>\n<li><p>ftp传输</p>\n</li>\n<li><p>系统备份</p>\n</li>\n<li><p>长时间运行任务</p>\n</li>\n</ul>\n<p>好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。</p>\n<h1 id=\"凶手-SIGHUP-信号\"><a href=\"#凶手-SIGHUP-信号\" class=\"headerlink\" title=\"凶手 SIGHUP 信号\"></a>凶手 SIGHUP 信号</h1><blockquote>\n<p>以下资料来自维基百科 </p>\n<blockquote>\n<p>SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p>\n</blockquote>\n</blockquote>\n<p>简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。</p>\n<h2 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h2><p>在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。</p>\n<ul>\n<li><p>Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。</p>\n</li>\n<li><p>Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。</p>\n</li>\n<li><p>Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。</p>\n</li>\n</ul>\n<h2 id=\"前因后果\"><a href=\"#前因后果\" class=\"headerlink\" title=\"前因后果\"></a>前因后果</h2><p>相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。</p>\n<p><strong>更多有关SIGHUP信号的资料，我会在后面的文章进行更新。</strong></p>\n<hr>\n<h1 id=\"开始使用Screen\"><a href=\"#开始使用Screen\" class=\"headerlink\" title=\"开始使用Screen\"></a>开始使用Screen</h1><p>先简单说说什么是Screen:</p>\n<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。</p>\n<p>Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。</p>\n<p><strong>1.创建一个screen窗口</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen</span><br></pre></td></tr></table></figure>\n<p>这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。</p>\n<p><strong>2.创建窗口+执行命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim</span><br></pre></td></tr></table></figure>\n<p>screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。</p>\n<p><strong>3.一个窗口中再有一个窗口中再有一个窗口中…</strong></p>\n<p>你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。</p>\n<p><strong>4.screen的暂时断开(detach)和重新链接(attach)</strong></p>\n<p>比如在screen窗口下用vim编辑C++源文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim test.cpp</span><br></pre></td></tr></table></figure>\n<p>但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/detachedInfo.png\" alt=\"挂起提示\"></p>\n<p>当你做完其他事你就可以找回该会话，进行重新连接:</p>\n<p>找到会话</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -ls</span><br><span class=\"line\">There are screens on:</span><br><span class=\"line\">        17944.pts-4.EvanLinux   (Detached)</span><br><span class=\"line\">        14290.server    (Detached)</span><br><span class=\"line\">2 Sockets in /run/screens/S-evanmeek.</span><br></pre></td></tr></table></figure>\n<p>重新连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek＠Evan-PC]# screen- r 17944</span><br></pre></td></tr></table></figure>\n<p>这样就可以恢复pts这个会话的窗口了．</p>\n<hr>\n<h1 id=\"配置你的Screen\"><a href=\"#配置你的Screen\" class=\"headerlink\" title=\"配置你的Screen\"></a>配置你的Screen</h1><p>前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.</p>\n<p>可通过如下键绑定查看所有键绑定．</p>\n<p><strong>C-a ?</strong></p>\n<p>常用的键绑定有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">键绑定</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">C-a ?</td>\n<td style=\"text-align:center\">显示所有键绑定信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a w</td>\n<td style=\"text-align:center\">显示所有窗口列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a C-a</td>\n<td style=\"text-align:center\">切换到之前显示的窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a c</td>\n<td style=\"text-align:center\">创建一个新的运行shell的窗口并切换到该窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a n</td>\n<td style=\"text-align:center\">切换到下一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a p</td>\n<td style=\"text-align:center\">切换到前一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a 0~9</td>\n<td style=\"text-align:center\">切换到0~9窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a a</td>\n<td style=\"text-align:center\">发送C-a到当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a d</td>\n<td style=\"text-align:center\">暂时断开screen会话</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a k</td>\n<td style=\"text-align:center\">杀掉当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a [</td>\n<td style=\"text-align:center\">进入拷贝/回滚模式</td>\n</tr>\n</tbody>\n</table>\n<p>我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png\" alt=\"默认的命令字符\">;</p>\n<p>我们可以修改它，通过如下格式:</p>\n<p><strong>-exy</strong></p>\n<p>x:命令字符</p>\n<p>y:转义字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -e^oo</span><br></pre></td></tr></table></figure>\n<p>这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．</p>\n<hr>"},{"title":"自我反省","copyright":true,"date":"2019-09-23T11:02:17.000Z","_content":"\n自我反省，回想一下开学以来自己都做了些什么?\n\n<!--more-->\n\n&emsp;&emsp;还在暑假时，我就十分期待开学，因为暑假一个人有些无聊。不是说hack不够快乐，而是我更想偶尔跟朋友一起娱乐。现在开学也有20天了，我却发现我开学时的计划已经被我忘得干干净净了。所以我得总结一下，自开学以来，李天宇都干了些什么?\n\n&emsp;&emsp;由于在上学期竞选了社团技术部的部长，所以我不得不处于刚开学就忙得不可开交的状态。说实话，我并不擅长管理，而社团部门部长这一任职对我来说压力挺大的，我得每天留意微信，遗漏掉任何一条消息，都可能失去大量的信息。正是因为我每天微信消息很多，所以我越来越讨厌那些发长语音的人(除了我女朋友)，如果长语音能清晰地表达出意思还好，但往往很多人都是在嗯...啊...昂...徘徊，花费近1min的时间去听那个信息量两三句话的语音，简直让我每次听完都想立刻瞬间移动到对方面前，大喊几声:\"你到底想说什么?你发语音能不能别发那么长段的!\"，不过得益于网络的发展，我并不需要瞬间移动过去，我偶尔会把这两句话通过微信以网络传输的方式发送至对方。事情往往没有想得那么简单，因为我发完那两句话之后，对方可能又是一个长语音过来，解释他刚刚说的。讲了这一个小例子，读者们可能意识到，我是想表达:因为很多人是这么做的，所以我在使用微信时是十分低效的。每次想到这里，我就回想起在irc内通过邮件列表互相交流的时光是多么的美好。\n\n&emsp;&emsp;我几乎每天都会在图书馆待上一阵子，正如此时，我就在图书馆敲打着蝶式键盘写着这一句。每天在图书馆的时间，我都用来学习Python了，因为我在暑假时在B站发现一位up主，他使用Vim完成日常的写代码、写文章、记笔记的事情，并且在看过他演示后，我便被他所提到的Vim彻底吸引了，因为实在太高效了。那时我每天就研究关于Linux某些软件的配置，例如:`i3wm`,`ranger`,`neovim`，其中我渐渐觉得Python几乎出现在我所接触到的软件的任何地方，可能是由于其第三方库丰富以及语法简单、优雅，程序可移植性高的缘故，由Python开发的开源软件，大多数都可以很轻松的使用Python扩展你想要添加的新功能。其中`ranger`我就想着为其提供一些新功能，所以我便开始学习Python，图书馆的日子基本都是学习Python这门语言了。\n\n&emsp;&emsp;前面介绍了我生活的一些七七八八的东西，搞的我脑子很乱，我发现我还是不怎么会写作，下次得好好看下如何写作了，这篇文章暂时先写到这里，等我什么时候(咕咕咕) 有新想法了再继续吧!\n","source":"_posts/自我反省.md","raw":"---\ntitle: 自我反省\ncopyright: true\ndate: 2019-09-23 19:02:17\ncategories: 个人感想\ntags:\n  - 个人感想\n---\n\n自我反省，回想一下开学以来自己都做了些什么?\n\n<!--more-->\n\n&emsp;&emsp;还在暑假时，我就十分期待开学，因为暑假一个人有些无聊。不是说hack不够快乐，而是我更想偶尔跟朋友一起娱乐。现在开学也有20天了，我却发现我开学时的计划已经被我忘得干干净净了。所以我得总结一下，自开学以来，李天宇都干了些什么?\n\n&emsp;&emsp;由于在上学期竞选了社团技术部的部长，所以我不得不处于刚开学就忙得不可开交的状态。说实话，我并不擅长管理，而社团部门部长这一任职对我来说压力挺大的，我得每天留意微信，遗漏掉任何一条消息，都可能失去大量的信息。正是因为我每天微信消息很多，所以我越来越讨厌那些发长语音的人(除了我女朋友)，如果长语音能清晰地表达出意思还好，但往往很多人都是在嗯...啊...昂...徘徊，花费近1min的时间去听那个信息量两三句话的语音，简直让我每次听完都想立刻瞬间移动到对方面前，大喊几声:\"你到底想说什么?你发语音能不能别发那么长段的!\"，不过得益于网络的发展，我并不需要瞬间移动过去，我偶尔会把这两句话通过微信以网络传输的方式发送至对方。事情往往没有想得那么简单，因为我发完那两句话之后，对方可能又是一个长语音过来，解释他刚刚说的。讲了这一个小例子，读者们可能意识到，我是想表达:因为很多人是这么做的，所以我在使用微信时是十分低效的。每次想到这里，我就回想起在irc内通过邮件列表互相交流的时光是多么的美好。\n\n&emsp;&emsp;我几乎每天都会在图书馆待上一阵子，正如此时，我就在图书馆敲打着蝶式键盘写着这一句。每天在图书馆的时间，我都用来学习Python了，因为我在暑假时在B站发现一位up主，他使用Vim完成日常的写代码、写文章、记笔记的事情，并且在看过他演示后，我便被他所提到的Vim彻底吸引了，因为实在太高效了。那时我每天就研究关于Linux某些软件的配置，例如:`i3wm`,`ranger`,`neovim`，其中我渐渐觉得Python几乎出现在我所接触到的软件的任何地方，可能是由于其第三方库丰富以及语法简单、优雅，程序可移植性高的缘故，由Python开发的开源软件，大多数都可以很轻松的使用Python扩展你想要添加的新功能。其中`ranger`我就想着为其提供一些新功能，所以我便开始学习Python，图书馆的日子基本都是学习Python这门语言了。\n\n&emsp;&emsp;前面介绍了我生活的一些七七八八的东西，搞的我脑子很乱，我发现我还是不怎么会写作，下次得好好看下如何写作了，这篇文章暂时先写到这里，等我什么时候(咕咕咕) 有新想法了再继续吧!\n","slug":"自我反省","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodh006homooc7npxa5t","content":"<p>自我反省，回想一下开学以来自己都做了些什么?</p>\n<a id=\"more\"></a>\n<p>&emsp;&emsp;还在暑假时，我就十分期待开学，因为暑假一个人有些无聊。不是说hack不够快乐，而是我更想偶尔跟朋友一起娱乐。现在开学也有20天了，我却发现我开学时的计划已经被我忘得干干净净了。所以我得总结一下，自开学以来，李天宇都干了些什么?</p>\n<p>&emsp;&emsp;由于在上学期竞选了社团技术部的部长，所以我不得不处于刚开学就忙得不可开交的状态。说实话，我并不擅长管理，而社团部门部长这一任职对我来说压力挺大的，我得每天留意微信，遗漏掉任何一条消息，都可能失去大量的信息。正是因为我每天微信消息很多，所以我越来越讨厌那些发长语音的人(除了我女朋友)，如果长语音能清晰地表达出意思还好，但往往很多人都是在嗯…啊…昂…徘徊，花费近1min的时间去听那个信息量两三句话的语音，简直让我每次听完都想立刻瞬间移动到对方面前，大喊几声:”你到底想说什么?你发语音能不能别发那么长段的!”，不过得益于网络的发展，我并不需要瞬间移动过去，我偶尔会把这两句话通过微信以网络传输的方式发送至对方。事情往往没有想得那么简单，因为我发完那两句话之后，对方可能又是一个长语音过来，解释他刚刚说的。讲了这一个小例子，读者们可能意识到，我是想表达:因为很多人是这么做的，所以我在使用微信时是十分低效的。每次想到这里，我就回想起在irc内通过邮件列表互相交流的时光是多么的美好。</p>\n<p>&emsp;&emsp;我几乎每天都会在图书馆待上一阵子，正如此时，我就在图书馆敲打着蝶式键盘写着这一句。每天在图书馆的时间，我都用来学习Python了，因为我在暑假时在B站发现一位up主，他使用Vim完成日常的写代码、写文章、记笔记的事情，并且在看过他演示后，我便被他所提到的Vim彻底吸引了，因为实在太高效了。那时我每天就研究关于Linux某些软件的配置，例如:<code>i3wm</code>,<code>ranger</code>,<code>neovim</code>，其中我渐渐觉得Python几乎出现在我所接触到的软件的任何地方，可能是由于其第三方库丰富以及语法简单、优雅，程序可移植性高的缘故，由Python开发的开源软件，大多数都可以很轻松的使用Python扩展你想要添加的新功能。其中<code>ranger</code>我就想着为其提供一些新功能，所以我便开始学习Python，图书馆的日子基本都是学习Python这门语言了。</p>\n<p>&emsp;&emsp;前面介绍了我生活的一些七七八八的东西，搞的我脑子很乱，我发现我还是不怎么会写作，下次得好好看下如何写作了，这篇文章暂时先写到这里，等我什么时候(咕咕咕) 有新想法了再继续吧!</p>\n","site":{"data":{}},"excerpt":"<p>自我反省，回想一下开学以来自己都做了些什么?</p>","more":"<p>&emsp;&emsp;还在暑假时，我就十分期待开学，因为暑假一个人有些无聊。不是说hack不够快乐，而是我更想偶尔跟朋友一起娱乐。现在开学也有20天了，我却发现我开学时的计划已经被我忘得干干净净了。所以我得总结一下，自开学以来，李天宇都干了些什么?</p>\n<p>&emsp;&emsp;由于在上学期竞选了社团技术部的部长，所以我不得不处于刚开学就忙得不可开交的状态。说实话，我并不擅长管理，而社团部门部长这一任职对我来说压力挺大的，我得每天留意微信，遗漏掉任何一条消息，都可能失去大量的信息。正是因为我每天微信消息很多，所以我越来越讨厌那些发长语音的人(除了我女朋友)，如果长语音能清晰地表达出意思还好，但往往很多人都是在嗯…啊…昂…徘徊，花费近1min的时间去听那个信息量两三句话的语音，简直让我每次听完都想立刻瞬间移动到对方面前，大喊几声:”你到底想说什么?你发语音能不能别发那么长段的!”，不过得益于网络的发展，我并不需要瞬间移动过去，我偶尔会把这两句话通过微信以网络传输的方式发送至对方。事情往往没有想得那么简单，因为我发完那两句话之后，对方可能又是一个长语音过来，解释他刚刚说的。讲了这一个小例子，读者们可能意识到，我是想表达:因为很多人是这么做的，所以我在使用微信时是十分低效的。每次想到这里，我就回想起在irc内通过邮件列表互相交流的时光是多么的美好。</p>\n<p>&emsp;&emsp;我几乎每天都会在图书馆待上一阵子，正如此时，我就在图书馆敲打着蝶式键盘写着这一句。每天在图书馆的时间，我都用来学习Python了，因为我在暑假时在B站发现一位up主，他使用Vim完成日常的写代码、写文章、记笔记的事情，并且在看过他演示后，我便被他所提到的Vim彻底吸引了，因为实在太高效了。那时我每天就研究关于Linux某些软件的配置，例如:<code>i3wm</code>,<code>ranger</code>,<code>neovim</code>，其中我渐渐觉得Python几乎出现在我所接触到的软件的任何地方，可能是由于其第三方库丰富以及语法简单、优雅，程序可移植性高的缘故，由Python开发的开源软件，大多数都可以很轻松的使用Python扩展你想要添加的新功能。其中<code>ranger</code>我就想着为其提供一些新功能，所以我便开始学习Python，图书馆的日子基本都是学习Python这门语言了。</p>\n<p>&emsp;&emsp;前面介绍了我生活的一些七七八八的东西，搞的我脑子很乱，我发现我还是不怎么会写作，下次得好好看下如何写作了，这篇文章暂时先写到这里，等我什么时候(咕咕咕) 有新想法了再继续吧!</p>"},{"title":"解决KDE下部分应用不能使用fcitx中文输入法的问题","copyright":true,"date":"2019-05-19T07:56:33.000Z","_content":"\n我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。\n\n<!--more-->\n\n*********** 本教程使用fcitx输入法框架。**************\n\n# 第一步\n\n首先安装一些必要的软件:\n\n~~~shell\n$ sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin\n~~~\n\n# 第二步\n\n安装完成后编辑:**/etc/environment**文件，加上如下内容:\n\n~~~shell\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=@im=fcitx\n~~~\n\n# 第三步\n\n注销当前会话，配置输入法为googlepinyin即可使用。\n\n\n> [本文参考](https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/)\n\n---\n","source":"_posts/解决KDE下部分应用不能使用fctix中文输入法的问题.md","raw":"---\ntitle: 解决KDE下部分应用不能使用fcitx中文输入法的问题\ncopyright: true\ndate: 2019-05-19 15:56:33\ncategories: 学习笔记\ntags:\n - Linux\n - KDE\n---\n\n我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。\n\n<!--more-->\n\n*********** 本教程使用fcitx输入法框架。**************\n\n# 第一步\n\n首先安装一些必要的软件:\n\n~~~shell\n$ sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin\n~~~\n\n# 第二步\n\n安装完成后编辑:**/etc/environment**文件，加上如下内容:\n\n~~~shell\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=@im=fcitx\n~~~\n\n# 第三步\n\n注销当前会话，配置输入法为googlepinyin即可使用。\n\n\n> [本文参考](https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/)\n\n---\n","slug":"解决KDE下部分应用不能使用fctix中文输入法的问题","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodi006komoo47es3irb","content":"<p>我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。</p>\n<a id=\"more\"></a>\n<p><strong><strong>***</strong></strong> 本教程使用fcitx输入法框架。<strong><strong><strong>**</strong></strong></strong></p>\n<h1 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h1><p>首先安装一些必要的软件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h1><p>安装完成后编辑:<strong>/etc/environment</strong>文件，加上如下内容:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>\n<h1 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h1><p>注销当前会话，配置输入法为googlepinyin即可使用。</p>\n<blockquote>\n<p><a href=\"https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">本文参考</a></p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"<p>我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。</p>","more":"<p><strong><strong>***</strong></strong> 本教程使用fcitx输入法框架。<strong><strong><strong>**</strong></strong></strong></p>\n<h1 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h1><p>首先安装一些必要的软件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h1><p>安装完成后编辑:<strong>/etc/environment</strong>文件，加上如下内容:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>\n<h1 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h1><p>注销当前会话，配置输入法为googlepinyin即可使用。</p>\n<blockquote>\n<p><a href=\"https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">本文参考</a></p>\n</blockquote>\n<hr>"},{"title":"趣学Haskell-01","copyright":true,"date":"2019-09-26T15:46:32.000Z","_content":"","source":"_posts/趣学Haskell-01.md","raw":"---\ntitle: 趣学Haskell-01\ncopyright: true\ndate: 2019-09-26 23:46:32\ncategories:\ntags:\n---\n","slug":"趣学Haskell-01","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodi006nomoo68hb1eag","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"超酷-字符文件管理-ranger","copyright":true,"date":"2019-07-03T01:47:24.000Z","_content":"\n<!--more-->\n\n![ranger](超酷-字符文件管理-ranger/ranger-pre.png)\n\n# 0x0 什么是ranger?\n\n`ranger`是一个基于文本的文件管理器，由Python编写。\n\n# 0x1 为什么要选择ranger?\n\n`ranger`具有以下特性:\n\n- vi风格的快捷键\n\n- 书签\n\n- 选择\n\n- 标签\n\n- 选项\n\n- 命令历史\n\n- 创建符号链接\n\n- 任务视图\n\n- 自定义命令\n\n- 自定义快捷键按\n\n# 0x2 使用ranger\n\n在终端内输入`ranger`以启动ranger\n\n使用`h j k l`进行目录之间的进出。\n\n# 0x3 配置ranger\n\n配置文件:\n\n- rc.conf 基本选项与快捷键设置\n\n- commands.py 可在ranger下使用`:`执行的命令\n\n- rifile.conf 文件关联，控制不同文件用不同程序打开\n\n配色方案:\n\n`ranger`默认自带四种配色方案:`defalut` `jungle` `snow` `zenburn`\n\n使用`:set colorscheme scheme`进行切换。\n\n自定义配色方案文件放在`~/.config/ranger/colorschemes`\n\n# 0x4 我的ranger配置\n\n以上传至Github\n\n[点击访问](https://github.com/EvanMeek/Vanilla/tree/master/ranger)\n\n# 0x5 其他\n\n下载地址:[点击获取](https://github.com/ranger/ranger/releases)\n\nArch系:\n\n~~~\n> pacman -S ranger\n~~~\n","source":"_posts/超酷-字符文件管理-ranger.md","raw":"---\ntitle: 超酷-字符文件管理-ranger\ncopyright: true\ndate: 2019-07-03 09:47:24\ncategories: 折腾日记\ntags:\n  - Linux\n---\n\n<!--more-->\n\n![ranger](超酷-字符文件管理-ranger/ranger-pre.png)\n\n# 0x0 什么是ranger?\n\n`ranger`是一个基于文本的文件管理器，由Python编写。\n\n# 0x1 为什么要选择ranger?\n\n`ranger`具有以下特性:\n\n- vi风格的快捷键\n\n- 书签\n\n- 选择\n\n- 标签\n\n- 选项\n\n- 命令历史\n\n- 创建符号链接\n\n- 任务视图\n\n- 自定义命令\n\n- 自定义快捷键按\n\n# 0x2 使用ranger\n\n在终端内输入`ranger`以启动ranger\n\n使用`h j k l`进行目录之间的进出。\n\n# 0x3 配置ranger\n\n配置文件:\n\n- rc.conf 基本选项与快捷键设置\n\n- commands.py 可在ranger下使用`:`执行的命令\n\n- rifile.conf 文件关联，控制不同文件用不同程序打开\n\n配色方案:\n\n`ranger`默认自带四种配色方案:`defalut` `jungle` `snow` `zenburn`\n\n使用`:set colorscheme scheme`进行切换。\n\n自定义配色方案文件放在`~/.config/ranger/colorschemes`\n\n# 0x4 我的ranger配置\n\n以上传至Github\n\n[点击访问](https://github.com/EvanMeek/Vanilla/tree/master/ranger)\n\n# 0x5 其他\n\n下载地址:[点击获取](https://github.com/ranger/ranger/releases)\n\nArch系:\n\n~~~\n> pacman -S ranger\n~~~\n","slug":"超酷-字符文件管理-ranger","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodj006qomookz8frew5","content":"<a id=\"more\"></a>\n<p><img src=\"/2019/07/03/超酷-字符文件管理-ranger/ranger-pre.png\" alt=\"ranger\"></p>\n<h1 id=\"0x0-什么是ranger\"><a href=\"#0x0-什么是ranger\" class=\"headerlink\" title=\"0x0 什么是ranger?\"></a>0x0 什么是ranger?</h1><p><code>ranger</code>是一个基于文本的文件管理器，由Python编写。</p>\n<h1 id=\"0x1-为什么要选择ranger\"><a href=\"#0x1-为什么要选择ranger\" class=\"headerlink\" title=\"0x1 为什么要选择ranger?\"></a>0x1 为什么要选择ranger?</h1><p><code>ranger</code>具有以下特性:</p>\n<ul>\n<li><p>vi风格的快捷键</p>\n</li>\n<li><p>书签</p>\n</li>\n<li><p>选择</p>\n</li>\n<li><p>标签</p>\n</li>\n<li><p>选项</p>\n</li>\n<li><p>命令历史</p>\n</li>\n<li><p>创建符号链接</p>\n</li>\n<li><p>任务视图</p>\n</li>\n<li><p>自定义命令</p>\n</li>\n<li><p>自定义快捷键按</p>\n</li>\n</ul>\n<h1 id=\"0x2-使用ranger\"><a href=\"#0x2-使用ranger\" class=\"headerlink\" title=\"0x2 使用ranger\"></a>0x2 使用ranger</h1><p>在终端内输入<code>ranger</code>以启动ranger</p>\n<p>使用<code>h j k l</code>进行目录之间的进出。</p>\n<h1 id=\"0x3-配置ranger\"><a href=\"#0x3-配置ranger\" class=\"headerlink\" title=\"0x3 配置ranger\"></a>0x3 配置ranger</h1><p>配置文件:</p>\n<ul>\n<li><p>rc.conf 基本选项与快捷键设置</p>\n</li>\n<li><p>commands.py 可在ranger下使用<code>:</code>执行的命令</p>\n</li>\n<li><p>rifile.conf 文件关联，控制不同文件用不同程序打开</p>\n</li>\n</ul>\n<p>配色方案:</p>\n<p><code>ranger</code>默认自带四种配色方案:<code>defalut</code> <code>jungle</code> <code>snow</code> <code>zenburn</code></p>\n<p>使用<code>:set colorscheme scheme</code>进行切换。</p>\n<p>自定义配色方案文件放在<code>~/.config/ranger/colorschemes</code></p>\n<h1 id=\"0x4-我的ranger配置\"><a href=\"#0x4-我的ranger配置\" class=\"headerlink\" title=\"0x4 我的ranger配置\"></a>0x4 我的ranger配置</h1><p>以上传至Github</p>\n<p><a href=\"https://github.com/EvanMeek/Vanilla/tree/master/ranger\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x5-其他\"><a href=\"#0x5-其他\" class=\"headerlink\" title=\"0x5 其他\"></a>0x5 其他</h1><p>下载地址:<a href=\"https://github.com/ranger/ranger/releases\" target=\"_blank\" rel=\"noopener\">点击获取</a></p>\n<p>Arch系:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; pacman -S ranger</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/07/03/超酷-字符文件管理-ranger/ranger-pre.png\" alt=\"ranger\"></p>\n<h1 id=\"0x0-什么是ranger\"><a href=\"#0x0-什么是ranger\" class=\"headerlink\" title=\"0x0 什么是ranger?\"></a>0x0 什么是ranger?</h1><p><code>ranger</code>是一个基于文本的文件管理器，由Python编写。</p>\n<h1 id=\"0x1-为什么要选择ranger\"><a href=\"#0x1-为什么要选择ranger\" class=\"headerlink\" title=\"0x1 为什么要选择ranger?\"></a>0x1 为什么要选择ranger?</h1><p><code>ranger</code>具有以下特性:</p>\n<ul>\n<li><p>vi风格的快捷键</p>\n</li>\n<li><p>书签</p>\n</li>\n<li><p>选择</p>\n</li>\n<li><p>标签</p>\n</li>\n<li><p>选项</p>\n</li>\n<li><p>命令历史</p>\n</li>\n<li><p>创建符号链接</p>\n</li>\n<li><p>任务视图</p>\n</li>\n<li><p>自定义命令</p>\n</li>\n<li><p>自定义快捷键按</p>\n</li>\n</ul>\n<h1 id=\"0x2-使用ranger\"><a href=\"#0x2-使用ranger\" class=\"headerlink\" title=\"0x2 使用ranger\"></a>0x2 使用ranger</h1><p>在终端内输入<code>ranger</code>以启动ranger</p>\n<p>使用<code>h j k l</code>进行目录之间的进出。</p>\n<h1 id=\"0x3-配置ranger\"><a href=\"#0x3-配置ranger\" class=\"headerlink\" title=\"0x3 配置ranger\"></a>0x3 配置ranger</h1><p>配置文件:</p>\n<ul>\n<li><p>rc.conf 基本选项与快捷键设置</p>\n</li>\n<li><p>commands.py 可在ranger下使用<code>:</code>执行的命令</p>\n</li>\n<li><p>rifile.conf 文件关联，控制不同文件用不同程序打开</p>\n</li>\n</ul>\n<p>配色方案:</p>\n<p><code>ranger</code>默认自带四种配色方案:<code>defalut</code> <code>jungle</code> <code>snow</code> <code>zenburn</code></p>\n<p>使用<code>:set colorscheme scheme</code>进行切换。</p>\n<p>自定义配色方案文件放在<code>~/.config/ranger/colorschemes</code></p>\n<h1 id=\"0x4-我的ranger配置\"><a href=\"#0x4-我的ranger配置\" class=\"headerlink\" title=\"0x4 我的ranger配置\"></a>0x4 我的ranger配置</h1><p>以上传至Github</p>\n<p><a href=\"https://github.com/EvanMeek/Vanilla/tree/master/ranger\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x5-其他\"><a href=\"#0x5-其他\" class=\"headerlink\" title=\"0x5 其他\"></a>0x5 其他</h1><p>下载地址:<a href=\"https://github.com/ranger/ranger/releases\" target=\"_blank\" rel=\"noopener\">点击获取</a></p>\n<p>Arch系:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; pacman -S ranger</span><br></pre></td></tr></table></figure>"},{"title":"读《笨方法学习VimScript》所学","copyright":true,"date":"2019-09-27T10:26:16.000Z","_content":"\n身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。\n\n<!--more-->\n\n# 为什么选择这本书?\n\n&emsp;首先，我是一个重度Vim用户，目前记笔记，写代码等操作都是在Vim中实现的，为了让这个强大的古老神器能在我手上发挥巨大威力，所以我决定看书学习Vim。而这本书的前言说的就很好，第一句则是`程序猿们很喜欢实现自己的idea`，虽然我现在只是一名学生，但在我日常生活中经常想把自己使用Vim时的好点子加入我的`vimrc` 中。再就是这本书的`每章都只讲述一个主题，虽然内容简短但是信息丰富`，这样我很喜欢，没有过多啰嗦的地方，有些地方这本书更推荐看Vim自带的文档，这样也让读者有一个自我理解与学习的过程，就像书中所说`现实世界中事情的进展并不是遇到问题后可以很快速轻松的解决`。\n\n# 前言\n\n所提到的都是这本书是面向谁的，以及读完这本书能获得些什么，并且给了一些学习时的忠告，最后提醒了要多利用`:help`命令.\n\n# 预备知识\n\n这本书主要讲VimScript所以，在学习VimScript之前，得了解Vim的基本使用，例如`buffer,window,normal mode,insert mode,text mode`。\n\n最好是具有编程经验。\n\n本书基于Vim-7.3版本撰写的，所以读者需要确保系统安装了>=7.3版本的Vim。\n\n## 创建Vimrc文件\n\n这一节没有提到`Vimrc` 是什么，我这里提一下，是`Vimrc`一个文件，文件内的可以写vim的命令，而写在`Vimrc` 中的命令都被称为Ex命令，Ex命令不是这一小节的讨论范围。\n\n主要说到在Linux或Mac OS X中，这个文件位于`home`目录下，并且是以`.vimrc`命名的，而在Windows下则是位于`home`文件夹下，并以`_vimrc`命名。\n\n以上三个系统，都可以在Vim中通过执行`:echo $MYVIMRC`得知此文件的位置等信息。\n\n**注意:若你没有找到此文件，请自行创建** \n\n# 打印信息\n\n主要提到Vim中打印命令和注释的使用与作用。\n\nVim中的打印命令有:`echo` 和`echom` ，其区别在于:\n\n- echo 仅仅输出回显表达式结果。\n\n  > 回显表达式\n\n  `echo {expr1}` 其中{expr1}就是回显表达式\n- echom 输出回显表达式结果，并且将其存储在`message-history` 内\n\n  > message-history\n\n  `message-history` 是消息历史，可以通过命令查看`:messages` \n\n## 注释\n\nVimScript可以通过`\"` 字符添加注释，就像这样:\n\n```\n\" 将<space>映射为za\nnnoremap <space> za\n```\n\n# 设置选项\n\nVim中有两种选型: 布尔选项(`on` 或`off`)以及键值选项。\n\n## 布尔选项\n\n类似于开关，例如想让Vim中显示行号，可以执行:`:set number`，这就代表开启，如果想要关闭，则可以使用:`:set nonumber` 代表关闭状态，如果不想纠结当前状态，只想切换可以执行:`set number!`，如果想知道当前状态的值，可以执行:`set number?`，这样可以看到选项的值。\n\n## 键值选项\n\n有些选项，比不是像布尔选项只有两种状态，它们可能会有一个不固定的值，例如改变行号宽度的选项`numberwidth` ，如果我们想查看`numberwidth` 的值，可以执行`set numberwidth?`。\n\n## 一次性设置多个选项\n\n前面我们一直在使用`:set`命令设置单个选项的值，不过`:set`命令还允许一次设置多个选项的值。\n\n```\n:set numberwidth=2\n:set nonumber\n```\n\n可以写成:`set numberwidth=2 nonumber` \n\n## 练习\n\n**'number'的帮助文档:** 在每行前显示行号。\n\n**relativenumber的帮助文档:** 在每行前显示相对于光标所在行的行号。布尔型选项\n\n> 建议开启这个选项，它可以让你在上下移动光标时不需要动脑子去算。\n\n**numberwidth的帮助文档:** 键值选项，该选项可以设置行号的列数，Vim中默认为4，也就是说当行号超过9999则会自动扩容。\n\n**wrap的帮助文档:** 布尔选项，该选项的作用是自动换行，默认打开。\n\n**shiftround的帮助文档:** 布尔选项，表示没看太懂，文档内是说将缩进取整为`shiftwidth` 的倍数。这个是命令是应用于`> 和 <` 命令的\n\n**matchtime的帮助文档:** 键值型选项，默认值为5，作用是设置配对括号的时间。\n\n# 基本映射\n\n从这一章节开始，逐渐变得有趣起来。\n\n映射是数学中一个有趣的概念，而在VimScript中，键盘的映射也是非常重要且能让Vim随你心意的一个重要概念，因为你可以通过键盘映射告诉Vim: `当我按下某组键位时，则执行某些命令`。\n\n最简单的键盘映射是`map`命令，`map`命令还可以使用特殊字符，**`map`命令不可以映射注释** \n\n## 练习\n\n映射按键`_`，让当前行上移一行。\n\n`:map _ ddkp` \n\n# 模式映射\n\n我们知道Vim中有很多种模式，常见的有:`normal,visual,insert` 而上一章节所学的`map` 命令只能应用在`normal` 模式下。\n\n不过不用担心，VimScript提供了应用在不同模式下的映射，它们是:`nmap,vmap,imap` 分别对应了三种常见的模式。\n\n**注意:在插入模式映射下，Vim只会按你所想去做，所以如果要执行normal模式下的命令，别忘了使用`<Esc>` 退出插入模式再使用.** \n\n## 练习\n\n在insert模式下，可通过按`<C-u>` 将当前光标所在的单词转换成大写格式。\n\n```\n:imap <C-u> <esc>vgU\n```\n\n在normal模式下，按`C-u`将当前光标的单词转换成大写格式。\n\n```\n:nmap <C-u> vwgU\n```\n\n# 精确映射\n\n书上说本章内容会比较难理解，其实很简单..\n\n前面我们学了`map`以及三种模式对应的映射命令，但他们有一个问题，就是如果当前映射的键再次被映射了，那么当我们使用其快捷键时，就会执行原先映射的键，这就是递归。\n\n想要避免递归映射，我们可以使用另一组映射命令，可以使得映射的键不会进行递归。\n\n例如`nmap` 的非递归映射命令是:`nnoremap` 其中的`nore` 应该就是`not recursion`的意思，其他两种模式映射命令也是如此。\n\n**注意:我们应当在任何时候都使用非递归映射，以免递归映射带来的不必要麻烦** \n\n## 练习\n\n**unmap的帮助文档:** unmap是一个系列命令，其作用是在映射命令作用的模式中删除映射，同系列的其他命令还有`nunmap vunmap xunmap sunmap ounmap iunmap lunmap cunmap` 等。\n\n# Leaders\n\nLeaders是Vim中让用户自定义的特殊键位，其作用主要是作为映射键位的前缀键，这样可防止在映射过多快捷键后覆盖的问题。\n\n想要设置leader键，执行命令:`:let mapleader = \"选择你想要的\"`，默认的Leader键为`\\`\n\n## Local Leader\n\n前面所提到的Leader更偏向于全局键位映射，如果我们需要对不同文件类型设置不同的快捷键，则可以使用`Local Leader` 。\n\n想要设置`Local Leader` 的键位，可以执行:`:let maplocalleader = \"<space>\"` 你可以把<space>替换成你想要的。\n\n**本章本小节只是粗略的提了下LocalLeader的作用，后面的章节将会更加详细的介绍。**\n\n## 练习\n\n**mapleader的帮助文档:** 其实也没什么好说的，上面都写完了，这里说一点:`mapleader` 的值仅在定义映射时被使用，就算后面改变'mapleader'也不会影响已经定义过的映射。\n\n**maplocalleader的帮助文档:** 主要就说一两句忠告:在全局插件里应该使用`<Leader>` 而在一个根据文件类型有不同操作的插件里应该使用`<LocalLeader>` ，还有就是`mapleader` 和`maplocalleader` 的值是可以相同的。\n\n# 编辑你的Vimrc文件\n\n这一章算一个小技巧，书中是这么说的：当你在`疯狂编码时` 突然想加点什么到Vimrc中，但是你又必须立刻编辑vimrc以防忘记，并且又不想退出当前文件，以防打断思路，那么本小节将会实现这个小技巧。\n\n## 编辑映射\n\n我们可以在新建一个分屏，然后那个分屏中编辑`vimrc`，通过几个简单的键位，即可实现。\n\n`:nnoremap <Leader>er :vsplit $MYVIMRC<cr>` \n\n这个命令使用快捷键`Leader+e+r` 实现新建一个`纵向分屏` 并且在纵向分屏中打开`$MYVIM` ，注意最后的`<cr>` 代表回车，你们可以试下去掉会`<cr>`发生什么。\n\n## 重读映射配置\n\n当我们添加完即刻所想的idea后，我们还需要重载配置文件，但还是需要再次拼写那长长的命令，所以我们直接通过精确键盘映射完成重读映射，在多次使用后，重读一次配置文件的时间不超过`0.2秒` \n\n`:nnoremap <Leader>sr :source $MYVIMRC<CR>` \n\n## 练习\n\n说让我添加一些没意义的映射...那好吧，我想要快速执行外部命令，并将外部命令的输出插入到当前文本中。\n\n我要执行的外部程序是:`figlet` ，这是一个可以将字符转化为字符画的一个小程序，那么我可以这样映射。\n\n`:nnoremap <Leader>fl :r !figlet ` \n\n这样当我按下`<Leader>+f+l` 这个键盘映射后将会自动帮我输入我映射的值，然后等到我输入一些内容，按下回车后就会将figlet的执行结果插入到当前文本中。\n\n**myvimrc的帮助文档:** 文档中说，`$MYVIMRC` 是一个环境变量，这个环境变量指向的是`vimrc` 文件，这个文件用于VIM启动时的初始化。并且这个环境变量如果没有被设置或使用VIMINIT则会从5个地方开始查找，分别是`1. 环境变量$VIMINIT 2.用户vimrc文件 3.环境变量$EXINIT 4.用户exrc文件 5. 默认的vimrc文件(位于$VIMRUNTIME/defaults.vim)` \n\n# Abbreviations\n\n`Abbreviations`是Vim中一个灵活且强大的特性，其主要用于`insert replace command` 模式\n\n书里说了，只讲`insert` 模式下的`abbreviations`，简单的说`abbreviations` 就是一个缩写替换，可以自定义一些缩写，当你在`insert` 模式下键入这些缩写就会被替换成事先定义好的值。\n\n`insert` 模式的`abbreviations` 命令是:`iabbrev` 例如:`:ibbrev name8 EvanMeek` ，执行这条命令当我们在插入模式下键入`name8` 并按下空格，Vim的`abbreviations` 特性就会将其替换为我们定义好的`EvanMeek` 。\n\n## Keyword Characters\n\n`Keyword Characters`是`abbreviations` 的一个概念，Vim中有一个`keyword范围列表` 想要查看这个返回列表可以执行命令:`:set iskeyword?` ，你将会看类似`iskeyword=@,48-57,_,192-255` 的结果，这里简单介绍一下，这是一个格式，这个格式包含了如下几种:\n\n- 48-57 其实是ASCII值在48-57之间的字符，也就是数字(0-9)\n\n- 192-255 是ASCII值，代表了一些特殊的ASCII字符\n\n- @ 代表除了小写字母ASCII字母以外的字母\n\n- `_` 以及下划线\n\n为什么说`Keyword Characters`是`Abbreviations` 的概念，因为: 当在插入模式下键入缩写后的后一个字符不包含在`iskeyword` 列表中则会将定义好的全拼替换掉缩写，例如我们敲<space>就不在`iskeyword` 列表中，所以可以替换。\n\n下面举个`abbreviations` 特性的常用例子吧:\n\n```\n:iabbrev em7 email:the_lty_mail@foxmail.com\n```\n\n重载配置文件后，当我们在插入模式下键入em7然后再键入一个非`iskeyword` 列表中的字符，将会替换为`email:the_lty_mail@foxmail.com`。\n\n## 为什么不用Mappings?\n\n其实书上的例子已经很好的解释这个问题了。\n\n首先用mappings做一个替换:`:inoremap lol ILoveLOL`，然后你进入`insert` 模式，键入`你玩不玩lol?` ，此时`lol` 将会被替换为`ILoveLOL` ，让我们用`abbreviations` 特性再做相同的操作。\n\n执行命令:\n\n```\n:iunmap lol\n:iabbrev lol ILoveLOL\n```\n\n现在再试试，你就懂了。\n\n## 练习\n\n为我常用的字符串添加`abbreviations` 特性与配置中。\n\n```\n:iabbrev info email:the_lty_mail@foxmail.com    name:EvanMeek    WebSize:https://evanmeek.github.io\n```\n\n# 更多的Mappings\n\n前面用到了很多多字符的mappings但是我们一直没有提到mappings的连续性。\n\n首先运行如下命令:`:nonoremap jk dd` \n\n当我们处于 normal模式时，快速键入`jk`  Vim则会执行我们映射的 `dd` 命令，当前行被删除了。\n\n现在再试试按`jk`，但是在按下`j` 后等待一会儿，再按下`k` ，我们会发现，Vim不会执行我们所映射的那个命令。这是因为，当我们设置的多字符`mappings`在键入时，如果没有快速连贯的输入，那么Vim就不会识别。\n\n## 一个更为复杂的Mapping\n\n书中是在normal模式下将单词用`\"\"`包住。\n\n运行命令:`nonoremap <LEADER>\" viw<ESC>a\"<ESC>hbi\"<ESC>lel` \n\n现在解释一下:\n\n- `viw` 高亮选中单词\n\n- `<ESC>` 退出visual模式，此时光标会在单词的最后一个字符上\n\n- `a` 移动光标至当前位置后并进入`insert` 模式\n\n- `\"` 插入一个`\"` \n\n- `<ESC>` 退出insert模式，进入normal模式\n\n- `h` 光标左移\n\n- `b` 移动光标至单词头部\n\n- `i` 进入insert模式\n\n- `\"` 键入一个`\"` \n\n- `<ESC>` 返回到normal模式\n\n- `l` 光标右移，置于单词头部\n\n- `e` 移动光标至单词尾部\n\n- `l` 光标右移，置于第一个添加的引号上\n\n需要注意的是:这里是使用`nonoremap` 映射的，而非`nmap` 映射，所以尽管映射的字符已经被映射，Vim也只会讲其中的字符按默认功能执行。\n\n## 练习\n\n创建一个mappings，使用单引号而不是双引号。\n\n`:nonoremap <LEADER>' viw<ESC>a'<ESC>hbi'<ESC>lel` \n\n# 本地缓冲区的选项和映射\n\n如题所示，本章会讲到本地缓冲区，我们将会对本地缓冲区与全局缓冲区做对比。\n\n为了演示，请打开两个文件，例如`file1` 和`file2`，然后输入一些字符。\n\n## 映射\n\n首先，我们打开 `file1` ，然后执行命令:\n\n```\n:nnoremap <LEADER>d dd\n:nnoremap <BUFFER> <LEADER>x dd\n```\n\n现在我们再打开`file2` ，然后使用刚刚映射的快捷键，你会发现第一个映射的快捷键可以使用，但是第二个则不行，现在我们再打开`file1` ，却发现两个快捷键都可以被使用。\n\n好了，现在解释一下这是为什么。首先，我们看到两个映射不同的地方除了映射键以外，第二个映射还多了个`<buffer>` ，这代表了我们当前映射的快捷键只有在当前**缓冲区** 起作用，而当我们切换到另外一个缓冲器，那么自然映射不起作用了。\n\n## 本地Leader\n\n本地Leader的作用是: 更精确的定义映射。\n\n有时我们在使用一些对特殊缓冲区起作用的插件时，为了防止与全局Leader映射起冲突，所以就需要使用本地Leader，也就是`<localleader>` 。\n\n## 设置\n\n前面几个章节我们都是使用`set` 命令进行设置VIM的，但是为了让我们的设置更加精准，在不同特殊缓冲区具有不同的设置时，我们就应该使用本地设置`setlocal` 命令进行设置，下面来看几个例子:\n\n仍然是操作`file1` 和`file2` ，首先，我们打开`file1` 键入命令:`:setlocl wrap` 然后在打开`file2` 键入命令:`:setlocal nowrap` ，然后为两个文件键入长长的一段字符。\n\n你会发现`file1` 是具有自动折行的，而`file2` 却不具备。\n\n**注意:不是所有命令都可以设置setlocl的，如果需要查看命令是否可以设置为`setlock` 那么可以通过命令执行:Help命令查看命令的帮助文档** \n\n## 覆盖\n\n这一小节其实不需要做什么演示，一句话就可以概括:`本地缓冲区命令要比全局缓冲区优先级高，如果本地缓冲区命令与全局缓冲去起了冲突，那么Vim将会忽略全局缓冲区的命令` \n\n## 练习\n\n阅读`:help local-options` \n\n> 写完了两章，结果被Nvim的交换文件给重置了，心态崩了\n\n# 自动命令\n\n自动命令与映射一样重要。\n\n自动命令可以让Vim自动执行某些命令，这些命令会在某些事件触发时执行。\n\n下面看一个例子:\n\n`:autocmd BufNewFile * :write` \n\n输入这条命令，然后使用`:edit` 命令新建一个缓冲区，你会发现会缓冲区会被自动写入进文件了。\n\n下面我们就来解释一下。\n\n## 自动命令结构\n\n先讲一下自动命令结构，你就可以很清晰的了解自动命令为什么能做到监听事件了。\n\n`:autocmd BufNewFile * :write` \n\n- BufNewFile 代表要监听的“事件”\n\n- * 代表事件过滤的“模式（pattern）”\n\n- :write 代表要执行的命令。\n\n这条命令的实际上做的事是:\n\n1. 当Vim监听到`BufNewFile` 这个事件后,\n\n2. 对所有类型的文件，因为过滤模式是`*` ,\n\n3. 执行`:write` 命令。\n\n另一个栗子:\n\n`:autocmd BufNewFile *.txt :write` \n\n这个例子是将事件过滤模式改为了`*.txt` ，代表只有新建缓冲区的文件类型为`txt` 才会触发这个自动命令。\n\n## 多个事件\n\n一个自动命令可以绑定多个事件，多个事件之间由逗号分隔开。\n\n例如:\n\n`:autocmd BufWritePre,BufRead *.html :normal gg=G` \n\n这个自动命令将会在文件类型为`html` 的缓冲区写入文件时或者读入文件类型为`html` 类型的文件至缓冲区时进行文本缩进处理。\n\n## FileType事件\n\n`FileType`可以让Vim在设置一个缓冲区的`filetype` 时触发。\n\n见名知意，`filetype` 也就是文件类型的意思。\n\n例如我们要对JavaScript与Python映射快速添加注释的快捷键，但由于两门编程语言的注释语法不同，所以我们就可以根据`FileType`  的值设置不同的文件，定义不同的映射。\n\n```\n:autocmd FileType javascript nnoremap <buffer> <localleader>c I//<ESC>\n:autocmd FileType python nnoremap <buffer> <localleader>c I#<ESC>\n```\n\n# 本地缓冲区缩写\n\n本章很简单，只是将缩写添加一个范围限制。\n\n首先，我们执行命令:`:iabbrev <buffer> --- Hello` \n\n再进入插入模式，键入`Hello --- World` \n\n我们发现，`---` 被替换为了`Hello` ，这没什么新鲜的，但是当我们打开另一个缓冲区，将会发现这个缩写不起作用了，因为这个缩写是`local iabbrev` \n\n# 自动命令组\n\n前面几章，我们学习了自动命令，但其实他在某些场景下仍然有些问题。\n\n例如，先执行命令:`:autocmd BufWrite * :echom \"Writing buffer\"` \n\n然后使用`:write` 命令将当前缓冲区写入文件，然后执行`:messages` 命令查看消息日志。你当然会看见`Writing buffer` 在消息列表中。\n\n然后重复上面的操作，我们将会看到`Writing buffer` 在消息列表出现了两次，如果我们再执行上面的自动命令`:autocmd BufWrite * :echom \"Writing buffer\"` ，然后再重复刚刚的操作，你将会看到`Writing buffer` 出现了4次.\n\n这样是有问题的，因为自动命令被重复设置了，因为Vim不知道你是想替换前面设置的自动命令。\n\n## 这会有什么问题?\n\n直接说吧，这样会影响Vim的启动速度，因为你的命令通常都是写在`~/.vimrc` 下，但是每次启动`Vim` 时，都会加载`vimrc` ，而这些重复的自动命令将会大大降低Vim的启动速度。\n\n你可以执行下面的命令，模拟延迟情况。 \n\n`:autocmd BufWrite * :sleep 200m` \n\n如果还不够，你可以多执行几次。\n\n**键入:** `:autocmd!` 以取消所有的自动命令。\n\n## 把自动命令放到组中(Grouping Autocommands)\n\n上面的问题，可以通过将自动命令放入一个组内解决。\n\n例如:\n\n```\naugroup testGroup\n  autocmd BUfWrite * :echom \"Write ONE\"\n  autocmd BUfWrite * :echom \"Write TWO\"\naugroup END\n```\n中间的两行缩进可以省略。\n\n现在试试将缓冲区写入文件，然后查看消息列表。然后再执行如下命令:\n\n```\naugroup testGroup\n  autocmd BUfWrite * :echom \"Write THREE\"\naugroup END\n```\n\n现在再将缓冲区写入文件，然后查看消息列表，于是，操蛋的事就发生了。。。\n\n## 清楚自动命令组\n\n你以为定义相同的自动命令组将会自动替换，但其实不是。。。\n\n为了解决这个问题，所以你最好这么做:\n\n```\n:augroup testGroup\n:autocmd!\n:autocmd BUfWrite * :echom \"Write FOUR\"\n:augroup END\n```\n\n请注意,autocmd!，这将会把当前组内的自动命令都先清空，然后再定义新的自动命令。\n\n你现在可以试试还会不会有:`Write ONE TWO ... ` 等信息\n\n# Operator-Pending映射\n","source":"_posts/读《笨方法学习VimScript》所学.md","raw":"---\ntitle: 读《笨方法学习VimScript》所学\ncopyright: true\ndate: 2019-09-27 18:26:16\ncategories: 学习记录\ntags:\n\n  - Vim\n---\n\n身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。\n\n<!--more-->\n\n# 为什么选择这本书?\n\n&emsp;首先，我是一个重度Vim用户，目前记笔记，写代码等操作都是在Vim中实现的，为了让这个强大的古老神器能在我手上发挥巨大威力，所以我决定看书学习Vim。而这本书的前言说的就很好，第一句则是`程序猿们很喜欢实现自己的idea`，虽然我现在只是一名学生，但在我日常生活中经常想把自己使用Vim时的好点子加入我的`vimrc` 中。再就是这本书的`每章都只讲述一个主题，虽然内容简短但是信息丰富`，这样我很喜欢，没有过多啰嗦的地方，有些地方这本书更推荐看Vim自带的文档，这样也让读者有一个自我理解与学习的过程，就像书中所说`现实世界中事情的进展并不是遇到问题后可以很快速轻松的解决`。\n\n# 前言\n\n所提到的都是这本书是面向谁的，以及读完这本书能获得些什么，并且给了一些学习时的忠告，最后提醒了要多利用`:help`命令.\n\n# 预备知识\n\n这本书主要讲VimScript所以，在学习VimScript之前，得了解Vim的基本使用，例如`buffer,window,normal mode,insert mode,text mode`。\n\n最好是具有编程经验。\n\n本书基于Vim-7.3版本撰写的，所以读者需要确保系统安装了>=7.3版本的Vim。\n\n## 创建Vimrc文件\n\n这一节没有提到`Vimrc` 是什么，我这里提一下，是`Vimrc`一个文件，文件内的可以写vim的命令，而写在`Vimrc` 中的命令都被称为Ex命令，Ex命令不是这一小节的讨论范围。\n\n主要说到在Linux或Mac OS X中，这个文件位于`home`目录下，并且是以`.vimrc`命名的，而在Windows下则是位于`home`文件夹下，并以`_vimrc`命名。\n\n以上三个系统，都可以在Vim中通过执行`:echo $MYVIMRC`得知此文件的位置等信息。\n\n**注意:若你没有找到此文件，请自行创建** \n\n# 打印信息\n\n主要提到Vim中打印命令和注释的使用与作用。\n\nVim中的打印命令有:`echo` 和`echom` ，其区别在于:\n\n- echo 仅仅输出回显表达式结果。\n\n  > 回显表达式\n\n  `echo {expr1}` 其中{expr1}就是回显表达式\n- echom 输出回显表达式结果，并且将其存储在`message-history` 内\n\n  > message-history\n\n  `message-history` 是消息历史，可以通过命令查看`:messages` \n\n## 注释\n\nVimScript可以通过`\"` 字符添加注释，就像这样:\n\n```\n\" 将<space>映射为za\nnnoremap <space> za\n```\n\n# 设置选项\n\nVim中有两种选型: 布尔选项(`on` 或`off`)以及键值选项。\n\n## 布尔选项\n\n类似于开关，例如想让Vim中显示行号，可以执行:`:set number`，这就代表开启，如果想要关闭，则可以使用:`:set nonumber` 代表关闭状态，如果不想纠结当前状态，只想切换可以执行:`set number!`，如果想知道当前状态的值，可以执行:`set number?`，这样可以看到选项的值。\n\n## 键值选项\n\n有些选项，比不是像布尔选项只有两种状态，它们可能会有一个不固定的值，例如改变行号宽度的选项`numberwidth` ，如果我们想查看`numberwidth` 的值，可以执行`set numberwidth?`。\n\n## 一次性设置多个选项\n\n前面我们一直在使用`:set`命令设置单个选项的值，不过`:set`命令还允许一次设置多个选项的值。\n\n```\n:set numberwidth=2\n:set nonumber\n```\n\n可以写成:`set numberwidth=2 nonumber` \n\n## 练习\n\n**'number'的帮助文档:** 在每行前显示行号。\n\n**relativenumber的帮助文档:** 在每行前显示相对于光标所在行的行号。布尔型选项\n\n> 建议开启这个选项，它可以让你在上下移动光标时不需要动脑子去算。\n\n**numberwidth的帮助文档:** 键值选项，该选项可以设置行号的列数，Vim中默认为4，也就是说当行号超过9999则会自动扩容。\n\n**wrap的帮助文档:** 布尔选项，该选项的作用是自动换行，默认打开。\n\n**shiftround的帮助文档:** 布尔选项，表示没看太懂，文档内是说将缩进取整为`shiftwidth` 的倍数。这个是命令是应用于`> 和 <` 命令的\n\n**matchtime的帮助文档:** 键值型选项，默认值为5，作用是设置配对括号的时间。\n\n# 基本映射\n\n从这一章节开始，逐渐变得有趣起来。\n\n映射是数学中一个有趣的概念，而在VimScript中，键盘的映射也是非常重要且能让Vim随你心意的一个重要概念，因为你可以通过键盘映射告诉Vim: `当我按下某组键位时，则执行某些命令`。\n\n最简单的键盘映射是`map`命令，`map`命令还可以使用特殊字符，**`map`命令不可以映射注释** \n\n## 练习\n\n映射按键`_`，让当前行上移一行。\n\n`:map _ ddkp` \n\n# 模式映射\n\n我们知道Vim中有很多种模式，常见的有:`normal,visual,insert` 而上一章节所学的`map` 命令只能应用在`normal` 模式下。\n\n不过不用担心，VimScript提供了应用在不同模式下的映射，它们是:`nmap,vmap,imap` 分别对应了三种常见的模式。\n\n**注意:在插入模式映射下，Vim只会按你所想去做，所以如果要执行normal模式下的命令，别忘了使用`<Esc>` 退出插入模式再使用.** \n\n## 练习\n\n在insert模式下，可通过按`<C-u>` 将当前光标所在的单词转换成大写格式。\n\n```\n:imap <C-u> <esc>vgU\n```\n\n在normal模式下，按`C-u`将当前光标的单词转换成大写格式。\n\n```\n:nmap <C-u> vwgU\n```\n\n# 精确映射\n\n书上说本章内容会比较难理解，其实很简单..\n\n前面我们学了`map`以及三种模式对应的映射命令，但他们有一个问题，就是如果当前映射的键再次被映射了，那么当我们使用其快捷键时，就会执行原先映射的键，这就是递归。\n\n想要避免递归映射，我们可以使用另一组映射命令，可以使得映射的键不会进行递归。\n\n例如`nmap` 的非递归映射命令是:`nnoremap` 其中的`nore` 应该就是`not recursion`的意思，其他两种模式映射命令也是如此。\n\n**注意:我们应当在任何时候都使用非递归映射，以免递归映射带来的不必要麻烦** \n\n## 练习\n\n**unmap的帮助文档:** unmap是一个系列命令，其作用是在映射命令作用的模式中删除映射，同系列的其他命令还有`nunmap vunmap xunmap sunmap ounmap iunmap lunmap cunmap` 等。\n\n# Leaders\n\nLeaders是Vim中让用户自定义的特殊键位，其作用主要是作为映射键位的前缀键，这样可防止在映射过多快捷键后覆盖的问题。\n\n想要设置leader键，执行命令:`:let mapleader = \"选择你想要的\"`，默认的Leader键为`\\`\n\n## Local Leader\n\n前面所提到的Leader更偏向于全局键位映射，如果我们需要对不同文件类型设置不同的快捷键，则可以使用`Local Leader` 。\n\n想要设置`Local Leader` 的键位，可以执行:`:let maplocalleader = \"<space>\"` 你可以把<space>替换成你想要的。\n\n**本章本小节只是粗略的提了下LocalLeader的作用，后面的章节将会更加详细的介绍。**\n\n## 练习\n\n**mapleader的帮助文档:** 其实也没什么好说的，上面都写完了，这里说一点:`mapleader` 的值仅在定义映射时被使用，就算后面改变'mapleader'也不会影响已经定义过的映射。\n\n**maplocalleader的帮助文档:** 主要就说一两句忠告:在全局插件里应该使用`<Leader>` 而在一个根据文件类型有不同操作的插件里应该使用`<LocalLeader>` ，还有就是`mapleader` 和`maplocalleader` 的值是可以相同的。\n\n# 编辑你的Vimrc文件\n\n这一章算一个小技巧，书中是这么说的：当你在`疯狂编码时` 突然想加点什么到Vimrc中，但是你又必须立刻编辑vimrc以防忘记，并且又不想退出当前文件，以防打断思路，那么本小节将会实现这个小技巧。\n\n## 编辑映射\n\n我们可以在新建一个分屏，然后那个分屏中编辑`vimrc`，通过几个简单的键位，即可实现。\n\n`:nnoremap <Leader>er :vsplit $MYVIMRC<cr>` \n\n这个命令使用快捷键`Leader+e+r` 实现新建一个`纵向分屏` 并且在纵向分屏中打开`$MYVIM` ，注意最后的`<cr>` 代表回车，你们可以试下去掉会`<cr>`发生什么。\n\n## 重读映射配置\n\n当我们添加完即刻所想的idea后，我们还需要重载配置文件，但还是需要再次拼写那长长的命令，所以我们直接通过精确键盘映射完成重读映射，在多次使用后，重读一次配置文件的时间不超过`0.2秒` \n\n`:nnoremap <Leader>sr :source $MYVIMRC<CR>` \n\n## 练习\n\n说让我添加一些没意义的映射...那好吧，我想要快速执行外部命令，并将外部命令的输出插入到当前文本中。\n\n我要执行的外部程序是:`figlet` ，这是一个可以将字符转化为字符画的一个小程序，那么我可以这样映射。\n\n`:nnoremap <Leader>fl :r !figlet ` \n\n这样当我按下`<Leader>+f+l` 这个键盘映射后将会自动帮我输入我映射的值，然后等到我输入一些内容，按下回车后就会将figlet的执行结果插入到当前文本中。\n\n**myvimrc的帮助文档:** 文档中说，`$MYVIMRC` 是一个环境变量，这个环境变量指向的是`vimrc` 文件，这个文件用于VIM启动时的初始化。并且这个环境变量如果没有被设置或使用VIMINIT则会从5个地方开始查找，分别是`1. 环境变量$VIMINIT 2.用户vimrc文件 3.环境变量$EXINIT 4.用户exrc文件 5. 默认的vimrc文件(位于$VIMRUNTIME/defaults.vim)` \n\n# Abbreviations\n\n`Abbreviations`是Vim中一个灵活且强大的特性，其主要用于`insert replace command` 模式\n\n书里说了，只讲`insert` 模式下的`abbreviations`，简单的说`abbreviations` 就是一个缩写替换，可以自定义一些缩写，当你在`insert` 模式下键入这些缩写就会被替换成事先定义好的值。\n\n`insert` 模式的`abbreviations` 命令是:`iabbrev` 例如:`:ibbrev name8 EvanMeek` ，执行这条命令当我们在插入模式下键入`name8` 并按下空格，Vim的`abbreviations` 特性就会将其替换为我们定义好的`EvanMeek` 。\n\n## Keyword Characters\n\n`Keyword Characters`是`abbreviations` 的一个概念，Vim中有一个`keyword范围列表` 想要查看这个返回列表可以执行命令:`:set iskeyword?` ，你将会看类似`iskeyword=@,48-57,_,192-255` 的结果，这里简单介绍一下，这是一个格式，这个格式包含了如下几种:\n\n- 48-57 其实是ASCII值在48-57之间的字符，也就是数字(0-9)\n\n- 192-255 是ASCII值，代表了一些特殊的ASCII字符\n\n- @ 代表除了小写字母ASCII字母以外的字母\n\n- `_` 以及下划线\n\n为什么说`Keyword Characters`是`Abbreviations` 的概念，因为: 当在插入模式下键入缩写后的后一个字符不包含在`iskeyword` 列表中则会将定义好的全拼替换掉缩写，例如我们敲<space>就不在`iskeyword` 列表中，所以可以替换。\n\n下面举个`abbreviations` 特性的常用例子吧:\n\n```\n:iabbrev em7 email:the_lty_mail@foxmail.com\n```\n\n重载配置文件后，当我们在插入模式下键入em7然后再键入一个非`iskeyword` 列表中的字符，将会替换为`email:the_lty_mail@foxmail.com`。\n\n## 为什么不用Mappings?\n\n其实书上的例子已经很好的解释这个问题了。\n\n首先用mappings做一个替换:`:inoremap lol ILoveLOL`，然后你进入`insert` 模式，键入`你玩不玩lol?` ，此时`lol` 将会被替换为`ILoveLOL` ，让我们用`abbreviations` 特性再做相同的操作。\n\n执行命令:\n\n```\n:iunmap lol\n:iabbrev lol ILoveLOL\n```\n\n现在再试试，你就懂了。\n\n## 练习\n\n为我常用的字符串添加`abbreviations` 特性与配置中。\n\n```\n:iabbrev info email:the_lty_mail@foxmail.com    name:EvanMeek    WebSize:https://evanmeek.github.io\n```\n\n# 更多的Mappings\n\n前面用到了很多多字符的mappings但是我们一直没有提到mappings的连续性。\n\n首先运行如下命令:`:nonoremap jk dd` \n\n当我们处于 normal模式时，快速键入`jk`  Vim则会执行我们映射的 `dd` 命令，当前行被删除了。\n\n现在再试试按`jk`，但是在按下`j` 后等待一会儿，再按下`k` ，我们会发现，Vim不会执行我们所映射的那个命令。这是因为，当我们设置的多字符`mappings`在键入时，如果没有快速连贯的输入，那么Vim就不会识别。\n\n## 一个更为复杂的Mapping\n\n书中是在normal模式下将单词用`\"\"`包住。\n\n运行命令:`nonoremap <LEADER>\" viw<ESC>a\"<ESC>hbi\"<ESC>lel` \n\n现在解释一下:\n\n- `viw` 高亮选中单词\n\n- `<ESC>` 退出visual模式，此时光标会在单词的最后一个字符上\n\n- `a` 移动光标至当前位置后并进入`insert` 模式\n\n- `\"` 插入一个`\"` \n\n- `<ESC>` 退出insert模式，进入normal模式\n\n- `h` 光标左移\n\n- `b` 移动光标至单词头部\n\n- `i` 进入insert模式\n\n- `\"` 键入一个`\"` \n\n- `<ESC>` 返回到normal模式\n\n- `l` 光标右移，置于单词头部\n\n- `e` 移动光标至单词尾部\n\n- `l` 光标右移，置于第一个添加的引号上\n\n需要注意的是:这里是使用`nonoremap` 映射的，而非`nmap` 映射，所以尽管映射的字符已经被映射，Vim也只会讲其中的字符按默认功能执行。\n\n## 练习\n\n创建一个mappings，使用单引号而不是双引号。\n\n`:nonoremap <LEADER>' viw<ESC>a'<ESC>hbi'<ESC>lel` \n\n# 本地缓冲区的选项和映射\n\n如题所示，本章会讲到本地缓冲区，我们将会对本地缓冲区与全局缓冲区做对比。\n\n为了演示，请打开两个文件，例如`file1` 和`file2`，然后输入一些字符。\n\n## 映射\n\n首先，我们打开 `file1` ，然后执行命令:\n\n```\n:nnoremap <LEADER>d dd\n:nnoremap <BUFFER> <LEADER>x dd\n```\n\n现在我们再打开`file2` ，然后使用刚刚映射的快捷键，你会发现第一个映射的快捷键可以使用，但是第二个则不行，现在我们再打开`file1` ，却发现两个快捷键都可以被使用。\n\n好了，现在解释一下这是为什么。首先，我们看到两个映射不同的地方除了映射键以外，第二个映射还多了个`<buffer>` ，这代表了我们当前映射的快捷键只有在当前**缓冲区** 起作用，而当我们切换到另外一个缓冲器，那么自然映射不起作用了。\n\n## 本地Leader\n\n本地Leader的作用是: 更精确的定义映射。\n\n有时我们在使用一些对特殊缓冲区起作用的插件时，为了防止与全局Leader映射起冲突，所以就需要使用本地Leader，也就是`<localleader>` 。\n\n## 设置\n\n前面几个章节我们都是使用`set` 命令进行设置VIM的，但是为了让我们的设置更加精准，在不同特殊缓冲区具有不同的设置时，我们就应该使用本地设置`setlocal` 命令进行设置，下面来看几个例子:\n\n仍然是操作`file1` 和`file2` ，首先，我们打开`file1` 键入命令:`:setlocl wrap` 然后在打开`file2` 键入命令:`:setlocal nowrap` ，然后为两个文件键入长长的一段字符。\n\n你会发现`file1` 是具有自动折行的，而`file2` 却不具备。\n\n**注意:不是所有命令都可以设置setlocl的，如果需要查看命令是否可以设置为`setlock` 那么可以通过命令执行:Help命令查看命令的帮助文档** \n\n## 覆盖\n\n这一小节其实不需要做什么演示，一句话就可以概括:`本地缓冲区命令要比全局缓冲区优先级高，如果本地缓冲区命令与全局缓冲去起了冲突，那么Vim将会忽略全局缓冲区的命令` \n\n## 练习\n\n阅读`:help local-options` \n\n> 写完了两章，结果被Nvim的交换文件给重置了，心态崩了\n\n# 自动命令\n\n自动命令与映射一样重要。\n\n自动命令可以让Vim自动执行某些命令，这些命令会在某些事件触发时执行。\n\n下面看一个例子:\n\n`:autocmd BufNewFile * :write` \n\n输入这条命令，然后使用`:edit` 命令新建一个缓冲区，你会发现会缓冲区会被自动写入进文件了。\n\n下面我们就来解释一下。\n\n## 自动命令结构\n\n先讲一下自动命令结构，你就可以很清晰的了解自动命令为什么能做到监听事件了。\n\n`:autocmd BufNewFile * :write` \n\n- BufNewFile 代表要监听的“事件”\n\n- * 代表事件过滤的“模式（pattern）”\n\n- :write 代表要执行的命令。\n\n这条命令的实际上做的事是:\n\n1. 当Vim监听到`BufNewFile` 这个事件后,\n\n2. 对所有类型的文件，因为过滤模式是`*` ,\n\n3. 执行`:write` 命令。\n\n另一个栗子:\n\n`:autocmd BufNewFile *.txt :write` \n\n这个例子是将事件过滤模式改为了`*.txt` ，代表只有新建缓冲区的文件类型为`txt` 才会触发这个自动命令。\n\n## 多个事件\n\n一个自动命令可以绑定多个事件，多个事件之间由逗号分隔开。\n\n例如:\n\n`:autocmd BufWritePre,BufRead *.html :normal gg=G` \n\n这个自动命令将会在文件类型为`html` 的缓冲区写入文件时或者读入文件类型为`html` 类型的文件至缓冲区时进行文本缩进处理。\n\n## FileType事件\n\n`FileType`可以让Vim在设置一个缓冲区的`filetype` 时触发。\n\n见名知意，`filetype` 也就是文件类型的意思。\n\n例如我们要对JavaScript与Python映射快速添加注释的快捷键，但由于两门编程语言的注释语法不同，所以我们就可以根据`FileType`  的值设置不同的文件，定义不同的映射。\n\n```\n:autocmd FileType javascript nnoremap <buffer> <localleader>c I//<ESC>\n:autocmd FileType python nnoremap <buffer> <localleader>c I#<ESC>\n```\n\n# 本地缓冲区缩写\n\n本章很简单，只是将缩写添加一个范围限制。\n\n首先，我们执行命令:`:iabbrev <buffer> --- Hello` \n\n再进入插入模式，键入`Hello --- World` \n\n我们发现，`---` 被替换为了`Hello` ，这没什么新鲜的，但是当我们打开另一个缓冲区，将会发现这个缩写不起作用了，因为这个缩写是`local iabbrev` \n\n# 自动命令组\n\n前面几章，我们学习了自动命令，但其实他在某些场景下仍然有些问题。\n\n例如，先执行命令:`:autocmd BufWrite * :echom \"Writing buffer\"` \n\n然后使用`:write` 命令将当前缓冲区写入文件，然后执行`:messages` 命令查看消息日志。你当然会看见`Writing buffer` 在消息列表中。\n\n然后重复上面的操作，我们将会看到`Writing buffer` 在消息列表出现了两次，如果我们再执行上面的自动命令`:autocmd BufWrite * :echom \"Writing buffer\"` ，然后再重复刚刚的操作，你将会看到`Writing buffer` 出现了4次.\n\n这样是有问题的，因为自动命令被重复设置了，因为Vim不知道你是想替换前面设置的自动命令。\n\n## 这会有什么问题?\n\n直接说吧，这样会影响Vim的启动速度，因为你的命令通常都是写在`~/.vimrc` 下，但是每次启动`Vim` 时，都会加载`vimrc` ，而这些重复的自动命令将会大大降低Vim的启动速度。\n\n你可以执行下面的命令，模拟延迟情况。 \n\n`:autocmd BufWrite * :sleep 200m` \n\n如果还不够，你可以多执行几次。\n\n**键入:** `:autocmd!` 以取消所有的自动命令。\n\n## 把自动命令放到组中(Grouping Autocommands)\n\n上面的问题，可以通过将自动命令放入一个组内解决。\n\n例如:\n\n```\naugroup testGroup\n  autocmd BUfWrite * :echom \"Write ONE\"\n  autocmd BUfWrite * :echom \"Write TWO\"\naugroup END\n```\n中间的两行缩进可以省略。\n\n现在试试将缓冲区写入文件，然后查看消息列表。然后再执行如下命令:\n\n```\naugroup testGroup\n  autocmd BUfWrite * :echom \"Write THREE\"\naugroup END\n```\n\n现在再将缓冲区写入文件，然后查看消息列表，于是，操蛋的事就发生了。。。\n\n## 清楚自动命令组\n\n你以为定义相同的自动命令组将会自动替换，但其实不是。。。\n\n为了解决这个问题，所以你最好这么做:\n\n```\n:augroup testGroup\n:autocmd!\n:autocmd BUfWrite * :echom \"Write FOUR\"\n:augroup END\n```\n\n请注意,autocmd!，这将会把当前组内的自动命令都先清空，然后再定义新的自动命令。\n\n你现在可以试试还会不会有:`Write ONE TWO ... ` 等信息\n\n# Operator-Pending映射\n","slug":"读《笨方法学习VimScript》所学","published":1,"updated":"2020-01-19T03:49:51.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5oozodk006somoo59inyfck","content":"<p>身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。</p>\n<a id=\"more\"></a>\n<h1 id=\"为什么选择这本书\"><a href=\"#为什么选择这本书\" class=\"headerlink\" title=\"为什么选择这本书?\"></a>为什么选择这本书?</h1><p>&emsp;首先，我是一个重度Vim用户，目前记笔记，写代码等操作都是在Vim中实现的，为了让这个强大的古老神器能在我手上发挥巨大威力，所以我决定看书学习Vim。而这本书的前言说的就很好，第一句则是<code>程序猿们很喜欢实现自己的idea</code>，虽然我现在只是一名学生，但在我日常生活中经常想把自己使用Vim时的好点子加入我的<code>vimrc</code> 中。再就是这本书的<code>每章都只讲述一个主题，虽然内容简短但是信息丰富</code>，这样我很喜欢，没有过多啰嗦的地方，有些地方这本书更推荐看Vim自带的文档，这样也让读者有一个自我理解与学习的过程，就像书中所说<code>现实世界中事情的进展并不是遇到问题后可以很快速轻松的解决</code>。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>所提到的都是这本书是面向谁的，以及读完这本书能获得些什么，并且给了一些学习时的忠告，最后提醒了要多利用<code>:help</code>命令.</p>\n<h1 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h1><p>这本书主要讲VimScript所以，在学习VimScript之前，得了解Vim的基本使用，例如<code>buffer,window,normal mode,insert mode,text mode</code>。</p>\n<p>最好是具有编程经验。</p>\n<p>本书基于Vim-7.3版本撰写的，所以读者需要确保系统安装了&gt;=7.3版本的Vim。</p>\n<h2 id=\"创建Vimrc文件\"><a href=\"#创建Vimrc文件\" class=\"headerlink\" title=\"创建Vimrc文件\"></a>创建Vimrc文件</h2><p>这一节没有提到<code>Vimrc</code> 是什么，我这里提一下，是<code>Vimrc</code>一个文件，文件内的可以写vim的命令，而写在<code>Vimrc</code> 中的命令都被称为Ex命令，Ex命令不是这一小节的讨论范围。</p>\n<p>主要说到在Linux或Mac OS X中，这个文件位于<code>home</code>目录下，并且是以<code>.vimrc</code>命名的，而在Windows下则是位于<code>home</code>文件夹下，并以<code>_vimrc</code>命名。</p>\n<p>以上三个系统，都可以在Vim中通过执行<code>:echo $MYVIMRC</code>得知此文件的位置等信息。</p>\n<p><strong>注意:若你没有找到此文件，请自行创建</strong> </p>\n<h1 id=\"打印信息\"><a href=\"#打印信息\" class=\"headerlink\" title=\"打印信息\"></a>打印信息</h1><p>主要提到Vim中打印命令和注释的使用与作用。</p>\n<p>Vim中的打印命令有:<code>echo</code> 和<code>echom</code> ，其区别在于:</p>\n<ul>\n<li><p>echo 仅仅输出回显表达式结果。</p>\n<blockquote>\n<p>回显表达式</p>\n</blockquote>\n<p><code>echo {expr1}</code> 其中{expr1}就是回显表达式</p>\n</li>\n<li><p>echom 输出回显表达式结果，并且将其存储在<code>message-history</code> 内</p>\n<blockquote>\n<p>message-history</p>\n</blockquote>\n<p><code>message-history</code> 是消息历史，可以通过命令查看<code>:messages</code> </p>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>VimScript可以通过<code>&quot;</code> 字符添加注释，就像这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot; 将&lt;space&gt;映射为za</span><br><span class=\"line\">nnoremap &lt;space&gt; za</span><br></pre></td></tr></table></figure>\n<h1 id=\"设置选项\"><a href=\"#设置选项\" class=\"headerlink\" title=\"设置选项\"></a>设置选项</h1><p>Vim中有两种选型: 布尔选项(<code>on</code> 或<code>off</code>)以及键值选项。</p>\n<h2 id=\"布尔选项\"><a href=\"#布尔选项\" class=\"headerlink\" title=\"布尔选项\"></a>布尔选项</h2><p>类似于开关，例如想让Vim中显示行号，可以执行:<code>:set number</code>，这就代表开启，如果想要关闭，则可以使用:<code>:set nonumber</code> 代表关闭状态，如果不想纠结当前状态，只想切换可以执行:<code>set number!</code>，如果想知道当前状态的值，可以执行:<code>set number?</code>，这样可以看到选项的值。</p>\n<h2 id=\"键值选项\"><a href=\"#键值选项\" class=\"headerlink\" title=\"键值选项\"></a>键值选项</h2><p>有些选项，比不是像布尔选项只有两种状态，它们可能会有一个不固定的值，例如改变行号宽度的选项<code>numberwidth</code> ，如果我们想查看<code>numberwidth</code> 的值，可以执行<code>set numberwidth?</code>。</p>\n<h2 id=\"一次性设置多个选项\"><a href=\"#一次性设置多个选项\" class=\"headerlink\" title=\"一次性设置多个选项\"></a>一次性设置多个选项</h2><p>前面我们一直在使用<code>:set</code>命令设置单个选项的值，不过<code>:set</code>命令还允许一次设置多个选项的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set numberwidth=2</span><br><span class=\"line\">:set nonumber</span><br></pre></td></tr></table></figure>\n<p>可以写成:<code>set numberwidth=2 nonumber</code> </p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><strong>‘number’的帮助文档:</strong> 在每行前显示行号。</p>\n<p><strong>relativenumber的帮助文档:</strong> 在每行前显示相对于光标所在行的行号。布尔型选项</p>\n<blockquote>\n<p>建议开启这个选项，它可以让你在上下移动光标时不需要动脑子去算。</p>\n</blockquote>\n<p><strong>numberwidth的帮助文档:</strong> 键值选项，该选项可以设置行号的列数，Vim中默认为4，也就是说当行号超过9999则会自动扩容。</p>\n<p><strong>wrap的帮助文档:</strong> 布尔选项，该选项的作用是自动换行，默认打开。</p>\n<p><strong>shiftround的帮助文档:</strong> 布尔选项，表示没看太懂，文档内是说将缩进取整为<code>shiftwidth</code> 的倍数。这个是命令是应用于<code>&gt; 和 &lt;</code> 命令的</p>\n<p><strong>matchtime的帮助文档:</strong> 键值型选项，默认值为5，作用是设置配对括号的时间。</p>\n<h1 id=\"基本映射\"><a href=\"#基本映射\" class=\"headerlink\" title=\"基本映射\"></a>基本映射</h1><p>从这一章节开始，逐渐变得有趣起来。</p>\n<p>映射是数学中一个有趣的概念，而在VimScript中，键盘的映射也是非常重要且能让Vim随你心意的一个重要概念，因为你可以通过键盘映射告诉Vim: <code>当我按下某组键位时，则执行某些命令</code>。</p>\n<p>最简单的键盘映射是<code>map</code>命令，<code>map</code>命令还可以使用特殊字符，<strong><code>map</code>命令不可以映射注释</strong> </p>\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>映射按键<code>_</code>，让当前行上移一行。</p>\n<p><code>:map _ ddkp</code> </p>\n<h1 id=\"模式映射\"><a href=\"#模式映射\" class=\"headerlink\" title=\"模式映射\"></a>模式映射</h1><p>我们知道Vim中有很多种模式，常见的有:<code>normal,visual,insert</code> 而上一章节所学的<code>map</code> 命令只能应用在<code>normal</code> 模式下。</p>\n<p>不过不用担心，VimScript提供了应用在不同模式下的映射，它们是:<code>nmap,vmap,imap</code> 分别对应了三种常见的模式。</p>\n<p><strong>注意:在插入模式映射下，Vim只会按你所想去做，所以如果要执行normal模式下的命令，别忘了使用<code>&lt;Esc&gt;</code> 退出插入模式再使用.</strong> </p>\n<h2 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>在insert模式下，可通过按<code>&lt;C-u&gt;</code> 将当前光标所在的单词转换成大写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:imap &lt;C-u&gt; &lt;esc&gt;vgU</span><br></pre></td></tr></table></figure>\n<p>在normal模式下，按<code>C-u</code>将当前光标的单词转换成大写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:nmap &lt;C-u&gt; vwgU</span><br></pre></td></tr></table></figure>\n<h1 id=\"精确映射\"><a href=\"#精确映射\" class=\"headerlink\" title=\"精确映射\"></a>精确映射</h1><p>书上说本章内容会比较难理解，其实很简单..</p>\n<p>前面我们学了<code>map</code>以及三种模式对应的映射命令，但他们有一个问题，就是如果当前映射的键再次被映射了，那么当我们使用其快捷键时，就会执行原先映射的键，这就是递归。</p>\n<p>想要避免递归映射，我们可以使用另一组映射命令，可以使得映射的键不会进行递归。</p>\n<p>例如<code>nmap</code> 的非递归映射命令是:<code>nnoremap</code> 其中的<code>nore</code> 应该就是<code>not recursion</code>的意思，其他两种模式映射命令也是如此。</p>\n<p><strong>注意:我们应当在任何时候都使用非递归映射，以免递归映射带来的不必要麻烦</strong> </p>\n<h2 id=\"练习-3\"><a href=\"#练习-3\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><strong>unmap的帮助文档:</strong> unmap是一个系列命令，其作用是在映射命令作用的模式中删除映射，同系列的其他命令还有<code>nunmap vunmap xunmap sunmap ounmap iunmap lunmap cunmap</code> 等。</p>\n<h1 id=\"Leaders\"><a href=\"#Leaders\" class=\"headerlink\" title=\"Leaders\"></a>Leaders</h1><p>Leaders是Vim中让用户自定义的特殊键位，其作用主要是作为映射键位的前缀键，这样可防止在映射过多快捷键后覆盖的问题。</p>\n<p>想要设置leader键，执行命令:<code>:let mapleader = &quot;选择你想要的&quot;</code>，默认的Leader键为<code>\\</code></p>\n<h2 id=\"Local-Leader\"><a href=\"#Local-Leader\" class=\"headerlink\" title=\"Local Leader\"></a>Local Leader</h2><p>前面所提到的Leader更偏向于全局键位映射，如果我们需要对不同文件类型设置不同的快捷键，则可以使用<code>Local Leader</code> 。</p>\n<p>想要设置<code>Local Leader</code> 的键位，可以执行:<code>:let maplocalleader = &quot;&lt;space&gt;&quot;</code> 你可以把<space>替换成你想要的。</space></p>\n<p><strong>本章本小节只是粗略的提了下LocalLeader的作用，后面的章节将会更加详细的介绍。</strong></p>\n<h2 id=\"练习-4\"><a href=\"#练习-4\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><strong>mapleader的帮助文档:</strong> 其实也没什么好说的，上面都写完了，这里说一点:<code>mapleader</code> 的值仅在定义映射时被使用，就算后面改变’mapleader’也不会影响已经定义过的映射。</p>\n<p><strong>maplocalleader的帮助文档:</strong> 主要就说一两句忠告:在全局插件里应该使用<code>&lt;Leader&gt;</code> 而在一个根据文件类型有不同操作的插件里应该使用<code>&lt;LocalLeader&gt;</code> ，还有就是<code>mapleader</code> 和<code>maplocalleader</code> 的值是可以相同的。</p>\n<h1 id=\"编辑你的Vimrc文件\"><a href=\"#编辑你的Vimrc文件\" class=\"headerlink\" title=\"编辑你的Vimrc文件\"></a>编辑你的Vimrc文件</h1><p>这一章算一个小技巧，书中是这么说的：当你在<code>疯狂编码时</code> 突然想加点什么到Vimrc中，但是你又必须立刻编辑vimrc以防忘记，并且又不想退出当前文件，以防打断思路，那么本小节将会实现这个小技巧。</p>\n<h2 id=\"编辑映射\"><a href=\"#编辑映射\" class=\"headerlink\" title=\"编辑映射\"></a>编辑映射</h2><p>我们可以在新建一个分屏，然后那个分屏中编辑<code>vimrc</code>，通过几个简单的键位，即可实现。</p>\n<p><code>:nnoremap &lt;Leader&gt;er :vsplit $MYVIMRC&lt;cr&gt;</code> </p>\n<p>这个命令使用快捷键<code>Leader+e+r</code> 实现新建一个<code>纵向分屏</code> 并且在纵向分屏中打开<code>$MYVIM</code> ，注意最后的<code>&lt;cr&gt;</code> 代表回车，你们可以试下去掉会<code>&lt;cr&gt;</code>发生什么。</p>\n<h2 id=\"重读映射配置\"><a href=\"#重读映射配置\" class=\"headerlink\" title=\"重读映射配置\"></a>重读映射配置</h2><p>当我们添加完即刻所想的idea后，我们还需要重载配置文件，但还是需要再次拼写那长长的命令，所以我们直接通过精确键盘映射完成重读映射，在多次使用后，重读一次配置文件的时间不超过<code>0.2秒</code> </p>\n<p><code>:nnoremap &lt;Leader&gt;sr :source $MYVIMRC&lt;CR&gt;</code> </p>\n<h2 id=\"练习-5\"><a href=\"#练习-5\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>说让我添加一些没意义的映射…那好吧，我想要快速执行外部命令，并将外部命令的输出插入到当前文本中。</p>\n<p>我要执行的外部程序是:<code>figlet</code> ，这是一个可以将字符转化为字符画的一个小程序，那么我可以这样映射。</p>\n<p><code>:nnoremap &lt;Leader&gt;fl :r !figlet</code> </p>\n<p>这样当我按下<code>&lt;Leader&gt;+f+l</code> 这个键盘映射后将会自动帮我输入我映射的值，然后等到我输入一些内容，按下回车后就会将figlet的执行结果插入到当前文本中。</p>\n<p><strong>myvimrc的帮助文档:</strong> 文档中说，<code>$MYVIMRC</code> 是一个环境变量，这个环境变量指向的是<code>vimrc</code> 文件，这个文件用于VIM启动时的初始化。并且这个环境变量如果没有被设置或使用VIMINIT则会从5个地方开始查找，分别是<code>1. 环境变量$VIMINIT 2.用户vimrc文件 3.环境变量$EXINIT 4.用户exrc文件 5. 默认的vimrc文件(位于$VIMRUNTIME/defaults.vim)</code> </p>\n<h1 id=\"Abbreviations\"><a href=\"#Abbreviations\" class=\"headerlink\" title=\"Abbreviations\"></a>Abbreviations</h1><p><code>Abbreviations</code>是Vim中一个灵活且强大的特性，其主要用于<code>insert replace command</code> 模式</p>\n<p>书里说了，只讲<code>insert</code> 模式下的<code>abbreviations</code>，简单的说<code>abbreviations</code> 就是一个缩写替换，可以自定义一些缩写，当你在<code>insert</code> 模式下键入这些缩写就会被替换成事先定义好的值。</p>\n<p><code>insert</code> 模式的<code>abbreviations</code> 命令是:<code>iabbrev</code> 例如:<code>:ibbrev name8 EvanMeek</code> ，执行这条命令当我们在插入模式下键入<code>name8</code> 并按下空格，Vim的<code>abbreviations</code> 特性就会将其替换为我们定义好的<code>EvanMeek</code> 。</p>\n<h2 id=\"Keyword-Characters\"><a href=\"#Keyword-Characters\" class=\"headerlink\" title=\"Keyword Characters\"></a>Keyword Characters</h2><p><code>Keyword Characters</code>是<code>abbreviations</code> 的一个概念，Vim中有一个<code>keyword范围列表</code> 想要查看这个返回列表可以执行命令:<code>:set iskeyword?</code> ，你将会看类似<code>iskeyword=@,48-57,_,192-255</code> 的结果，这里简单介绍一下，这是一个格式，这个格式包含了如下几种:</p>\n<ul>\n<li><p>48-57 其实是ASCII值在48-57之间的字符，也就是数字(0-9)</p>\n</li>\n<li><p>192-255 是ASCII值，代表了一些特殊的ASCII字符</p>\n</li>\n<li><p>@ 代表除了小写字母ASCII字母以外的字母</p>\n</li>\n<li><p><code>_</code> 以及下划线</p>\n</li>\n</ul>\n<p>为什么说<code>Keyword Characters</code>是<code>Abbreviations</code> 的概念，因为: 当在插入模式下键入缩写后的后一个字符不包含在<code>iskeyword</code> 列表中则会将定义好的全拼替换掉缩写，例如我们敲<space>就不在<code>iskeyword</code> 列表中，所以可以替换。</space></p>\n<p>下面举个<code>abbreviations</code> 特性的常用例子吧:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iabbrev em7 email:the_lty_mail@foxmail.com</span><br></pre></td></tr></table></figure>\n<p>重载配置文件后，当我们在插入模式下键入em7然后再键入一个非<code>iskeyword</code> 列表中的字符，将会替换为<code>email:the_lty_mail@foxmail.com</code>。</p>\n<h2 id=\"为什么不用Mappings\"><a href=\"#为什么不用Mappings\" class=\"headerlink\" title=\"为什么不用Mappings?\"></a>为什么不用Mappings?</h2><p>其实书上的例子已经很好的解释这个问题了。</p>\n<p>首先用mappings做一个替换:<code>:inoremap lol ILoveLOL</code>，然后你进入<code>insert</code> 模式，键入<code>你玩不玩lol?</code> ，此时<code>lol</code> 将会被替换为<code>ILoveLOL</code> ，让我们用<code>abbreviations</code> 特性再做相同的操作。</p>\n<p>执行命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iunmap lol</span><br><span class=\"line\">:iabbrev lol ILoveLOL</span><br></pre></td></tr></table></figure>\n<p>现在再试试，你就懂了。</p>\n<h2 id=\"练习-6\"><a href=\"#练习-6\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>为我常用的字符串添加<code>abbreviations</code> 特性与配置中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iabbrev info email:the_lty_mail@foxmail.com    name:EvanMeek    WebSize:https://evanmeek.github.io</span><br></pre></td></tr></table></figure>\n<h1 id=\"更多的Mappings\"><a href=\"#更多的Mappings\" class=\"headerlink\" title=\"更多的Mappings\"></a>更多的Mappings</h1><p>前面用到了很多多字符的mappings但是我们一直没有提到mappings的连续性。</p>\n<p>首先运行如下命令:<code>:nonoremap jk dd</code> </p>\n<p>当我们处于 normal模式时，快速键入<code>jk</code>  Vim则会执行我们映射的 <code>dd</code> 命令，当前行被删除了。</p>\n<p>现在再试试按<code>jk</code>，但是在按下<code>j</code> 后等待一会儿，再按下<code>k</code> ，我们会发现，Vim不会执行我们所映射的那个命令。这是因为，当我们设置的多字符<code>mappings</code>在键入时，如果没有快速连贯的输入，那么Vim就不会识别。</p>\n<h2 id=\"一个更为复杂的Mapping\"><a href=\"#一个更为复杂的Mapping\" class=\"headerlink\" title=\"一个更为复杂的Mapping\"></a>一个更为复杂的Mapping</h2><p>书中是在normal模式下将单词用<code>&quot;&quot;</code>包住。</p>\n<p>运行命令:<code>nonoremap &lt;LEADER&gt;&quot; viw&lt;ESC&gt;a&quot;&lt;ESC&gt;hbi&quot;&lt;ESC&gt;lel</code> </p>\n<p>现在解释一下:</p>\n<ul>\n<li><p><code>viw</code> 高亮选中单词</p>\n</li>\n<li><p><code>&lt;ESC&gt;</code> 退出visual模式，此时光标会在单词的最后一个字符上</p>\n</li>\n<li><p><code>a</code> 移动光标至当前位置后并进入<code>insert</code> 模式</p>\n</li>\n<li><p><code>&quot;</code> 插入一个<code>&quot;</code> </p>\n</li>\n<li><p><code>&lt;ESC&gt;</code> 退出insert模式，进入normal模式</p>\n</li>\n<li><p><code>h</code> 光标左移</p>\n</li>\n<li><p><code>b</code> 移动光标至单词头部</p>\n</li>\n<li><p><code>i</code> 进入insert模式</p>\n</li>\n<li><p><code>&quot;</code> 键入一个<code>&quot;</code> </p>\n</li>\n<li><p><code>&lt;ESC&gt;</code> 返回到normal模式</p>\n</li>\n<li><p><code>l</code> 光标右移，置于单词头部</p>\n</li>\n<li><p><code>e</code> 移动光标至单词尾部</p>\n</li>\n<li><p><code>l</code> 光标右移，置于第一个添加的引号上</p>\n</li>\n</ul>\n<p>需要注意的是:这里是使用<code>nonoremap</code> 映射的，而非<code>nmap</code> 映射，所以尽管映射的字符已经被映射，Vim也只会讲其中的字符按默认功能执行。</p>\n<h2 id=\"练习-7\"><a href=\"#练习-7\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>创建一个mappings，使用单引号而不是双引号。</p>\n<p><code>:nonoremap &lt;LEADER&gt;&#39; viw&lt;ESC&gt;a&#39;&lt;ESC&gt;hbi&#39;&lt;ESC&gt;lel</code> </p>\n<h1 id=\"本地缓冲区的选项和映射\"><a href=\"#本地缓冲区的选项和映射\" class=\"headerlink\" title=\"本地缓冲区的选项和映射\"></a>本地缓冲区的选项和映射</h1><p>如题所示，本章会讲到本地缓冲区，我们将会对本地缓冲区与全局缓冲区做对比。</p>\n<p>为了演示，请打开两个文件，例如<code>file1</code> 和<code>file2</code>，然后输入一些字符。</p>\n<h2 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h2><p>首先，我们打开 <code>file1</code> ，然后执行命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:nnoremap &lt;LEADER&gt;d dd</span><br><span class=\"line\">:nnoremap &lt;BUFFER&gt; &lt;LEADER&gt;x dd</span><br></pre></td></tr></table></figure>\n<p>现在我们再打开<code>file2</code> ，然后使用刚刚映射的快捷键，你会发现第一个映射的快捷键可以使用，但是第二个则不行，现在我们再打开<code>file1</code> ，却发现两个快捷键都可以被使用。</p>\n<p>好了，现在解释一下这是为什么。首先，我们看到两个映射不同的地方除了映射键以外，第二个映射还多了个<code>&lt;buffer&gt;</code> ，这代表了我们当前映射的快捷键只有在当前<strong>缓冲区</strong> 起作用，而当我们切换到另外一个缓冲器，那么自然映射不起作用了。</p>\n<h2 id=\"本地Leader\"><a href=\"#本地Leader\" class=\"headerlink\" title=\"本地Leader\"></a>本地Leader</h2><p>本地Leader的作用是: 更精确的定义映射。</p>\n<p>有时我们在使用一些对特殊缓冲区起作用的插件时，为了防止与全局Leader映射起冲突，所以就需要使用本地Leader，也就是<code>&lt;localleader&gt;</code> 。</p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>前面几个章节我们都是使用<code>set</code> 命令进行设置VIM的，但是为了让我们的设置更加精准，在不同特殊缓冲区具有不同的设置时，我们就应该使用本地设置<code>setlocal</code> 命令进行设置，下面来看几个例子:</p>\n<p>仍然是操作<code>file1</code> 和<code>file2</code> ，首先，我们打开<code>file1</code> 键入命令:<code>:setlocl wrap</code> 然后在打开<code>file2</code> 键入命令:<code>:setlocal nowrap</code> ，然后为两个文件键入长长的一段字符。</p>\n<p>你会发现<code>file1</code> 是具有自动折行的，而<code>file2</code> 却不具备。</p>\n<p><strong>注意:不是所有命令都可以设置setlocl的，如果需要查看命令是否可以设置为<code>setlock</code> 那么可以通过命令执行:Help命令查看命令的帮助文档</strong> </p>\n<h2 id=\"覆盖\"><a href=\"#覆盖\" class=\"headerlink\" title=\"覆盖\"></a>覆盖</h2><p>这一小节其实不需要做什么演示，一句话就可以概括:<code>本地缓冲区命令要比全局缓冲区优先级高，如果本地缓冲区命令与全局缓冲去起了冲突，那么Vim将会忽略全局缓冲区的命令</code> </p>\n<h2 id=\"练习-8\"><a href=\"#练习-8\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>阅读<code>:help local-options</code> </p>\n<blockquote>\n<p>写完了两章，结果被Nvim的交换文件给重置了，心态崩了</p>\n</blockquote>\n<h1 id=\"自动命令\"><a href=\"#自动命令\" class=\"headerlink\" title=\"自动命令\"></a>自动命令</h1><p>自动命令与映射一样重要。</p>\n<p>自动命令可以让Vim自动执行某些命令，这些命令会在某些事件触发时执行。</p>\n<p>下面看一个例子:</p>\n<p><code>:autocmd BufNewFile * :write</code> </p>\n<p>输入这条命令，然后使用<code>:edit</code> 命令新建一个缓冲区，你会发现会缓冲区会被自动写入进文件了。</p>\n<p>下面我们就来解释一下。</p>\n<h2 id=\"自动命令结构\"><a href=\"#自动命令结构\" class=\"headerlink\" title=\"自动命令结构\"></a>自动命令结构</h2><p>先讲一下自动命令结构，你就可以很清晰的了解自动命令为什么能做到监听事件了。</p>\n<p><code>:autocmd BufNewFile * :write</code> </p>\n<ul>\n<li><p>BufNewFile 代表要监听的“事件”</p>\n</li>\n<li><ul>\n<li>代表事件过滤的“模式（pattern）”</li>\n</ul>\n</li>\n<li><p>:write 代表要执行的命令。</p>\n</li>\n</ul>\n<p>这条命令的实际上做的事是:</p>\n<ol>\n<li><p>当Vim监听到<code>BufNewFile</code> 这个事件后,</p>\n</li>\n<li><p>对所有类型的文件，因为过滤模式是<code>*</code> ,</p>\n</li>\n<li><p>执行<code>:write</code> 命令。</p>\n</li>\n</ol>\n<p>另一个栗子:</p>\n<p><code>:autocmd BufNewFile *.txt :write</code> </p>\n<p>这个例子是将事件过滤模式改为了<code>*.txt</code> ，代表只有新建缓冲区的文件类型为<code>txt</code> 才会触发这个自动命令。</p>\n<h2 id=\"多个事件\"><a href=\"#多个事件\" class=\"headerlink\" title=\"多个事件\"></a>多个事件</h2><p>一个自动命令可以绑定多个事件，多个事件之间由逗号分隔开。</p>\n<p>例如:</p>\n<p><code>:autocmd BufWritePre,BufRead *.html :normal gg=G</code> </p>\n<p>这个自动命令将会在文件类型为<code>html</code> 的缓冲区写入文件时或者读入文件类型为<code>html</code> 类型的文件至缓冲区时进行文本缩进处理。</p>\n<h2 id=\"FileType事件\"><a href=\"#FileType事件\" class=\"headerlink\" title=\"FileType事件\"></a>FileType事件</h2><p><code>FileType</code>可以让Vim在设置一个缓冲区的<code>filetype</code> 时触发。</p>\n<p>见名知意，<code>filetype</code> 也就是文件类型的意思。</p>\n<p>例如我们要对JavaScript与Python映射快速添加注释的快捷键，但由于两门编程语言的注释语法不同，所以我们就可以根据<code>FileType</code>  的值设置不同的文件，定义不同的映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:autocmd FileType javascript nnoremap &lt;buffer&gt; &lt;localleader&gt;c I//&lt;ESC&gt;</span><br><span class=\"line\">:autocmd FileType python nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;ESC&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"本地缓冲区缩写\"><a href=\"#本地缓冲区缩写\" class=\"headerlink\" title=\"本地缓冲区缩写\"></a>本地缓冲区缩写</h1><p>本章很简单，只是将缩写添加一个范围限制。</p>\n<p>首先，我们执行命令:<code>:iabbrev &lt;buffer&gt; --- Hello</code> </p>\n<p>再进入插入模式，键入<code>Hello --- World</code> </p>\n<p>我们发现，<code>---</code> 被替换为了<code>Hello</code> ，这没什么新鲜的，但是当我们打开另一个缓冲区，将会发现这个缩写不起作用了，因为这个缩写是<code>local iabbrev</code> </p>\n<h1 id=\"自动命令组\"><a href=\"#自动命令组\" class=\"headerlink\" title=\"自动命令组\"></a>自动命令组</h1><p>前面几章，我们学习了自动命令，但其实他在某些场景下仍然有些问题。</p>\n<p>例如，先执行命令:<code>:autocmd BufWrite * :echom &quot;Writing buffer&quot;</code> </p>\n<p>然后使用<code>:write</code> 命令将当前缓冲区写入文件，然后执行<code>:messages</code> 命令查看消息日志。你当然会看见<code>Writing buffer</code> 在消息列表中。</p>\n<p>然后重复上面的操作，我们将会看到<code>Writing buffer</code> 在消息列表出现了两次，如果我们再执行上面的自动命令<code>:autocmd BufWrite * :echom &quot;Writing buffer&quot;</code> ，然后再重复刚刚的操作，你将会看到<code>Writing buffer</code> 出现了4次.</p>\n<p>这样是有问题的，因为自动命令被重复设置了，因为Vim不知道你是想替换前面设置的自动命令。</p>\n<h2 id=\"这会有什么问题\"><a href=\"#这会有什么问题\" class=\"headerlink\" title=\"这会有什么问题?\"></a>这会有什么问题?</h2><p>直接说吧，这样会影响Vim的启动速度，因为你的命令通常都是写在<code>~/.vimrc</code> 下，但是每次启动<code>Vim</code> 时，都会加载<code>vimrc</code> ，而这些重复的自动命令将会大大降低Vim的启动速度。</p>\n<p>你可以执行下面的命令，模拟延迟情况。 </p>\n<p><code>:autocmd BufWrite * :sleep 200m</code> </p>\n<p>如果还不够，你可以多执行几次。</p>\n<p><strong>键入:</strong> <code>:autocmd!</code> 以取消所有的自动命令。</p>\n<h2 id=\"把自动命令放到组中-Grouping-Autocommands\"><a href=\"#把自动命令放到组中-Grouping-Autocommands\" class=\"headerlink\" title=\"把自动命令放到组中(Grouping Autocommands)\"></a>把自动命令放到组中(Grouping Autocommands)</h2><p>上面的问题，可以通过将自动命令放入一个组内解决。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">augroup testGroup</span><br><span class=\"line\">  autocmd BUfWrite * :echom &quot;Write ONE&quot;</span><br><span class=\"line\">  autocmd BUfWrite * :echom &quot;Write TWO&quot;</span><br><span class=\"line\">augroup END</span><br></pre></td></tr></table></figure>\n<p>中间的两行缩进可以省略。</p>\n<p>现在试试将缓冲区写入文件，然后查看消息列表。然后再执行如下命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">augroup testGroup</span><br><span class=\"line\">  autocmd BUfWrite * :echom &quot;Write THREE&quot;</span><br><span class=\"line\">augroup END</span><br></pre></td></tr></table></figure>\n<p>现在再将缓冲区写入文件，然后查看消息列表，于是，操蛋的事就发生了。。。</p>\n<h2 id=\"清楚自动命令组\"><a href=\"#清楚自动命令组\" class=\"headerlink\" title=\"清楚自动命令组\"></a>清楚自动命令组</h2><p>你以为定义相同的自动命令组将会自动替换，但其实不是。。。</p>\n<p>为了解决这个问题，所以你最好这么做:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testGroup</span><br><span class=\"line\">:autocmd!</span><br><span class=\"line\">:autocmd BUfWrite * :echom &quot;Write FOUR&quot;</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure>\n<p>请注意,autocmd!，这将会把当前组内的自动命令都先清空，然后再定义新的自动命令。</p>\n<p>你现在可以试试还会不会有:<code>Write ONE TWO ...</code> 等信息</p>\n<h1 id=\"Operator-Pending映射\"><a href=\"#Operator-Pending映射\" class=\"headerlink\" title=\"Operator-Pending映射\"></a>Operator-Pending映射</h1>","site":{"data":{}},"excerpt":"<p>身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。</p>","more":"<h1 id=\"为什么选择这本书\"><a href=\"#为什么选择这本书\" class=\"headerlink\" title=\"为什么选择这本书?\"></a>为什么选择这本书?</h1><p>&emsp;首先，我是一个重度Vim用户，目前记笔记，写代码等操作都是在Vim中实现的，为了让这个强大的古老神器能在我手上发挥巨大威力，所以我决定看书学习Vim。而这本书的前言说的就很好，第一句则是<code>程序猿们很喜欢实现自己的idea</code>，虽然我现在只是一名学生，但在我日常生活中经常想把自己使用Vim时的好点子加入我的<code>vimrc</code> 中。再就是这本书的<code>每章都只讲述一个主题，虽然内容简短但是信息丰富</code>，这样我很喜欢，没有过多啰嗦的地方，有些地方这本书更推荐看Vim自带的文档，这样也让读者有一个自我理解与学习的过程，就像书中所说<code>现实世界中事情的进展并不是遇到问题后可以很快速轻松的解决</code>。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>所提到的都是这本书是面向谁的，以及读完这本书能获得些什么，并且给了一些学习时的忠告，最后提醒了要多利用<code>:help</code>命令.</p>\n<h1 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h1><p>这本书主要讲VimScript所以，在学习VimScript之前，得了解Vim的基本使用，例如<code>buffer,window,normal mode,insert mode,text mode</code>。</p>\n<p>最好是具有编程经验。</p>\n<p>本书基于Vim-7.3版本撰写的，所以读者需要确保系统安装了&gt;=7.3版本的Vim。</p>\n<h2 id=\"创建Vimrc文件\"><a href=\"#创建Vimrc文件\" class=\"headerlink\" title=\"创建Vimrc文件\"></a>创建Vimrc文件</h2><p>这一节没有提到<code>Vimrc</code> 是什么，我这里提一下，是<code>Vimrc</code>一个文件，文件内的可以写vim的命令，而写在<code>Vimrc</code> 中的命令都被称为Ex命令，Ex命令不是这一小节的讨论范围。</p>\n<p>主要说到在Linux或Mac OS X中，这个文件位于<code>home</code>目录下，并且是以<code>.vimrc</code>命名的，而在Windows下则是位于<code>home</code>文件夹下，并以<code>_vimrc</code>命名。</p>\n<p>以上三个系统，都可以在Vim中通过执行<code>:echo $MYVIMRC</code>得知此文件的位置等信息。</p>\n<p><strong>注意:若你没有找到此文件，请自行创建</strong> </p>\n<h1 id=\"打印信息\"><a href=\"#打印信息\" class=\"headerlink\" title=\"打印信息\"></a>打印信息</h1><p>主要提到Vim中打印命令和注释的使用与作用。</p>\n<p>Vim中的打印命令有:<code>echo</code> 和<code>echom</code> ，其区别在于:</p>\n<ul>\n<li><p>echo 仅仅输出回显表达式结果。</p>\n<blockquote>\n<p>回显表达式</p>\n</blockquote>\n<p><code>echo {expr1}</code> 其中{expr1}就是回显表达式</p>\n</li>\n<li><p>echom 输出回显表达式结果，并且将其存储在<code>message-history</code> 内</p>\n<blockquote>\n<p>message-history</p>\n</blockquote>\n<p><code>message-history</code> 是消息历史，可以通过命令查看<code>:messages</code> </p>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>VimScript可以通过<code>&quot;</code> 字符添加注释，就像这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot; 将&lt;space&gt;映射为za</span><br><span class=\"line\">nnoremap &lt;space&gt; za</span><br></pre></td></tr></table></figure>\n<h1 id=\"设置选项\"><a href=\"#设置选项\" class=\"headerlink\" title=\"设置选项\"></a>设置选项</h1><p>Vim中有两种选型: 布尔选项(<code>on</code> 或<code>off</code>)以及键值选项。</p>\n<h2 id=\"布尔选项\"><a href=\"#布尔选项\" class=\"headerlink\" title=\"布尔选项\"></a>布尔选项</h2><p>类似于开关，例如想让Vim中显示行号，可以执行:<code>:set number</code>，这就代表开启，如果想要关闭，则可以使用:<code>:set nonumber</code> 代表关闭状态，如果不想纠结当前状态，只想切换可以执行:<code>set number!</code>，如果想知道当前状态的值，可以执行:<code>set number?</code>，这样可以看到选项的值。</p>\n<h2 id=\"键值选项\"><a href=\"#键值选项\" class=\"headerlink\" title=\"键值选项\"></a>键值选项</h2><p>有些选项，比不是像布尔选项只有两种状态，它们可能会有一个不固定的值，例如改变行号宽度的选项<code>numberwidth</code> ，如果我们想查看<code>numberwidth</code> 的值，可以执行<code>set numberwidth?</code>。</p>\n<h2 id=\"一次性设置多个选项\"><a href=\"#一次性设置多个选项\" class=\"headerlink\" title=\"一次性设置多个选项\"></a>一次性设置多个选项</h2><p>前面我们一直在使用<code>:set</code>命令设置单个选项的值，不过<code>:set</code>命令还允许一次设置多个选项的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set numberwidth=2</span><br><span class=\"line\">:set nonumber</span><br></pre></td></tr></table></figure>\n<p>可以写成:<code>set numberwidth=2 nonumber</code> </p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><strong>‘number’的帮助文档:</strong> 在每行前显示行号。</p>\n<p><strong>relativenumber的帮助文档:</strong> 在每行前显示相对于光标所在行的行号。布尔型选项</p>\n<blockquote>\n<p>建议开启这个选项，它可以让你在上下移动光标时不需要动脑子去算。</p>\n</blockquote>\n<p><strong>numberwidth的帮助文档:</strong> 键值选项，该选项可以设置行号的列数，Vim中默认为4，也就是说当行号超过9999则会自动扩容。</p>\n<p><strong>wrap的帮助文档:</strong> 布尔选项，该选项的作用是自动换行，默认打开。</p>\n<p><strong>shiftround的帮助文档:</strong> 布尔选项，表示没看太懂，文档内是说将缩进取整为<code>shiftwidth</code> 的倍数。这个是命令是应用于<code>&gt; 和 &lt;</code> 命令的</p>\n<p><strong>matchtime的帮助文档:</strong> 键值型选项，默认值为5，作用是设置配对括号的时间。</p>\n<h1 id=\"基本映射\"><a href=\"#基本映射\" class=\"headerlink\" title=\"基本映射\"></a>基本映射</h1><p>从这一章节开始，逐渐变得有趣起来。</p>\n<p>映射是数学中一个有趣的概念，而在VimScript中，键盘的映射也是非常重要且能让Vim随你心意的一个重要概念，因为你可以通过键盘映射告诉Vim: <code>当我按下某组键位时，则执行某些命令</code>。</p>\n<p>最简单的键盘映射是<code>map</code>命令，<code>map</code>命令还可以使用特殊字符，<strong><code>map</code>命令不可以映射注释</strong> </p>\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>映射按键<code>_</code>，让当前行上移一行。</p>\n<p><code>:map _ ddkp</code> </p>\n<h1 id=\"模式映射\"><a href=\"#模式映射\" class=\"headerlink\" title=\"模式映射\"></a>模式映射</h1><p>我们知道Vim中有很多种模式，常见的有:<code>normal,visual,insert</code> 而上一章节所学的<code>map</code> 命令只能应用在<code>normal</code> 模式下。</p>\n<p>不过不用担心，VimScript提供了应用在不同模式下的映射，它们是:<code>nmap,vmap,imap</code> 分别对应了三种常见的模式。</p>\n<p><strong>注意:在插入模式映射下，Vim只会按你所想去做，所以如果要执行normal模式下的命令，别忘了使用<code>&lt;Esc&gt;</code> 退出插入模式再使用.</strong> </p>\n<h2 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>在insert模式下，可通过按<code>&lt;C-u&gt;</code> 将当前光标所在的单词转换成大写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:imap &lt;C-u&gt; &lt;esc&gt;vgU</span><br></pre></td></tr></table></figure>\n<p>在normal模式下，按<code>C-u</code>将当前光标的单词转换成大写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:nmap &lt;C-u&gt; vwgU</span><br></pre></td></tr></table></figure>\n<h1 id=\"精确映射\"><a href=\"#精确映射\" class=\"headerlink\" title=\"精确映射\"></a>精确映射</h1><p>书上说本章内容会比较难理解，其实很简单..</p>\n<p>前面我们学了<code>map</code>以及三种模式对应的映射命令，但他们有一个问题，就是如果当前映射的键再次被映射了，那么当我们使用其快捷键时，就会执行原先映射的键，这就是递归。</p>\n<p>想要避免递归映射，我们可以使用另一组映射命令，可以使得映射的键不会进行递归。</p>\n<p>例如<code>nmap</code> 的非递归映射命令是:<code>nnoremap</code> 其中的<code>nore</code> 应该就是<code>not recursion</code>的意思，其他两种模式映射命令也是如此。</p>\n<p><strong>注意:我们应当在任何时候都使用非递归映射，以免递归映射带来的不必要麻烦</strong> </p>\n<h2 id=\"练习-3\"><a href=\"#练习-3\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><strong>unmap的帮助文档:</strong> unmap是一个系列命令，其作用是在映射命令作用的模式中删除映射，同系列的其他命令还有<code>nunmap vunmap xunmap sunmap ounmap iunmap lunmap cunmap</code> 等。</p>\n<h1 id=\"Leaders\"><a href=\"#Leaders\" class=\"headerlink\" title=\"Leaders\"></a>Leaders</h1><p>Leaders是Vim中让用户自定义的特殊键位，其作用主要是作为映射键位的前缀键，这样可防止在映射过多快捷键后覆盖的问题。</p>\n<p>想要设置leader键，执行命令:<code>:let mapleader = &quot;选择你想要的&quot;</code>，默认的Leader键为<code>\\</code></p>\n<h2 id=\"Local-Leader\"><a href=\"#Local-Leader\" class=\"headerlink\" title=\"Local Leader\"></a>Local Leader</h2><p>前面所提到的Leader更偏向于全局键位映射，如果我们需要对不同文件类型设置不同的快捷键，则可以使用<code>Local Leader</code> 。</p>\n<p>想要设置<code>Local Leader</code> 的键位，可以执行:<code>:let maplocalleader = &quot;&lt;space&gt;&quot;</code> 你可以把<space>替换成你想要的。</space></p>\n<p><strong>本章本小节只是粗略的提了下LocalLeader的作用，后面的章节将会更加详细的介绍。</strong></p>\n<h2 id=\"练习-4\"><a href=\"#练习-4\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><strong>mapleader的帮助文档:</strong> 其实也没什么好说的，上面都写完了，这里说一点:<code>mapleader</code> 的值仅在定义映射时被使用，就算后面改变’mapleader’也不会影响已经定义过的映射。</p>\n<p><strong>maplocalleader的帮助文档:</strong> 主要就说一两句忠告:在全局插件里应该使用<code>&lt;Leader&gt;</code> 而在一个根据文件类型有不同操作的插件里应该使用<code>&lt;LocalLeader&gt;</code> ，还有就是<code>mapleader</code> 和<code>maplocalleader</code> 的值是可以相同的。</p>\n<h1 id=\"编辑你的Vimrc文件\"><a href=\"#编辑你的Vimrc文件\" class=\"headerlink\" title=\"编辑你的Vimrc文件\"></a>编辑你的Vimrc文件</h1><p>这一章算一个小技巧，书中是这么说的：当你在<code>疯狂编码时</code> 突然想加点什么到Vimrc中，但是你又必须立刻编辑vimrc以防忘记，并且又不想退出当前文件，以防打断思路，那么本小节将会实现这个小技巧。</p>\n<h2 id=\"编辑映射\"><a href=\"#编辑映射\" class=\"headerlink\" title=\"编辑映射\"></a>编辑映射</h2><p>我们可以在新建一个分屏，然后那个分屏中编辑<code>vimrc</code>，通过几个简单的键位，即可实现。</p>\n<p><code>:nnoremap &lt;Leader&gt;er :vsplit $MYVIMRC&lt;cr&gt;</code> </p>\n<p>这个命令使用快捷键<code>Leader+e+r</code> 实现新建一个<code>纵向分屏</code> 并且在纵向分屏中打开<code>$MYVIM</code> ，注意最后的<code>&lt;cr&gt;</code> 代表回车，你们可以试下去掉会<code>&lt;cr&gt;</code>发生什么。</p>\n<h2 id=\"重读映射配置\"><a href=\"#重读映射配置\" class=\"headerlink\" title=\"重读映射配置\"></a>重读映射配置</h2><p>当我们添加完即刻所想的idea后，我们还需要重载配置文件，但还是需要再次拼写那长长的命令，所以我们直接通过精确键盘映射完成重读映射，在多次使用后，重读一次配置文件的时间不超过<code>0.2秒</code> </p>\n<p><code>:nnoremap &lt;Leader&gt;sr :source $MYVIMRC&lt;CR&gt;</code> </p>\n<h2 id=\"练习-5\"><a href=\"#练习-5\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>说让我添加一些没意义的映射…那好吧，我想要快速执行外部命令，并将外部命令的输出插入到当前文本中。</p>\n<p>我要执行的外部程序是:<code>figlet</code> ，这是一个可以将字符转化为字符画的一个小程序，那么我可以这样映射。</p>\n<p><code>:nnoremap &lt;Leader&gt;fl :r !figlet</code> </p>\n<p>这样当我按下<code>&lt;Leader&gt;+f+l</code> 这个键盘映射后将会自动帮我输入我映射的值，然后等到我输入一些内容，按下回车后就会将figlet的执行结果插入到当前文本中。</p>\n<p><strong>myvimrc的帮助文档:</strong> 文档中说，<code>$MYVIMRC</code> 是一个环境变量，这个环境变量指向的是<code>vimrc</code> 文件，这个文件用于VIM启动时的初始化。并且这个环境变量如果没有被设置或使用VIMINIT则会从5个地方开始查找，分别是<code>1. 环境变量$VIMINIT 2.用户vimrc文件 3.环境变量$EXINIT 4.用户exrc文件 5. 默认的vimrc文件(位于$VIMRUNTIME/defaults.vim)</code> </p>\n<h1 id=\"Abbreviations\"><a href=\"#Abbreviations\" class=\"headerlink\" title=\"Abbreviations\"></a>Abbreviations</h1><p><code>Abbreviations</code>是Vim中一个灵活且强大的特性，其主要用于<code>insert replace command</code> 模式</p>\n<p>书里说了，只讲<code>insert</code> 模式下的<code>abbreviations</code>，简单的说<code>abbreviations</code> 就是一个缩写替换，可以自定义一些缩写，当你在<code>insert</code> 模式下键入这些缩写就会被替换成事先定义好的值。</p>\n<p><code>insert</code> 模式的<code>abbreviations</code> 命令是:<code>iabbrev</code> 例如:<code>:ibbrev name8 EvanMeek</code> ，执行这条命令当我们在插入模式下键入<code>name8</code> 并按下空格，Vim的<code>abbreviations</code> 特性就会将其替换为我们定义好的<code>EvanMeek</code> 。</p>\n<h2 id=\"Keyword-Characters\"><a href=\"#Keyword-Characters\" class=\"headerlink\" title=\"Keyword Characters\"></a>Keyword Characters</h2><p><code>Keyword Characters</code>是<code>abbreviations</code> 的一个概念，Vim中有一个<code>keyword范围列表</code> 想要查看这个返回列表可以执行命令:<code>:set iskeyword?</code> ，你将会看类似<code>iskeyword=@,48-57,_,192-255</code> 的结果，这里简单介绍一下，这是一个格式，这个格式包含了如下几种:</p>\n<ul>\n<li><p>48-57 其实是ASCII值在48-57之间的字符，也就是数字(0-9)</p>\n</li>\n<li><p>192-255 是ASCII值，代表了一些特殊的ASCII字符</p>\n</li>\n<li><p>@ 代表除了小写字母ASCII字母以外的字母</p>\n</li>\n<li><p><code>_</code> 以及下划线</p>\n</li>\n</ul>\n<p>为什么说<code>Keyword Characters</code>是<code>Abbreviations</code> 的概念，因为: 当在插入模式下键入缩写后的后一个字符不包含在<code>iskeyword</code> 列表中则会将定义好的全拼替换掉缩写，例如我们敲<space>就不在<code>iskeyword</code> 列表中，所以可以替换。</space></p>\n<p>下面举个<code>abbreviations</code> 特性的常用例子吧:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iabbrev em7 email:the_lty_mail@foxmail.com</span><br></pre></td></tr></table></figure>\n<p>重载配置文件后，当我们在插入模式下键入em7然后再键入一个非<code>iskeyword</code> 列表中的字符，将会替换为<code>email:the_lty_mail@foxmail.com</code>。</p>\n<h2 id=\"为什么不用Mappings\"><a href=\"#为什么不用Mappings\" class=\"headerlink\" title=\"为什么不用Mappings?\"></a>为什么不用Mappings?</h2><p>其实书上的例子已经很好的解释这个问题了。</p>\n<p>首先用mappings做一个替换:<code>:inoremap lol ILoveLOL</code>，然后你进入<code>insert</code> 模式，键入<code>你玩不玩lol?</code> ，此时<code>lol</code> 将会被替换为<code>ILoveLOL</code> ，让我们用<code>abbreviations</code> 特性再做相同的操作。</p>\n<p>执行命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iunmap lol</span><br><span class=\"line\">:iabbrev lol ILoveLOL</span><br></pre></td></tr></table></figure>\n<p>现在再试试，你就懂了。</p>\n<h2 id=\"练习-6\"><a href=\"#练习-6\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>为我常用的字符串添加<code>abbreviations</code> 特性与配置中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iabbrev info email:the_lty_mail@foxmail.com    name:EvanMeek    WebSize:https://evanmeek.github.io</span><br></pre></td></tr></table></figure>\n<h1 id=\"更多的Mappings\"><a href=\"#更多的Mappings\" class=\"headerlink\" title=\"更多的Mappings\"></a>更多的Mappings</h1><p>前面用到了很多多字符的mappings但是我们一直没有提到mappings的连续性。</p>\n<p>首先运行如下命令:<code>:nonoremap jk dd</code> </p>\n<p>当我们处于 normal模式时，快速键入<code>jk</code>  Vim则会执行我们映射的 <code>dd</code> 命令，当前行被删除了。</p>\n<p>现在再试试按<code>jk</code>，但是在按下<code>j</code> 后等待一会儿，再按下<code>k</code> ，我们会发现，Vim不会执行我们所映射的那个命令。这是因为，当我们设置的多字符<code>mappings</code>在键入时，如果没有快速连贯的输入，那么Vim就不会识别。</p>\n<h2 id=\"一个更为复杂的Mapping\"><a href=\"#一个更为复杂的Mapping\" class=\"headerlink\" title=\"一个更为复杂的Mapping\"></a>一个更为复杂的Mapping</h2><p>书中是在normal模式下将单词用<code>&quot;&quot;</code>包住。</p>\n<p>运行命令:<code>nonoremap &lt;LEADER&gt;&quot; viw&lt;ESC&gt;a&quot;&lt;ESC&gt;hbi&quot;&lt;ESC&gt;lel</code> </p>\n<p>现在解释一下:</p>\n<ul>\n<li><p><code>viw</code> 高亮选中单词</p>\n</li>\n<li><p><code>&lt;ESC&gt;</code> 退出visual模式，此时光标会在单词的最后一个字符上</p>\n</li>\n<li><p><code>a</code> 移动光标至当前位置后并进入<code>insert</code> 模式</p>\n</li>\n<li><p><code>&quot;</code> 插入一个<code>&quot;</code> </p>\n</li>\n<li><p><code>&lt;ESC&gt;</code> 退出insert模式，进入normal模式</p>\n</li>\n<li><p><code>h</code> 光标左移</p>\n</li>\n<li><p><code>b</code> 移动光标至单词头部</p>\n</li>\n<li><p><code>i</code> 进入insert模式</p>\n</li>\n<li><p><code>&quot;</code> 键入一个<code>&quot;</code> </p>\n</li>\n<li><p><code>&lt;ESC&gt;</code> 返回到normal模式</p>\n</li>\n<li><p><code>l</code> 光标右移，置于单词头部</p>\n</li>\n<li><p><code>e</code> 移动光标至单词尾部</p>\n</li>\n<li><p><code>l</code> 光标右移，置于第一个添加的引号上</p>\n</li>\n</ul>\n<p>需要注意的是:这里是使用<code>nonoremap</code> 映射的，而非<code>nmap</code> 映射，所以尽管映射的字符已经被映射，Vim也只会讲其中的字符按默认功能执行。</p>\n<h2 id=\"练习-7\"><a href=\"#练习-7\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>创建一个mappings，使用单引号而不是双引号。</p>\n<p><code>:nonoremap &lt;LEADER&gt;&#39; viw&lt;ESC&gt;a&#39;&lt;ESC&gt;hbi&#39;&lt;ESC&gt;lel</code> </p>\n<h1 id=\"本地缓冲区的选项和映射\"><a href=\"#本地缓冲区的选项和映射\" class=\"headerlink\" title=\"本地缓冲区的选项和映射\"></a>本地缓冲区的选项和映射</h1><p>如题所示，本章会讲到本地缓冲区，我们将会对本地缓冲区与全局缓冲区做对比。</p>\n<p>为了演示，请打开两个文件，例如<code>file1</code> 和<code>file2</code>，然后输入一些字符。</p>\n<h2 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h2><p>首先，我们打开 <code>file1</code> ，然后执行命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:nnoremap &lt;LEADER&gt;d dd</span><br><span class=\"line\">:nnoremap &lt;BUFFER&gt; &lt;LEADER&gt;x dd</span><br></pre></td></tr></table></figure>\n<p>现在我们再打开<code>file2</code> ，然后使用刚刚映射的快捷键，你会发现第一个映射的快捷键可以使用，但是第二个则不行，现在我们再打开<code>file1</code> ，却发现两个快捷键都可以被使用。</p>\n<p>好了，现在解释一下这是为什么。首先，我们看到两个映射不同的地方除了映射键以外，第二个映射还多了个<code>&lt;buffer&gt;</code> ，这代表了我们当前映射的快捷键只有在当前<strong>缓冲区</strong> 起作用，而当我们切换到另外一个缓冲器，那么自然映射不起作用了。</p>\n<h2 id=\"本地Leader\"><a href=\"#本地Leader\" class=\"headerlink\" title=\"本地Leader\"></a>本地Leader</h2><p>本地Leader的作用是: 更精确的定义映射。</p>\n<p>有时我们在使用一些对特殊缓冲区起作用的插件时，为了防止与全局Leader映射起冲突，所以就需要使用本地Leader，也就是<code>&lt;localleader&gt;</code> 。</p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>前面几个章节我们都是使用<code>set</code> 命令进行设置VIM的，但是为了让我们的设置更加精准，在不同特殊缓冲区具有不同的设置时，我们就应该使用本地设置<code>setlocal</code> 命令进行设置，下面来看几个例子:</p>\n<p>仍然是操作<code>file1</code> 和<code>file2</code> ，首先，我们打开<code>file1</code> 键入命令:<code>:setlocl wrap</code> 然后在打开<code>file2</code> 键入命令:<code>:setlocal nowrap</code> ，然后为两个文件键入长长的一段字符。</p>\n<p>你会发现<code>file1</code> 是具有自动折行的，而<code>file2</code> 却不具备。</p>\n<p><strong>注意:不是所有命令都可以设置setlocl的，如果需要查看命令是否可以设置为<code>setlock</code> 那么可以通过命令执行:Help命令查看命令的帮助文档</strong> </p>\n<h2 id=\"覆盖\"><a href=\"#覆盖\" class=\"headerlink\" title=\"覆盖\"></a>覆盖</h2><p>这一小节其实不需要做什么演示，一句话就可以概括:<code>本地缓冲区命令要比全局缓冲区优先级高，如果本地缓冲区命令与全局缓冲去起了冲突，那么Vim将会忽略全局缓冲区的命令</code> </p>\n<h2 id=\"练习-8\"><a href=\"#练习-8\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>阅读<code>:help local-options</code> </p>\n<blockquote>\n<p>写完了两章，结果被Nvim的交换文件给重置了，心态崩了</p>\n</blockquote>\n<h1 id=\"自动命令\"><a href=\"#自动命令\" class=\"headerlink\" title=\"自动命令\"></a>自动命令</h1><p>自动命令与映射一样重要。</p>\n<p>自动命令可以让Vim自动执行某些命令，这些命令会在某些事件触发时执行。</p>\n<p>下面看一个例子:</p>\n<p><code>:autocmd BufNewFile * :write</code> </p>\n<p>输入这条命令，然后使用<code>:edit</code> 命令新建一个缓冲区，你会发现会缓冲区会被自动写入进文件了。</p>\n<p>下面我们就来解释一下。</p>\n<h2 id=\"自动命令结构\"><a href=\"#自动命令结构\" class=\"headerlink\" title=\"自动命令结构\"></a>自动命令结构</h2><p>先讲一下自动命令结构，你就可以很清晰的了解自动命令为什么能做到监听事件了。</p>\n<p><code>:autocmd BufNewFile * :write</code> </p>\n<ul>\n<li><p>BufNewFile 代表要监听的“事件”</p>\n</li>\n<li><ul>\n<li>代表事件过滤的“模式（pattern）”</li>\n</ul>\n</li>\n<li><p>:write 代表要执行的命令。</p>\n</li>\n</ul>\n<p>这条命令的实际上做的事是:</p>\n<ol>\n<li><p>当Vim监听到<code>BufNewFile</code> 这个事件后,</p>\n</li>\n<li><p>对所有类型的文件，因为过滤模式是<code>*</code> ,</p>\n</li>\n<li><p>执行<code>:write</code> 命令。</p>\n</li>\n</ol>\n<p>另一个栗子:</p>\n<p><code>:autocmd BufNewFile *.txt :write</code> </p>\n<p>这个例子是将事件过滤模式改为了<code>*.txt</code> ，代表只有新建缓冲区的文件类型为<code>txt</code> 才会触发这个自动命令。</p>\n<h2 id=\"多个事件\"><a href=\"#多个事件\" class=\"headerlink\" title=\"多个事件\"></a>多个事件</h2><p>一个自动命令可以绑定多个事件，多个事件之间由逗号分隔开。</p>\n<p>例如:</p>\n<p><code>:autocmd BufWritePre,BufRead *.html :normal gg=G</code> </p>\n<p>这个自动命令将会在文件类型为<code>html</code> 的缓冲区写入文件时或者读入文件类型为<code>html</code> 类型的文件至缓冲区时进行文本缩进处理。</p>\n<h2 id=\"FileType事件\"><a href=\"#FileType事件\" class=\"headerlink\" title=\"FileType事件\"></a>FileType事件</h2><p><code>FileType</code>可以让Vim在设置一个缓冲区的<code>filetype</code> 时触发。</p>\n<p>见名知意，<code>filetype</code> 也就是文件类型的意思。</p>\n<p>例如我们要对JavaScript与Python映射快速添加注释的快捷键，但由于两门编程语言的注释语法不同，所以我们就可以根据<code>FileType</code>  的值设置不同的文件，定义不同的映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:autocmd FileType javascript nnoremap &lt;buffer&gt; &lt;localleader&gt;c I//&lt;ESC&gt;</span><br><span class=\"line\">:autocmd FileType python nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;ESC&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"本地缓冲区缩写\"><a href=\"#本地缓冲区缩写\" class=\"headerlink\" title=\"本地缓冲区缩写\"></a>本地缓冲区缩写</h1><p>本章很简单，只是将缩写添加一个范围限制。</p>\n<p>首先，我们执行命令:<code>:iabbrev &lt;buffer&gt; --- Hello</code> </p>\n<p>再进入插入模式，键入<code>Hello --- World</code> </p>\n<p>我们发现，<code>---</code> 被替换为了<code>Hello</code> ，这没什么新鲜的，但是当我们打开另一个缓冲区，将会发现这个缩写不起作用了，因为这个缩写是<code>local iabbrev</code> </p>\n<h1 id=\"自动命令组\"><a href=\"#自动命令组\" class=\"headerlink\" title=\"自动命令组\"></a>自动命令组</h1><p>前面几章，我们学习了自动命令，但其实他在某些场景下仍然有些问题。</p>\n<p>例如，先执行命令:<code>:autocmd BufWrite * :echom &quot;Writing buffer&quot;</code> </p>\n<p>然后使用<code>:write</code> 命令将当前缓冲区写入文件，然后执行<code>:messages</code> 命令查看消息日志。你当然会看见<code>Writing buffer</code> 在消息列表中。</p>\n<p>然后重复上面的操作，我们将会看到<code>Writing buffer</code> 在消息列表出现了两次，如果我们再执行上面的自动命令<code>:autocmd BufWrite * :echom &quot;Writing buffer&quot;</code> ，然后再重复刚刚的操作，你将会看到<code>Writing buffer</code> 出现了4次.</p>\n<p>这样是有问题的，因为自动命令被重复设置了，因为Vim不知道你是想替换前面设置的自动命令。</p>\n<h2 id=\"这会有什么问题\"><a href=\"#这会有什么问题\" class=\"headerlink\" title=\"这会有什么问题?\"></a>这会有什么问题?</h2><p>直接说吧，这样会影响Vim的启动速度，因为你的命令通常都是写在<code>~/.vimrc</code> 下，但是每次启动<code>Vim</code> 时，都会加载<code>vimrc</code> ，而这些重复的自动命令将会大大降低Vim的启动速度。</p>\n<p>你可以执行下面的命令，模拟延迟情况。 </p>\n<p><code>:autocmd BufWrite * :sleep 200m</code> </p>\n<p>如果还不够，你可以多执行几次。</p>\n<p><strong>键入:</strong> <code>:autocmd!</code> 以取消所有的自动命令。</p>\n<h2 id=\"把自动命令放到组中-Grouping-Autocommands\"><a href=\"#把自动命令放到组中-Grouping-Autocommands\" class=\"headerlink\" title=\"把自动命令放到组中(Grouping Autocommands)\"></a>把自动命令放到组中(Grouping Autocommands)</h2><p>上面的问题，可以通过将自动命令放入一个组内解决。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">augroup testGroup</span><br><span class=\"line\">  autocmd BUfWrite * :echom &quot;Write ONE&quot;</span><br><span class=\"line\">  autocmd BUfWrite * :echom &quot;Write TWO&quot;</span><br><span class=\"line\">augroup END</span><br></pre></td></tr></table></figure>\n<p>中间的两行缩进可以省略。</p>\n<p>现在试试将缓冲区写入文件，然后查看消息列表。然后再执行如下命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">augroup testGroup</span><br><span class=\"line\">  autocmd BUfWrite * :echom &quot;Write THREE&quot;</span><br><span class=\"line\">augroup END</span><br></pre></td></tr></table></figure>\n<p>现在再将缓冲区写入文件，然后查看消息列表，于是，操蛋的事就发生了。。。</p>\n<h2 id=\"清楚自动命令组\"><a href=\"#清楚自动命令组\" class=\"headerlink\" title=\"清楚自动命令组\"></a>清楚自动命令组</h2><p>你以为定义相同的自动命令组将会自动替换，但其实不是。。。</p>\n<p>为了解决这个问题，所以你最好这么做:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testGroup</span><br><span class=\"line\">:autocmd!</span><br><span class=\"line\">:autocmd BUfWrite * :echom &quot;Write FOUR&quot;</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure>\n<p>请注意,autocmd!，这将会把当前组内的自动命令都先清空，然后再定义新的自动命令。</p>\n<p>你现在可以试试还会不会有:<code>Write ONE TWO ...</code> 等信息</p>\n<h1 id=\"Operator-Pending映射\"><a href=\"#Operator-Pending映射\" class=\"headerlink\" title=\"Operator-Pending映射\"></a>Operator-Pending映射</h1>"}],"PostAsset":[{"_id":"source/_posts/如何自学编程/群组.png","slug":"群组.png","post":"ck5oozod9005qomoouvjt6as2","modified":0,"renderable":0},{"_id":"source/_posts/fcitx5安装与配置/kcm.png","slug":"kcm.png","post":"ck5oozocy004xomoors3pls6z","modified":0,"renderable":0},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/dict()函数创建字典.png","slug":"dict()函数创建字典.png","post":"ck5oozocp003zomoog6fcvtkn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/逆光.jpg","slug":"逆光.jpg","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/我儿子的博客/预览.png","slug":"预览.png","post":"ck5oozoda005uomoo3zq55hwc","modified":0,"renderable":0},{"_id":"source/_posts/C-内存四区之堆区/test.png","slug":"test.png","post":"ck5oozoaz0007omoo8n2b0n72","modified":0,"renderable":0},{"_id":"source/_posts/C-指针-基础02/指针位偏移.png","slug":"指针位偏移.png","post":"ck5oozobc000vomooae2kfbnz","modified":0,"renderable":0},{"_id":"source/_posts/C-内存四区之代码区与全局区/代码区示意图.png","slug":"代码区示意图.png","post":"ck5oozob10009omoo91rvkdrr","modified":0,"renderable":0},{"_id":"source/_posts/C-读写文件/二进制文件.png","slug":"二进制文件.png","post":"ck5oozobq001comoorzdisk1v","modified":0,"renderable":0},{"_id":"source/_posts/Learn-Qt5-HelloWorld/newProject.gif","slug":"newProject.gif","post":"ck5oozoc0001vomoo9r8bqls3","modified":0,"renderable":0},{"_id":"source/_posts/Linux-Linux命令行简介-0/1.1.2-0","slug":"1.1.2-0","post":"ck5oozoc30028omoog9r7lgl2","modified":0,"renderable":0},{"_id":"source/_posts/Python-01-Python教程基础/Python知识体系框架.png","slug":"Python知识体系框架.png","post":"ck5oozocl003oomoo5f0lhoev","modified":0,"renderable":0},{"_id":"source/_posts/The-process-of-purchasing-MacBook-Pro/配置图.jpg","slug":"配置图.jpg","post":"ck5oozocv004momoo7hbzlmxh","modified":0,"renderable":0},{"_id":"source/_posts/What-is-Vim/VIM.png","slug":"VIM.png","post":"ck5oozocw004qomoo0l5plv7t","modified":0,"renderable":0},{"_id":"source/_posts/平铺式桌面-从入门到入坟/桌面预览.png","slug":"桌面预览.png","post":"ck5oozodc005yomoo8drakipa","modified":0,"renderable":0},{"_id":"source/_posts/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图01.png","slug":"软件预览图01.png","post":"ck5oozoca002yomoo74w8m1zy","modified":0,"renderable":0},{"_id":"source/_posts/Mac下超好用的风扇控制与温度监控软件————TG-Pro/软件预览图02.png","slug":"软件预览图02.png","post":"ck5oozoca002yomoo74w8m1zy","modified":0,"renderable":0},{"_id":"source/_posts/Python-02-Python初探/python2运行.png","slug":"python2运行.png","post":"ck5oozocn003romoo5ieqwa9i","modified":0,"renderable":0},{"_id":"source/_posts/Python-02-Python初探/python3运行.png","slug":"python3运行.png","post":"ck5oozocn003romoo5ieqwa9i","modified":0,"renderable":0},{"_id":"source/_posts/hexo-next插入网易云音乐/01.png","slug":"01.png","post":"ck5oozocw004tomooq5z20hcf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-next插入网易云音乐/插哪.png","slug":"插哪.png","post":"ck5oozocw004tomooq5z20hcf","modified":0,"renderable":0},{"_id":"source/_posts/fcitx5安装与配置/输入.gif","slug":"输入.gif","post":"ck5oozocy004xomoors3pls6z","modified":0,"renderable":0},{"_id":"source/_posts/最快-GPU加速-Alacritty终端/error.png","slug":"error.png","post":"ck5oozode0068omooso0wmqzt","modified":0,"renderable":0},{"_id":"source/_posts/最快-GPU加速-Alacritty终端/ponysay.png","slug":"ponysay.png","post":"ck5oozode0068omooso0wmqzt","modified":0,"renderable":0},{"_id":"source/_posts/终端多窗口神器——Screen/DefalutCommandKey.png","slug":"DefalutCommandKey.png","post":"ck5oozodg006eomooa5taq734","modified":0,"renderable":0},{"_id":"source/_posts/终端多窗口神器——Screen/detachedInfo.png","slug":"detachedInfo.png","post":"ck5oozodg006eomooa5taq734","modified":0,"renderable":0},{"_id":"source/_posts/2008年5月12日14时28分04秒/操场.webp","slug":"操场.webp","post":"ck5oozoas0001omoo0he5grvj","modified":0,"renderable":0},{"_id":"source/_posts/2008年5月12日14时28分04秒/流量图.webp","slug":"流量图.webp","post":"ck5oozoas0001omoo0he5grvj","modified":0,"renderable":0},{"_id":"source/_posts/2008年5月12日14时28分04秒/空降.webp","slug":"空降.webp","post":"ck5oozoas0001omoo0he5grvj","modified":0,"renderable":0},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/Python序列内置函数.png","slug":"Python序列内置函数.png","post":"ck5oozocp003zomoog6fcvtkn","modified":0,"renderable":0},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/Python集合示意图.png","slug":"Python集合示意图.png","post":"ck5oozocp003zomoog6fcvtkn","modified":0,"renderable":0},{"_id":"source/_posts/Python-04-Python列表、元组、字典和集合/Python集合运算.png","slug":"Python集合运算.png","post":"ck5oozocp003zomoog6fcvtkn","modified":0,"renderable":0},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python位运算符.png","slug":"Python位运算符.png","post":"ck5oozoco003womoow59myfdw","modified":0,"renderable":0},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python常用算术运算符.png","slug":"Python常用算术运算符.png","post":"ck5oozoco003womoow59myfdw","modified":0,"renderable":0},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python常用赋值运算符.png","slug":"Python常用赋值运算符.png","post":"ck5oozoco003womoow59myfdw","modified":0,"renderable":0},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python比较运算符.png","slug":"Python比较运算符.png","post":"ck5oozoco003womoow59myfdw","modified":0,"renderable":0},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python运算符优先级.png","slug":"Python运算符优先级.png","post":"ck5oozoco003womoow59myfdw","modified":0,"renderable":0},{"_id":"source/_posts/Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png","slug":"Python逻辑运算符及功能.png","post":"ck5oozoco003womoow59myfdw","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/分区.png","slug":"分区.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/分区标识.png","slug":"分区标识.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/安装选择界面.png","slug":"安装选择界面.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/开始安装.png","slug":"开始安装.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/摘要.png","slug":"摘要.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/桌面.png","slug":"桌面.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/编辑文章时截图.png","slug":"编辑文章时截图.png","post":"ck5oozocg0035omootchc9fa9","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/deploy.png","slug":"deploy.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/hexoinit.png","slug":"hexoinit.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/ssh目录.png","slug":"ssh目录.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/创建仓库.png","slug":"创建仓库.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/导入密钥.png","slug":"导入密钥.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/打开设置.png","slug":"打开设置.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/本地部署.png","slug":"本地部署.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/设置SSH.png","slug":"设置SSH.png","post":"ck5oozod5005fomoomqa2rvxn","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck5oozoas0001omoo0he5grvj","category_id":"ck5oozoay0004omoo4wk7f47m","_id":"ck5oozob6000jomoofr1pqk6u"},{"post_id":"ck5oozoaw0003omoo4hl6t0bx","category_id":"ck5oozob3000comoor175qoki","_id":"ck5oozobb000romoogp8nyj79"},{"post_id":"ck5oozoba000oomooiptb4qh5","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozobg000yomoocbu5wau4"},{"post_id":"ck5oozoaz0007omoo8n2b0n72","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozobi0012omookmn3bjoy"},{"post_id":"ck5oozobb000qomoo38xk44q9","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozobl0015omootmhe2e1w"},{"post_id":"ck5oozobc000vomooae2kfbnz","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozobo001aomoorhu0z9aa"},{"post_id":"ck5oozob10009omoo91rvkdrr","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozobr001domoo3brsylve"},{"post_id":"ck5oozobi0011omoobujoychz","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozobu001homoo1npnvy5s"},{"post_id":"ck5oozob2000bomoo7pr08vrr","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozobx001lomoomvs6ax7i"},{"post_id":"ck5oozobl0014omooierdv4pm","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozoby001pomoo5ww6ikn3"},{"post_id":"ck5oozobn0019omooyli7pu2s","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozobz001tomoozmhk3xwv"},{"post_id":"ck5oozob4000gomooddmicnpl","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoc0001womoo1xiqf6id"},{"post_id":"ck5oozobq001comoorzdisk1v","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoc1001zomoo3y8r1hsj"},{"post_id":"ck5oozobu001gomoogxnjrkye","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozoc20022omoogua790fq"},{"post_id":"ck5oozob6000iomoovwuhu17o","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoc30026omoorqf93y4p"},{"post_id":"ck5oozobx001komoojv0qi1iu","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozoc40029omoo8zrv7sye"},{"post_id":"ck5oozoby001oomoo6nuvqxzc","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozoc5002eomoo13dyb45v"},{"post_id":"ck5oozobz001somooyj5wsdj9","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoc6002homooakv36i17"},{"post_id":"ck5oozobf000xomooc3csvtb9","category_id":"ck5oozoby001nomoofd08b7if","_id":"ck5oozoc7002momoojcl7dwdm"},{"post_id":"ck5oozoc0001vomoo9r8bqls3","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoc8002pomoo84nakim0"},{"post_id":"ck5oozoc1001yomoo5d1xos3s","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoc9002tomoo1ajmxkx5"},{"post_id":"ck5oozoc20021omoo1knddeyr","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoca002xomoo2cmb637f"},{"post_id":"ck5oozoc5002gomoo4bqs8u60","category_id":"ck5oozoc4002comoog1p8mvm2","_id":"ck5oozoce002zomootw3yfqde"},{"post_id":"ck5oozoc30025omoocyeti0ij","category_id":"ck5oozoc4002comoog1p8mvm2","_id":"ck5oozocf0032omooza2r24fv"},{"post_id":"ck5oozoc6002komooz6zrjq3h","category_id":"ck5oozoc4002comoog1p8mvm2","_id":"ck5oozocg0036omoosnlunchb"},{"post_id":"ck5oozoc8002oomooy5l2ikoh","category_id":"ck5oozoc4002comoog1p8mvm2","_id":"ck5oozoch0039omoo0y3ca229"},{"post_id":"ck5oozoc30028omoog9r7lgl2","category_id":"ck5oozoc4002comoog1p8mvm2","_id":"ck5oozoci003bomoo11927qfi"},{"post_id":"ck5oozoc8002romoo43cs2bq6","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozoci003fomooak38hetr"},{"post_id":"ck5oozoca002womoo4n42k9yh","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozock003iomoo33gbseo7"},{"post_id":"ck5oozoc5002domoor37oi8c3","category_id":"ck5oozoc4002comoog1p8mvm2","_id":"ck5oozocl003lomoo73kz11mj"},{"post_id":"ck5oozocf0031omoohc1lti0e","category_id":"ck5oozob3000comoor175qoki","_id":"ck5oozocm003pomoob6uxni76"},{"post_id":"ck5oozocg0035omootchc9fa9","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozocn003somoo5gnmkgbn"},{"post_id":"ck5oozocg0038omoo0rpck07a","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozoco003xomoounkrzkv9"},{"post_id":"ck5oozoca002yomoo74w8m1zy","category_id":"ck5oozocf0034omoodjvumw63","_id":"ck5oozocp0040omoofgm409sp"},{"post_id":"ck5oozoch003aomoo7bd461du","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozocq0045omool9zqodii"},{"post_id":"ck5oozoci003eomoo9xxkm97y","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozocr0048omoo9wbevbve"},{"post_id":"ck5oozocj003homooub6a09tl","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozocs004domooph6fswwt"},{"post_id":"ck5oozock003komoowz87ww52","category_id":"ck5oozocf0034omoodjvumw63","_id":"ck5oozoct004gomoo7901j7zp"},{"post_id":"ck5oozocp003zomoog6fcvtkn","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozocu004komoocsop4oya"},{"post_id":"ck5oozocl003oomoo5f0lhoev","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozocv004nomoo7kij2je4"},{"post_id":"ck5oozocq0043omoohb34cisw","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozocw004romoo27vgbyks"},{"post_id":"ck5oozocr0047omoowsl2xkbs","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozocx004uomookz28ifpu"},{"post_id":"ck5oozocn003romoo5ieqwa9i","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozocz004yomootnwwftet"},{"post_id":"ck5oozocs004bomoorh9xatxz","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozod00052omoo355f9f7g"},{"post_id":"ck5oozoct004fomoodguiskf5","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozod10055omoo34wmme65"},{"post_id":"ck5oozoco003womoow59myfdw","category_id":"ck5oozoco003uomookifni6gt","_id":"ck5oozod20059omoo2sr264me"},{"post_id":"ck5oozocu004jomoom4fx76z0","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozod4005domoo78oac71v"},{"post_id":"ck5oozocv004momoo7hbzlmxh","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozod5005gomoo9vz1js5r"},{"post_id":"ck5oozocw004qomoo0l5plv7t","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozod7005lomoo4sfe30bb"},{"post_id":"ck5oozocy004xomoors3pls6z","category_id":"ck5oozoby001nomoofd08b7if","_id":"ck5oozod8005oomook7p7br1p"},{"post_id":"ck5oozod00054omooe0f292qg","category_id":"ck5oozobi000zomoojnk7hhf1","_id":"ck5oozoda005somoom2exwj45"},{"post_id":"ck5oozocw004tomooq5z20hcf","category_id":"ck5oozocz004zomooinj9gv41","_id":"ck5oozodb005vomoo92hwx143"},{"post_id":"ck5oozod10057omoog0navbvp","category_id":"ck5oozoby001nomoofd08b7if","_id":"ck5oozodc005zomoolwiuzviv"},{"post_id":"ck5oozocz0051omoowxsnbzdu","category_id":"ck5oozocz004zomooinj9gv41","_id":"ck5oozodd0062omoojrobvmgx"},{"post_id":"ck5oozod5005fomoomqa2rvxn","category_id":"ck5oozocz004zomooinj9gv41","_id":"ck5oozode0065omooxi52v4dm"},{"post_id":"ck5oozod8005nomoos0u39re1","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozodf0069omoo9yka2vuh"},{"post_id":"ck5oozod4005comoo4m5w0o4n","category_id":"ck5oozod6005iomookeoshlqz","_id":"ck5oozodf006bomoocngs5bzq"},{"post_id":"ck5oozod9005qomoouvjt6as2","category_id":"ck5oozod6005iomookeoshlqz","_id":"ck5oozodh006fomoo782rvqq4"},{"post_id":"ck5oozoda005uomoo3zq55hwc","category_id":"ck5oozob3000comoor175qoki","_id":"ck5oozodh006iomoojgzg29jc"},{"post_id":"ck5oozod6005komoo9v320mts","category_id":"ck5oozoda005romoo4343h5qr","_id":"ck5oozodi006lomoo5sznaabg"},{"post_id":"ck5oozodd0061omooj6q4ks0w","category_id":"ck5oozod6005iomookeoshlqz","_id":"ck5oozodj006oomool4rssnv1"},{"post_id":"ck5oozodd0064omoocr03o98l","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozodk006romoobei2lo0q"},{"post_id":"ck5oozode0068omooso0wmqzt","category_id":"ck5oozoby001nomoofd08b7if","_id":"ck5oozodk006tomooyk2zkcxg"},{"post_id":"ck5oozodc005yomoo8drakipa","category_id":"ck5oozodd0063omoo9nvkqb3v","_id":"ck5oozodl006womoo40c8bd42"},{"post_id":"ck5oozodf006aomooa0pax6ac","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozodl006zomoobqq2bdsf"},{"post_id":"ck5oozodg006eomooa5taq734","category_id":"ck5oozoby001nomoofd08b7if","_id":"ck5oozodl0072omooylwqidxt"},{"post_id":"ck5oozodh006homooc7npxa5t","category_id":"ck5oozod6005iomookeoshlqz","_id":"ck5oozodl0074omool049ydgj"},{"post_id":"ck5oozodi006komoo47es3irb","category_id":"ck5oozob6000komooxs4556zu","_id":"ck5oozodm0077omoo8qsfj6pl"},{"post_id":"ck5oozodj006qomookz8frew5","category_id":"ck5oozoby001nomoofd08b7if","_id":"ck5oozodn0079omoouz8qo6nq"},{"post_id":"ck5oozodk006somoo59inyfck","category_id":"ck5oozodl006xomoo7ro4ay5a","_id":"ck5oozodn007bomooa77pg1c3"}],"PostTag":[{"post_id":"ck5oozoas0001omoo0he5grvj","tag_id":"ck5oozoaz0005omooeqjbolq2","_id":"ck5oozob4000eomoopnc406af"},{"post_id":"ck5oozob4000gomooddmicnpl","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozob7000momoosqb0vk9r"},{"post_id":"ck5oozoaz0007omoo8n2b0n72","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozoba000pomooh0dxqazx"},{"post_id":"ck5oozoba000oomooiptb4qh5","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozobc000uomooxnmqq18d"},{"post_id":"ck5oozob10009omoo91rvkdrr","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozobf000womoojosol1qj"},{"post_id":"ck5oozob2000bomoo7pr08vrr","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozobj0013omoo2823duz0"},{"post_id":"ck5oozobi0011omoobujoychz","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozobn0016omoowjcpkah9"},{"post_id":"ck5oozob6000iomoovwuhu17o","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozobq001bomoox0sqynu6"},{"post_id":"ck5oozob6000iomoovwuhu17o","tag_id":"ck5oozobi0010omoo2c6rzqo0","_id":"ck5oozobu001eomooszdxtuf0"},{"post_id":"ck5oozobq001comoorzdisk1v","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozobx001jomoop0m4orm2"},{"post_id":"ck5oozobu001gomoogxnjrkye","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozoby001momoo71r3quw4"},{"post_id":"ck5oozobx001komoojv0qi1iu","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozobz001romoo7hjs4i1a"},{"post_id":"ck5oozoby001oomoo6nuvqxzc","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozoc0001uomoo285uvloa"},{"post_id":"ck5oozobb000qomoo38xk44q9","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozoc10020omoo3gokva78"},{"post_id":"ck5oozobb000qomoo38xk44q9","tag_id":"ck5oozobn0018omoo4rp5m5ao","_id":"ck5oozoc20023omoodjs5k0cs"},{"post_id":"ck5oozobb000qomoo38xk44q9","tag_id":"ck5oozobv001iomooaajj3fc7","_id":"ck5oozoc30027omoo2wkg89tj"},{"post_id":"ck5oozobb000qomoo38xk44q9","tag_id":"ck5oozobz001qomoo3kr9k4uc","_id":"ck5oozoc4002aomoo5f1o93ik"},{"post_id":"ck5oozobc000vomooae2kfbnz","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozoc5002fomoo5syxvimz"},{"post_id":"ck5oozobc000vomooae2kfbnz","tag_id":"ck5oozobn0018omoo4rp5m5ao","_id":"ck5oozoc6002iomoou0kiekm6"},{"post_id":"ck5oozobc000vomooae2kfbnz","tag_id":"ck5oozobv001iomooaajj3fc7","_id":"ck5oozoc7002nomoor4piu811"},{"post_id":"ck5oozobf000xomooc3csvtb9","tag_id":"ck5oozoc4002bomoopu504zl4","_id":"ck5oozoc8002qomoor9f9pxyq"},{"post_id":"ck5oozobl0014omooierdv4pm","tag_id":"ck5oozoc6002jomoolhc027eh","_id":"ck5oozoca002vomooxc9faz25"},{"post_id":"ck5oozobn0019omooyli7pu2s","tag_id":"ck5oozoc9002uomoorkx0dz3o","_id":"ck5oozocf0033omooy8vgjlof"},{"post_id":"ck5oozocg0038omoo0rpck07a","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozoci003comoosugylnaz"},{"post_id":"ck5oozobz001somooyj5wsdj9","tag_id":"ck5oozoce0030omooqgkowohm","_id":"ck5oozocj003gomooyhb79c42"},{"post_id":"ck5oozobz001somooyj5wsdj9","tag_id":"ck5oozocg0037omoo4rxw6inw","_id":"ck5oozock003jomoopa8lwfwp"},{"post_id":"ck5oozoch003aomoo7bd461du","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozocl003nomoozk3t8vul"},{"post_id":"ck5oozoci003eomoo9xxkm97y","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozocn003qomoo7g915kqm"},{"post_id":"ck5oozocj003homooub6a09tl","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozoco003vomoonbzfmifx"},{"post_id":"ck5oozoc0001vomoo9r8bqls3","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozocp003yomoofu3gsayv"},{"post_id":"ck5oozoc0001vomoo9r8bqls3","tag_id":"ck5oozoci003domooykvm5y5y","_id":"ck5oozocq0042omooiturhd02"},{"post_id":"ck5oozoc1001yomoo5d1xos3s","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozocr0046omoo4ibiphpp"},{"post_id":"ck5oozoc1001yomoo5d1xos3s","tag_id":"ck5oozoci003domooykvm5y5y","_id":"ck5oozocs004aomooa1qcc9jx"},{"post_id":"ck5oozoc20021omoo1knddeyr","tag_id":"ck5oozoci003domooykvm5y5y","_id":"ck5oozoct004eomoo5l58lbld"},{"post_id":"ck5oozoc20021omoo1knddeyr","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozocu004iomoo86mq3r73"},{"post_id":"ck5oozoc30025omoocyeti0ij","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozocu004lomood7eb5p5s"},{"post_id":"ck5oozoc30028omoog9r7lgl2","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozocw004pomoor9vvyz7t"},{"post_id":"ck5oozocu004jomoom4fx76z0","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozocw004somooqau4ulrj"},{"post_id":"ck5oozoc5002domoor37oi8c3","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozocy004womooaw9olgle"},{"post_id":"ck5oozoc5002gomoo4bqs8u60","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozocz0050omoo1452xbii"},{"post_id":"ck5oozoc6002komooz6zrjq3h","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozod10056omoo207pwgkh"},{"post_id":"ck5oozod00054omooe0f292qg","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozod3005bomoo4jmysxts"},{"post_id":"ck5oozoc8002oomooy5l2ikoh","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozod5005eomooo5lry9pe"},{"post_id":"ck5oozod4005comoo4m5w0o4n","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozod6005jomoom67mgvie"},{"post_id":"ck5oozoc8002romoo43cs2bq6","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozod8005momoo4knn5o9l"},{"post_id":"ck5oozoca002womoo4n42k9yh","tag_id":"ck5oozod6005homooco8uj8te","_id":"ck5oozoda005tomoo04hl6phx"},{"post_id":"ck5oozod9005qomoouvjt6as2","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozodc005womoolwna85d2"},{"post_id":"ck5oozoca002yomoo74w8m1zy","tag_id":"ck5oozod9005pomoonuyam26r","_id":"ck5oozodc0060omoo4o0osvjj"},{"post_id":"ck5oozodd0061omooj6q4ks0w","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozode0067omoo6fsjke9l"},{"post_id":"ck5oozocf0031omoohc1lti0e","tag_id":"ck5oozodc005xomoojvkj3ygm","_id":"ck5oozodg006domoo21aqfb7j"},{"post_id":"ck5oozocf0031omoohc1lti0e","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodh006gomooukyyo4yq"},{"post_id":"ck5oozodh006homooc7npxa5t","tag_id":"ck5oozobb000somoo7iivzqh8","_id":"ck5oozodi006momool273ce8s"},{"post_id":"ck5oozodj006qomookz8frew5","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodk006vomoosnk0ph8u"},{"post_id":"ck5oozocg0035omootchc9fa9","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodl006yomooq26uhl94"},{"post_id":"ck5oozocg0035omootchc9fa9","tag_id":"ck5oozodh006jomoocomwgkdq","_id":"ck5oozodl0070omoogrj2uhvz"},{"post_id":"ck5oozocg0035omootchc9fa9","tag_id":"ck5oozodj006pomoo1kvtmxl3","_id":"ck5oozodl0073omooc919a9c3"},{"post_id":"ck5oozocl003oomoo5f0lhoev","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodl0075omooiz3sq7w1"},{"post_id":"ck5oozocn003romoo5ieqwa9i","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodm0078omooq9i9np7r"},{"post_id":"ck5oozoco003womoow59myfdw","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodn007comoosk6qvy4a"},{"post_id":"ck5oozocp003zomoog6fcvtkn","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodo007eomootng7fzwp"},{"post_id":"ck5oozocq0043omoohb34cisw","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodo007gomoofbhra2jo"},{"post_id":"ck5oozocr0047omoowsl2xkbs","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodo007iomoo2snkyrom"},{"post_id":"ck5oozocs004bomoorh9xatxz","tag_id":"ck5oozod6005homooco8uj8te","_id":"ck5oozodp007komooxh653nph"},{"post_id":"ck5oozoct004fomoodguiskf5","tag_id":"ck5oozodk006uomooo3uxavi2","_id":"ck5oozodp007momoofcaq8ahh"},{"post_id":"ck5oozocv004momoo7hbzlmxh","tag_id":"ck5oozodp007lomoops6n1d4d","_id":"ck5oozodp007oomoo99ymkfa8"},{"post_id":"ck5oozocw004qomoo0l5plv7t","tag_id":"ck5oozodp007nomooeci0svea","_id":"ck5oozodq007qomookuyl21i8"},{"post_id":"ck5oozocw004tomooq5z20hcf","tag_id":"ck5oozodp007pomoovzzum7ed","_id":"ck5oozodq007tomoo7tnw53n0"},{"post_id":"ck5oozocw004tomooq5z20hcf","tag_id":"ck5oozodq007romooez09jhdf","_id":"ck5oozodq007uomooj7dpfaki"},{"post_id":"ck5oozocy004xomoors3pls6z","tag_id":"ck5oozodq007somoor9q8zw06","_id":"ck5oozodq007womoo5u9u7295"},{"post_id":"ck5oozocz0051omoowxsnbzdu","tag_id":"ck5oozodp007pomoovzzum7ed","_id":"ck5oozodr007yomooh130iqvx"},{"post_id":"ck5oozod10057omoog0navbvp","tag_id":"ck5oozodr007xomoov45er9yj","_id":"ck5oozodr0080omoo4vshphd9"},{"post_id":"ck5oozod5005fomoomqa2rvxn","tag_id":"ck5oozodp007pomoovzzum7ed","_id":"ck5oozodr0083omoowcoimhb7"},{"post_id":"ck5oozod5005fomoomqa2rvxn","tag_id":"ck5oozodr0081omoom8vrm3jx","_id":"ck5oozodr0084omoobl3apnsz"},{"post_id":"ck5oozod6005komoo9v320mts","tag_id":"ck5oozodr0082omooxikg39cc","_id":"ck5oozods0086omooqfyyrnsf"},{"post_id":"ck5oozod8005nomoos0u39re1","tag_id":"ck5oozodr0085omoozm0186ao","_id":"ck5oozodt0088omoo9xa9dzud"},{"post_id":"ck5oozoda005uomoo3zq55hwc","tag_id":"ck5oozods0087omoodidz5kg9","_id":"ck5oozodt008aomoo8t0tgce7"},{"post_id":"ck5oozodc005yomoo8drakipa","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodt008comooayrp92bk"},{"post_id":"ck5oozodc005yomoo8drakipa","tag_id":"ck5oozodt0089omooa0009t0m","_id":"ck5oozodt008domooxmkqpex8"},{"post_id":"ck5oozodd0064omoocr03o98l","tag_id":"ck5oozodp007nomooeci0svea","_id":"ck5oozodu008fomoof1yj3duz"},{"post_id":"ck5oozode0068omooso0wmqzt","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodu008homoo4m8525y6"},{"post_id":"ck5oozode0068omooso0wmqzt","tag_id":"ck5oozodr007xomoov45er9yj","_id":"ck5oozodu008iomoo21rs6ekc"},{"post_id":"ck5oozodf006aomooa0pax6ac","tag_id":"ck5oozob3000domoog9h1lz0c","_id":"ck5oozodv008komookbl0n8px"},{"post_id":"ck5oozodf006aomooa0pax6ac","tag_id":"ck5oozodu008gomootojrj75k","_id":"ck5oozodv008lomooxnz1ld0g"},{"post_id":"ck5oozodg006eomooa5taq734","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodv008nomooi2i4cpqo"},{"post_id":"ck5oozodg006eomooa5taq734","tag_id":"ck5oozodr007xomoov45er9yj","_id":"ck5oozodv008oomoo7safn0mh"},{"post_id":"ck5oozodi006komoo47es3irb","tag_id":"ck5oozocp0041omooo6upuqvp","_id":"ck5oozodw008qomoos9h1h51i"},{"post_id":"ck5oozodi006komoo47es3irb","tag_id":"ck5oozodv008momooxpb2efhc","_id":"ck5oozodw008romooq2is1djg"},{"post_id":"ck5oozodk006somoo59inyfck","tag_id":"ck5oozodw008pomook63r055b","_id":"ck5oozodw008somoopojgipja"}],"Tag":[{"name":"社会事件","_id":"ck5oozoaz0005omooeqjbolq2"},{"name":"C++","_id":"ck5oozob3000domoog9h1lz0c"},{"name":"个人感想","_id":"ck5oozobb000somoo7iivzqh8"},{"name":"编程","_id":"ck5oozobi0010omoo2c6rzqo0"},{"name":"指针","_id":"ck5oozobn0018omoo4rp5m5ao"},{"name":"学习笔记","_id":"ck5oozobv001iomooaajj3fc7"},{"name":"基础","_id":"ck5oozobz001qomoo3kr9k4uc"},{"name":"Emacs","_id":"ck5oozoc4002bomoopu504zl4"},{"name":"日常","_id":"ck5oozoc6002jomoolhc027eh"},{"name":"转载","_id":"ck5oozoc9002uomoorkx0dz3o"},{"name":"Qt","_id":"ck5oozoce0030omooqgkowohm"},{"name":"C_++","_id":"ck5oozocg0037omoo4rxw6inw"},{"name":"Qt5","_id":"ck5oozoci003domooykvm5y5y"},{"name":"Linux","_id":"ck5oozocp0041omooo6upuqvp"},{"name":"Rust","_id":"ck5oozod6005homooco8uj8te"},{"name":"软件分享","_id":"ck5oozod9005pomoonuyam26r"},{"name":"Telegram","_id":"ck5oozodc005xomoojvkj3ygm"},{"name":"折腾","_id":"ck5oozodh006jomoocomwgkdq"},{"name":"软件使用","_id":"ck5oozodj006pomoo1kvtmxl3"},{"name":"Python系列","_id":"ck5oozodk006uomooo3uxavi2"},{"name":"购物体验","_id":"ck5oozodp007lomoops6n1d4d"},{"name":"VIM","_id":"ck5oozodp007nomooeci0svea"},{"name":"hexo","_id":"ck5oozodp007pomoovzzum7ed"},{"name":"网易云音乐","_id":"ck5oozodq007romooez09jhdf"},{"name":"fcitx5","_id":"ck5oozodq007somoor9q8zw06"},{"name":"软件折腾","_id":"ck5oozodr007xomoov45er9yj"},{"name":"博客","_id":"ck5oozodr0081omoom8vrm3jx"},{"name":"EmacsLisp","_id":"ck5oozodr0082omooxikg39cc"},{"name":"算法","_id":"ck5oozodr0085omoozm0186ao"},{"name":"欢乐时光","_id":"ck5oozods0087omoodidz5kg9"},{"name":"i3","_id":"ck5oozodt0089omooa0009t0m"},{"name":"经典案例","_id":"ck5oozodu008gomootojrj75k"},{"name":"KDE","_id":"ck5oozodv008momooxpb2efhc"},{"name":"Vim","_id":"ck5oozodw008pomook63r055b"}]}}