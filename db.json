{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatPay.png","path":"images/wechatPay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/aliPay.png","path":"images/aliPay.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/background.png","path":"images/background.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/card.png","path":"images/card.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/background2.png","path":"images/background2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/img.jpg","path":"images/img.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1556894150637},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1556894150637},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1556894150637},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1556894150637},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1556894150637},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1556894150637},{"_id":"themes/next/.gitignore","hash":"3558a8b174618c7a643aceb13233edd729813f9a","modified":1556894150637},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1556894150637},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1556894150637},{"_id":"themes/next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1556894150637},{"_id":"themes/next/_config.yml","hash":"31bbc395f04a473f13b55e516b4deb2ea32d4e33","modified":1558331966627},{"_id":"themes/next/bower.json","hash":"8fa4f26f5205cbc64d33318d1be5d35b2667398c","modified":1556894150637},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1556894150637},{"_id":"themes/next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1556894150641},{"_id":"themes/next/package.json","hash":"888bcacea284ec536a1428ad957a78dfb3ec255d","modified":1556894150644},{"_id":"source/_posts/2008年5月12日14时28分04秒.md","hash":"c5ea941e3cf7a39609098a2dd898c51c3a5bd0dd","modified":1557674757143},{"_id":"source/_posts/C-内存四区之代码区与全局区.md","hash":"83c3e9f6d0e2a8816edfbe6d1fe4a20f80a67bed","modified":1557847870807},{"_id":"source/_posts/C-内存四区之堆区.md","hash":"e15526c51ce83aae48d53fed6cfbafc4709f1432","modified":1557482413640},{"_id":"source/_posts/C-内存四区之栈区.md","hash":"69104dcc33c9f327aab970295d8879f2747a3767","modified":1557482413640},{"_id":"source/_posts/C-函数探幽.md","hash":"2a87dc1c4e79a5ddaccb5ec6d63b672f6ca0966c","modified":1557413710943},{"_id":"source/_posts/C-指针-基础01.md","hash":"efe160c3d372e21f9859c3490b819fb0b7f5a381","modified":1557413703853},{"_id":"source/_posts/C-友元.md","hash":"3b1582401978a7783c9cdad7fd084250221d764c","modified":1558428389190},{"_id":"source/_posts/C-指针-基础02.md","hash":"5c33a68bef7c0ee36e11753bbd16a3c8a5ea450e","modified":1557413697567},{"_id":"source/_posts/Linux中的解压与压缩.md","hash":"315c8b0781112d2f49a59de124926b8e943ecda4","modified":1557413672530},{"_id":"source/_posts/ManjaroLinuxTG讨论群组.md","hash":"d07e8516f78dadabdd29ebef18cc96a715769420","modified":1557936221913},{"_id":"source/_posts/C-读写文件.md","hash":"9a7850229a5ffa7ff0f025b66d1a9cee48694796","modified":1558624342211},{"_id":"source/_posts/hexo-next插入网易云音乐.md","hash":"14e906fb89646ca557003f1e4dfd335e51bb2b62","modified":1557413689830},{"_id":"source/_posts/hexo博客文章插入图片.md","hash":"558f15f9aba7a586f16cb3dc4b6be67043d88e0c","modified":1557413681177},{"_id":"source/_posts/ManjaroLinux的安装过程.md","hash":"47e96f0542a4246cdd300115a5ff0375c08bf921","modified":1557413655127},{"_id":"source/_posts/如何用hexo-github-pages搭建博客.md","hash":"3914749b99ea79f5e84920cf507723692e986c71","modified":1557413662657},{"_id":"source/_posts/如何自学编程.md","hash":"c216c5a029c2b684bad1d5c7186aa3ba86200d54","modified":1558624181850},{"_id":"source/_posts/我儿子的博客.md","hash":"f0af5adf03a78befaeded83a43f47d14bd1cbb65","modified":1558624342211},{"_id":"source/_posts/我的Linux之路.md","hash":"98695246419a1381a04c23cf514995fe1f6cfba4","modified":1557850024533},{"_id":"source/_posts/深拷贝和浅拷贝的区别.md","hash":"4df9447000917c6f6f08e727f3b598e8ac01752b","modified":1557851982660},{"_id":"source/_posts/解决KDE下部分应用不能使用fctix中文输入法的问题.md","hash":"8fd64a2586b1ab78dabd2d16ee3985562e3ed7e2","modified":1558331966627},{"_id":"source/_posts/终端多窗口神器——Screen.md","hash":"b99e62af0cc6e8d128ed650502921f24c4459a24","modified":1557413640133},{"_id":"source/categories/index.md","hash":"c253f6262eddb81f50f7e92baa7d4a0185acdbf2","modified":1556894150634},{"_id":"source/tags/index.md","hash":"603136cef8b46b91aa07a80a7abd0716b1217709","modified":1556894150634},{"_id":"source/关于我/index.md","hash":"8dd11324b17266ba9f9d60ad990ac7d5db49ca48","modified":1557880562450},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1556894150637},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"285a95aca36e0ac770bcde2b35e3b572d45d1518","modified":1556894150637},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1556894150637},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"492b2c159d871e5b5d4c70d259f36e603afe192d","modified":1556894150637},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1556894150637},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1556894150637},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1556894150637},{"_id":"themes/next/.github/mergeable.yml","hash":"8e3a6abc74b5cba57f9586fe6d98762fd4fc9b04","modified":1556894150637},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1556894150637},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1556894150637},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1556894150637},{"_id":"themes/next/.github/topissuebot.yml","hash":"10665bf2b5aba351725715c71e94ad183a0e8f18","modified":1556894150637},{"_id":"themes/next/.github/weekly-digest.yml","hash":"404e4ccb7fcd6587bc9b0247a7a7ff256d21f2cb","modified":1556894150637},{"_id":"themes/next/.github/release-drafter.yml","hash":"b4476ada5c62ee7d63ba2e59ead2ec4897086e3c","modified":1556894150637},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1556894150637},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1556894150637},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1556894150637},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1556894150637},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1556894150641},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1556894150641},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1556894150641},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1556894150641},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1556894150641},{"_id":"themes/next/layout/_layout.swig","hash":"74701fcf2303d59400587436ab4c244e04df7ad9","modified":1557076839703},{"_id":"themes/next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1556894150644},{"_id":"themes/next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1556894150644},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1556894150644},{"_id":"themes/next/layout/page.swig","hash":"d8a6cbf6f611c5d68d5da430cb6dc7010ff2c7e0","modified":1556894150644},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1556894150644},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1556894150644},{"_id":"themes/next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1556894150644},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1556894150641},{"_id":"themes/next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1556894150641},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1556894150641},{"_id":"themes/next/languages/es.yml","hash":"1752429687861b5cedd063c6ebe5dacefbe7e5a7","modified":1556894150641},{"_id":"themes/next/languages/fr.yml","hash":"7005c2b42c2c6e82bd7a1be5cc2f443b5fc79105","modified":1556894150641},{"_id":"themes/next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1556894150641},{"_id":"themes/next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1556894150641},{"_id":"themes/next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1556894150641},{"_id":"themes/next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1556894150641},{"_id":"themes/next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1556894150641},{"_id":"themes/next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1556894150641},{"_id":"themes/next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1556894150641},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1556894150641},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1556894150641},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1556894150641},{"_id":"themes/next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1556894150641},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1556894150641},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1556894150641},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1556894150641},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1556894150644},{"_id":"themes/next/source/404.html","hash":"a5991bb3598c5d934bd97e3bc4ed14b71ebf1e62","modified":1556917308544},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1556894150644},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1556894150647},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1556894150647},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1556894150647},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556894150647},{"_id":"source/_posts/C-内存四区之代码区与全局区/代码区示意图.png","hash":"2a6b0689ddce4a392d7682b7cc097553ba275324","modified":1557580437467},{"_id":"source/_posts/C-内存四区之堆区/test.png","hash":"23c51bc2893f2c2b8828d47a5d531ac10111c300","modified":1557482413640},{"_id":"source/_posts/2008年5月12日14时28分04秒/流量图.webp","hash":"27c7ab59ae1f74cfea9a7cb67f9502ff3f4144be","modified":1557673333690},{"_id":"source/_posts/2008年5月12日14时28分04秒/操场.webp","hash":"84b7577e7d9c8c41cde1d1a41606d9077e4c682d","modified":1557673221147},{"_id":"source/_posts/2008年5月12日14时28分04秒/空降.webp","hash":"9a4e00e6b4f76fcef94423bfa1910da06a01364f","modified":1557672827800},{"_id":"source/_posts/C-读写文件/二进制文件.png","hash":"5fce0c55af8a1d1a375ab1dd71c7b06f3416e13c","modified":1558624342211},{"_id":"source/_posts/C-指针-基础02/指针位偏移.png","hash":"156676e17c34db6889b740035c5afebc560c79f4","modified":1557320822767},{"_id":"source/_posts/hexo-next插入网易云音乐/插哪.png","hash":"8928d6bd2393fb9cebf22a137d4f198a1bca8f1f","modified":1556894150627},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/ssh目录.png","hash":"6929462dbbece6c66d66111337bc50954f3420e1","modified":1556894150631},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/deploy.png","hash":"e7b85d668727ff191542d33f0f8b7fd4626216d9","modified":1556894150627},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/导入密钥.png","hash":"eb1ed1a6da91cf7a446f714ca7ad95edde7a4545","modified":1556894150631},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/打开设置.png","hash":"a277cee3b835adfc37ce01e798a5302a5ae70e02","modified":1556894150631},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1556894150637},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1556894150637},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1556894150637},{"_id":"source/_posts/终端多窗口神器——Screen/detachedInfo.png","hash":"39337b8922e262fb456a13464188e1d145199b97","modified":1557411983077},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1556894150637},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1556894150641},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1556894150641},{"_id":"themes/next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1556894150641},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1556894150641},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1556894150641},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1556894150641},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bc43beb3af74d64fbd3920539d08861e4cadb9a0","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b76ccbc658024e86639cfa5f8a3817647fc8d651","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1556894150641},{"_id":"themes/next/docs/zh-CN/README.md","hash":"1b5bd6ae5781137d81dc8667e912d3df6eeab260","modified":1556894150641},{"_id":"themes/next/layout/_partials/comments.swig","hash":"09a01a124bc1cf4ba369fa6101f547906b68edc2","modified":1557682429427},{"_id":"themes/next/layout/_partials/footer.swig","hash":"589f545333e21a8c7823bce89ab45cf1eb7db6e2","modified":1557076839703},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1556894150641},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1556894150641},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1556894150641},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"b787d5c965ffe1a9cb8c3fbfa767f3a62bfe2ea0","modified":1556894150641},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"f29b50d83bcdc9e70696b6a8a8917d8b2ad4be10","modified":1556918256288},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1556894150641},{"_id":"themes/next/layout/_macro/post.swig","hash":"06c586ee180ee66989804dad666a7951c34f93fc","modified":1557412341813},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"23b9dacfac1e5a137b1f4687a3eddb5d2c0fc7bf","modified":1556894150641},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1556894150641},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1556894150641},{"_id":"themes/next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1556894150641},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1556894150641},{"_id":"themes/next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1556894150641},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"83470eb401f78f4683907c48ad6760b90730daa3","modified":1556894150641},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1556894150641},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1556894150641},{"_id":"themes/next/layout/_third-party/chatra.swig","hash":"eefb68b69b4b0ed558ee0324ccd711990059b20d","modified":1556894150641},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"01ded5e1bad89a6f8d64cd063e3e4e42c20d33bc","modified":1556894150641},{"_id":"themes/next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1556894150644},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1556894150644},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1556894150644},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1556894150644},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5db80e8d7ea3f29e998320f79508f7e14342a33c","modified":1556894150644},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1556894150644},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1556894150644},{"_id":"themes/next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1556894150644},{"_id":"themes/next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1556894150644},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1556894150644},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1556894150644},{"_id":"themes/next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1556894150644},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1556894150644},{"_id":"themes/next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1556894150644},{"_id":"themes/next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1556894150644},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1556894150644},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1556894150644},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1556894150644},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1556894150644},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1556894150644},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1556894150644},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1556894150644},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1556894150644},{"_id":"themes/next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1556894150647},{"_id":"themes/next/source/css/style.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1558332095363},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1556894150647},{"_id":"themes/next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1556894150647},{"_id":"themes/next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1556894150647},{"_id":"themes/next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1556894150647},{"_id":"themes/next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1556894150647},{"_id":"themes/next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1556894150647},{"_id":"themes/next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1556894150647},{"_id":"themes/next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1556894150647},{"_id":"themes/next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1556894150647},{"_id":"themes/next/source/js/utils.js","hash":"3c987de7cfb944c33e9e527f1214724c7aafc796","modified":1556894150647},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1556894150647},{"_id":"themes/next/source/images/alipay.jpg","hash":"ac4b5bc8f3ae1a8a512b0d0663e2abf0bfea246d","modified":1556894150647},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1556894150647},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1556894150647},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1556894150647},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1556894150647},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1556894150647},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1556894150647},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1556894150647},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1556894150647},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1556894150647},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1556894150647},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1556894150647},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1556894150647},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1556894150647},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1556894150647},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1556894150647},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1556894150647},{"_id":"themes/next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1556894150647},{"_id":"source/_posts/ManjaroLinux的安装过程/分区.png","hash":"6a54d049cbfe3fc4d65d6a027b36ad758ed61b6c","modified":1556894150621},{"_id":"source/_posts/ManjaroLinux的安装过程/分区标识.png","hash":"675089cbcbe932471d6ce5c7b3a8671ee689c8c2","modified":1556894150621},{"_id":"source/_posts/hexo-next插入网易云音乐/01.png","hash":"f1bbad3d02ccb53b8898fc7ad337ef5ea368b2ae","modified":1556894150627},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/创建仓库.png","hash":"2008592b8eda92867b78f6deb69971dce00c7b13","modified":1556894150631},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/设置SSH.png","hash":"e9f200e3559e93a06fa4e8b9c37a486949081a45","modified":1556894150631},{"_id":"source/_posts/终端多窗口神器——Screen/DefalutCommandKey.png","hash":"6a5a12569b253f7bec7087f7f6ad3eea3791218c","modified":1557411983077},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556894150644},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556894150644},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556894150644},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556894150647},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556894150647},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"38959a2b517f6c0b7c851b288ed0339d9bc62f76","modified":1556894150647},{"_id":"themes/next/source/images/wechatPay.png","hash":"69539f4644858fc6e2fbeb6a5d187a7244c89506","modified":1557338320000},{"_id":"source/_posts/ManjaroLinux的安装过程/安装选择界面.png","hash":"25d2152a8bb8e8e2eb904610ef7068576c9b7d11","modified":1556894150621},{"_id":"source/_posts/ManjaroLinux的安装过程/开始安装.png","hash":"2ac6b5ee42b758265b9c4d130d303e2050e8a929","modified":1556894150624},{"_id":"source/_posts/ManjaroLinux的安装过程/摘要.png","hash":"763ba8b64bc381afc7eb4b0166db36741399872a","modified":1556894150624},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1556894150641},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1556894150641},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1556894150641},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1556894150641},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1556894150641},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1556894150641},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1556894150641},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1556894150641},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"36eae78a4d7160a1c5e59ca3f7333f00b43d359b","modified":1556894150641},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1556894150641},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1556894150641},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1556894150641},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1556894150641},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1556894150641},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1556894150641},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1556894150641},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1556894150641},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1556894150641},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1556894150641},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1556894150641},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1556894150641},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1556894150641},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1556894150641},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1556894150641},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1556894150641},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1556894150641},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"c77a2e7ef5f449a445fb4d36b055721fba4a81af","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"2cbaae65a020bbb0e9265364488aff8bf84fa48d","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"388efc86af7f19c05ad0e26720cd24ee012d20b9","modified":1556894150641},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4a908b613518878b9b69576c5dba4a5185f552ab","modified":1556894150641},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1556894150641},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1556894150644},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1556894150644},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"d422beaf35a5d2646feaa098bc3e5adf691c7565","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1556894150641},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1556894150641},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"e3ede52f6f71a906c8e87d96f039e602a9501949","modified":1558428389190},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1556894150644},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1556894150644},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1556894150644},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1556894150644},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1556894150644},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"2036bbb73afd43251982ce824f06c6e88d35a2ef","modified":1556894150644},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1556894150647},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1556894150647},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1556894150647},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1556894150647},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1556894150647},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1556894150647},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1556894150647},{"_id":"themes/next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1556894150647},{"_id":"source/_posts/如何自学编程/群组.png","hash":"41dcf8a1a81a79580dd7a9b35edd424d54c1e79d","modified":1558624090522},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1556894150647},{"_id":"themes/next/source/css/_variables/base.styl","hash":"640f25a63770af5566ccc9cec79c40a4f1c0b29e","modified":1556894150647},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1556894150644},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1556894150644},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1556894150644},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"a5305a2fa0b03b1dc1dfd156bb1a590b4819f1f3","modified":1556894150644},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1556894150644},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"33456264a74d1bba38264d14713544d67d003733","modified":1556894150644},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"fe5ff961b86004a306778c7d33a85b32e5e00e48","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"c8b3225396cb444d8baeb94bac78e5216b992a81","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"ea7ae16562c619a589bcddde57a061b883f6c6bc","modified":1557680928747},{"_id":"themes/next/source/css/_common/components/gitment.styl","hash":"a22797865d5266e6f8560570c1e874bb87da552b","modified":1557680898890},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"57044a6d19eb418c1c3d28787e82c69efa9e0ca6","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1556894150647},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1556894150647},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1556894150647},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/逆光.jpg","hash":"e31908ec199b23699ac587a1963a54bce16d362a","modified":1556894150634},{"_id":"source/_posts/我儿子的博客/预览.png","hash":"127d112dee5632a53e88a5e6888bd0acb94404ab","modified":1558624342211},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1556894150647},{"_id":"source/_posts/ManjaroLinux的安装过程/编辑文章时截图.png","hash":"3557732a051927d718f9bdff7c4bd3f98a8bbe52","modified":1556894150627},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"6c4990d375b640ee4551e62c48c1cbe4c3d62212","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e9dd8de7d98f1478ac7d351624fffd3d8738c905","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"1a510f995e665b28d85ba4d169b824276c40e4f3","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"1385862a5c0bd845015d165aadbd1a6add7b72d7","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b082d07b13a3d55b4c032fd351dfa9a4fd74edec","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"473dd49e73f4356b93699904f4daa64c43bc2430","modified":1557412376517},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1557076839703},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cc83816614f21c7e1d8d3f867d547ff7c658cec4","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c01609176929590f8f347075a9a12b661acd661e","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"fcda60fecff1479adaf6521cf629cda2506337a8","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"f1d9ee1f86a179741f2478f8c70ca11ab578810e","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1556894150644},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"03c4fa9573fddd930552784cf484fd2ee7825323","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1556894150644},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1556894150644},{"_id":"themes/next/source/images/aliPay.png","hash":"61750b1d63b30ca8ac5bcbec79664d541223b879","modified":1557338324000},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/hexoinit.png","hash":"46b6d53a445cc3e15cc45ab9afd916486e3a5d7a","modified":1556894150631},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/本地部署.png","hash":"0cfadb0ae6808ba58c821653ca76e8099819e98d","modified":1556894150631},{"_id":"source/_posts/ManjaroLinux的安装过程/桌面.png","hash":"99a28838b2ba8cf7fdce7f3f997723c185326fdf","modified":1556894150627},{"_id":"themes/next/source/images/background.png","hash":"a0ec840a777b3b18ca80b71b3d23553311008191","modified":1557411504583},{"_id":"themes/next/source/images/card.png","hash":"08e8213581ac3fac8c119440a124643b05ef716a","modified":1557411504593},{"_id":"themes/next/source/images/background2.png","hash":"8611760e073872829af4a22dbeb38cd5ccf2144a","modified":1557411504590},{"_id":"themes/next/source/images/img.jpg","hash":"f84efb620744db1c422800669c4fcb852e03998d","modified":1558428389210},{"_id":"public/atom.xml","hash":"243da31c2b38d9f3f84efe456d469654b340c84e","modified":1558624363815},{"_id":"public/search.xml","hash":"31abe5331d36afc008b2cba6b7bb9a053c9ca56c","modified":1558624363815},{"_id":"public/sitemap.xml","hash":"a4be77e976651fb58285c694551e18554b2e82d5","modified":1558624363833},{"_id":"public/categories/转载/index.html","hash":"cfbe4f617b08fef79789973f3c82703038507685","modified":1558624378170},{"_id":"public/categories/折腾日记/index.html","hash":"780814e821c44160624dd6cadcd37fe5eafa6475","modified":1558624378170},{"_id":"public/tags/社会事件/index.html","hash":"d7189c02ca41b4a138c70063b64264ac0e9252c0","modified":1558624378171},{"_id":"public/tags/基础/index.html","hash":"7d8e0dc8cb1a9c2d7b23a1f0f22eddc132955b4b","modified":1558624378171},{"_id":"public/tags/Telegram/index.html","hash":"f849b50f617d00496fcd1d6228d89bd54ea2606a","modified":1558624378171},{"_id":"public/tags/网易云音乐/index.html","hash":"3915758f1b40da0eb469ffd79117f671df6820e8","modified":1558624378171},{"_id":"public/tags/博客/index.html","hash":"f86fe36bf7c2bdfec043c5c3fc23d82caf9afbdf","modified":1558624378171},{"_id":"public/tags/折腾/index.html","hash":"2eb4a077cf62b62394458b9704ff76d8be7af299","modified":1558624378171},{"_id":"public/tags/软件使用/index.html","hash":"a8086087b2ef1db97201beaf8f5760867f82cef3","modified":1558624378172},{"_id":"public/tags/欢乐时光/index.html","hash":"6be5f9f4873032400958c4b01782914c14c9d2e9","modified":1558624378172},{"_id":"public/tags/个人感想/index.html","hash":"9b91b9aa1cb82a08360dd1e09ece9ecbef43b835","modified":1558624378172},{"_id":"public/tags/KDE/index.html","hash":"4e9fc184eeddc6ef4ad9f90d53c810d5553fe294","modified":1558624378172},{"_id":"public/tags/经典案例/index.html","hash":"17ebbd328253ca41449b1b3740c9a114e1361c2a","modified":1558624378172},{"_id":"public/tags/软件折腾/index.html","hash":"3a51cdbce3a6932e742c51bc24dbb6fa2987725b","modified":1558624378172},{"_id":"public/tags/编程/index.html","hash":"611127637d0ae52b390396509ced8ac8c3499471","modified":1558624378172},{"_id":"public/categories/index.html","hash":"6d070e92eaa57c3cf107c0eb4b011d550070896f","modified":1558624378172},{"_id":"public/tags/index.html","hash":"29de585d1f3353e46e98b0f34dd1bc1ca1cb10b6","modified":1558624378172},{"_id":"public/关于我/index.html","hash":"b42ab5517a1e042708aec632ec7c1de78cc90752","modified":1558624378172},{"_id":"public/2019/05/23/如何自学编程/index.html","hash":"0160fc911c953ef4b2cedf51594ce8cddd25cec6","modified":1558624378172},{"_id":"public/2019/05/22/C-读写文件/index.html","hash":"10105d58e65e7732124baba4159757009a9d2bbf","modified":1558624378172},{"_id":"public/2019/05/21/我儿子的博客/index.html","hash":"69d18397a32be3fe883bd289c4bc5719f54d6446","modified":1558624378172},{"_id":"public/2019/05/19/解决KDE下部分应用不能使用fctix中文输入法的问题/index.html","hash":"23b08b1a2c4a8f24bd84d5c075dc57099531e3f2","modified":1558624378172},{"_id":"public/2019/05/17/C-友元/index.html","hash":"2b4c7d94b3692a1770ff6c652d3cfc627eb8ad24","modified":1558624378173},{"_id":"public/2019/05/16/ManjaroLinuxTG讨论群组/index.html","hash":"f5a539829110b469c2f2cd77d1dfd03f8fe8613f","modified":1558624378173},{"_id":"public/2019/05/15/我的Linux之路/index.html","hash":"2a8f5831c1f8d26285954b0cbe38fe4cd3247255","modified":1558624378173},{"_id":"public/2019/05/14/深拷贝和浅拷贝的区别/index.html","hash":"6d127a16168083e53c6bc166402a860584296783","modified":1558624378173},{"_id":"public/2019/05/12/2008年5月12日14时28分04秒/index.html","hash":"c96e650a667ffe468b6f7d81a78c0bdfc57da571","modified":1558624378173},{"_id":"public/2019/05/11/C-内存四区之代码区与全局区/index.html","hash":"a035ae210e1b70a1aab676263c93cbe28b5ccdfa","modified":1558624378173},{"_id":"public/2019/05/10/C-内存四区之堆区/index.html","hash":"618330e8b3105809bc1e9eb0176b316e761d8aa6","modified":1558624378173},{"_id":"public/2019/05/10/C-内存四区之栈区/index.html","hash":"9c8bcbd77b35d1f12ba199089c8dea8bec378239","modified":1558624378173},{"_id":"public/2019/05/09/终端多窗口神器——Screen/index.html","hash":"afc3bd6868a05006667eaae290577acc6c1e8b3c","modified":1558624378173},{"_id":"public/2019/05/08/Linux中的解压与压缩/index.html","hash":"b5eca008c29c3df4ec83553e418a1cbfeada7036","modified":1558624378173},{"_id":"public/2019/05/06/C-指针-基础02/index.html","hash":"2a0997455d54ea3f335722a74680f3b56348a93b","modified":1558624378173},{"_id":"public/2019/05/06/C-指针-基础01/index.html","hash":"5e4c4a9d018933a5370fa3d05589c1f7fbf6ca7e","modified":1558624378173},{"_id":"public/2019/04/30/hexo-next插入网易云音乐/index.html","hash":"fdcab71dbeb5712017124e3beafbcc498c169b59","modified":1558624378173},{"_id":"public/2019/04/29/如何用hexo-github-pages搭建博客/index.html","hash":"03342ecddb8d2f1f6b748b8a90f9c8b6933fca3e","modified":1558624378174},{"_id":"public/2019/04/29/hexo博客文章插入图片/index.html","hash":"65c260d3e929fbd9790f29ac10d4a6b16faa3a99","modified":1558624378174},{"_id":"public/2019/04/24/C-函数探幽/index.html","hash":"7f82fff8afe3d8c3f02628f60cf2a30d8f64bb32","modified":1558624378174},{"_id":"public/2019/04/23/ManjaroLinux的安装过程/index.html","hash":"d456c3a5ee84ddd44c8e9a8a6a921ce6a726baee","modified":1558624378174},{"_id":"public/archives/index.html","hash":"c899fb7e646159c857199f5fba8a6e92d2cbf0f1","modified":1558624378174},{"_id":"public/archives/page/2/index.html","hash":"467c213e9bb2693d8903d1d18be0df279e9b9fd8","modified":1558624378174},{"_id":"public/archives/2019/index.html","hash":"72c0b9c8dbc9881935bf1ee3d73ffa594c83105d","modified":1558624378174},{"_id":"public/archives/2019/page/2/index.html","hash":"649bc204f2cef21e1d01ca9cb9ac51ff6dfc8f5d","modified":1558624378175},{"_id":"public/archives/2019/04/index.html","hash":"6dd1998dbb05b4d8a43e20e15a45932697360415","modified":1558624378175},{"_id":"public/archives/2019/05/index.html","hash":"5887b43449413cb8c0d79fd1ba5376a440e74c65","modified":1558624378175},{"_id":"public/archives/2019/05/page/2/index.html","hash":"a37abd4a9bbb44350420e7ef01a75aab44172db0","modified":1558624378175},{"_id":"public/categories/学习笔记/index.html","hash":"fba78703552e9ed08e8a42ddcac24331cb5100b9","modified":1558624378175},{"_id":"public/categories/学习笔记/page/2/index.html","hash":"c85dd58216890e22e3d904d0cf605f864cad6651","modified":1558624378175},{"_id":"public/categories/分享/index.html","hash":"1f198dc75f77737b3885cca62c706df6152bb30a","modified":1558624378175},{"_id":"public/categories/折腾记录/index.html","hash":"b6b2136a5b3327b9f25da69d0120e621673477c9","modified":1558624378175},{"_id":"public/categories/个人感想/index.html","hash":"224f266e103e914c98c0e4a07d1f0fbb41161557","modified":1558624378175},{"_id":"public/index.html","hash":"58d39cb015b2ef64d72700dad11f8d0352999fa4","modified":1558624378175},{"_id":"public/page/2/index.html","hash":"dfd22005e80dcf8bb87ed3523ea9f8482feb1c30","modified":1558624378175},{"_id":"public/tags/C/index.html","hash":"2e218581ad8ac52676c84a89bbbc1e026f77935c","modified":1558624378175},{"_id":"public/tags/指针/index.html","hash":"2dbba27eb8ff550c5ab95df0fb039de1bdd0a008","modified":1558624378176},{"_id":"public/tags/学习笔记/index.html","hash":"a2a806376b0988c86f49ac4783474ae335804bf5","modified":1558624378176},{"_id":"public/tags/Linux/index.html","hash":"9526b3161e3f994e6d1ca3db28fed1d51600937b","modified":1558624378176},{"_id":"public/tags/hexo/index.html","hash":"09addc18ec242ad16b138291594420db8e11ae2c","modified":1558624378176},{"_id":"public/archives/page/3/index.html","hash":"4e1de8aff0b5a1adca1bab9bbab08117c5acfcf8","modified":1558624378178},{"_id":"public/archives/2019/page/3/index.html","hash":"c7524bb3c90e9d97e893bbcc83bd3a49de0708d6","modified":1558624378178},{"_id":"public/page/3/index.html","hash":"8b82477fd745146b1e1c8457e1f6ec1692b4e763","modified":1558624378178}],"Category":[{"name":"学习笔记","_id":"cjw0sp9x20004xcvvwp70aysd"},{"name":"转载","_id":"cjw0sp9x7000axcvv0uqs68ot"},{"name":"分享","_id":"cjw0sp9xh000txcvvzidh6o55"},{"name":"折腾记录","_id":"cjw0sp9xo0010xcvv6hlb82h6"},{"name":"个人感想","_id":"cjw0sp9xu001lxcvvmqps63zh"},{"name":"折腾日记","_id":"cjw0sp9xw001xxcvvccm88ito"}],"Data":[],"Page":[{"title":"文章分类","date":"2019-04-23T08:03:29.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-04-23 16:03:29\ntype: \"categories\"\n---\n","updated":"2019-05-03T14:35:50.634Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjw0sp9wz0001xcvvo6xrhy1b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-04-23T08:06:47.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-04-23 16:06:47\ntype: \"tags\"\n---\n","updated":"2019-05-03T14:35:50.634Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjw0sp9x10003xcvv6ecagydu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2019-05-01T12:58:42.000Z","_content":"\n# Q: 你是谁?\n\n# A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\n\n---\n\n# Q: 你是做什么的?\n\n# A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\n\n---\n\n# Q: 如何联系你?\n\n# A: 你可以通过如下途径联系我:\n\n- email: the_lty_mail@foxmail.com\n\n- wechat: A2-B0x\n\n- tencentQQ: 2864011679\n\n- GitHub-Issue: [点击提交反馈](https://github.com/EvanMeek/evanmeek.github.io/issues/new)\n","source":"关于我/index.md","raw":"---\ntitle: 关于我\ndate: 2019-05-01 20:58:42\n---\n\n# Q: 你是谁?\n\n# A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\n\n---\n\n# Q: 你是做什么的?\n\n# A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\n\n---\n\n# Q: 如何联系你?\n\n# A: 你可以通过如下途径联系我:\n\n- email: the_lty_mail@foxmail.com\n\n- wechat: A2-B0x\n\n- tencentQQ: 2864011679\n\n- GitHub-Issue: [点击提交反馈](https://github.com/EvanMeek/evanmeek.github.io/issues/new)\n","updated":"2019-05-15T00:36:02.450Z","path":"关于我/index.html","comments":1,"layout":"page","_id":"cjw0sp9x50007xcvvw4pe94rl","content":"<h1 id=\"Q-你是谁\"><a href=\"#Q-你是谁\" class=\"headerlink\" title=\"Q: 你是谁?\"></a>Q: 你是谁?</h1><h1 id=\"A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"><a href=\"#A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\" class=\"headerlink\" title=\"A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"></a>A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。</h1><hr>\n<h1 id=\"Q-你是做什么的\"><a href=\"#Q-你是做什么的\" class=\"headerlink\" title=\"Q: 你是做什么的?\"></a>Q: 你是做什么的?</h1><h1 id=\"A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"><a href=\"#A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\" class=\"headerlink\" title=\"A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"></a>A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。</h1><hr>\n<h1 id=\"Q-如何联系你\"><a href=\"#Q-如何联系你\" class=\"headerlink\" title=\"Q: 如何联系你?\"></a>Q: 如何联系你?</h1><h1 id=\"A-你可以通过如下途径联系我\"><a href=\"#A-你可以通过如下途径联系我\" class=\"headerlink\" title=\"A: 你可以通过如下途径联系我:\"></a>A: 你可以通过如下途径联系我:</h1><ul>\n<li><p>email: <a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n</li>\n<li><p>wechat: A2-B0x</p>\n</li>\n<li><p>tencentQQ: 2864011679</p>\n</li>\n<li><p>GitHub-Issue: <a href=\"https://github.com/EvanMeek/evanmeek.github.io/issues/new\" target=\"_blank\" rel=\"noopener\">点击提交反馈</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Q-你是谁\"><a href=\"#Q-你是谁\" class=\"headerlink\" title=\"Q: 你是谁?\"></a>Q: 你是谁?</h1><h1 id=\"A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"><a href=\"#A-我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\" class=\"headerlink\" title=\"A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。\"></a>A: 我叫李天宇，今年18，生活在广州，没钱时宅，有钱时浪，现在处于没钱时。</h1><hr>\n<h1 id=\"Q-你是做什么的\"><a href=\"#Q-你是做什么的\" class=\"headerlink\" title=\"Q: 你是做什么的?\"></a>Q: 你是做什么的?</h1><h1 id=\"A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"><a href=\"#A-大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\" class=\"headerlink\" title=\"A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。\"></a>A: 大一学生，爱折腾计算机相关事物，偶尔拿起单反拍拍照。</h1><hr>\n<h1 id=\"Q-如何联系你\"><a href=\"#Q-如何联系你\" class=\"headerlink\" title=\"Q: 如何联系你?\"></a>Q: 如何联系你?</h1><h1 id=\"A-你可以通过如下途径联系我\"><a href=\"#A-你可以通过如下途径联系我\" class=\"headerlink\" title=\"A: 你可以通过如下途径联系我:\"></a>A: 你可以通过如下途径联系我:</h1><ul>\n<li><p>email: <a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n</li>\n<li><p>wechat: A2-B0x</p>\n</li>\n<li><p>tencentQQ: 2864011679</p>\n</li>\n<li><p>GitHub-Issue: <a href=\"https://github.com/EvanMeek/evanmeek.github.io/issues/new\" target=\"_blank\" rel=\"noopener\">点击提交反馈</a></p>\n</li>\n</ul>\n"}],"Post":[{"title":"C++内存四区之代码区与全局区","copyright":true,"date":"2019-05-11T12:52:44.000Z","_content":"\n其实这一篇应该是作为\"C++内存四区\"的第一篇的。\n\n<!--more-->\n\n# 0x00 内存分区模型\n\nC++程序在执行时，内存大方向的可划分为 *****************四个区域**\n\n   - 代码区: 存放代码的二进制代码，由操作系统进行管理。\n\n   - 全局区: 存放全局变量和静态变量以及常量。\n\n   - 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。\n\n   - 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。\n\n## 内存四区的意义:\n\n不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。\n\n# 0x01 程序运行前\n\n在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域\n\n代码区:\n\n   存放CPU执行的机器指令\n   \n   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。\n\n   只读的，为了防止程序意外修改代码的指令，所以有了只读。\n\n![代码区示意图](C-内存四区之代码区与全局区/代码区示意图.png)\n\n如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,\n\n而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。\n\n---\n\n","source":"_posts/C-内存四区之代码区与全局区.md","raw":"---\ntitle: C++内存四区之代码区与全局区\ncopyright: true\ndate: 2019-05-11 20:52:44\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n其实这一篇应该是作为\"C++内存四区\"的第一篇的。\n\n<!--more-->\n\n# 0x00 内存分区模型\n\nC++程序在执行时，内存大方向的可划分为 *****************四个区域**\n\n   - 代码区: 存放代码的二进制代码，由操作系统进行管理。\n\n   - 全局区: 存放全局变量和静态变量以及常量。\n\n   - 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。\n\n   - 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。\n\n## 内存四区的意义:\n\n不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。\n\n# 0x01 程序运行前\n\n在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域\n\n代码区:\n\n   存放CPU执行的机器指令\n   \n   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。\n\n   只读的，为了防止程序意外修改代码的指令，所以有了只读。\n\n![代码区示意图](C-内存四区之代码区与全局区/代码区示意图.png)\n\n如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,\n\n而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。\n\n---\n\n","slug":"C-内存四区之代码区与全局区","published":1,"updated":"2019-05-14T15:31:10.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9ws0000xcvvazn1yhs5","content":"<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p>\n<a id=\"more\"></a>\n<h1 id=\"0x00-内存分区模型\"><a href=\"#0x00-内存分区模型\" class=\"headerlink\" title=\"0x00 内存分区模型\"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p>\n<ul>\n<li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p>\n</li>\n<li><p>全局区: 存放全局变量和静态变量以及常量。</p>\n</li>\n<li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p>\n</li>\n<li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>\n</li>\n</ul>\n<h2 id=\"内存四区的意义\"><a href=\"#内存四区的意义\" class=\"headerlink\" title=\"内存四区的意义:\"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p>\n<h1 id=\"0x01-程序运行前\"><a href=\"#0x01-程序运行前\" class=\"headerlink\" title=\"0x01 程序运行前\"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p>\n<p>代码区:</p>\n<p>   存放CPU执行的机器指令</p>\n<p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>\n<p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p>\n<p><img src=\"/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png\" alt=\"代码区示意图\"></p>\n<p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p>\n<p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>其实这一篇应该是作为”C++内存四区”的第一篇的。</p>","more":"<h1 id=\"0x00-内存分区模型\"><a href=\"#0x00-内存分区模型\" class=\"headerlink\" title=\"0x00 内存分区模型\"></a>0x00 内存分区模型</h1><p>C++程序在执行时，内存大方向的可划分为 <strong><strong><strong><strong>*</strong></strong></strong></strong>四个区域**</p>\n<ul>\n<li><p>代码区: 存放代码的二进制代码，由操作系统进行管理。</p>\n</li>\n<li><p>全局区: 存放全局变量和静态变量以及常量。</p>\n</li>\n<li><p>栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。</p>\n</li>\n<li><p>堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>\n</li>\n</ul>\n<h2 id=\"内存四区的意义\"><a href=\"#内存四区的意义\" class=\"headerlink\" title=\"内存四区的意义:\"></a>内存四区的意义:</h2><p>不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。</p>\n<h1 id=\"0x01-程序运行前\"><a href=\"#0x01-程序运行前\" class=\"headerlink\" title=\"0x01 程序运行前\"></a>0x01 程序运行前</h1><p>在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域</p>\n<p>代码区:</p>\n<p>   存放CPU执行的机器指令</p>\n<p>   共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>\n<p>   只读的，为了防止程序意外修改代码的指令，所以有了只读。</p>\n<p><img src=\"/2019/05/11/C-内存四区之代码区与全局区/代码区示意图.png\" alt=\"代码区示意图\"></p>\n<p>如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中,</p>\n<p>而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。</p>\n<hr>"},{"title":"2008年5月12日14时28分04秒","copyright":false,"date":"2019-05-12T14:53:06.000Z","_content":"\n![空降](2008年5月12日14时28分04秒/空降.webp)\n\n  图为汶川大地震时某部队空降救灾  \n\n<!--more-->\n\n# 0x00  \n\n5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。\n\n此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。\n\n伤亡人数：69227人遇难，374643人受伤，17923人失踪。\n\n以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。\n\n# 0x01   \n\n每年的这个时刻，我都不由自主的想起这个事情。\n\n2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。\n\n那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，\n\n突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。\n\n这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！\n\n跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。\n\n宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。\n\n因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。\n\n大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。\n\n晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。\n\n学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。\n\n天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。\n\n![操场](2008年5月12日14时28分04秒/操场.webp)\n\n# 0x02   \n2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。\n\n我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。\n\n两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。\n\n![流量](2008年5月12日14时28分04秒/流量图.webp)\n\n这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。\n\n这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。\n\n谷歌当时的博文说道：\n\n“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”\n\n几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。\n\n全世界的中华儿女在这三分钟连在了一起。\n\n# 0x03   \n\n在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。\n\n大家那时候就只有一个身份，就叫中国人。\n\n那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。\n\n   况且古往今来，历史诚不欺我。   \n\n> 知乎 ———— 小小白告\n\n\n\n汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。\n\n打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。\n\n最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。\n\n  多年过去，讲起这个故事，仍旧热泪盈眶。  \n\n> 知乎 ———— 匿名用户\n\n\n\n昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。\n\n她给我看她们初中的学校。\n\n我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。\n\n我听了这句话瞬间眼睛红了，那年她初二，今年她研二。\n\n   活着，本身就意味着一切。   \n\n> 知乎 ———— 匿名用户\n\n\n\n推荐25分钟纪录片:《为了生命》。\n\n---\n\n本篇文章转载于：[阅读原文](https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##)\n作者：纯洁的微笑(一个有故事的程序员)\n\n\n\n","source":"_posts/2008年5月12日14时28分04秒.md","raw":"---\ntitle: 2008年5月12日14时28分04秒\ncopyright: false\ndate: 2019-05-12 22:53:06\ncategories: 转载\ntags:\n - 社会事件\n---\n\n![空降](2008年5月12日14时28分04秒/空降.webp)\n\n  图为汶川大地震时某部队空降救灾  \n\n<!--more-->\n\n# 0x00  \n\n5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。\n\n此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。\n\n伤亡人数：69227人遇难，374643人受伤，17923人失踪。\n\n以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。\n\n# 0x01   \n\n每年的这个时刻，我都不由自主的想起这个事情。\n\n2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。\n\n那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，\n\n突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。\n\n这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！\n\n跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。\n\n宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。\n\n因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。\n\n大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。\n\n晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。\n\n学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。\n\n天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。\n\n![操场](2008年5月12日14时28分04秒/操场.webp)\n\n# 0x02   \n2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。\n\n我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。\n\n两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。\n\n![流量](2008年5月12日14时28分04秒/流量图.webp)\n\n这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。\n\n这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。\n\n谷歌当时的博文说道：\n\n“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”\n\n几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。\n\n全世界的中华儿女在这三分钟连在了一起。\n\n# 0x03   \n\n在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。\n\n大家那时候就只有一个身份，就叫中国人。\n\n那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。\n\n   况且古往今来，历史诚不欺我。   \n\n> 知乎 ———— 小小白告\n\n\n\n汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。\n\n打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。\n\n最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。\n\n  多年过去，讲起这个故事，仍旧热泪盈眶。  \n\n> 知乎 ———— 匿名用户\n\n\n\n昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。\n\n她给我看她们初中的学校。\n\n我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。\n\n我听了这句话瞬间眼睛红了，那年她初二，今年她研二。\n\n   活着，本身就意味着一切。   \n\n> 知乎 ———— 匿名用户\n\n\n\n推荐25分钟纪录片:《为了生命》。\n\n---\n\n本篇文章转载于：[阅读原文](https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##)\n作者：纯洁的微笑(一个有故事的程序员)\n\n\n\n","slug":"2008年5月12日14时28分04秒","published":1,"updated":"2019-05-12T15:25:57.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9x00002xcvv5nx30yan","content":"<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/空降.webp\" alt=\"空降\"></p>\n<p>  图为汶川大地震时某部队空降救灾  </p>\n<a id=\"more\"></a>\n<h1 id=\"0x00\"><a href=\"#0x00\" class=\"headerlink\" title=\"0x00\"></a>0x00</h1><p>5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。</p>\n<p>此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。</p>\n<p>伤亡人数：69227人遇难，374643人受伤，17923人失踪。</p>\n<p>以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。</p>\n<h1 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"></a>0x01</h1><p>每年的这个时刻，我都不由自主的想起这个事情。</p>\n<p>2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。</p>\n<p>那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，</p>\n<p>突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。</p>\n<p>这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！</p>\n<p>跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。</p>\n<p>宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。</p>\n<p>因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。</p>\n<p>大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。</p>\n<p>晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。</p>\n<p>学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。</p>\n<p>天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/操场.webp\" alt=\"操场\"></p>\n<h1 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"></a>0x02</h1><p>2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。</p>\n<p>我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。</p>\n<p>两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/流量图.webp\" alt=\"流量\"></p>\n<p>这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。</p>\n<p>这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。</p>\n<p>谷歌当时的博文说道：</p>\n<p>“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”</p>\n<p>几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。</p>\n<p>全世界的中华儿女在这三分钟连在了一起。</p>\n<h1 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"></a>0x03</h1><p>在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。</p>\n<p>大家那时候就只有一个身份，就叫中国人。</p>\n<p>那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。</p>\n<p>   况且古往今来，历史诚不欺我。   </p>\n<blockquote>\n<p>知乎 ———— 小小白告</p>\n</blockquote>\n<p>汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。</p>\n<p>打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。</p>\n<p>最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。</p>\n<p>  多年过去，讲起这个故事，仍旧热泪盈眶。  </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。</p>\n<p>她给我看她们初中的学校。</p>\n<p>我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。</p>\n<p>我听了这句话瞬间眼睛红了，那年她初二，今年她研二。</p>\n<p>   活着，本身就意味着一切。   </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>推荐25分钟纪录片:《为了生命》。</p>\n<hr>\n<p>本篇文章转载于：<a href=\"https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##\" target=\"_blank\" rel=\"noopener\">阅读原文</a><br>作者：纯洁的微笑(一个有故事的程序员)</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/空降.webp\" alt=\"空降\"></p>\n<p>  图为汶川大地震时某部队空降救灾  </p>","more":"<h1 id=\"0x00\"><a href=\"#0x00\" class=\"headerlink\" title=\"0x00\"></a>0x00</h1><p>5·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。</p>\n<p>此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。</p>\n<p>伤亡人数：69227人遇难，374643人受伤，17923人失踪。</p>\n<p>以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。</p>\n<h1 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"></a>0x01</h1><p>每年的这个时刻，我都不由自主的想起这个事情。</p>\n<p>2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。</p>\n<p>那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课，</p>\n<p>突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。</p>\n<p>这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！</p>\n<p>跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。</p>\n<p>宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。</p>\n<p>因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。</p>\n<p>大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。</p>\n<p>晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。</p>\n<p>学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。</p>\n<p>天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/操场.webp\" alt=\"操场\"></p>\n<h1 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"></a>0x02</h1><p>2008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。</p>\n<p>我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。</p>\n<p>两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。</p>\n<p><img src=\"/2019/05/12/2008年5月12日14时28分04秒/流量图.webp\" alt=\"流量\"></p>\n<p>这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。</p>\n<p>这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。</p>\n<p>谷歌当时的博文说道：</p>\n<p>“当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。”</p>\n<p>几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。</p>\n<p>全世界的中华儿女在这三分钟连在了一起。</p>\n<h1 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"></a>0x03</h1><p>在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。</p>\n<p>大家那时候就只有一个身份，就叫中国人。</p>\n<p>那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。</p>\n<p>   况且古往今来，历史诚不欺我。   </p>\n<blockquote>\n<p>知乎 ———— 小小白告</p>\n</blockquote>\n<p>汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。</p>\n<p>打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。</p>\n<p>最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。</p>\n<p>  多年过去，讲起这个故事，仍旧热泪盈眶。  </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。</p>\n<p>她给我看她们初中的学校。</p>\n<p>我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。</p>\n<p>我听了这句话瞬间眼睛红了，那年她初二，今年她研二。</p>\n<p>   活着，本身就意味着一切。   </p>\n<blockquote>\n<p>知乎 ———— 匿名用户</p>\n</blockquote>\n<p>推荐25分钟纪录片:《为了生命》。</p>\n<hr>\n<p>本篇文章转载于：<a href=\"https://mp.weixin.qq.com/s/CFNQAx1Ksnxkl29FLnqDnA##\" target=\"_blank\" rel=\"noopener\">阅读原文</a><br>作者：纯洁的微笑(一个有故事的程序员)</p>"},{"title":"C++内存四区之堆区","copyright":true,"date":"2019-05-10T03:13:46.000Z","_content":"\n# 什么是堆区\n\n由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．\n\n# 如何将数据放在堆区\n\n在C++中由**new**关键字在堆区中开辟内存。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint* func(){\n    //创建局部指针变量，但是数据是存放在堆区的。\n    int *a_p= new int(10);\n\n    return a_p;\n} \n\nint main(){\n    int *p = func();\n\n    cout<<*p<<endl;\n\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\n10\n~~~\n\n看到上述代码的**创建局部指针变量，但数据存放在栈区**是什么意思呢?\n\n其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。\n\n![堆区](C-内存四区之堆区/test.png)\n\n也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。\n\n---\n","source":"_posts/C-内存四区之堆区.md","raw":"---\ntitle: C++内存四区之堆区\ncopyright: true\ndate: 2019-05-10 11:13:46\ncategories: 学习笔记\ntags:\n - C++\n---\n\n# 什么是堆区\n\n由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．\n\n# 如何将数据放在堆区\n\n在C++中由**new**关键字在堆区中开辟内存。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint* func(){\n    //创建局部指针变量，但是数据是存放在堆区的。\n    int *a_p= new int(10);\n\n    return a_p;\n} \n\nint main(){\n    int *p = func();\n\n    cout<<*p<<endl;\n\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\n10\n~~~\n\n看到上述代码的**创建局部指针变量，但数据存放在栈区**是什么意思呢?\n\n其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。\n\n![堆区](C-内存四区之堆区/test.png)\n\n也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。\n\n---\n","slug":"C-内存四区之堆区","published":1,"updated":"2019-05-10T10:00:13.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9x40006xcvvlrr8nd63","content":"<h1 id=\"什么是堆区\"><a href=\"#什么是堆区\" class=\"headerlink\" title=\"什么是堆区\"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p>\n<h1 id=\"如何将数据放在堆区\"><a href=\"#如何将数据放在堆区\" class=\"headerlink\" title=\"如何将数据放在堆区\"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a_p= <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a_p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p>\n<p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p>\n<p><img src=\"/2019/05/10/C-内存四区之堆区/test.png\" alt=\"堆区\"></p>\n<p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是堆区\"><a href=\"#什么是堆区\" class=\"headerlink\" title=\"什么是堆区\"></a>什么是堆区</h1><p>由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收．</p>\n<h1 id=\"如何将数据放在堆区\"><a href=\"#如何将数据放在堆区\" class=\"headerlink\" title=\"如何将数据放在堆区\"></a>如何将数据放在堆区</h1><p>在C++中由<strong>new</strong>关键字在堆区中开辟内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建局部指针变量，但是数据是存放在堆区的。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a_p= <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a_p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>看到上述代码的<strong>创建局部指针变量，但数据存放在栈区</strong>是什么意思呢?</p>\n<p>其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。</p>\n<p><img src=\"/2019/05/10/C-内存四区之堆区/test.png\" alt=\"堆区\"></p>\n<p>也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。</p>\n<hr>\n"},{"title":"C++内存四区之栈区","copyright":true,"date":"2019-05-10T02:51:17.000Z","_content":"\n# 什么是栈区\n\n栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..\n\n# 操作栈区的注意事项\n\n在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．\n\n因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\nint *func(){\n    //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．\n    int a = 10;\n\n    //尝试返回局部变量的地址\n    return &a;\n}\nint main(){\n    //接受func的返回值\n    int *p = func();\n    //输出p\n    cout<<*p<<endl;\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~\nProcess finished with exit code 139 (interrupted by signal 11: SIGSEGV)\n~~~\n\n上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．\n\n# 其他问题\n\n可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．\n\n---","source":"_posts/C-内存四区之栈区.md","raw":"---\ntitle: C++内存四区之栈区\ncopyright: true\ndate: 2019-05-10 10:51:17\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n# 什么是栈区\n\n栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..\n\n# 操作栈区的注意事项\n\n在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．\n\n因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\nint *func(){\n    //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．\n    int a = 10;\n\n    //尝试返回局部变量的地址\n    return &a;\n}\nint main(){\n    //接受func的返回值\n    int *p = func();\n    //输出p\n    cout<<*p<<endl;\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~\nProcess finished with exit code 139 (interrupted by signal 11: SIGSEGV)\n~~~\n\n上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．\n\n# 其他问题\n\n可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．\n\n---","slug":"C-内存四区之栈区","published":1,"updated":"2019-05-10T10:00:13.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9x50008xcvvpmfg6c2o","content":"<h1 id=\"什么是栈区\"><a href=\"#什么是栈区\" class=\"headerlink\" title=\"什么是栈区\"></a>什么是栈区</h1><p>栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..</p>\n<h1 id=\"操作栈区的注意事项\"><a href=\"#操作栈区的注意事项\" class=\"headerlink\" title=\"操作栈区的注意事项\"></a>操作栈区的注意事项</h1><p>在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．</p>\n<p>因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//尝试返回局部变量的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//接受func的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\">    <span class=\"comment\">//输出p</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure>\n<p>上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．</p>\n<h1 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h1><p>可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是栈区\"><a href=\"#什么是栈区\" class=\"headerlink\" title=\"什么是栈区\"></a>什么是栈区</h1><p>栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等..</p>\n<h1 id=\"操作栈区的注意事项\"><a href=\"#操作栈区的注意事项\" class=\"headerlink\" title=\"操作栈区的注意事项\"></a>操作栈区的注意事项</h1><p>在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址．</p>\n<p>因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错．</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部变量．存放在栈区,此变量将会在函数体执行完后自动释放．</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//尝试返回局部变量的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//接受func的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();</span><br><span class=\"line\">    <span class=\"comment\">//输出p</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure>\n<p>上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题．</p>\n<h1 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h1><p>可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．</p>\n<hr>\n"},{"title":"C++指针[基础01]","date":"2019-05-06T12:19:25.000Z","copyright":true,"_content":"\n开始写C++中比较难理解的几个知识点的笔记。\n\n<!--more-->\n\n# 0x00 **空指针**\n\n**用途:给指针初始化值。**\n\n**特性:空指针不可访问。**\n\n为什么不可访问?\n\n因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。\n\n**报错例子**\n\n~~~c++\n//定义空指针\nint *p = NULL;\n\n//尝试修改空指针所指向的空间的值,报错!\n*p = 2;\n~~~\n\n**常用情景**\n\n~~~C++\n//定义空指针\nint *p = NULL;\n\nint a = 10;\n\n//使指针重新指向内存空间,可行!\np = &a;\n\n~~~\n\n**小结**\n\n空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。\n\n# 0x01 **野指针**\n\n**说明:指针指向的是非法的内存空间叫做野指针**\n\n**异常:读取访问权限错误**\n\n**报错例子:**\n\n~~~C++\n//使指针指向一个未知空间\nint *p = (int*)0x1010;\n\n//尝试修改指向的空间的值,报错!\n*p = 10;\n~~~\n\n**小结**\n\n我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!\n\n# 0x02 **const修饰指针**\n\nconst修饰指针分为三种场景\n\n- const修饰指针————常量指针\n\n- const修饰常量————指针常量\n\n- const既修饰指针又修饰常量\n\n> 常量指针\n\n~~~C++\nint a=10,b=20;\n\n//定义常量指针\nconst int *p = &a;\n\n//尝试修改指针所指向空间的值,报错!\n*p = 20;\n\n//指针重新指向新的空间,可行!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针是不能修改所指向的空间的值，但可重新指向新的空间**,并且定义时，**const关键字是放在指针的左侧的**。\n\n---\n\n> 指针常量\n\n~~~C++\nint a=10,b=20;\n\n//定义指针常量\nint * const p = &a;\n\n//修改指针所指向空间的值,可行!\n*p=20;\n\n//尝试为指针重新指向新的空间，报错!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针可修改所指向的空间的值，但不可重新指向新的空间**,并且定义时，**const关键字是放在指针的右侧的**。\n\n---\n\n> 既修饰指针又修饰常量\n\n~~~C++\n\nint a=10,b=20;\n\n//定义同时const修饰指针常量的指针\nconst int * cosnt p = &a;\n\n//尝试修改指针所指向的空间的值，报错!\n*p = 20;\n\n//尝试为指针重新指向新的空间，报错!\n\np = &b;\n~~~\n\n看上面的案例，可以得出，**如果指针和常量都被const修饰，那么就和const 引用非常类似了**。\n\n---\n\n**小结**\n\n常量指针\n\n- 不可修改所指向的空间的值\n- 可重新指向新的空间\n\n指针常量\n\n- 可修改所指向的空间的值\n- 不可重新指向新的空间\n\n指针和常量都被const所修饰\n\n- 不可修改所指向的空间的值\n- 不可重新指向新的空间\n\n**小技巧**\n\n> 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符\"*\")的右侧还是做左侧。\n\n---","source":"_posts/C-指针-基础01.md","raw":"---\ntitle: 'C++指针[基础01]'\ndate: 2019-05-06 20:19:25\ncategories: 学习笔记\ntags:\n  - C++\n  - 指针\n  - 学习笔记\n  - 基础\ncopyright: true\n---\n\n开始写C++中比较难理解的几个知识点的笔记。\n\n<!--more-->\n\n# 0x00 **空指针**\n\n**用途:给指针初始化值。**\n\n**特性:空指针不可访问。**\n\n为什么不可访问?\n\n因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。\n\n**报错例子**\n\n~~~c++\n//定义空指针\nint *p = NULL;\n\n//尝试修改空指针所指向的空间的值,报错!\n*p = 2;\n~~~\n\n**常用情景**\n\n~~~C++\n//定义空指针\nint *p = NULL;\n\nint a = 10;\n\n//使指针重新指向内存空间,可行!\np = &a;\n\n~~~\n\n**小结**\n\n空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。\n\n# 0x01 **野指针**\n\n**说明:指针指向的是非法的内存空间叫做野指针**\n\n**异常:读取访问权限错误**\n\n**报错例子:**\n\n~~~C++\n//使指针指向一个未知空间\nint *p = (int*)0x1010;\n\n//尝试修改指向的空间的值,报错!\n*p = 10;\n~~~\n\n**小结**\n\n我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!\n\n# 0x02 **const修饰指针**\n\nconst修饰指针分为三种场景\n\n- const修饰指针————常量指针\n\n- const修饰常量————指针常量\n\n- const既修饰指针又修饰常量\n\n> 常量指针\n\n~~~C++\nint a=10,b=20;\n\n//定义常量指针\nconst int *p = &a;\n\n//尝试修改指针所指向空间的值,报错!\n*p = 20;\n\n//指针重新指向新的空间,可行!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针是不能修改所指向的空间的值，但可重新指向新的空间**,并且定义时，**const关键字是放在指针的左侧的**。\n\n---\n\n> 指针常量\n\n~~~C++\nint a=10,b=20;\n\n//定义指针常量\nint * const p = &a;\n\n//修改指针所指向空间的值,可行!\n*p=20;\n\n//尝试为指针重新指向新的空间，报错!\np = &b;\n~~~\n\n看上面的案例，可以得出，**常量指针可修改所指向的空间的值，但不可重新指向新的空间**,并且定义时，**const关键字是放在指针的右侧的**。\n\n---\n\n> 既修饰指针又修饰常量\n\n~~~C++\n\nint a=10,b=20;\n\n//定义同时const修饰指针常量的指针\nconst int * cosnt p = &a;\n\n//尝试修改指针所指向的空间的值，报错!\n*p = 20;\n\n//尝试为指针重新指向新的空间，报错!\n\np = &b;\n~~~\n\n看上面的案例，可以得出，**如果指针和常量都被const修饰，那么就和const 引用非常类似了**。\n\n---\n\n**小结**\n\n常量指针\n\n- 不可修改所指向的空间的值\n- 可重新指向新的空间\n\n指针常量\n\n- 可修改所指向的空间的值\n- 不可重新指向新的空间\n\n指针和常量都被const所修饰\n\n- 不可修改所指向的空间的值\n- 不可重新指向新的空间\n\n**小技巧**\n\n> 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符\"*\")的右侧还是做左侧。\n\n---","slug":"C-指针-基础01","published":1,"updated":"2019-05-09T14:55:03.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9x60009xcvvraqenlrf","content":"<p>开始写C++中比较难理解的几个知识点的笔记。</p>\n<a id=\"more\"></a>\n<h1 id=\"0x00-空指针\"><a href=\"#0x00-空指针\" class=\"headerlink\" title=\"0x00 空指针\"></a>0x00 <strong>空指针</strong></h1><p><strong>用途:给指针初始化值。</strong></p>\n<p><strong>特性:空指针不可访问。</strong></p>\n<p>为什么不可访问?</p>\n<p>因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。</p>\n<p><strong>报错例子</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改空指针所指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>常用情景</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使指针重新指向内存空间,可行!</span></span><br><span class=\"line\">p = &amp;a;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。</p>\n<h1 id=\"0x01-野指针\"><a href=\"#0x01-野指针\" class=\"headerlink\" title=\"0x01 野指针\"></a>0x01 <strong>野指针</strong></h1><p><strong>说明:指针指向的是非法的内存空间叫做野指针</strong></p>\n<p><strong>异常:读取访问权限错误</strong></p>\n<p><strong>报错例子:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使指针指向一个未知空间</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span>*)<span class=\"number\">0x1010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!</p>\n<h1 id=\"0x02-const修饰指针\"><a href=\"#0x02-const修饰指针\" class=\"headerlink\" title=\"0x02 const修饰指针\"></a>0x02 <strong>const修饰指针</strong></h1><p>const修饰指针分为三种场景</p>\n<ul>\n<li><p>const修饰指针————常量指针</p>\n</li>\n<li><p>const修饰常量————指针常量</p>\n</li>\n<li><p>const既修饰指针又修饰常量</p>\n</li>\n</ul>\n<blockquote>\n<p>常量指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义常量指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指针重新指向新的空间,可行!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针是不能修改所指向的空间的值，但可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的左侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>指针常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义指针常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改指针所指向空间的值,可行!</span></span><br><span class=\"line\">*p=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针可修改所指向的空间的值，但不可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的右侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>既修饰指针又修饰常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义同时const修饰指针常量的指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * cosnt p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向的空间的值，报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>如果指针和常量都被const修饰，那么就和const 引用非常类似了</strong>。</p>\n<hr>\n<p><strong>小结</strong></p>\n<p>常量指针</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>可重新指向新的空间</li>\n</ul>\n<p>指针常量</p>\n<ul>\n<li>可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p>指针和常量都被const所修饰</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p><strong>小技巧</strong></p>\n<blockquote>\n<p>辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"<p>开始写C++中比较难理解的几个知识点的笔记。</p>","more":"<h1 id=\"0x00-空指针\"><a href=\"#0x00-空指针\" class=\"headerlink\" title=\"0x00 空指针\"></a>0x00 <strong>空指针</strong></h1><p><strong>用途:给指针初始化值。</strong></p>\n<p><strong>特性:空指针不可访问。</strong></p>\n<p>为什么不可访问?</p>\n<p>因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。</p>\n<p><strong>报错例子</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改空指针所指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>常用情景</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义空指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使指针重新指向内存空间,可行!</span></span><br><span class=\"line\">p = &amp;a;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。</p>\n<h1 id=\"0x01-野指针\"><a href=\"#0x01-野指针\" class=\"headerlink\" title=\"0x01 野指针\"></a>0x01 <strong>野指针</strong></h1><p><strong>说明:指针指向的是非法的内存空间叫做野指针</strong></p>\n<p><strong>异常:读取访问权限错误</strong></p>\n<p><strong>报错例子:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使指针指向一个未知空间</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span>*)<span class=\"number\">0x1010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指向的空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong></p>\n<p>我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃!</p>\n<h1 id=\"0x02-const修饰指针\"><a href=\"#0x02-const修饰指针\" class=\"headerlink\" title=\"0x02 const修饰指针\"></a>0x02 <strong>const修饰指针</strong></h1><p>const修饰指针分为三种场景</p>\n<ul>\n<li><p>const修饰指针————常量指针</p>\n</li>\n<li><p>const修饰常量————指针常量</p>\n</li>\n<li><p>const既修饰指针又修饰常量</p>\n</li>\n</ul>\n<blockquote>\n<p>常量指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义常量指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向空间的值,报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指针重新指向新的空间,可行!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针是不能修改所指向的空间的值，但可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的左侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>指针常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义指针常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改指针所指向空间的值,可行!</span></span><br><span class=\"line\">*p=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>常量指针可修改所指向的空间的值，但不可重新指向新的空间</strong>,并且定义时，<strong>const关键字是放在指针的右侧的</strong>。</p>\n<hr>\n<blockquote>\n<p>既修饰指针又修饰常量</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">10</span>,b=<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义同时const修饰指针常量的指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * cosnt p = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试修改指针所指向的空间的值，报错!</span></span><br><span class=\"line\">*p = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尝试为指针重新指向新的空间，报错!</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = &amp;b;</span><br></pre></td></tr></table></figure>\n<p>看上面的案例，可以得出，<strong>如果指针和常量都被const修饰，那么就和const 引用非常类似了</strong>。</p>\n<hr>\n<p><strong>小结</strong></p>\n<p>常量指针</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>可重新指向新的空间</li>\n</ul>\n<p>指针常量</p>\n<ul>\n<li>可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p>指针和常量都被const所修饰</p>\n<ul>\n<li>不可修改所指向的空间的值</li>\n<li>不可重新指向新的空间</li>\n</ul>\n<p><strong>小技巧</strong></p>\n<blockquote>\n<p>辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。</p>\n</blockquote>\n<hr>"},{"title":"C++友元","copyright":true,"date":"2019-05-17T09:07:28.000Z","_content":"\n相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。\n\n<!--more-->\n\n# 什么是友元？\n\n友元可以访问类中私有的成员。\n\n它的使用场景又如下几种:\n\n- 全局函数作友元\n\n- 类作友元\n\n- 成员函数做友元\n\n# 实例\n\n下面将通过几个案例，分别演示不同场景下，友元的使用方式。\n\n---\n\n## 全局函数作友元\n\n本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//先声明Person类，防止下面报错\nclass Person;\n//声明showPrivateVar函数，防止报错.\nvoid showPrivateVar();\n\n//定义Person类\nclass Person{\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n\n//类外定义构造函数\nPerson::Person(){\n    this->money = 10;\n}\n/**\n * 访问私有成员\n */\nvoid showPrivateVar(){\n    //实例化Person类对象\n    Person p;\n    //访问Person对象的私有成员\n    cout<<\"尝试访问Person类的私有属性:\"<<p.money<<endl;\n}\n\nint main(){\n    //调用访问私有成员函数\n    showPrivateVar();\n    return 0;\n}\n~~~\n\n显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。\n\n~~~C++\nclass Person{\n    //使showPrivateVar函数作为Person类的友元\n    friend void showPrivateVar();\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n~~~\n\n运行结果:\n\n~~~shell\n尝试访问Person类的私有属性:10\n\nProcess finished with exit code 0\n~~~\n\n我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.\n\n**那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。**\n\n---\n\n## 类作类的友元\n\n这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend FriendForBuild;\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~shell\n我正在访问Build类对象的publicRoom成员:公共客厅\n我正在访问Build类对象的privateRoom成员:私人卧室\n\nProcess finished with exit code 0\n~~~\n\n**可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。**\n\n---\n\n## 成员函数做友元\n\n上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend void FriendForBuild::visit();\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n---\n\n# 总结\n\n友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。\n","source":"_posts/C-友元.md","raw":"---\ntitle: C++友元\ncopyright: true\ndate: 2019-05-17 17:07:28\ncategories: 学习笔记\ntags:\n  - C++\n---\n\n相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。\n\n<!--more-->\n\n# 什么是友元？\n\n友元可以访问类中私有的成员。\n\n它的使用场景又如下几种:\n\n- 全局函数作友元\n\n- 类作友元\n\n- 成员函数做友元\n\n# 实例\n\n下面将通过几个案例，分别演示不同场景下，友元的使用方式。\n\n---\n\n## 全局函数作友元\n\n本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//先声明Person类，防止下面报错\nclass Person;\n//声明showPrivateVar函数，防止报错.\nvoid showPrivateVar();\n\n//定义Person类\nclass Person{\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n\n//类外定义构造函数\nPerson::Person(){\n    this->money = 10;\n}\n/**\n * 访问私有成员\n */\nvoid showPrivateVar(){\n    //实例化Person类对象\n    Person p;\n    //访问Person对象的私有成员\n    cout<<\"尝试访问Person类的私有属性:\"<<p.money<<endl;\n}\n\nint main(){\n    //调用访问私有成员函数\n    showPrivateVar();\n    return 0;\n}\n~~~\n\n显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。\n\n~~~C++\nclass Person{\n    //使showPrivateVar函数作为Person类的友元\n    friend void showPrivateVar();\nprivate:\n    //私有属性，money,showPrivateVar函数访问的就是这个\n    double money;\npublic:\n    //声明构造函数\n    Person();\n};\n~~~\n\n运行结果:\n\n~~~shell\n尝试访问Person类的私有属性:10\n\nProcess finished with exit code 0\n~~~\n\n我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.\n\n**那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。**\n\n---\n\n## 类作类的友元\n\n这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend FriendForBuild;\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n输出结果:\n\n~~~shell\n我正在访问Build类对象的publicRoom成员:公共客厅\n我正在访问Build类对象的privateRoom成员:私人卧室\n\nProcess finished with exit code 0\n~~~\n\n**可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。**\n\n---\n\n## 成员函数做友元\n\n上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。\n\n~~~C++\n#include <iostream>\nusing namespace std;\n\n//声明类，防止报错\nclass Build;\n/**\n * Build类的好朋友类，可以访问它的私有属性\n */\nclass FriendForBuild{\n    Build * b;\npublic:\n    //声明构造函数\n    FriendForBuild();\n    //声明visit函数\n    void visit();\n};\n\n//定义Build类\nclass Build{\n    friend void FriendForBuild::visit();\nprivate:\n    //私有房间\n    string privateRoom;\npublic:\n    //公共房间\n    string publicRoom;\n    /**\n     * 构造函数\n     */\n    Build(){\n       this->privateRoom = \"私人卧室\";\n       this->publicRoom = \"公共客厅\";\n    }\n};\n\nFriendForBuild::FriendForBuild() {\n    b = new Build();\n}\n/**\n * 访问Build类对象的所有成员，包括私有成员\n */\nvoid FriendForBuild::visit(){\n    cout<<\"我正在访问Build类对象的publicRoom成员:\"<<b->publicRoom<<endl;\n    cout<<\"我正在访问Build类对象的privateRoom成员:\"<<b->privateRoom<<endl;\n}\n\n\nint main(){\n    FriendForBuild friendForBuild;\n    friendForBuild.visit();\n    return 0;\n}\n~~~\n\n---\n\n# 总结\n\n友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。\n","slug":"C-友元","published":1,"updated":"2019-05-21T08:46:29.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9x8000dxcvvjg0pnlos","content":"<p>相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。</p>\n<a id=\"more\"></a>\n<h1 id=\"什么是友元？\"><a href=\"#什么是友元？\" class=\"headerlink\" title=\"什么是友元？\"></a>什么是友元？</h1><p>友元可以访问类中私有的成员。</p>\n<p>它的使用场景又如下几种:</p>\n<ul>\n<li><p>全局函数作友元</p>\n</li>\n<li><p>类作友元</p>\n</li>\n<li><p>成员函数做友元</p>\n</li>\n</ul>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>下面将通过几个案例，分别演示不同场景下，友元的使用方式。</p>\n<hr>\n<h2 id=\"全局函数作友元\"><a href=\"#全局函数作友元\" class=\"headerlink\" title=\"全局函数作友元\"></a>全局函数作友元</h2><p>本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先声明Person类，防止下面报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//声明showPrivateVar函数，防止报错.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Person类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外定义构造函数</span></span><br><span class=\"line\">Person::Person()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;money = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化Person类对象</span></span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"comment\">//访问Person对象的私有成员</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"尝试访问Person类的私有属性:\"</span>&lt;&lt;p.money&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用访问私有成员函数</span></span><br><span class=\"line\">    showPrivateVar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//使showPrivateVar函数作为Person类的友元</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试访问Person类的私有属性:10</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.</p>\n<p><strong>那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。</strong></p>\n<hr>\n<h2 id=\"类作类的友元\"><a href=\"#类作类的友元\" class=\"headerlink\" title=\"类作类的友元\"></a>类作类的友元</h2><p>这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> FriendForBuild;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我正在访问Build类对象的publicRoom成员:公共客厅</span><br><span class=\"line\">我正在访问Build类对象的privateRoom成员:私人卧室</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p><strong>可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。</strong></p>\n<hr>\n<h2 id=\"成员函数做友元\"><a href=\"#成员函数做友元\" class=\"headerlink\" title=\"成员函数做友元\"></a>成员函数做友元</h2><p>上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> FriendForBuild::visit();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。</p>\n","site":{"data":{}},"excerpt":"<p>相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。</p>","more":"<h1 id=\"什么是友元？\"><a href=\"#什么是友元？\" class=\"headerlink\" title=\"什么是友元？\"></a>什么是友元？</h1><p>友元可以访问类中私有的成员。</p>\n<p>它的使用场景又如下几种:</p>\n<ul>\n<li><p>全局函数作友元</p>\n</li>\n<li><p>类作友元</p>\n</li>\n<li><p>成员函数做友元</p>\n</li>\n</ul>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>下面将通过几个案例，分别演示不同场景下，友元的使用方式。</p>\n<hr>\n<h2 id=\"全局函数作友元\"><a href=\"#全局函数作友元\" class=\"headerlink\" title=\"全局函数作友元\"></a>全局函数作友元</h2><p>本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先声明Person类，防止下面报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//声明showPrivateVar函数，防止报错.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Person类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外定义构造函数</span></span><br><span class=\"line\">Person::Person()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;money = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化Person类对象</span></span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"comment\">//访问Person对象的私有成员</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"尝试访问Person类的私有属性:\"</span>&lt;&lt;p.money&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用访问私有成员函数</span></span><br><span class=\"line\">    showPrivateVar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//使showPrivateVar函数作为Person类的友元</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">showPrivateVar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有属性，money,showPrivateVar函数访问的就是这个</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> money;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    Person();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试访问Person类的私有属性:10</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员.</p>\n<p><strong>那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。</strong></p>\n<hr>\n<h2 id=\"类作类的友元\"><a href=\"#类作类的友元\" class=\"headerlink\" title=\"类作类的友元\"></a>类作类的友元</h2><p>这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> FriendForBuild;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我正在访问Build类对象的publicRoom成员:公共客厅</span><br><span class=\"line\">我正在访问Build类对象的privateRoom成员:私人卧室</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p><strong>可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。</strong></p>\n<hr>\n<h2 id=\"成员函数做友元\"><a href=\"#成员函数做友元\" class=\"headerlink\" title=\"成员函数做友元\"></a>成员函数做友元</h2><p>上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明类，防止报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Build类的好朋友类，可以访问它的私有属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendForBuild</span>&#123;</span></span><br><span class=\"line\">    Build * b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//声明构造函数</span></span><br><span class=\"line\">    FriendForBuild();</span><br><span class=\"line\">    <span class=\"comment\">//声明visit函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义Build类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> FriendForBuild::visit();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//私有房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> privateRoom;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//公共房间</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> publicRoom;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Build()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;privateRoom = <span class=\"string\">\"私人卧室\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>-&gt;publicRoom = <span class=\"string\">\"公共客厅\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">FriendForBuild::FriendForBuild() &#123;</span><br><span class=\"line\">    b = <span class=\"keyword\">new</span> Build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 访问Build类对象的所有成员，包括私有成员</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> FriendForBuild::visit()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的publicRoom成员:\"</span>&lt;&lt;b-&gt;publicRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"我正在访问Build类对象的privateRoom成员:\"</span>&lt;&lt;b-&gt;privateRoom&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    FriendForBuild friendForBuild;</span><br><span class=\"line\">    friendForBuild.visit();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。</p>"},{"title":"C++指针[基础02]","date":"2019-05-06T13:58:29.000Z","copyright":true,"_content":"\nC++指针和数组的操作。\n\n<!--more-->\n\nC++中访问数组元素可以使用如下示例进行访问:\n\n~~~C++\nint arr[3]={0,1,2};\n\ncout<<\"第2个元素为:\"<<arr[1]<<endl;\n~~~\n\n想必大家都知道输出的值为:1\n\n---\n\n那么我们现在可以使用指针进行访问数组元素\n\n数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\ncout<<\"p:\"<<*p<<endl;\n~~~\n\n输出结果为:\n\n~~~\np:0\n~~~\n\n**提问:**\n\n为什么指针可以指向数组名，而不需要使用引用符(&)？\n\n**疑惑解答:**\n\n那是因为在C++中，数组其实就是一块内存空间，然而里面的**每个元素也就组成了一块连续的内存空间**，而**数组名就当任了数组的首地址**的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。\n\n---\n\n通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\n//对指针进行位偏移\np++;\n\ncout<<\"p:\";\n~~~\n\n输出结果:\n\n~~~\np: 1\n~~~\n\n上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&arr[1]的位置，我们通过下图更直观的查看它的变化。\n\n![位偏移](C-指针-基础02/指针位偏移.png)\n\n---\n\n最后利用指针遍历输出数组内的元素\n\n~~~C++\nint arr[3] = {0,1,2};\n\nint *p = arr;\n\nfor(int i = 0;i <3;i++,p++){\n  std::cout<<*p<<std::endl;\n}\n~~~\n\n输出结果:\n\n~~~\n0\n1\n2\n~~~\n\n---","source":"_posts/C-指针-基础02.md","raw":"---\ntitle: 'C++指针[基础02]'\ndate: 2019-05-06 21:58:29\ncategories: 学习笔记\ntags:\n  - C++\n  - 指针\n  - 学习笔记\ncopyright: true\n---\n\nC++指针和数组的操作。\n\n<!--more-->\n\nC++中访问数组元素可以使用如下示例进行访问:\n\n~~~C++\nint arr[3]={0,1,2};\n\ncout<<\"第2个元素为:\"<<arr[1]<<endl;\n~~~\n\n想必大家都知道输出的值为:1\n\n---\n\n那么我们现在可以使用指针进行访问数组元素\n\n数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\ncout<<\"p:\"<<*p<<endl;\n~~~\n\n输出结果为:\n\n~~~\np:0\n~~~\n\n**提问:**\n\n为什么指针可以指向数组名，而不需要使用引用符(&)？\n\n**疑惑解答:**\n\n那是因为在C++中，数组其实就是一块内存空间，然而里面的**每个元素也就组成了一块连续的内存空间**，而**数组名就当任了数组的首地址**的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。\n\n---\n\n通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];\n\n~~~C++\nint arr[3]={0,1,2};\n\nint *p = arr;\n\n//对指针进行位偏移\np++;\n\ncout<<\"p:\";\n~~~\n\n输出结果:\n\n~~~\np: 1\n~~~\n\n上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&arr[1]的位置，我们通过下图更直观的查看它的变化。\n\n![位偏移](C-指针-基础02/指针位偏移.png)\n\n---\n\n最后利用指针遍历输出数组内的元素\n\n~~~C++\nint arr[3] = {0,1,2};\n\nint *p = arr;\n\nfor(int i = 0;i <3;i++,p++){\n  std::cout<<*p<<std::endl;\n}\n~~~\n\n输出结果:\n\n~~~\n0\n1\n2\n~~~\n\n---","slug":"C-指针-基础02","published":1,"updated":"2019-05-09T14:54:57.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9x9000fxcvvfjd73gu7","content":"<p>C++指针和数组的操作。</p>\n<a id=\"more\"></a>\n<p>C++中访问数组元素可以使用如下示例进行访问:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"第2个元素为:\"</span>&lt;&lt;arr[<span class=\"number\">1</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>想必大家都知道输出的值为:1</p>\n<hr>\n<p>那么我们现在可以使用指针进行访问数组元素</p>\n<p>数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p:0</span><br></pre></td></tr></table></figure>\n<p><strong>提问:</strong></p>\n<p>为什么指针可以指向数组名，而不需要使用引用符(&amp;)？</p>\n<p><strong>疑惑解答:</strong></p>\n<p>那是因为在C++中，数组其实就是一块内存空间，然而里面的<strong>每个元素也就组成了一块连续的内存空间</strong>，而<strong>数组名就当任了数组的首地址</strong>的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。</p>\n<hr>\n<p>通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对指针进行位偏移</span></span><br><span class=\"line\">p++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p: 1</span><br></pre></td></tr></table></figure>\n<p>上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。</p>\n<p><img src=\"/2019/05/06/C-指针-基础02/指针位偏移.png\" alt=\"位偏移\"></p>\n<hr>\n<p>最后利用指针遍历输出数组内的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;<span class=\"number\">3</span>;i++,p++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<p>C++指针和数组的操作。</p>","more":"<p>C++中访问数组元素可以使用如下示例进行访问:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"第2个元素为:\"</span>&lt;&lt;arr[<span class=\"number\">1</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>想必大家都知道输出的值为:1</p>\n<hr>\n<p>那么我们现在可以使用指针进行访问数组元素</p>\n<p>数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p:0</span><br></pre></td></tr></table></figure>\n<p><strong>提问:</strong></p>\n<p>为什么指针可以指向数组名，而不需要使用引用符(&amp;)？</p>\n<p><strong>疑惑解答:</strong></p>\n<p>那是因为在C++中，数组其实就是一块内存空间，然而里面的<strong>每个元素也就组成了一块连续的内存空间</strong>，而<strong>数组名就当任了数组的首地址</strong>的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。</p>\n<hr>\n<p>通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1];</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对指针进行位偏移</span></span><br><span class=\"line\">p++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p:\"</span>;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p: 1</span><br></pre></td></tr></table></figure>\n<p>上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。</p>\n<p><img src=\"/2019/05/06/C-指针-基础02/指针位偏移.png\" alt=\"位偏移\"></p>\n<hr>\n<p>最后利用指针遍历输出数组内的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;<span class=\"number\">3</span>;i++,p++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"Linux中的解压与压缩","date":"2019-05-08T12:54:19.000Z","copyright":true,"_content":"\n当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。\n\n<!--more-->\n\n在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。\n\n\nLinux下有三种主流常用的解压压缩软件可选:\n\n- gzip (GNUzip)\n\n- bz2 (bzip2)\n\n- xz (xzutils)\n\n三个软件的参数相同，只是命令不同:\n\n~~~shell\n$ gzip [参数] <文件名>\n~~~\n\n~~~shell\n$ bzip2 [参数] <文件名>\n~~~\n\n~~~shell\n$ xz [参数] <文件名>\n~~~\n\n> 可选参数\n\n|参数名|作用|\n---|:---:|---\n|-d|解压|\n|-k|压缩时不删除源文件|\n|-r|递归查找目录下的文件，并且压缩|\n|-v|显示详细信息|\n|-t|测试压缩包是否完整|\n|-l|显示压缩包信息|\n|-c|写入标准输出，保持原始文件不变|\n|-1~9|压缩等级|\n\n**示例:**\n\n> 压缩test.txt，并删除.\n\n~~~shell\n$ gzip test.txt\n~~~\n\n> 压缩test.txt，不删除原文件，并且显示信息.\n\n~~~shell\n$ gzip -vk test.txt\n~~~\n\n> 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz\n\n~~~shell\n$ gzip -9cvk test.txt test2.txt > test.gz\n~~~\n\n> 解压test.gz\n\n~~~shell\n$ gzip -d test.gz\n~~~\n\n---\n\n介绍完上面的几种压缩软件，下面介绍一个打包软件**tar**\n\n我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。\n\n\n## 压缩\n\n这里注意第一个参数，它们分别代表使用什么压缩软件。\n\n> bz2\n~~~shell\n$ tar -jcvf test.tar.bz test/ \n~~~\n\n>xz\n~~~shell\n$ tar -Jcvf test.tar.xz test/\n~~~\n\n>gzip\n~~~shell\n$ tar -zcvf test.tar.gz test/\n~~~\n\n## 解压\n\n只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.\n\n\n~~~shell\n$ tar -Jxvf test.tar.xz test/\n~~~\n\n---\n","source":"_posts/Linux中的解压与压缩.md","raw":"---\ntitle: Linux中的解压与压缩\ndate: 2019-05-08 20:54:19\ncategories: 学习笔记\ntags:\n  - Linux\ncopyright: true\n---\n\n当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。\n\n<!--more-->\n\n在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。\n\n\nLinux下有三种主流常用的解压压缩软件可选:\n\n- gzip (GNUzip)\n\n- bz2 (bzip2)\n\n- xz (xzutils)\n\n三个软件的参数相同，只是命令不同:\n\n~~~shell\n$ gzip [参数] <文件名>\n~~~\n\n~~~shell\n$ bzip2 [参数] <文件名>\n~~~\n\n~~~shell\n$ xz [参数] <文件名>\n~~~\n\n> 可选参数\n\n|参数名|作用|\n---|:---:|---\n|-d|解压|\n|-k|压缩时不删除源文件|\n|-r|递归查找目录下的文件，并且压缩|\n|-v|显示详细信息|\n|-t|测试压缩包是否完整|\n|-l|显示压缩包信息|\n|-c|写入标准输出，保持原始文件不变|\n|-1~9|压缩等级|\n\n**示例:**\n\n> 压缩test.txt，并删除.\n\n~~~shell\n$ gzip test.txt\n~~~\n\n> 压缩test.txt，不删除原文件，并且显示信息.\n\n~~~shell\n$ gzip -vk test.txt\n~~~\n\n> 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz\n\n~~~shell\n$ gzip -9cvk test.txt test2.txt > test.gz\n~~~\n\n> 解压test.gz\n\n~~~shell\n$ gzip -d test.gz\n~~~\n\n---\n\n介绍完上面的几种压缩软件，下面介绍一个打包软件**tar**\n\n我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。\n\n\n## 压缩\n\n这里注意第一个参数，它们分别代表使用什么压缩软件。\n\n> bz2\n~~~shell\n$ tar -jcvf test.tar.bz test/ \n~~~\n\n>xz\n~~~shell\n$ tar -Jcvf test.tar.xz test/\n~~~\n\n>gzip\n~~~shell\n$ tar -zcvf test.tar.gz test/\n~~~\n\n## 解压\n\n只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.\n\n\n~~~shell\n$ tar -Jxvf test.tar.xz test/\n~~~\n\n---\n","slug":"Linux中的解压与压缩","published":1,"updated":"2019-05-09T14:54:32.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xb000kxcvv284yfi6p","content":"<p>当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。</p>\n<a id=\"more\"></a>\n<p>在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。</p>\n<p>Linux下有三种主流常用的解压压缩软件可选:</p>\n<ul>\n<li><p>gzip (GNUzip)</p>\n</li>\n<li><p>bz2 (bzip2)</p>\n</li>\n<li><p>xz (xzutils)</p>\n</li>\n</ul>\n<p>三个软件的参数相同，只是命令不同:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> bzip2 [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> xz [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可选参数</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">参数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-d</td>\n<td>解压</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-k</td>\n<td>压缩时不删除源文件</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-r</td>\n<td>递归查找目录下的文件，并且压缩</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-v</td>\n<td>显示详细信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-t</td>\n<td>测试压缩包是否完整</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-l</td>\n<td>显示压缩包信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-c</td>\n<td>写入标准输出，保持原始文件不变</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-1~9</td>\n<td>压缩等级</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例:</strong></p>\n<blockquote>\n<p>压缩test.txt，并删除.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>压缩test.txt，不删除原文件，并且显示信息.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -vk test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -9cvk test.txt test2.txt &gt; test.gz</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解压test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -d test.gz</span><br></pre></td></tr></table></figure>\n<hr>\n<p>介绍完上面的几种压缩软件，下面介绍一个打包软件<strong>tar</strong></p>\n<p>我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。</p>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>这里注意第一个参数，它们分别代表使用什么压缩软件。</p>\n<blockquote>\n<p>bz2<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -jcvf test.tar.bz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>xz<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jcvf test.tar.xz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>gzip<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -zcvf test.tar.gz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h2><p>只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jxvf test.tar.xz test/</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<p>当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。</p>","more":"<p>在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。</p>\n<p>Linux下有三种主流常用的解压压缩软件可选:</p>\n<ul>\n<li><p>gzip (GNUzip)</p>\n</li>\n<li><p>bz2 (bzip2)</p>\n</li>\n<li><p>xz (xzutils)</p>\n</li>\n</ul>\n<p>三个软件的参数相同，只是命令不同:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> bzip2 [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> xz [参数] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可选参数</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">参数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-d</td>\n<td>解压</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-k</td>\n<td>压缩时不删除源文件</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-r</td>\n<td>递归查找目录下的文件，并且压缩</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-v</td>\n<td>显示详细信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-t</td>\n<td>测试压缩包是否完整</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-l</td>\n<td>显示压缩包信息</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-c</td>\n<td>写入标准输出，保持原始文件不变</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\">-1~9</td>\n<td>压缩等级</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例:</strong></p>\n<blockquote>\n<p>压缩test.txt，并删除.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>压缩test.txt，不删除原文件，并且显示信息.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -vk test.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -9cvk test.txt test2.txt &gt; test.gz</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解压test.gz</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gzip -d test.gz</span><br></pre></td></tr></table></figure>\n<hr>\n<p>介绍完上面的几种压缩软件，下面介绍一个打包软件<strong>tar</strong></p>\n<p>我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。</p>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>这里注意第一个参数，它们分别代表使用什么压缩软件。</p>\n<blockquote>\n<p>bz2<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -jcvf test.tar.bz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>xz<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jcvf test.tar.xz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>gzip<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -zcvf test.tar.gz test/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h2><p>只需要看文件名的后缀，然后把参数c改为x即可.x代表解压.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar -Jxvf test.tar.xz test/</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"ManjaroLinuxTG讨论群组","copyright":true,"date":"2019-05-15T16:01:58.000Z","_content":"\n创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。\n\n# [点击加入](https://t.me/manjarozhihu)\n","source":"_posts/ManjaroLinuxTG讨论群组.md","raw":"---\ntitle: ManjaroLinuxTG讨论群组\ncopyright: true\ndate: 2019-05-16 00:01:58\ncategories: 分享\ntags:\n - Telegram\n - Linux\n---\n\n创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。\n\n# [点击加入](https://t.me/manjarozhihu)\n","slug":"ManjaroLinuxTG讨论群组","published":1,"updated":"2019-05-15T16:03:41.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xd000nxcvv27ujf3bn","content":"<p>创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。</p>\n<h1 id=\"点击加入\"><a href=\"#点击加入\" class=\"headerlink\" title=\"点击加入\"></a><a href=\"https://t.me/manjarozhihu\" target=\"_blank\" rel=\"noopener\">点击加入</a></h1>","site":{"data":{}},"excerpt":"","more":"<p>创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。</p>\n<h1 id=\"点击加入\"><a href=\"#点击加入\" class=\"headerlink\" title=\"点击加入\"></a><a href=\"https://t.me/manjarozhihu\" target=\"_blank\" rel=\"noopener\">点击加入</a></h1>"},{"title":"hexo+next插入网易云音乐","date":"2019-04-30T12:05:20.000Z","copyright":true,"_content":"\n让大爷们在阅读博客时能优哉游哉的听着歌看文章。\n\n<!--more-->\n\n# 获取外链\n\n打开[网易云音乐](https://music.163.com)官网\n\n找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。\n\n![01](hexo-next插入网易云音乐/01.png)\n\n可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!\n\n# 插入外链\n\n**如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.**\n\n**如果是想插入到侧边栏**\n\n需要编辑next/layout/_macro/sidebar.swig文件\n\n此时我们就需要使用开发者工具插入到自己合适的位置下\n\n![插哪](hexo-next插入网易云音乐/插哪.png)\n\n可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。\n\n---","source":"_posts/hexo-next插入网易云音乐.md","raw":"---\ntitle: hexo+next插入网易云音乐\ndate: 2019-04-30 20:05:20\ncategories: 折腾记录\ntags: \n  - hexo\n  - 网易云音乐\ncopyright: true\n---\n\n让大爷们在阅读博客时能优哉游哉的听着歌看文章。\n\n<!--more-->\n\n# 获取外链\n\n打开[网易云音乐](https://music.163.com)官网\n\n找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。\n\n![01](hexo-next插入网易云音乐/01.png)\n\n可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!\n\n# 插入外链\n\n**如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.**\n\n**如果是想插入到侧边栏**\n\n需要编辑next/layout/_macro/sidebar.swig文件\n\n此时我们就需要使用开发者工具插入到自己合适的位置下\n\n![插哪](hexo-next插入网易云音乐/插哪.png)\n\n可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。\n\n---","slug":"hexo-next插入网易云音乐","published":1,"updated":"2019-05-09T14:54:49.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xe000qxcvvkmgic6kc","content":"<p>让大爷们在阅读博客时能优哉游哉的听着歌看文章。</p>\n<a id=\"more\"></a>\n<h1 id=\"获取外链\"><a href=\"#获取外链\" class=\"headerlink\" title=\"获取外链\"></a>获取外链</h1><p>打开<a href=\"https://music.163.com\" target=\"_blank\" rel=\"noopener\">网易云音乐</a>官网</p>\n<p>找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/01.png\" alt=\"01\"></p>\n<p>可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!</p>\n<h1 id=\"插入外链\"><a href=\"#插入外链\" class=\"headerlink\" title=\"插入外链\"></a>插入外链</h1><p><strong>如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.</strong></p>\n<p><strong>如果是想插入到侧边栏</strong></p>\n<p>需要编辑next/layout/_macro/sidebar.swig文件</p>\n<p>此时我们就需要使用开发者工具插入到自己合适的位置下</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/插哪.png\" alt=\"插哪\"></p>\n<p>可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>让大爷们在阅读博客时能优哉游哉的听着歌看文章。</p>","more":"<h1 id=\"获取外链\"><a href=\"#获取外链\" class=\"headerlink\" title=\"获取外链\"></a>获取外链</h1><p>打开<a href=\"https://music.163.com\" target=\"_blank\" rel=\"noopener\">网易云音乐</a>官网</p>\n<p>找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/01.png\" alt=\"01\"></p>\n<p>可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧!</p>\n<h1 id=\"插入外链\"><a href=\"#插入外链\" class=\"headerlink\" title=\"插入外链\"></a>插入外链</h1><p><strong>如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的.</strong></p>\n<p><strong>如果是想插入到侧边栏</strong></p>\n<p>需要编辑next/layout/_macro/sidebar.swig文件</p>\n<p>此时我们就需要使用开发者工具插入到自己合适的位置下</p>\n<p><img src=\"/2019/04/30/hexo-next插入网易云音乐/插哪.png\" alt=\"插哪\"></p>\n<p>可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。</p>\n<hr>"},{"title":"hexo博客文章插入图片","date":"2019-04-29T07:15:29.000Z","copyright":true,"_content":"\n# 前言\n\n在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。\n\n<!--more-->\n\n# 如何安装\n\n安装此插件很简单，你只需要在你的hexo目录下执行如下命令:\n\n~~~shell\n$ npm install hexo-asset-image --save\n~~~\n\n如果安装速度很慢可以把npm源改为国内源。\n\n[点击打开npm源改为国内源的方法](https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/)\n\n在设置镜像源->npm国内源下\n\n# 如何使用\n\n## 第一步\n首先，我们得先设置主目录(博客目录)下的 **_config.yml** 文件.\n\n找到 **post_asset_folder:** 项，将其修改为 **true**\n\n## 第二步\n\n使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。\n\n然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。\n\n# 栗子\n\n~~~shell\n$ hexo n \"test\"\n$ mv test.jpg source/_posts/test\n~~~\n\n插入图片\n\n~~~\n![图片alt](图片地址)\n\n# ![test](./test/test.jpng)\n~~~\n\n---","source":"_posts/hexo博客文章插入图片.md","raw":"---\ntitle: hexo博客文章插入图片\ndate: 2019-04-29 15:15:29\ncategories: 折腾记录\ncopyright: true\ntags:\n  - hexo\n---\n\n# 前言\n\n在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。\n\n<!--more-->\n\n# 如何安装\n\n安装此插件很简单，你只需要在你的hexo目录下执行如下命令:\n\n~~~shell\n$ npm install hexo-asset-image --save\n~~~\n\n如果安装速度很慢可以把npm源改为国内源。\n\n[点击打开npm源改为国内源的方法](https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/)\n\n在设置镜像源->npm国内源下\n\n# 如何使用\n\n## 第一步\n首先，我们得先设置主目录(博客目录)下的 **_config.yml** 文件.\n\n找到 **post_asset_folder:** 项，将其修改为 **true**\n\n## 第二步\n\n使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。\n\n然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。\n\n# 栗子\n\n~~~shell\n$ hexo n \"test\"\n$ mv test.jpg source/_posts/test\n~~~\n\n插入图片\n\n~~~\n![图片alt](图片地址)\n\n# ![test](./test/test.jpng)\n~~~\n\n---","slug":"hexo博客文章插入图片","published":1,"updated":"2019-05-09T14:54:41.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xh000uxcvvvzbqvchv","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p>\n<a id=\"more\"></a>\n<h1 id=\"如何安装\"><a href=\"#如何安装\" class=\"headerlink\" title=\"如何安装\"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n<p>如果安装速度很慢可以把npm源改为国内源。</p>\n<p><a href=\"https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/\">点击打开npm源改为国内源的方法</a></p>\n<p>在设置镜像源-&gt;npm国内源下</p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h2 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p>\n<p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p>\n<h2 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p>\n<p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p>\n<h1 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"test\"</span><br><span class=\"line\"><span class=\"meta\">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure>\n<p>插入图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片alt](图片地址)</span><br><span class=\"line\"></span><br><span class=\"line\"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。</p>","more":"<h1 id=\"如何安装\"><a href=\"#如何安装\" class=\"headerlink\" title=\"如何安装\"></a>如何安装</h1><p>安装此插件很简单，你只需要在你的hexo目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n<p>如果安装速度很慢可以把npm源改为国内源。</p>\n<p><a href=\"https://evanmeek.github.io/2019/04/23/ManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/\">点击打开npm源改为国内源的方法</a></p>\n<p>在设置镜像源-&gt;npm国内源下</p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h2 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h2><p>首先，我们得先设置主目录(博客目录)下的 <strong>_config.yml</strong> 文件.</p>\n<p>找到 <strong>post_asset_folder:</strong> 项，将其修改为 <strong>true</strong></p>\n<h2 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h2><p>使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。</p>\n<p>然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。</p>\n<h1 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"test\"</span><br><span class=\"line\"><span class=\"meta\">$</span> mv test.jpg source/_posts/test</span><br></pre></td></tr></table></figure>\n<p>插入图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片alt](图片地址)</span><br><span class=\"line\"></span><br><span class=\"line\"># ![test](./test/test.jpng)</span><br></pre></td></tr></table></figure>\n<hr>"},{"title":"如何用hexo+github-pages搭建博客","date":"2019-04-29T14:56:54.000Z","copyright":true,"_content":"\n成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.\n\n<!--more-->\n\n![逆光](如何用hexo-github-pages搭建博客/逆光.jpg)\n\n# 为何选择hexo\n\n- hexo博客框架的网上资料较多，技术较为成熟.\n\n- hexo使用Makrdown进行渲染.\n\n- hexo只需几步就可部署博客.\n\n- hexo具有丰富的主题/插件可选.\n\n# 安装hexo\n\n## 安装Nodejs,Git\n\n要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。\n\n大部分发行版自带Git,Nodejs只需要一条命令:\n\n**apt**\n\n~~~shell\n$ sudo apt install nodejs npm\n~~~\n\n**pacman**\n\n~~~shell\n$ sudo pacman -S nodejs npm\n~~~\n## 配置Nodejs\n\n**安装完成Nodejs和Git后还需要设置npm的软件源.**\n\n在任意目录下执行如下命令:\n\n~~~shell\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):\n\n~~~shell\n$ npm config get registry\n~~~\n\n## 配置Git\n\n### **注册Github**\n\n[注册Github](https://github.com/join)\n\n### **创建仓库**\n\n[创建Github仓库](https://github.com/new)\n\n注意: 仓库名必须是**name.github.io**\n\n例如我的 evanmeek.github.io\n\n![创建Github仓库](如何用hexo-github-pages搭建博客/创建仓库.png)\n\n\n需要设置两点:\n\n- Git身份标识\n\n~~~shell\n$ git config --global user.email \"你的邮箱\"\n$ git config --global user.name \"你的名字\"\n~~~\n\n推荐把邮箱和名字设置为Github上的邮箱和名字相同\n\n\n- SSH密钥\n\n如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:\n\n~~~shell\n$ ls ~/.ssh\n~~~\n\n若没有则创建新的密钥\n\n~~~shell\n$ ssh-keygen -t rsa -C \"你的邮箱\"\n~~~\n\n创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。\n\n创建完成后，你会在~/.ssh内看到两个文件\n\n![ssh目录](如何用hexo-github-pages搭建博客/ssh目录.png)\n\n分别是私钥(id_rsa),公钥(id_rsa.pub)\n\n下一步则是需要在Github中添加刚刚生成的密钥\n\n首先登陆Github,打开设置.\n\n如图所示：\n\n![登陆Github](如何用hexo-github-pages搭建博客/打开设置.png)\n\n下一步找到SSH选项\n\n如图所示：\n\n![设置SSH](如何用hexo-github-pages搭建博客/设置SSH.png)\n\n下一步导入公钥\n\n![导入密钥](如何用hexo-github-pages搭建博客/导入密钥.png)\n\n复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名\n\n~~~shell\n$ cat ~/.ssh/id_rsa.pub\n~~~\n\n## 安装hexo\n\n前面安装完Nodejs和Git之后可以通过一条命令安装hexo\n\n**要使用sudo提权**\n\n执行如下命令:\n\n~~~shell\n$ npm install -g hexo-cli\n~~~\n\n看到Done!之后则为安装成功.\n\n# 开始搭建\n\n## 初始化hexo博客\n\n使用如下命令初始化博客\n\n~~~shell\n$ hexo init <目录>\n~~~\n\n![hexoinit](如何用hexo-github-pages搭建博客/hexoinit.png)\n\n初始化完成之后目录结构大概是这样的:\n\n~~~\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n~~~\n\n下面分别讲下这些文件或目录分别存放了些什么。\n\n主配置文件: **_config.yml**\n\n> 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.\n\n插件信息: **package.json**\n\n> 包含了当前hexo博客中安装了哪些插件.\n\n模板目录: **scaffolds/**\n\n> 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.\n\n资源目录: **source/**\n\n> 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.\n\n主题目录: **themes/**\n\n> 主题目录，所有的主题都丢在这里。\n\n---\n\n## 生成博客\n\n执行如下命令创建一篇博文:\n\n~~~shell\n$ hexo n \"文章名\"\n~~~\n\nhexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!\n\n这一步用于生成静态文件(就是把md转为html的操作)\n\n**要在网站目录(就是初始化的目录下)下执行**\n\n~~~shell\n$ hexo generate\n~~~\n\n这个命令可以简化，并且还可以带两个参数\n\n简化+参数:\n~~~shell\n$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)\n\n$ hexo g -w # 可以监视有哪些文件被生成了\n~~~\n\n---\n\n# 配置hexo\n\n这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.\n\n下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。\n\n找到deploy项\n\n修改为:\n\n![deploy](如何用hexo-github-pages搭建博客/deploy.png)\n\n**type为git不能为大写**\n\n\n\n---\n\n## 部署博客\n\n部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署\n\n**本地部署**\n\n\n执行如下命令:\n~~~shell\n$ npm install hexo-deployer-git --save\n~~~\n\n~~~shell\n$ hexo s\n~~~\n\n执行完后可以通过localhost:4000进行[查看](localhost:4000).\n\n![本地部署](如何用hexo-github-pages搭建博客/本地部署.png)\n\n**部署到Github**\n\n~~~shell\n$ hexo d\n~~~\n\n这样就可以部署到Github了，通过https://你的Github用户名.github.io访问\n\n# 寻找主题\n\n[Hexo主题](https://hexo.io/themes/)\n\n把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。\n\n# 使用体验\n\n还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com\n\n---","source":"_posts/如何用hexo-github-pages搭建博客.md","raw":"---\ntitle: 如何用hexo+github-pages搭建博客\ndate: 2019-04-29 22:56:54\ncategories: 折腾记录\ntags:\n - hexo\n - 博客\ncopyright: true\n---\n\n成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.\n\n<!--more-->\n\n![逆光](如何用hexo-github-pages搭建博客/逆光.jpg)\n\n# 为何选择hexo\n\n- hexo博客框架的网上资料较多，技术较为成熟.\n\n- hexo使用Makrdown进行渲染.\n\n- hexo只需几步就可部署博客.\n\n- hexo具有丰富的主题/插件可选.\n\n# 安装hexo\n\n## 安装Nodejs,Git\n\n要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。\n\n大部分发行版自带Git,Nodejs只需要一条命令:\n\n**apt**\n\n~~~shell\n$ sudo apt install nodejs npm\n~~~\n\n**pacman**\n\n~~~shell\n$ sudo pacman -S nodejs npm\n~~~\n## 配置Nodejs\n\n**安装完成Nodejs和Git后还需要设置npm的软件源.**\n\n在任意目录下执行如下命令:\n\n~~~shell\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):\n\n~~~shell\n$ npm config get registry\n~~~\n\n## 配置Git\n\n### **注册Github**\n\n[注册Github](https://github.com/join)\n\n### **创建仓库**\n\n[创建Github仓库](https://github.com/new)\n\n注意: 仓库名必须是**name.github.io**\n\n例如我的 evanmeek.github.io\n\n![创建Github仓库](如何用hexo-github-pages搭建博客/创建仓库.png)\n\n\n需要设置两点:\n\n- Git身份标识\n\n~~~shell\n$ git config --global user.email \"你的邮箱\"\n$ git config --global user.name \"你的名字\"\n~~~\n\n推荐把邮箱和名字设置为Github上的邮箱和名字相同\n\n\n- SSH密钥\n\n如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:\n\n~~~shell\n$ ls ~/.ssh\n~~~\n\n若没有则创建新的密钥\n\n~~~shell\n$ ssh-keygen -t rsa -C \"你的邮箱\"\n~~~\n\n创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。\n\n创建完成后，你会在~/.ssh内看到两个文件\n\n![ssh目录](如何用hexo-github-pages搭建博客/ssh目录.png)\n\n分别是私钥(id_rsa),公钥(id_rsa.pub)\n\n下一步则是需要在Github中添加刚刚生成的密钥\n\n首先登陆Github,打开设置.\n\n如图所示：\n\n![登陆Github](如何用hexo-github-pages搭建博客/打开设置.png)\n\n下一步找到SSH选项\n\n如图所示：\n\n![设置SSH](如何用hexo-github-pages搭建博客/设置SSH.png)\n\n下一步导入公钥\n\n![导入密钥](如何用hexo-github-pages搭建博客/导入密钥.png)\n\n复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名\n\n~~~shell\n$ cat ~/.ssh/id_rsa.pub\n~~~\n\n## 安装hexo\n\n前面安装完Nodejs和Git之后可以通过一条命令安装hexo\n\n**要使用sudo提权**\n\n执行如下命令:\n\n~~~shell\n$ npm install -g hexo-cli\n~~~\n\n看到Done!之后则为安装成功.\n\n# 开始搭建\n\n## 初始化hexo博客\n\n使用如下命令初始化博客\n\n~~~shell\n$ hexo init <目录>\n~~~\n\n![hexoinit](如何用hexo-github-pages搭建博客/hexoinit.png)\n\n初始化完成之后目录结构大概是这样的:\n\n~~~\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n~~~\n\n下面分别讲下这些文件或目录分别存放了些什么。\n\n主配置文件: **_config.yml**\n\n> 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.\n\n插件信息: **package.json**\n\n> 包含了当前hexo博客中安装了哪些插件.\n\n模板目录: **scaffolds/**\n\n> 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.\n\n资源目录: **source/**\n\n> 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.\n\n主题目录: **themes/**\n\n> 主题目录，所有的主题都丢在这里。\n\n---\n\n## 生成博客\n\n执行如下命令创建一篇博文:\n\n~~~shell\n$ hexo n \"文章名\"\n~~~\n\nhexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!\n\n这一步用于生成静态文件(就是把md转为html的操作)\n\n**要在网站目录(就是初始化的目录下)下执行**\n\n~~~shell\n$ hexo generate\n~~~\n\n这个命令可以简化，并且还可以带两个参数\n\n简化+参数:\n~~~shell\n$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)\n\n$ hexo g -w # 可以监视有哪些文件被生成了\n~~~\n\n---\n\n# 配置hexo\n\n这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.\n\n下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。\n\n找到deploy项\n\n修改为:\n\n![deploy](如何用hexo-github-pages搭建博客/deploy.png)\n\n**type为git不能为大写**\n\n\n\n---\n\n## 部署博客\n\n部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署\n\n**本地部署**\n\n\n执行如下命令:\n~~~shell\n$ npm install hexo-deployer-git --save\n~~~\n\n~~~shell\n$ hexo s\n~~~\n\n执行完后可以通过localhost:4000进行[查看](localhost:4000).\n\n![本地部署](如何用hexo-github-pages搭建博客/本地部署.png)\n\n**部署到Github**\n\n~~~shell\n$ hexo d\n~~~\n\n这样就可以部署到Github了，通过https://你的Github用户名.github.io访问\n\n# 寻找主题\n\n[Hexo主题](https://hexo.io/themes/)\n\n把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。\n\n# 使用体验\n\n还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com\n\n---","slug":"如何用hexo-github-pages搭建博客","published":1,"updated":"2019-05-09T14:54:22.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xl000xxcvvc122kaa5","content":"<p>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg\" alt=\"逆光\"></p>\n<h1 id=\"为何选择hexo\"><a href=\"#为何选择hexo\" class=\"headerlink\" title=\"为何选择hexo\"></a>为何选择hexo</h1><ul>\n<li><p>hexo博客框架的网上资料较多，技术较为成熟.</p>\n</li>\n<li><p>hexo使用Makrdown进行渲染.</p>\n</li>\n<li><p>hexo只需几步就可部署博客.</p>\n</li>\n<li><p>hexo具有丰富的主题/插件可选.</p>\n</li>\n</ul>\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><h2 id=\"安装Nodejs-Git\"><a href=\"#安装Nodejs-Git\" class=\"headerlink\" title=\"安装Nodejs,Git\"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p>\n<p>大部分发行版自带Git,Nodejs只需要一条命令:</p>\n<p><strong>apt</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure>\n<p><strong>pacman</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Nodejs\"><a href=\"#配置Nodejs\" class=\"headerlink\" title=\"配置Nodejs\"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p>\n<p>在任意目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config get registry</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h2><h3 id=\"注册Github\"><a href=\"#注册Github\" class=\"headerlink\" title=\"注册Github\"></a><strong>注册Github</strong></h3><p><a href=\"https://github.com/join\" target=\"_blank\" rel=\"noopener\">注册Github</a></p>\n<h3 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a><strong>创建仓库</strong></h3><p><a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">创建Github仓库</a></p>\n<p>注意: 仓库名必须是<strong>name.github.io</strong></p>\n<p>例如我的 evanmeek.github.io</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png\" alt=\"创建Github仓库\"></p>\n<p>需要设置两点:</p>\n<ul>\n<li>Git身份标识</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> git config --global user.email \"你的邮箱\"</span><br><span class=\"line\"><span class=\"meta\">$</span> git config --global user.name \"你的名字\"</span><br></pre></td></tr></table></figure>\n<p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p>\n<ul>\n<li>SSH密钥</li>\n</ul>\n<p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>若没有则创建新的密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ssh-keygen -t rsa -C \"你的邮箱\"</span><br></pre></td></tr></table></figure>\n<p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p>\n<p>创建完成后，你会在~/.ssh内看到两个文件</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png\" alt=\"ssh目录\"></p>\n<p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p>\n<p>下一步则是需要在Github中添加刚刚生成的密钥</p>\n<p>首先登陆Github,打开设置.</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png\" alt=\"登陆Github\"></p>\n<p>下一步找到SSH选项</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png\" alt=\"设置SSH\"></p>\n<p>下一步导入公钥</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png\" alt=\"导入密钥\"></p>\n<p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p>\n<p><strong>要使用sudo提权</strong></p>\n<p>执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>看到Done!之后则为安装成功.</p>\n<h1 id=\"开始搭建\"><a href=\"#开始搭建\" class=\"headerlink\" title=\"开始搭建\"></a>开始搭建</h1><h2 id=\"初始化hexo博客\"><a href=\"#初始化hexo博客\" class=\"headerlink\" title=\"初始化hexo博客\"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png\" alt=\"hexoinit\"></p>\n<p>初始化完成之后目录结构大概是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>下面分别讲下这些文件或目录分别存放了些什么。</p>\n<p>主配置文件: <strong>_config.yml</strong></p>\n<blockquote>\n<p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p>\n</blockquote>\n<p>插件信息: <strong>package.json</strong></p>\n<blockquote>\n<p>包含了当前hexo博客中安装了哪些插件.</p>\n</blockquote>\n<p>模板目录: <strong>scaffolds/</strong></p>\n<blockquote>\n<p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p>\n</blockquote>\n<p>资源目录: <strong>source/</strong></p>\n<blockquote>\n<p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p>\n</blockquote>\n<p>主题目录: <strong>themes/</strong></p>\n<blockquote>\n<p>主题目录，所有的主题都丢在这里。</p>\n</blockquote>\n<hr>\n<h2 id=\"生成博客\"><a href=\"#生成博客\" class=\"headerlink\" title=\"生成博客\"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"文章名\"</span><br></pre></td></tr></table></figure>\n<p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p>\n<p>这一步用于生成静态文件(就是把md转为html的操作)</p>\n<p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo generate</span><br></pre></td></tr></table></figure>\n<p>这个命令可以简化，并且还可以带两个参数</p>\n<p>简化+参数:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p>\n<p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p>\n<p>找到deploy项</p>\n<p>修改为:</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png\" alt=\"deploy\"></p>\n<p><strong>type为git不能为大写</strong></p>\n<hr>\n<h2 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p>\n<p><strong>本地部署</strong></p>\n<p>执行如下命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo s</span><br></pre></td></tr></table></figure>\n<p>执行完后可以通过localhost:4000进行<a href=\"localhost:4000\" target=\"_blank\" rel=\"noopener\">查看</a>.</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png\" alt=\"本地部署\"></p>\n<p><strong>部署到Github</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo d</span><br></pre></td></tr></table></figure>\n<p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p>\n<h1 id=\"寻找主题\"><a href=\"#寻找主题\" class=\"headerlink\" title=\"寻找主题\"></a>寻找主题</h1><p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a></p>\n<p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p>\n<h1 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章.</p>","more":"<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/逆光.jpg\" alt=\"逆光\"></p>\n<h1 id=\"为何选择hexo\"><a href=\"#为何选择hexo\" class=\"headerlink\" title=\"为何选择hexo\"></a>为何选择hexo</h1><ul>\n<li><p>hexo博客框架的网上资料较多，技术较为成熟.</p>\n</li>\n<li><p>hexo使用Makrdown进行渲染.</p>\n</li>\n<li><p>hexo只需几步就可部署博客.</p>\n</li>\n<li><p>hexo具有丰富的主题/插件可选.</p>\n</li>\n</ul>\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><h2 id=\"安装Nodejs-Git\"><a href=\"#安装Nodejs-Git\" class=\"headerlink\" title=\"安装Nodejs,Git\"></a>安装Nodejs,Git</h2><p>要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。</p>\n<p>大部分发行版自带Git,Nodejs只需要一条命令:</p>\n<p><strong>apt</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo apt install nodejs npm</span><br></pre></td></tr></table></figure>\n<p><strong>pacman</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Nodejs\"><a href=\"#配置Nodejs\" class=\"headerlink\" title=\"配置Nodejs\"></a>配置Nodejs</h2><p><strong>安装完成Nodejs和Git后还需要设置npm的软件源.</strong></p>\n<p>在任意目录下执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm config get registry</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h2><h3 id=\"注册Github\"><a href=\"#注册Github\" class=\"headerlink\" title=\"注册Github\"></a><strong>注册Github</strong></h3><p><a href=\"https://github.com/join\" target=\"_blank\" rel=\"noopener\">注册Github</a></p>\n<h3 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a><strong>创建仓库</strong></h3><p><a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">创建Github仓库</a></p>\n<p>注意: 仓库名必须是<strong>name.github.io</strong></p>\n<p>例如我的 evanmeek.github.io</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/创建仓库.png\" alt=\"创建Github仓库\"></p>\n<p>需要设置两点:</p>\n<ul>\n<li>Git身份标识</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> git config --global user.email \"你的邮箱\"</span><br><span class=\"line\"><span class=\"meta\">$</span> git config --global user.name \"你的名字\"</span><br></pre></td></tr></table></figure>\n<p>推荐把邮箱和名字设置为Github上的邮箱和名字相同</p>\n<ul>\n<li>SSH密钥</li>\n</ul>\n<p>如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ls ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>若没有则创建新的密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> ssh-keygen -t rsa -C \"你的邮箱\"</span><br></pre></td></tr></table></figure>\n<p>创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。</p>\n<p>创建完成后，你会在~/.ssh内看到两个文件</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/ssh目录.png\" alt=\"ssh目录\"></p>\n<p>分别是私钥(id_rsa),公钥(id_rsa.pub)</p>\n<p>下一步则是需要在Github中添加刚刚生成的密钥</p>\n<p>首先登陆Github,打开设置.</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/打开设置.png\" alt=\"登陆Github\"></p>\n<p>下一步找到SSH选项</p>\n<p>如图所示：</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/设置SSH.png\" alt=\"设置SSH\"></p>\n<p>下一步导入公钥</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/导入密钥.png\" alt=\"导入密钥\"></p>\n<p>复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>前面安装完Nodejs和Git之后可以通过一条命令安装hexo</p>\n<p><strong>要使用sudo提权</strong></p>\n<p>执行如下命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>看到Done!之后则为安装成功.</p>\n<h1 id=\"开始搭建\"><a href=\"#开始搭建\" class=\"headerlink\" title=\"开始搭建\"></a>开始搭建</h1><h2 id=\"初始化hexo博客\"><a href=\"#初始化hexo博客\" class=\"headerlink\" title=\"初始化hexo博客\"></a>初始化hexo博客</h2><p>使用如下命令初始化博客</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo init &lt;目录&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/hexoinit.png\" alt=\"hexoinit\"></p>\n<p>初始化完成之后目录结构大概是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>下面分别讲下这些文件或目录分别存放了些什么。</p>\n<p>主配置文件: <strong>_config.yml</strong></p>\n<blockquote>\n<p>主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件.</p>\n</blockquote>\n<p>插件信息: <strong>package.json</strong></p>\n<blockquote>\n<p>包含了当前hexo博客中安装了哪些插件.</p>\n</blockquote>\n<p>模板目录: <strong>scaffolds/</strong></p>\n<blockquote>\n<p>里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染.</p>\n</blockquote>\n<p>资源目录: <strong>source/</strong></p>\n<blockquote>\n<p>在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下.</p>\n</blockquote>\n<p>主题目录: <strong>themes/</strong></p>\n<blockquote>\n<p>主题目录，所有的主题都丢在这里。</p>\n</blockquote>\n<hr>\n<h2 id=\"生成博客\"><a href=\"#生成博客\" class=\"headerlink\" title=\"生成博客\"></a>生成博客</h2><p>执行如下命令创建一篇博文:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo n \"文章名\"</span><br></pre></td></tr></table></figure>\n<p>hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了!</p>\n<p>这一步用于生成静态文件(就是把md转为html的操作)</p>\n<p><strong>要在网站目录(就是初始化的目录下)下执行</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo generate</span><br></pre></td></tr></table></figure>\n<p>这个命令可以简化，并且还可以带两个参数</p>\n<p>简化+参数:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> hexo g -w # 可以监视有哪些文件被生成了</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h1><p>这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同.</p>\n<p>下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。</p>\n<p>找到deploy项</p>\n<p>修改为:</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/deploy.png\" alt=\"deploy\"></p>\n<p><strong>type为git不能为大写</strong></p>\n<hr>\n<h2 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h2><p>部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署</p>\n<p><strong>本地部署</strong></p>\n<p>执行如下命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo s</span><br></pre></td></tr></table></figure>\n<p>执行完后可以通过localhost:4000进行<a href=\"localhost:4000\" target=\"_blank\" rel=\"noopener\">查看</a>.</p>\n<p><img src=\"/2019/04/29/如何用hexo-github-pages搭建博客/本地部署.png\" alt=\"本地部署\"></p>\n<p><strong>部署到Github</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> hexo d</span><br></pre></td></tr></table></figure>\n<p>这样就可以部署到Github了，通过https://你的Github用户名.github.io访问</p>\n<h1 id=\"寻找主题\"><a href=\"#寻找主题\" class=\"headerlink\" title=\"寻找主题\"></a>寻找主题</h1><p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a></p>\n<p>把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。</p>\n<h1 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h1><p>还是有一些坑要踩的，如有问题，联系邮箱<a href=\"mailto:the_lty_mail@foxmail.com\" target=\"_blank\" rel=\"noopener\">the_lty_mail@foxmail.com</a></p>\n<hr>"},{"title":"ManjaroLinux的安装过程","date":"2019-04-23T08:37:18.000Z","copyright":"truu","_content":"\n![桌面](ManjaroLinux的安装过程/桌面.png)\n\n## 获取镜像\nManjaroLinux官方提供了多个桌面环境的镜像，分别是:\n- XFCE \n\n特点\n\n> 系统资源低耗，快速\n\n- KDE\n\n特点\n\n> 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+\n\n- GNOME\n\n特点\n\n> 简单易用，可定制化，美化较为简单，内存占用大\n\n并且ManjaroLinux在国内有4个镜像源可选，分别是:\n- [清华大学](https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/)\n- [中科大](http://mirrors.ustc.edu.cn/manjaro-cd/)\n- [华为](https://mirrors.huaweicloud.com/manjaro-cd/)\n- [浙江大学](http://mirrors.zju.edu.cn/manjaro/)\n\n我们也可以直接使用官方的镜像源获取镜像[Manjaro](https://manjaro.org/get-manjaro/)\n\n选择好自己要使用的桌面环境就可以开始制作启动盘了。\n\n## 制作启动盘\n\n**Windows:**\n\n推荐使用[Rufus](https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe)进行制作启动盘。\n\n下载好后直接选择镜像和要进行制作的U盘，选择开始。\n\n**开始时会让你勾选制作方式请选择dd模式**\n\n---\n\n**Linux:**\n\n只需要执行这几条命令\n\n~~~shell\n$ sudo lsblk #列出系统上的所有磁盘\n~~~\n\n找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是**sdb或sda**\n\n如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.\n\n~~~shell\n$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，\n~~~\n\n取消挂载之后就可以进行格式化了.\n\n~~~shell\n$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.\n~~~\n\n格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.\n\n~~~shell\n$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda\n~~~\n\n如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。\n\n## 开始安装\n\n**最好是在网络稳定的环境下进行**\n\n### 第一步\n\n如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:\n\n![安装选择界面](ManjaroLinux的安装过程/安装选择界面.png)\n\n**keytable**————设置键盘布局\n\n通常默认即可\n\n**lang**————设置语言\n\n设置为zh_CN，代表汉语\n\n**driver**————设置使用的驱动是开源的还是不开源的\n\n笔记本双显卡，想省电可以用free。\n\n台式机单显卡，推荐nofree。\n\n**Boot**————选择这个就开始安装了\n\n### 第二步\n\n等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)\n\n![开始安装-01](ManjaroLinux的安装过程/开始安装.png)\n\n这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。\n\n标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。\n\n点击后还可以设置一次语言，默认为中文了\n\n然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。\n\n下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。\n\n再下一步就是分区了，这一步是挺重要的，请认真看。\n\n默认情况下有两种选项:\n\n**抹除磁盘**\n\n将磁盘全部数据清除，分区是Manjaro自动帮你分配的.\n\n这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。\n\n**手动分区**\n\n选择手动分区之后，你将看到:\n\n![分区](ManjaroLinux的安装过程/分区.png)\n\n如果你是单硬盘(也就是只有一个硬盘,mdzz)\n\n那比较简单(就算有多个也没啥)\n\n点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视...)\n\n然后就可以看到有一个空闲空间，选中它，然后可以看到**创建**按钮可以点击了\n\n然后你就点击吧...\n\n你就可以看到创建分区的窗口，我们要创建的分区是**根目录,主目录，引导**\n\n> 引导的挂载点: /boot/efi\n\n记得标记点为:boot 和 esp\n\n> 根目录的挂载点: /\n\n记得标记点为:root\n\n> 主目录的挂载点: /home\n\n![分区标识](ManjaroLinux的安装过程/分区标识.png)\n\n如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。\n\n要注意的是主目录要选择扩展分区。\n\n下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。\n\n- 用户名首字母不要大写\n\n- 密码不要太简单\n\n下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。\n\n![摘要](ManjaroLinux的安装过程/摘要.png)\n\n静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。\n\n## 设置镜像源\n\n选择一个好的源是使用Linux体验是否良好的一个重要因素。\n\n### 官方软件包源\n\n~~~shell\n$ sudo pacman-mirrors -i -c China -m rank\n$ sudo pacman -Syu\n~~~\n\n随便选一个就好，推荐中科大的(USTC).\n### Aur软件包源\n\n~~~shell\n$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi\n\n$ sudo pacman -Syu\n~~~\n\n在最后一行输入:\n\n~~~\n[archlinuxcn]\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n~~~\n\n安装签名\n\n~~~shell\n$ sudo pacman -S archlinuxcn-keyring\n~~~\n\n### npm国内源\n\n首先你得先下载npm和nodejs\n\n~~~shell\n$ sudo pacman -S npm nodejs\n~~~\n\n打开终端输入:\n\n~~~\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n测试是否成功:\n\n~~~\n$ npm config get registry\n~~~\n\n如果看到上面这个链接就对了\n\n### pip国内源\n\n修改~/.pip/pip.conf\n\n(没有则创建)\n\n修改为:\n~~~\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\n~~~\n\n你也可以使用其他的源\n\n[清华](https://pypi.tuna.tsinghua.edu.cn/simple)\n\n[阿里云](http://mirrors.aliyun.com/pypi/simple/)\n\n[中国科技大学](https://pypi.mirrors.ustc.edu.cn/simple/)\n\n[豆瓣](http://pypi.douban.com/simple/)\n\n## 安装软件\n\n首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库\n\nInstall Yay\n\n~~~shell\n$ sudo pacman -S yay\n~~~\n\n安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8\n\nInstall Vim\n\n~~~shell\n$ sudo pacman -S Vim\n~~~\n\nInstall VSCode\n\n~~~shell\n$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制\n~~~\n\nInstall OracleJDK8\n\n~~~shell\n$ yay -S jdk8 #这里就是由第三方打包了的\n~~~\n\nInstall 搜狗输入法\n\n~~~shell\n$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin\n~~~\n\n再编辑配置文件~/.xprofile(若没有创建即可)\n\n修改为:\n\n~~~\nexport GTK_IM_MODULE=fcitx\n\nexport QT_IM_MODULE=fcitx\n\nexport XMODIFIERS=\"@im=fcitx\"\n~~~\n\n注销后就能使用搜狗输入法了\n\nInstall IDEA\n\n~~~shell\n$ yay -S intellij-idea-community-edition #社区版 IDEA\n$ yay -S intellij-idea-ultimate-edition #付费版 IDEA\n~~~\n\nInstall CLion\n\n~~~shell\n$ yay -S CLion\n~~~\n\nInstall 网易云音乐\n\n~~~shell\n$ sudo pacman -S netease-cloud-music  \n~~~\n\nInstall Chrome\n\n~~~shell\n$ sudo pacman -S google-chrome\n~~~\n\n这样就能完成基本的日常使用啦~\n\n## 使用体验总结\n\n稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6->15.9.4 LinuxMint17 ArchLinux \n\n最终还是选择了Manjaro-kde\n\n非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。\n\n这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。\n\n![Manjaro安装过程编写文章时截图](ManjaroLinux的安装过程/编辑文章时截图.png)\n\n---","source":"_posts/ManjaroLinux的安装过程.md","raw":"---\ntitle: 'ManjaroLinux的安装过程'\ndate: 2019-04-23 16:37:18\ncategories: 学习笔记\ntags:\n  - Linux\n  - 折腾\n  - 软件使用\ncopyright: truu\n---\n\n![桌面](ManjaroLinux的安装过程/桌面.png)\n\n## 获取镜像\nManjaroLinux官方提供了多个桌面环境的镜像，分别是:\n- XFCE \n\n特点\n\n> 系统资源低耗，快速\n\n- KDE\n\n特点\n\n> 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+\n\n- GNOME\n\n特点\n\n> 简单易用，可定制化，美化较为简单，内存占用大\n\n并且ManjaroLinux在国内有4个镜像源可选，分别是:\n- [清华大学](https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/)\n- [中科大](http://mirrors.ustc.edu.cn/manjaro-cd/)\n- [华为](https://mirrors.huaweicloud.com/manjaro-cd/)\n- [浙江大学](http://mirrors.zju.edu.cn/manjaro/)\n\n我们也可以直接使用官方的镜像源获取镜像[Manjaro](https://manjaro.org/get-manjaro/)\n\n选择好自己要使用的桌面环境就可以开始制作启动盘了。\n\n## 制作启动盘\n\n**Windows:**\n\n推荐使用[Rufus](https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe)进行制作启动盘。\n\n下载好后直接选择镜像和要进行制作的U盘，选择开始。\n\n**开始时会让你勾选制作方式请选择dd模式**\n\n---\n\n**Linux:**\n\n只需要执行这几条命令\n\n~~~shell\n$ sudo lsblk #列出系统上的所有磁盘\n~~~\n\n找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是**sdb或sda**\n\n如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.\n\n~~~shell\n$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，\n~~~\n\n取消挂载之后就可以进行格式化了.\n\n~~~shell\n$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.\n~~~\n\n格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.\n\n~~~shell\n$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda\n~~~\n\n如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。\n\n## 开始安装\n\n**最好是在网络稳定的环境下进行**\n\n### 第一步\n\n如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:\n\n![安装选择界面](ManjaroLinux的安装过程/安装选择界面.png)\n\n**keytable**————设置键盘布局\n\n通常默认即可\n\n**lang**————设置语言\n\n设置为zh_CN，代表汉语\n\n**driver**————设置使用的驱动是开源的还是不开源的\n\n笔记本双显卡，想省电可以用free。\n\n台式机单显卡，推荐nofree。\n\n**Boot**————选择这个就开始安装了\n\n### 第二步\n\n等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)\n\n![开始安装-01](ManjaroLinux的安装过程/开始安装.png)\n\n这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。\n\n标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。\n\n点击后还可以设置一次语言，默认为中文了\n\n然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。\n\n下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。\n\n再下一步就是分区了，这一步是挺重要的，请认真看。\n\n默认情况下有两种选项:\n\n**抹除磁盘**\n\n将磁盘全部数据清除，分区是Manjaro自动帮你分配的.\n\n这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。\n\n**手动分区**\n\n选择手动分区之后，你将看到:\n\n![分区](ManjaroLinux的安装过程/分区.png)\n\n如果你是单硬盘(也就是只有一个硬盘,mdzz)\n\n那比较简单(就算有多个也没啥)\n\n点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视...)\n\n然后就可以看到有一个空闲空间，选中它，然后可以看到**创建**按钮可以点击了\n\n然后你就点击吧...\n\n你就可以看到创建分区的窗口，我们要创建的分区是**根目录,主目录，引导**\n\n> 引导的挂载点: /boot/efi\n\n记得标记点为:boot 和 esp\n\n> 根目录的挂载点: /\n\n记得标记点为:root\n\n> 主目录的挂载点: /home\n\n![分区标识](ManjaroLinux的安装过程/分区标识.png)\n\n如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。\n\n要注意的是主目录要选择扩展分区。\n\n下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。\n\n- 用户名首字母不要大写\n\n- 密码不要太简单\n\n下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。\n\n![摘要](ManjaroLinux的安装过程/摘要.png)\n\n静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。\n\n## 设置镜像源\n\n选择一个好的源是使用Linux体验是否良好的一个重要因素。\n\n### 官方软件包源\n\n~~~shell\n$ sudo pacman-mirrors -i -c China -m rank\n$ sudo pacman -Syu\n~~~\n\n随便选一个就好，推荐中科大的(USTC).\n### Aur软件包源\n\n~~~shell\n$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi\n\n$ sudo pacman -Syu\n~~~\n\n在最后一行输入:\n\n~~~\n[archlinuxcn]\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n~~~\n\n安装签名\n\n~~~shell\n$ sudo pacman -S archlinuxcn-keyring\n~~~\n\n### npm国内源\n\n首先你得先下载npm和nodejs\n\n~~~shell\n$ sudo pacman -S npm nodejs\n~~~\n\n打开终端输入:\n\n~~~\n$ npm config set registry https://registry.npm.taobao.org\n~~~\n\n测试是否成功:\n\n~~~\n$ npm config get registry\n~~~\n\n如果看到上面这个链接就对了\n\n### pip国内源\n\n修改~/.pip/pip.conf\n\n(没有则创建)\n\n修改为:\n~~~\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\n~~~\n\n你也可以使用其他的源\n\n[清华](https://pypi.tuna.tsinghua.edu.cn/simple)\n\n[阿里云](http://mirrors.aliyun.com/pypi/simple/)\n\n[中国科技大学](https://pypi.mirrors.ustc.edu.cn/simple/)\n\n[豆瓣](http://pypi.douban.com/simple/)\n\n## 安装软件\n\n首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库\n\nInstall Yay\n\n~~~shell\n$ sudo pacman -S yay\n~~~\n\n安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8\n\nInstall Vim\n\n~~~shell\n$ sudo pacman -S Vim\n~~~\n\nInstall VSCode\n\n~~~shell\n$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制\n~~~\n\nInstall OracleJDK8\n\n~~~shell\n$ yay -S jdk8 #这里就是由第三方打包了的\n~~~\n\nInstall 搜狗输入法\n\n~~~shell\n$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin\n~~~\n\n再编辑配置文件~/.xprofile(若没有创建即可)\n\n修改为:\n\n~~~\nexport GTK_IM_MODULE=fcitx\n\nexport QT_IM_MODULE=fcitx\n\nexport XMODIFIERS=\"@im=fcitx\"\n~~~\n\n注销后就能使用搜狗输入法了\n\nInstall IDEA\n\n~~~shell\n$ yay -S intellij-idea-community-edition #社区版 IDEA\n$ yay -S intellij-idea-ultimate-edition #付费版 IDEA\n~~~\n\nInstall CLion\n\n~~~shell\n$ yay -S CLion\n~~~\n\nInstall 网易云音乐\n\n~~~shell\n$ sudo pacman -S netease-cloud-music  \n~~~\n\nInstall Chrome\n\n~~~shell\n$ sudo pacman -S google-chrome\n~~~\n\n这样就能完成基本的日常使用啦~\n\n## 使用体验总结\n\n稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6->15.9.4 LinuxMint17 ArchLinux \n\n最终还是选择了Manjaro-kde\n\n非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。\n\n这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。\n\n![Manjaro安装过程编写文章时截图](ManjaroLinux的安装过程/编辑文章时截图.png)\n\n---","slug":"ManjaroLinux的安装过程","published":1,"updated":"2019-05-09T14:54:15.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xo000zxcvvx4fve5yx","content":"<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/桌面.png\" alt=\"桌面\"></p>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p>\n<ul>\n<li>XFCE </li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>系统资源低耗，快速</p>\n</blockquote>\n<ul>\n<li>KDE</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p>\n</blockquote>\n<ul>\n<li>GNOME</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>简单易用，可定制化，美化较为简单，内存占用大</p>\n</blockquote>\n<p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p>\n<ul>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">清华大学</a></li>\n<li><a href=\"http://mirrors.ustc.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">中科大</a></li>\n<li><a href=\"https://mirrors.huaweicloud.com/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">华为</a></li>\n<li><a href=\"http://mirrors.zju.edu.cn/manjaro/\" target=\"_blank\" rel=\"noopener\">浙江大学</a></li>\n</ul>\n<p>我们也可以直接使用官方的镜像源获取镜像<a href=\"https://manjaro.org/get-manjaro/\" target=\"_blank\" rel=\"noopener\">Manjaro</a></p>\n<p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p>\n<h2 id=\"制作启动盘\"><a href=\"#制作启动盘\" class=\"headerlink\" title=\"制作启动盘\"></a>制作启动盘</h2><p><strong>Windows:</strong></p>\n<p>推荐使用<a href=\"https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe\" target=\"_blank\" rel=\"noopener\">Rufus</a>进行制作启动盘。</p>\n<p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p>\n<p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p>\n<hr>\n<p><strong>Linux:</strong></p>\n<p>只需要执行这几条命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure>\n<p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p>\n<p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure>\n<p>取消挂载之后就可以进行格式化了.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure>\n<p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure>\n<p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png\" alt=\"安装选择界面\"></p>\n<p><strong>keytable</strong>————设置键盘布局</p>\n<p>通常默认即可</p>\n<p><strong>lang</strong>————设置语言</p>\n<p>设置为zh_CN，代表汉语</p>\n<p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p>\n<p>笔记本双显卡，想省电可以用free。</p>\n<p>台式机单显卡，推荐nofree。</p>\n<p><strong>Boot</strong>————选择这个就开始安装了</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/开始安装.png\" alt=\"开始安装-01\"></p>\n<p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p>\n<p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p>\n<p>点击后还可以设置一次语言，默认为中文了</p>\n<p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p>\n<p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p>\n<p>再下一步就是分区了，这一步是挺重要的，请认真看。</p>\n<p>默认情况下有两种选项:</p>\n<p><strong>抹除磁盘</strong></p>\n<p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p>\n<p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p>\n<p><strong>手动分区</strong></p>\n<p>选择手动分区之后，你将看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区.png\" alt=\"分区\"></p>\n<p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p>\n<p>那比较简单(就算有多个也没啥)</p>\n<p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p>\n<p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p>\n<p>然后你就点击吧…</p>\n<p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p>\n<blockquote>\n<p>引导的挂载点: /boot/efi</p>\n</blockquote>\n<p>记得标记点为:boot 和 esp</p>\n<blockquote>\n<p>根目录的挂载点: /</p>\n</blockquote>\n<p>记得标记点为:root</p>\n<blockquote>\n<p>主目录的挂载点: /home</p>\n</blockquote>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区标识.png\" alt=\"分区标识\"></p>\n<p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p>\n<p>要注意的是主目录要选择扩展分区。</p>\n<p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p>\n<ul>\n<li><p>用户名首字母不要大写</p>\n</li>\n<li><p>密码不要太简单</p>\n</li>\n</ul>\n<p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/摘要.png\" alt=\"摘要\"></p>\n<p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p>\n<h2 id=\"设置镜像源\"><a href=\"#设置镜像源\" class=\"headerlink\" title=\"设置镜像源\"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p>\n<h3 id=\"官方软件包源\"><a href=\"#官方软件包源\" class=\"headerlink\" title=\"官方软件包源\"></a>官方软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>随便选一个就好，推荐中科大的(USTC).</p>\n<h3 id=\"Aur软件包源\"><a href=\"#Aur软件包源\" class=\"headerlink\" title=\"Aur软件包源\"></a>Aur软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>在最后一行输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>\n<p>安装签名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>\n<h3 id=\"npm国内源\"><a href=\"#npm国内源\" class=\"headerlink\" title=\"npm国内源\"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure>\n<p>打开终端输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>测试是否成功:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config get registry</span><br></pre></td></tr></table></figure>\n<p>如果看到上面这个链接就对了</p>\n<h3 id=\"pip国内源\"><a href=\"#pip国内源\" class=\"headerlink\" title=\"pip国内源\"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p>\n<p>(没有则创建)</p>\n<p>修改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p>\n<p>你也可以使用其他的源</p>\n<p><a href=\"https://pypi.tuna.tsinghua.edu.cn/simple\" target=\"_blank\" rel=\"noopener\">清华</a></p>\n<p><a href=\"http://mirrors.aliyun.com/pypi/simple/\" target=\"_blank\" rel=\"noopener\">阿里云</a></p>\n<p><a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\" target=\"_blank\" rel=\"noopener\">中国科技大学</a></p>\n<p><a href=\"http://pypi.douban.com/simple/\" target=\"_blank\" rel=\"noopener\">豆瓣</a></p>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p>\n<p>Install Yay</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure>\n<p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p>\n<p>Install Vim</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure>\n<p>Install VSCode</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure>\n<p>Install OracleJDK8</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure>\n<p>Install 搜狗输入法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure>\n<p>再编辑配置文件~/.xprofile(若没有创建即可)</p>\n<p>修改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>\n<p>注销后就能使用搜狗输入法了</p>\n<p>Install IDEA</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure>\n<p>Install CLion</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S CLion</span><br></pre></td></tr></table></figure>\n<p>Install 网易云音乐</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure>\n<p>Install Chrome</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure>\n<p>这样就能完成基本的日常使用啦~</p>\n<h2 id=\"使用体验总结\"><a href=\"#使用体验总结\" class=\"headerlink\" title=\"使用体验总结\"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p>\n<p>最终还是选择了Manjaro-kde</p>\n<p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p>\n<p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png\" alt=\"Manjaro安装过程编写文章时截图\"></p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/桌面.png\" alt=\"桌面\"></p>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>ManjaroLinux官方提供了多个桌面环境的镜像，分别是:</p>\n<ul>\n<li>XFCE </li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>系统资源低耗，快速</p>\n</blockquote>\n<ul>\n<li>KDE</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+</p>\n</blockquote>\n<ul>\n<li>GNOME</li>\n</ul>\n<p>特点</p>\n<blockquote>\n<p>简单易用，可定制化，美化较为简单，内存占用大</p>\n</blockquote>\n<p>并且ManjaroLinux在国内有4个镜像源可选，分别是:</p>\n<ul>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">清华大学</a></li>\n<li><a href=\"http://mirrors.ustc.edu.cn/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">中科大</a></li>\n<li><a href=\"https://mirrors.huaweicloud.com/manjaro-cd/\" target=\"_blank\" rel=\"noopener\">华为</a></li>\n<li><a href=\"http://mirrors.zju.edu.cn/manjaro/\" target=\"_blank\" rel=\"noopener\">浙江大学</a></li>\n</ul>\n<p>我们也可以直接使用官方的镜像源获取镜像<a href=\"https://manjaro.org/get-manjaro/\" target=\"_blank\" rel=\"noopener\">Manjaro</a></p>\n<p>选择好自己要使用的桌面环境就可以开始制作启动盘了。</p>\n<h2 id=\"制作启动盘\"><a href=\"#制作启动盘\" class=\"headerlink\" title=\"制作启动盘\"></a>制作启动盘</h2><p><strong>Windows:</strong></p>\n<p>推荐使用<a href=\"https://github.com/pbatard/rufus/releases/download/v3.5/rufus-3.5.exe\" target=\"_blank\" rel=\"noopener\">Rufus</a>进行制作启动盘。</p>\n<p>下载好后直接选择镜像和要进行制作的U盘，选择开始。</p>\n<p><strong>开始时会让你勾选制作方式请选择dd模式</strong></p>\n<hr>\n<p><strong>Linux:</strong></p>\n<p>只需要执行这几条命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo lsblk #列出系统上的所有磁盘</span><br></pre></td></tr></table></figure>\n<p>找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是<strong>sdb或sda</strong></p>\n<p>如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo umount /dev/sda* #这里的sda是你U盘的磁盘名，</span><br></pre></td></tr></table></figure>\n<p>取消挂载之后就可以进行格式化了.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名.</span><br></pre></td></tr></table></figure>\n<p>格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda</span><br></pre></td></tr></table></figure>\n<p>如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。</p>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p><strong>最好是在网络稳定的环境下进行</strong></p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/安装选择界面.png\" alt=\"安装选择界面\"></p>\n<p><strong>keytable</strong>————设置键盘布局</p>\n<p>通常默认即可</p>\n<p><strong>lang</strong>————设置语言</p>\n<p>设置为zh_CN，代表汉语</p>\n<p><strong>driver</strong>————设置使用的驱动是开源的还是不开源的</p>\n<p>笔记本双显卡，想省电可以用free。</p>\n<p>台式机单显卡，推荐nofree。</p>\n<p><strong>Boot</strong>————选择这个就开始安装了</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统)</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/开始安装.png\" alt=\"开始安装-01\"></p>\n<p>这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。</p>\n<p>标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。</p>\n<p>点击后还可以设置一次语言，默认为中文了</p>\n<p>然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。</p>\n<p>下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。</p>\n<p>再下一步就是分区了，这一步是挺重要的，请认真看。</p>\n<p>默认情况下有两种选项:</p>\n<p><strong>抹除磁盘</strong></p>\n<p>将磁盘全部数据清除，分区是Manjaro自动帮你分配的.</p>\n<p>这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。</p>\n<p><strong>手动分区</strong></p>\n<p>选择手动分区之后，你将看到:</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区.png\" alt=\"分区\"></p>\n<p>如果你是单硬盘(也就是只有一个硬盘,mdzz)</p>\n<p>那比较简单(就算有多个也没啥)</p>\n<p>点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…)</p>\n<p>然后就可以看到有一个空闲空间，选中它，然后可以看到<strong>创建</strong>按钮可以点击了</p>\n<p>然后你就点击吧…</p>\n<p>你就可以看到创建分区的窗口，我们要创建的分区是<strong>根目录,主目录，引导</strong></p>\n<blockquote>\n<p>引导的挂载点: /boot/efi</p>\n</blockquote>\n<p>记得标记点为:boot 和 esp</p>\n<blockquote>\n<p>根目录的挂载点: /</p>\n</blockquote>\n<p>记得标记点为:root</p>\n<blockquote>\n<p>主目录的挂载点: /home</p>\n</blockquote>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/分区标识.png\" alt=\"分区标识\"></p>\n<p>如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。</p>\n<p>要注意的是主目录要选择扩展分区。</p>\n<p>下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。</p>\n<ul>\n<li><p>用户名首字母不要大写</p>\n</li>\n<li><p>密码不要太简单</p>\n</li>\n</ul>\n<p>下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/摘要.png\" alt=\"摘要\"></p>\n<p>静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。</p>\n<h2 id=\"设置镜像源\"><a href=\"#设置镜像源\" class=\"headerlink\" title=\"设置镜像源\"></a>设置镜像源</h2><p>选择一个好的源是使用Linux体验是否良好的一个重要因素。</p>\n<h3 id=\"官方软件包源\"><a href=\"#官方软件包源\" class=\"headerlink\" title=\"官方软件包源\"></a>官方软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman-mirrors -i -c China -m rank</span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>随便选一个就好，推荐中科大的(USTC).</p>\n<h3 id=\"Aur软件包源\"><a href=\"#Aur软件包源\" class=\"headerlink\" title=\"Aur软件包源\"></a>Aur软件包源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -Syu</span><br></pre></td></tr></table></figure>\n<p>在最后一行输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>\n<p>安装签名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>\n<h3 id=\"npm国内源\"><a href=\"#npm国内源\" class=\"headerlink\" title=\"npm国内源\"></a>npm国内源</h3><p>首先你得先下载npm和nodejs</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S npm nodejs</span><br></pre></td></tr></table></figure>\n<p>打开终端输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>测试是否成功:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config get registry</span><br></pre></td></tr></table></figure>\n<p>如果看到上面这个链接就对了</p>\n<h3 id=\"pip国内源\"><a href=\"#pip国内源\" class=\"headerlink\" title=\"pip国内源\"></a>pip国内源</h3><p>修改~/.pip/pip.conf</p>\n<p>(没有则创建)</p>\n<p>修改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p>\n<p>你也可以使用其他的源</p>\n<p><a href=\"https://pypi.tuna.tsinghua.edu.cn/simple\" target=\"_blank\" rel=\"noopener\">清华</a></p>\n<p><a href=\"http://mirrors.aliyun.com/pypi/simple/\" target=\"_blank\" rel=\"noopener\">阿里云</a></p>\n<p><a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\" target=\"_blank\" rel=\"noopener\">中国科技大学</a></p>\n<p><a href=\"http://pypi.douban.com/simple/\" target=\"_blank\" rel=\"noopener\">豆瓣</a></p>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><p>首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库</p>\n<p>Install Yay</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S yay</span><br></pre></td></tr></table></figure>\n<p>安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8</p>\n<p>Install Vim</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S Vim</span><br></pre></td></tr></table></figure>\n<p>Install VSCode</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制</span><br></pre></td></tr></table></figure>\n<p>Install OracleJDK8</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S jdk8 #这里就是由第三方打包了的</span><br></pre></td></tr></table></figure>\n<p>Install 搜狗输入法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin</span><br></pre></td></tr></table></figure>\n<p>再编辑配置文件~/.xprofile(若没有创建即可)</p>\n<p>修改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\"></span><br><span class=\"line\">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>\n<p>注销后就能使用搜狗输入法了</p>\n<p>Install IDEA</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-community-edition #社区版 IDEA</span><br><span class=\"line\"><span class=\"meta\">$</span> yay -S intellij-idea-ultimate-edition #付费版 IDEA</span><br></pre></td></tr></table></figure>\n<p>Install CLion</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> yay -S CLion</span><br></pre></td></tr></table></figure>\n<p>Install 网易云音乐</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure>\n<p>Install Chrome</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure>\n<p>这样就能完成基本的日常使用啦~</p>\n<h2 id=\"使用体验总结\"><a href=\"#使用体验总结\" class=\"headerlink\" title=\"使用体验总结\"></a>使用体验总结</h2><p>稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux </p>\n<p>最终还是选择了Manjaro-kde</p>\n<p>非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。</p>\n<p>这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。</p>\n<p><img src=\"/2019/04/23/ManjaroLinux的安装过程/编辑文章时截图.png\" alt=\"Manjaro安装过程编写文章时截图\"></p>\n<hr>\n"},{"title":"我儿子的博客","copyright":true,"date":"2019-05-21T08:06:54.000Z","_content":"\n自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。\n\n<!--more-->\n\n随便截取一个片段，这哥们咋那么傻的可爱。\n\n![预览](我儿子的博客/预览.png)\n\n想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。\n\n```PS:痔疮，你看到了别打我```\n\n\n# [EvanShady的博客](https://evanshady.github.io/)\n\n\n","source":"_posts/我儿子的博客.md","raw":"---\ntitle: 我儿子的博客\ncopyright: true\ndate: 2019-05-21 16:06:54\ncategories: 分享\ntags:\n - 欢乐时光\n---\n\n自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。\n\n<!--more-->\n\n随便截取一个片段，这哥们咋那么傻的可爱。\n\n![预览](我儿子的博客/预览.png)\n\n想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。\n\n```PS:痔疮，你看到了别打我```\n\n\n# [EvanShady的博客](https://evanshady.github.io/)\n\n\n","slug":"我儿子的博客","published":1,"updated":"2019-05-23T15:12:22.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xp0013xcvve10zxbct","content":"<p>自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。</p>\n<a id=\"more\"></a>\n<p>随便截取一个片段，这哥们咋那么傻的可爱。</p>\n<p><img src=\"/2019/05/21/我儿子的博客/预览.png\" alt=\"预览\"></p>\n<p>想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。</p>\n<p><code>PS:痔疮，你看到了别打我</code></p>\n<h1 id=\"EvanShady的博客\"><a href=\"#EvanShady的博客\" class=\"headerlink\" title=\"EvanShady的博客\"></a><a href=\"https://evanshady.github.io/\" target=\"_blank\" rel=\"noopener\">EvanShady的博客</a></h1>","site":{"data":{}},"excerpt":"<p>自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。</p>","more":"<p>随便截取一个片段，这哥们咋那么傻的可爱。</p>\n<p><img src=\"/2019/05/21/我儿子的博客/预览.png\" alt=\"预览\"></p>\n<p>想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。</p>\n<p><code>PS:痔疮，你看到了别打我</code></p>\n<h1 id=\"EvanShady的博客\"><a href=\"#EvanShady的博客\" class=\"headerlink\" title=\"EvanShady的博客\"></a><a href=\"https://evanshady.github.io/\" target=\"_blank\" rel=\"noopener\">EvanShady的博客</a></h1>"},{"title":"如何自学编程?","copyright":true,"date":"2019-05-23T14:19:59.000Z","_content":"\n前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。\n\n今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，\n\n为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。\n\n<!--more-->\n\n# 0x0 制定目标\n\n这个目标最好是十分远大的，并且必须是准确的。\n\n例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险...然后开始学习销售方面的才能。\n\n制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。\n\n# 0x1 选择方向\n\n你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。\n\n当然，我这里是推荐学习C++，虽然它曾经被我的偶像`Linus Torvalds`臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种`hack`玩法。\n\n# 0x2 学习过程\n\n在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。\n\n## 0x21学习心态\n我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。\n\n## 0x22学习方法\n\n`不要问，去调试，去反编译`\n\n这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。\n\n`多写代码，多讨论，尝试新想法`\n\n多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。\n\n多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。\n\n尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。\n\n# 0x3 充分利用互联网\n\n虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。\n\n不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下`原子弹制作从入门到精通`。这边推荐一个更好的利用搜索引擎的文章[点击访问](https://www.zhihu.com/question/23622803)\n\n# 0x4 读书\n\n在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。\n\n推荐书籍以后会写。\n\n\n# 0x5 推荐学习\n\n[C++视频教程)(https://www.bilibili.com/video/av41559729)\n\n[C++书籍](http://bestcbooks.com/recommended-cpp-books/)\n\n[Git视频教程](https://www.bilibili.com/video/av24736323)\n\n# 0x6 其他\n\n如果你是Windows系统，那么推荐[Visual Studio](https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F)作为你的编程工具。\n\n如果你是Linux系统，那么推荐[CLion](https://www.jetbrains.com/clion/download/download-thanks.html)作为你的编程工具。\n\n如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。\n\n推荐学习资源:[点击访问](https://www.codedream.xin/archives/learning-material-list)\n\n# 0x7 讨论群组\n\n![群组](如何自学编程/群组.png)\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何自学编程.md","raw":"---\ntitle: 如何自学编程?\ncopyright: true\ndate: 2019-05-23 22:19:59\ncategories: 个人感想\ntags:\n - 个人感想\n---\n\n前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。\n\n今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，\n\n为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。\n\n<!--more-->\n\n# 0x0 制定目标\n\n这个目标最好是十分远大的，并且必须是准确的。\n\n例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险...然后开始学习销售方面的才能。\n\n制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。\n\n# 0x1 选择方向\n\n你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。\n\n当然，我这里是推荐学习C++，虽然它曾经被我的偶像`Linus Torvalds`臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种`hack`玩法。\n\n# 0x2 学习过程\n\n在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。\n\n## 0x21学习心态\n我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。\n\n## 0x22学习方法\n\n`不要问，去调试，去反编译`\n\n这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。\n\n`多写代码，多讨论，尝试新想法`\n\n多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。\n\n多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。\n\n尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。\n\n# 0x3 充分利用互联网\n\n虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。\n\n不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下`原子弹制作从入门到精通`。这边推荐一个更好的利用搜索引擎的文章[点击访问](https://www.zhihu.com/question/23622803)\n\n# 0x4 读书\n\n在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。\n\n推荐书籍以后会写。\n\n\n# 0x5 推荐学习\n\n[C++视频教程)(https://www.bilibili.com/video/av41559729)\n\n[C++书籍](http://bestcbooks.com/recommended-cpp-books/)\n\n[Git视频教程](https://www.bilibili.com/video/av24736323)\n\n# 0x6 其他\n\n如果你是Windows系统，那么推荐[Visual Studio](https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F)作为你的编程工具。\n\n如果你是Linux系统，那么推荐[CLion](https://www.jetbrains.com/clion/download/download-thanks.html)作为你的编程工具。\n\n如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。\n\n推荐学习资源:[点击访问](https://www.codedream.xin/archives/learning-material-list)\n\n# 0x7 讨论群组\n\n![群组](如何自学编程/群组.png)\n\n\n\n\n\n\n\n\n\n","slug":"如何自学编程","published":1,"updated":"2019-05-23T15:09:41.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xp0015xcvvz3j6xnhj","content":"<p>前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。</p>\n<p>今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，</p>\n<p>为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。</p>\n<a id=\"more\"></a>\n<h1 id=\"0x0-制定目标\"><a href=\"#0x0-制定目标\" class=\"headerlink\" title=\"0x0 制定目标\"></a>0x0 制定目标</h1><p>这个目标最好是十分远大的，并且必须是准确的。</p>\n<p>例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。</p>\n<p>制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。</p>\n<h1 id=\"0x1-选择方向\"><a href=\"#0x1-选择方向\" class=\"headerlink\" title=\"0x1 选择方向\"></a>0x1 选择方向</h1><p>你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。</p>\n<p>当然，我这里是推荐学习C++，虽然它曾经被我的偶像<code>Linus Torvalds</code>臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种<code>hack</code>玩法。</p>\n<h1 id=\"0x2-学习过程\"><a href=\"#0x2-学习过程\" class=\"headerlink\" title=\"0x2 学习过程\"></a>0x2 学习过程</h1><p>在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。</p>\n<h2 id=\"0x21学习心态\"><a href=\"#0x21学习心态\" class=\"headerlink\" title=\"0x21学习心态\"></a>0x21学习心态</h2><p>我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。</p>\n<h2 id=\"0x22学习方法\"><a href=\"#0x22学习方法\" class=\"headerlink\" title=\"0x22学习方法\"></a>0x22学习方法</h2><p><code>不要问，去调试，去反编译</code></p>\n<p>这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。</p>\n<p><code>多写代码，多讨论，尝试新想法</code></p>\n<p>多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。</p>\n<p>多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。</p>\n<p>尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。</p>\n<h1 id=\"0x3-充分利用互联网\"><a href=\"#0x3-充分利用互联网\" class=\"headerlink\" title=\"0x3 充分利用互联网\"></a>0x3 充分利用互联网</h1><p>虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。</p>\n<p>不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下<code>原子弹制作从入门到精通</code>。这边推荐一个更好的利用搜索引擎的文章<a href=\"https://www.zhihu.com/question/23622803\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x4-读书\"><a href=\"#0x4-读书\" class=\"headerlink\" title=\"0x4 读书\"></a>0x4 读书</h1><p>在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。</p>\n<p>推荐书籍以后会写。</p>\n<h1 id=\"0x5-推荐学习\"><a href=\"#0x5-推荐学习\" class=\"headerlink\" title=\"0x5 推荐学习\"></a>0x5 推荐学习</h1><p>[C++视频教程)(<a href=\"https://www.bilibili.com/video/av41559729\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av41559729</a>)</p>\n<p><a href=\"http://bestcbooks.com/recommended-cpp-books/\" target=\"_blank\" rel=\"noopener\">C++书籍</a></p>\n<p><a href=\"https://www.bilibili.com/video/av24736323\" target=\"_blank\" rel=\"noopener\">Git视频教程</a></p>\n<h1 id=\"0x6-其他\"><a href=\"#0x6-其他\" class=\"headerlink\" title=\"0x6 其他\"></a>0x6 其他</h1><p>如果你是Windows系统，那么推荐<a href=\"https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F\" target=\"_blank\" rel=\"noopener\">Visual Studio</a>作为你的编程工具。</p>\n<p>如果你是Linux系统，那么推荐<a href=\"https://www.jetbrains.com/clion/download/download-thanks.html\" target=\"_blank\" rel=\"noopener\">CLion</a>作为你的编程工具。</p>\n<p>如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。</p>\n<p>推荐学习资源:<a href=\"https://www.codedream.xin/archives/learning-material-list\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x7-讨论群组\"><a href=\"#0x7-讨论群组\" class=\"headerlink\" title=\"0x7 讨论群组\"></a>0x7 讨论群组</h1><p><img src=\"/2019/05/23/如何自学编程/群组.png\" alt=\"群组\"></p>\n","site":{"data":{}},"excerpt":"<p>前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。</p>\n<p>今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到，</p>\n<p>为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。</p>","more":"<h1 id=\"0x0-制定目标\"><a href=\"#0x0-制定目标\" class=\"headerlink\" title=\"0x0 制定目标\"></a>0x0 制定目标</h1><p>这个目标最好是十分远大的，并且必须是准确的。</p>\n<p>例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。</p>\n<p>制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。</p>\n<h1 id=\"0x1-选择方向\"><a href=\"#0x1-选择方向\" class=\"headerlink\" title=\"0x1 选择方向\"></a>0x1 选择方向</h1><p>你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。</p>\n<p>当然，我这里是推荐学习C++，虽然它曾经被我的偶像<code>Linus Torvalds</code>臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种<code>hack</code>玩法。</p>\n<h1 id=\"0x2-学习过程\"><a href=\"#0x2-学习过程\" class=\"headerlink\" title=\"0x2 学习过程\"></a>0x2 学习过程</h1><p>在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。</p>\n<h2 id=\"0x21学习心态\"><a href=\"#0x21学习心态\" class=\"headerlink\" title=\"0x21学习心态\"></a>0x21学习心态</h2><p>我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。</p>\n<h2 id=\"0x22学习方法\"><a href=\"#0x22学习方法\" class=\"headerlink\" title=\"0x22学习方法\"></a>0x22学习方法</h2><p><code>不要问，去调试，去反编译</code></p>\n<p>这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。</p>\n<p><code>多写代码，多讨论，尝试新想法</code></p>\n<p>多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。</p>\n<p>多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。</p>\n<p>尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。</p>\n<h1 id=\"0x3-充分利用互联网\"><a href=\"#0x3-充分利用互联网\" class=\"headerlink\" title=\"0x3 充分利用互联网\"></a>0x3 充分利用互联网</h1><p>虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。</p>\n<p>不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下<code>原子弹制作从入门到精通</code>。这边推荐一个更好的利用搜索引擎的文章<a href=\"https://www.zhihu.com/question/23622803\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x4-读书\"><a href=\"#0x4-读书\" class=\"headerlink\" title=\"0x4 读书\"></a>0x4 读书</h1><p>在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。</p>\n<p>推荐书籍以后会写。</p>\n<h1 id=\"0x5-推荐学习\"><a href=\"#0x5-推荐学习\" class=\"headerlink\" title=\"0x5 推荐学习\"></a>0x5 推荐学习</h1><p>[C++视频教程)(<a href=\"https://www.bilibili.com/video/av41559729\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av41559729</a>)</p>\n<p><a href=\"http://bestcbooks.com/recommended-cpp-books/\" target=\"_blank\" rel=\"noopener\">C++书籍</a></p>\n<p><a href=\"https://www.bilibili.com/video/av24736323\" target=\"_blank\" rel=\"noopener\">Git视频教程</a></p>\n<h1 id=\"0x6-其他\"><a href=\"#0x6-其他\" class=\"headerlink\" title=\"0x6 其他\"></a>0x6 其他</h1><p>如果你是Windows系统，那么推荐<a href=\"https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.microsoft.com%2Fzh-hk%2F\" target=\"_blank\" rel=\"noopener\">Visual Studio</a>作为你的编程工具。</p>\n<p>如果你是Linux系统，那么推荐<a href=\"https://www.jetbrains.com/clion/download/download-thanks.html\" target=\"_blank\" rel=\"noopener\">CLion</a>作为你的编程工具。</p>\n<p>如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。</p>\n<p>推荐学习资源:<a href=\"https://www.codedream.xin/archives/learning-material-list\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h1 id=\"0x7-讨论群组\"><a href=\"#0x7-讨论群组\" class=\"headerlink\" title=\"0x7 讨论群组\"></a>0x7 讨论群组</h1><p><img src=\"/2019/05/23/如何自学编程/群组.png\" alt=\"群组\"></p>"},{"title":"我的Linux之路","copyright":true,"date":"2019-05-14T16:04:56.000Z","_content":"\n这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.\n\n<!--more-->\n\n先说说一些题外话\n\n\n我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。\n\n\n第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)... 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。\n\n\n我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了\"驱动\" 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法...还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决...后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了....\n\n\n好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。\n\n\n身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 \"xxx可能是最好的Linux发行版\"，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。\n\n\n终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。\n\n\n自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!\n\n\n下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么... 毛玻璃效果非常漂亮，社区还是挺活跃的。\n\n\n说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）\n\n我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。\n\n\n我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。\n\n\n下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!\n\n\n解决了上面提到的所有问题，并且电脑还省电多了...并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。\n\n\n但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。\n\n\n总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。\n","source":"_posts/我的Linux之路.md","raw":"---\ntitle: 我的Linux之路\ncopyright: true\ndate: 2019-05-15 00:04:56\ncategories: 个人感想\ntags:\n - Linux\n---\n\n这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.\n\n<!--more-->\n\n先说说一些题外话\n\n\n我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。\n\n\n第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)... 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。\n\n\n我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了\"驱动\" 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法...还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决...后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了....\n\n\n好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。\n\n\n身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 \"xxx可能是最好的Linux发行版\"，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。\n\n\n终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。\n\n\n自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!\n\n\n下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么... 毛玻璃效果非常漂亮，社区还是挺活跃的。\n\n\n说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）\n\n我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。\n\n\n我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。\n\n\n下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!\n\n\n解决了上面提到的所有问题，并且电脑还省电多了...并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。\n\n\n但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。\n\n\n总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。\n","slug":"我的Linux之路","published":1,"updated":"2019-05-14T16:07:04.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xq0018xcvvgn675dlg","content":"<p>这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.</p>\n<a id=\"more\"></a>\n<p>先说说一些题外话</p>\n<p>我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。</p>\n<p>第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。</p>\n<p>我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了….</p>\n<p>好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。</p>\n<p>身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。</p>\n<p>终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。</p>\n<p>自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!</p>\n<p>下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。</p>\n<p>说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）</p>\n<p>我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。</p>\n<p>我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。</p>\n<p>下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!</p>\n<p>解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。</p>\n<p>但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。</p>\n<p>总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。</p>\n","site":{"data":{}},"excerpt":"<p>这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法.</p>","more":"<p>先说说一些题外话</p>\n<p>我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。</p>\n<p>第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。</p>\n<p>我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢?           某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了….</p>\n<p>好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。</p>\n<p>身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。</p>\n<p>终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。</p>\n<p>自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞!</p>\n<p>下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。</p>\n<p>说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验）</p>\n<p>我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。</p>\n<p>我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。</p>\n<p>下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了!</p>\n<p>解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。</p>\n<p>但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。</p>\n<p>总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。</p>"},{"title":"解决KDE下部分应用不能使用fctix中文输入法的问题","copyright":true,"date":"2019-05-19T07:56:33.000Z","_content":"\n我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。\n\n<!--more-->\n\n*********** 本教程使用fctix输入法框架。**************\n\n# 第一步\n\n首先安装一些必要的软件:\n\n~~~shell\n$ sudo pacman -S fctix fctix-im fctix-configtool fctix-googlepinyin\n~~~\n\n# 第二步\n\n安装完成后编辑:**/etc/environment**文件，加上如下内容:\n\n~~~shell\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=@im=fcitx\n~~~\n\n# 第三步\n\n注销当前会话，配置输入法为googlepinyin即可使用。\n\n\n> [本文参考](https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/)\n\n---\n","source":"_posts/解决KDE下部分应用不能使用fctix中文输入法的问题.md","raw":"---\ntitle: 解决KDE下部分应用不能使用fctix中文输入法的问题\ncopyright: true\ndate: 2019-05-19 15:56:33\ncategories: 学习笔记\ntags:\n - Linux\n - KDE\n---\n\n我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。\n\n<!--more-->\n\n*********** 本教程使用fctix输入法框架。**************\n\n# 第一步\n\n首先安装一些必要的软件:\n\n~~~shell\n$ sudo pacman -S fctix fctix-im fctix-configtool fctix-googlepinyin\n~~~\n\n# 第二步\n\n安装完成后编辑:**/etc/environment**文件，加上如下内容:\n\n~~~shell\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=@im=fcitx\n~~~\n\n# 第三步\n\n注销当前会话，配置输入法为googlepinyin即可使用。\n\n\n> [本文参考](https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/)\n\n---\n","slug":"解决KDE下部分应用不能使用fctix中文输入法的问题","published":1,"updated":"2019-05-20T05:59:26.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xr001cxcvv9bwouweh","content":"<p>我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。</p>\n<a id=\"more\"></a>\n<p><strong><strong>***</strong></strong> 本教程使用fctix输入法框架。<strong><strong><strong>**</strong></strong></strong></p>\n<h1 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h1><p>首先安装一些必要的软件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fctix fctix-im fctix-configtool fctix-googlepinyin</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h1><p>安装完成后编辑:<strong>/etc/environment</strong>文件，加上如下内容:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>\n<h1 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h1><p>注销当前会话，配置输入法为googlepinyin即可使用。</p>\n<blockquote>\n<p><a href=\"https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">本文参考</a></p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"<p>我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。</p>","more":"<p><strong><strong>***</strong></strong> 本教程使用fctix输入法框架。<strong><strong><strong>**</strong></strong></strong></p>\n<h1 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h1><p>首先安装一些必要的软件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> sudo pacman -S fctix fctix-im fctix-configtool fctix-googlepinyin</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h1><p>安装完成后编辑:<strong>/etc/environment</strong>文件，加上如下内容:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GTK_IM_MODULE=fcitx</span><br><span class=\"line\">export QT_IM_MODULE=fcitx</span><br><span class=\"line\">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>\n<h1 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h1><p>注销当前会话，配置输入法为googlepinyin即可使用。</p>\n<blockquote>\n<p><a href=\"https://code-insight.xyz/manjaro%E6%96%B0%E6%89%8B%E5%BF%AB%E9%80%9F%E8%A3%85%E9%85%8D%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">本文参考</a></p>\n</blockquote>\n<hr>"},{"title":"深拷贝和浅拷贝的区别","copyright":true,"date":"2019-05-14T14:55:24.000Z","_content":"\n虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。\n\n<!--more-->\n\n# 浅拷贝\n\n我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。\n\n**那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。**\n\n那什么是拷贝构造函数呢?\n\n**拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象**\n\n下面看个例子:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        age = f_age;\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" << h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" << h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，**这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。**\n\n浅拷贝的具体代码实现是怎样的呢？请看下面的代码:\n\n~~~C++\n    //默认的拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        age = h.age;\n    }\n~~~\n\n可与看出，它只是简单的将对象属性的值，进行拷贝。\n\n大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？\n\n答案是否定的，下面看下深拷贝。\n\n\n# 深拷贝\n\n什么是深拷贝?\n\n**深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.**\n\n下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nfree(): double free detected in tcache 2\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\n\nProcess finished with exit code 134 (interrupted by signal 6: SIGABRT)\n~~~\n\n通过输出结果，我们发现，程序发生了错误。\n\n因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。\n\n上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。\n\n由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。\n\n然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。\n\n既然问题找到了，我们就需要进行修改，将这个问题解决。\n\n下面通过深拷贝的方式，让这个bug被修复:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        //新开辟内存空间到堆区，存放age所指向的数据。\n        age = new int(*h.age);\n        cout<<\"Human拷贝构造函数调用.\"<<endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\nHuman拷贝构造函数调用.\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n程序没有报错，说明我们的bug成功解决了。\n\n上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。\n\n深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。\n\n为什么能避免？\n\n原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。\n\n# 两者该如何选择?\n\n**说得绝对点：**\n\n若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。\n\n这时需要使用深拷贝。\n\n**说的不那么绝对:**\n\n若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。\n","source":"_posts/深拷贝和浅拷贝的区别.md","raw":"---\ntitle: 深拷贝和浅拷贝的区别\ncopyright: true\ndate: 2019-05-14 22:55:24\ncategories: 学习笔记\ntags:\n - C++\n - 经典案例\n---\n\n虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。\n\n<!--more-->\n\n# 浅拷贝\n\n我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。\n\n**那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。**\n\n那什么是拷贝构造函数呢?\n\n**拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象**\n\n下面看个例子:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        age = f_age;\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" << h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" << h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，**这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。**\n\n浅拷贝的具体代码实现是怎样的呢？请看下面的代码:\n\n~~~C++\n    //默认的拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        age = h.age;\n    }\n~~~\n\n可与看出，它只是简单的将对象属性的值，进行拷贝。\n\n大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？\n\n答案是否定的，下面看下深拷贝。\n\n\n# 深拷贝\n\n什么是深拷贝?\n\n**深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.**\n\n下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nfree(): double free detected in tcache 2\nHuman有参构造函数调用.\n李四的年龄为:18\n李四的年龄为:18\nHuman析构函数调用.\n\nProcess finished with exit code 134 (interrupted by signal 6: SIGABRT)\n~~~\n\n通过输出结果，我们发现，程序发生了错误。\n\n因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。\n\n上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。\n\n由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。\n\n然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。\n\n既然问题找到了，我们就需要进行修改，将这个问题解决。\n\n下面通过深拷贝的方式，让这个bug被修复:\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nclass Human {\npublic:\n    string name;\n    int *age;\n\n    //默认构造函数\n    Human() {\n        cout << \"Human默认构造函数调用.\" << endl;\n    }\n\n    //有参构造函数\n    Human(string f_name, int f_age) {\n        name = f_name;\n        //动态分配内存空间，将age的数据存入堆区\n        age = new int(f_age);\n        cout << \"Human有参构造函数调用.\" << endl;\n    }\n\n    //拷贝构造函数\n    Human(const Human & h){\n        name = h.name;\n        //新开辟内存空间到堆区，存放age所指向的数据。\n        age = new int(*h.age);\n        cout<<\"Human拷贝构造函数调用.\"<<endl;\n    }\n\n    //析构函数\n    ~Human() {\n        //如果age指针变量是空，则释放\n        if(age !=NULL){\n            delete age;\n            //防止指针变量成为野指针\n            age = NULL;\n        }\n        cout << \"Human析构函数调用.\" << endl;\n    }\n};\n\nint main() {\n    Human h1(\"李四\", 18);\n    cout << h1.name << \"的年龄为:\" <<*h1.age << endl;\n    //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2\n    Human h2(h1);\n    cout << h2.name << \"的年龄为:\" <<*h2.age << endl;\n    return 0;\n}\n~~~\n\n输出结果为:\n\n~~~\nHuman有参构造函数调用.\n李四的年龄为:18\nHuman拷贝构造函数调用.\n李四的年龄为:18\nHuman析构函数调用.\nHuman析构函数调用.\n\nProcess finished with exit code 0\n~~~\n\n程序没有报错，说明我们的bug成功解决了。\n\n上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。\n\n深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。\n\n为什么能避免？\n\n原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。\n\n# 两者该如何选择?\n\n**说得绝对点：**\n\n若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。\n\n这时需要使用深拷贝。\n\n**说的不那么绝对:**\n\n若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。\n","slug":"深拷贝和浅拷贝的区别","published":1,"updated":"2019-05-14T16:39:42.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xt001gxcvv7l889s47","content":"<p>虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。</p>\n<a id=\"more\"></a>\n<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><p>我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。</p>\n<p><strong>那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。</strong></p>\n<p>那什么是拷贝构造函数呢?</p>\n<p><strong>拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象</strong></p>\n<p>下面看个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        age = f_age;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，<strong>这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。</strong></p>\n<p>浅拷贝的具体代码实现是怎样的呢？请看下面的代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认的拷贝构造函数</span></span><br><span class=\"line\">Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">    name = h.name;</span><br><span class=\"line\">    age = h.age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可与看出，它只是简单的将对象属性的值，进行拷贝。</p>\n<p>大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？</p>\n<p>答案是否定的，下面看下深拷贝。</p>\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><p>什么是深拷贝?</p>\n<p><strong>深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.</strong></p>\n<p>下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free(): double free detected in tcache 2</span><br><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></table></figure>\n<p>通过输出结果，我们发现，程序发生了错误。</p>\n<p>因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。</p>\n<p>上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。</p>\n<p>由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。</p>\n<p>然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。</p>\n<p>既然问题找到了，我们就需要进行修改，将这个问题解决。</p>\n<p>下面通过深拷贝的方式，让这个bug被修复:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">        name = h.name;</span><br><span class=\"line\">        <span class=\"comment\">//新开辟内存空间到堆区，存放age所指向的数据。</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*h.age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Human拷贝构造函数调用.\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human拷贝构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>程序没有报错，说明我们的bug成功解决了。</p>\n<p>上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。</p>\n<p>深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。</p>\n<p>为什么能避免？</p>\n<p>原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。</p>\n<h1 id=\"两者该如何选择\"><a href=\"#两者该如何选择\" class=\"headerlink\" title=\"两者该如何选择?\"></a>两者该如何选择?</h1><p><strong>说得绝对点：</strong></p>\n<p>若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。</p>\n<p>这时需要使用深拷贝。</p>\n<p><strong>说的不那么绝对:</strong></p>\n<p>若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。</p>\n","site":{"data":{}},"excerpt":"<p>虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。</p>","more":"<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><p>我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。</p>\n<p><strong>那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。</strong></p>\n<p>那什么是拷贝构造函数呢?</p>\n<p><strong>拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象</strong></p>\n<p>下面看个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        age = f_age;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt; h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，<strong>这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。</strong></p>\n<p>浅拷贝的具体代码实现是怎样的呢？请看下面的代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认的拷贝构造函数</span></span><br><span class=\"line\">Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">    name = h.name;</span><br><span class=\"line\">    age = h.age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可与看出，它只是简单的将对象属性的值，进行拷贝。</p>\n<p>大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？</p>\n<p>答案是否定的，下面看下深拷贝。</p>\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><p>什么是深拷贝?</p>\n<p><strong>深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景.</strong></p>\n<p>下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free(): double free detected in tcache 2</span><br><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></table></figure>\n<p>通过输出结果，我们发现，程序发生了错误。</p>\n<p>因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。</p>\n<p>上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。</p>\n<p>由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。</p>\n<p>然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。</p>\n<p>既然问题找到了，我们就需要进行修改，将这个问题解决。</p>\n<p>下面通过深拷贝的方式，让这个bug被修复:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    Human() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human默认构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    Human(<span class=\"built_in\">string</span> f_name, <span class=\"keyword\">int</span> f_age) &#123;</span><br><span class=\"line\">        name = f_name;</span><br><span class=\"line\">        <span class=\"comment\">//动态分配内存空间，将age的数据存入堆区</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(f_age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human有参构造函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    Human(<span class=\"keyword\">const</span> Human &amp; h)&#123;</span><br><span class=\"line\">        name = h.name;</span><br><span class=\"line\">        <span class=\"comment\">//新开辟内存空间到堆区，存放age所指向的数据。</span></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*h.age);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Human拷贝构造函数调用.\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Human() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果age指针变量是空，则释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age !=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            <span class=\"comment\">//防止指针变量成为野指针</span></span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Human析构函数调用.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h1</span><span class=\"params\">(<span class=\"string\">\"李四\"</span>, <span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h1.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h1.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，编译器会自动将h1对象属性的值拷贝给h2</span></span><br><span class=\"line\">    <span class=\"function\">Human <span class=\"title\">h2</span><span class=\"params\">(h1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; h2.name &lt;&lt; <span class=\"string\">\"的年龄为:\"</span> &lt;&lt;*h2.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Human有参构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human拷贝构造函数调用.</span><br><span class=\"line\">李四的年龄为:18</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\">Human析构函数调用.</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>程序没有报错，说明我们的bug成功解决了。</p>\n<p>上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。</p>\n<p>深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。</p>\n<p>为什么能避免？</p>\n<p>原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。</p>\n<h1 id=\"两者该如何选择\"><a href=\"#两者该如何选择\" class=\"headerlink\" title=\"两者该如何选择?\"></a>两者该如何选择?</h1><p><strong>说得绝对点：</strong></p>\n<p>若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。</p>\n<p>这时需要使用深拷贝。</p>\n<p><strong>说的不那么绝对:</strong></p>\n<p>若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。</p>"},{"title":"终端多窗口神器——Screen","date":"2019-05-09T08:56:08.000Z","copyright":true,"_content":"\n曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。\n\n曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。\n\n有了Screen,你就可以获得更好的使用终端多窗口的体验。\n\n<!--more-->\n\n我想你肯定遇到以下几种情况:\n\n- ftp传输\n\n- 系统备份\n\n- 长时间运行任务\n\n好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了...只能重新来过。\n\n# 凶手 SIGHUP 信号\n\n> 以下资料来自维基百科 \n>> SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。\n\n简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。\n\n## 发送信号\n\n在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。\n\n- Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。\n\n- Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。\n\n- Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。\n\n## 前因后果\n\n相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。\n\n**更多有关SIGHUP信号的资料，我会在后面的文章进行更新。**\n\n---\n\n# 开始使用Screen\n\n先简单说说什么是Screen:\n\nScreen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。\n\nScreen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。\n\n**1.创建一个screen窗口**\n\n~~~shell\n[evanmeek@Evan-PC]# screen\n~~~\n\n这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。\n\n**2.创建窗口+执行命令**\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim \n~~~\n\nscreen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。\n\n**3.一个窗口中再有一个窗口中再有一个窗口中...**\n\n你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。\n\n**4.screen的暂时断开(detach)和重新链接(attach)**\n\n比如在screen窗口下用vim编辑C++源文件\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim test.cpp \n~~~\n\n但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).\n\n![挂起提示](终端多窗口神器——Screen/detachedInfo.png)\n\n当你做完其他事你就可以找回该会话，进行重新连接:\n\n找到会话\n\n~~~shell\n[evanmeek@Evan-PC]# screen -ls\nThere are screens on:\n        17944.pts-4.EvanLinux   (Detached)\n        14290.server    (Detached)\n2 Sockets in /run/screens/S-evanmeek.\n~~~\n\n重新连接\n\n~~~shell\n[evanmeek＠Evan-PC]# screen- r 17944\n~~~\n\n这样就可以恢复pts这个会话的窗口了．\n\n---\n\n# 配置你的Screen\n\n前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.\n\n可通过如下键绑定查看所有键绑定．\n\n**C-a ?**\n\n常用的键绑定有：\n\n|键绑定|描述|\n|:---:|:---:|---|\n|C-a ?|显示所有键绑定信息|\n|C-a w|显示所有窗口列表|\n|C-a C-a|切换到之前显示的窗口|\n|C-a c|创建一个新的运行shell的窗口并切换到该窗口|\n|C-a n|切换到下一个窗口|\n|C-a p|切换到前一个窗口|\n|C-a 0~9|切换到0~9窗口|\n|C-a a|发送C-a到当前窗口|\n|C-a d|暂时断开screen会话|\n|C-a k|杀掉当前窗口|\n|C-a [|进入拷贝/回滚模式\n\n我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;\n\n![默认的命令字符](终端多窗口神器——Screen/DefalutCommandKey.png);\n\n我们可以修改它，通过如下格式:\n\n**-exy**\n\nx:命令字符\n\ny:转义字符\n\n~~~shell\n[evanmeek@Evan-PC]# screen -e^oo\n~~~\n\n这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．\n\n---","source":"_posts/终端多窗口神器——Screen.md","raw":"---\ntitle: 终端多窗口神器——Screen\ndate: 2019-05-09 16:56:08\ncategories: 折腾日记\ntags:\n  - Linux\n  - 软件折腾\ncopyright: true\n---\n\n曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。\n\n曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。\n\n有了Screen,你就可以获得更好的使用终端多窗口的体验。\n\n<!--more-->\n\n我想你肯定遇到以下几种情况:\n\n- ftp传输\n\n- 系统备份\n\n- 长时间运行任务\n\n好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了...只能重新来过。\n\n# 凶手 SIGHUP 信号\n\n> 以下资料来自维基百科 \n>> SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。\n\n简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。\n\n## 发送信号\n\n在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。\n\n- Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。\n\n- Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。\n\n- Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。\n\n## 前因后果\n\n相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。\n\n**更多有关SIGHUP信号的资料，我会在后面的文章进行更新。**\n\n---\n\n# 开始使用Screen\n\n先简单说说什么是Screen:\n\nScreen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。\n\nScreen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。\n\n**1.创建一个screen窗口**\n\n~~~shell\n[evanmeek@Evan-PC]# screen\n~~~\n\n这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。\n\n**2.创建窗口+执行命令**\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim \n~~~\n\nscreen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。\n\n**3.一个窗口中再有一个窗口中再有一个窗口中...**\n\n你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。\n\n**4.screen的暂时断开(detach)和重新链接(attach)**\n\n比如在screen窗口下用vim编辑C++源文件\n\n~~~shell\n[evanmeek@Evan-PC]# screen vim test.cpp \n~~~\n\n但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).\n\n![挂起提示](终端多窗口神器——Screen/detachedInfo.png)\n\n当你做完其他事你就可以找回该会话，进行重新连接:\n\n找到会话\n\n~~~shell\n[evanmeek@Evan-PC]# screen -ls\nThere are screens on:\n        17944.pts-4.EvanLinux   (Detached)\n        14290.server    (Detached)\n2 Sockets in /run/screens/S-evanmeek.\n~~~\n\n重新连接\n\n~~~shell\n[evanmeek＠Evan-PC]# screen- r 17944\n~~~\n\n这样就可以恢复pts这个会话的窗口了．\n\n---\n\n# 配置你的Screen\n\n前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.\n\n可通过如下键绑定查看所有键绑定．\n\n**C-a ?**\n\n常用的键绑定有：\n\n|键绑定|描述|\n|:---:|:---:|---|\n|C-a ?|显示所有键绑定信息|\n|C-a w|显示所有窗口列表|\n|C-a C-a|切换到之前显示的窗口|\n|C-a c|创建一个新的运行shell的窗口并切换到该窗口|\n|C-a n|切换到下一个窗口|\n|C-a p|切换到前一个窗口|\n|C-a 0~9|切换到0~9窗口|\n|C-a a|发送C-a到当前窗口|\n|C-a d|暂时断开screen会话|\n|C-a k|杀掉当前窗口|\n|C-a [|进入拷贝/回滚模式\n\n我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;\n\n![默认的命令字符](终端多窗口神器——Screen/DefalutCommandKey.png);\n\n我们可以修改它，通过如下格式:\n\n**-exy**\n\nx:命令字符\n\ny:转义字符\n\n~~~shell\n[evanmeek@Evan-PC]# screen -e^oo\n~~~\n\n这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．\n\n---","slug":"终端多窗口神器——Screen","published":1,"updated":"2019-05-09T14:54:00.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0sp9xu001kxcvvnts8ipqz","content":"<p>曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。</p>\n<p>曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。</p>\n<p>有了Screen,你就可以获得更好的使用终端多窗口的体验。</p>\n<a id=\"more\"></a>\n<p>我想你肯定遇到以下几种情况:</p>\n<ul>\n<li><p>ftp传输</p>\n</li>\n<li><p>系统备份</p>\n</li>\n<li><p>长时间运行任务</p>\n</li>\n</ul>\n<p>好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。</p>\n<h1 id=\"凶手-SIGHUP-信号\"><a href=\"#凶手-SIGHUP-信号\" class=\"headerlink\" title=\"凶手 SIGHUP 信号\"></a>凶手 SIGHUP 信号</h1><blockquote>\n<p>以下资料来自维基百科 </p>\n<blockquote>\n<p>SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p>\n</blockquote>\n</blockquote>\n<p>简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。</p>\n<h2 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h2><p>在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。</p>\n<ul>\n<li><p>Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。</p>\n</li>\n<li><p>Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。</p>\n</li>\n<li><p>Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。</p>\n</li>\n</ul>\n<h2 id=\"前因后果\"><a href=\"#前因后果\" class=\"headerlink\" title=\"前因后果\"></a>前因后果</h2><p>相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。</p>\n<p><strong>更多有关SIGHUP信号的资料，我会在后面的文章进行更新。</strong></p>\n<hr>\n<h1 id=\"开始使用Screen\"><a href=\"#开始使用Screen\" class=\"headerlink\" title=\"开始使用Screen\"></a>开始使用Screen</h1><p>先简单说说什么是Screen:</p>\n<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。</p>\n<p>Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。</p>\n<p><strong>1.创建一个screen窗口</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen</span><br></pre></td></tr></table></figure>\n<p>这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。</p>\n<p><strong>2.创建窗口+执行命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim</span><br></pre></td></tr></table></figure>\n<p>screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。</p>\n<p><strong>3.一个窗口中再有一个窗口中再有一个窗口中…</strong></p>\n<p>你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。</p>\n<p><strong>4.screen的暂时断开(detach)和重新链接(attach)</strong></p>\n<p>比如在screen窗口下用vim编辑C++源文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim test.cpp</span><br></pre></td></tr></table></figure>\n<p>但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/detachedInfo.png\" alt=\"挂起提示\"></p>\n<p>当你做完其他事你就可以找回该会话，进行重新连接:</p>\n<p>找到会话</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -ls</span><br><span class=\"line\">There are screens on:</span><br><span class=\"line\">        17944.pts-4.EvanLinux   (Detached)</span><br><span class=\"line\">        14290.server    (Detached)</span><br><span class=\"line\">2 Sockets in /run/screens/S-evanmeek.</span><br></pre></td></tr></table></figure>\n<p>重新连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek＠Evan-PC]# screen- r 17944</span><br></pre></td></tr></table></figure>\n<p>这样就可以恢复pts这个会话的窗口了．</p>\n<hr>\n<h1 id=\"配置你的Screen\"><a href=\"#配置你的Screen\" class=\"headerlink\" title=\"配置你的Screen\"></a>配置你的Screen</h1><p>前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.</p>\n<p>可通过如下键绑定查看所有键绑定．</p>\n<p><strong>C-a ?</strong></p>\n<p>常用的键绑定有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">键绑定</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">C-a ?</td>\n<td style=\"text-align:center\">显示所有键绑定信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a w</td>\n<td style=\"text-align:center\">显示所有窗口列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a C-a</td>\n<td style=\"text-align:center\">切换到之前显示的窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a c</td>\n<td style=\"text-align:center\">创建一个新的运行shell的窗口并切换到该窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a n</td>\n<td style=\"text-align:center\">切换到下一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a p</td>\n<td style=\"text-align:center\">切换到前一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a 0~9</td>\n<td style=\"text-align:center\">切换到0~9窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a a</td>\n<td style=\"text-align:center\">发送C-a到当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a d</td>\n<td style=\"text-align:center\">暂时断开screen会话</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a k</td>\n<td style=\"text-align:center\">杀掉当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a [</td>\n<td style=\"text-align:center\">进入拷贝/回滚模式</td>\n</tr>\n</tbody>\n</table>\n<p>我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png\" alt=\"默认的命令字符\">;</p>\n<p>我们可以修改它，通过如下格式:</p>\n<p><strong>-exy</strong></p>\n<p>x:命令字符</p>\n<p>y:转义字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -e^oo</span><br></pre></td></tr></table></figure>\n<p>这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。</p>\n<p>曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。</p>\n<p>有了Screen,你就可以获得更好的使用终端多窗口的体验。</p>","more":"<p>我想你肯定遇到以下几种情况:</p>\n<ul>\n<li><p>ftp传输</p>\n</li>\n<li><p>系统备份</p>\n</li>\n<li><p>长时间运行任务</p>\n</li>\n</ul>\n<p>好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。</p>\n<h1 id=\"凶手-SIGHUP-信号\"><a href=\"#凶手-SIGHUP-信号\" class=\"headerlink\" title=\"凶手 SIGHUP 信号\"></a>凶手 SIGHUP 信号</h1><blockquote>\n<p>以下资料来自维基百科 </p>\n<blockquote>\n<p>SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p>\n</blockquote>\n</blockquote>\n<p>简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。</p>\n<h2 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h2><p>在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。</p>\n<ul>\n<li><p>Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。</p>\n</li>\n<li><p>Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。</p>\n</li>\n<li><p>Ctrl-\\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。</p>\n</li>\n</ul>\n<h2 id=\"前因后果\"><a href=\"#前因后果\" class=\"headerlink\" title=\"前因后果\"></a>前因后果</h2><p>相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。</p>\n<p><strong>更多有关SIGHUP信号的资料，我会在后面的文章进行更新。</strong></p>\n<hr>\n<h1 id=\"开始使用Screen\"><a href=\"#开始使用Screen\" class=\"headerlink\" title=\"开始使用Screen\"></a>开始使用Screen</h1><p>先简单说说什么是Screen:</p>\n<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。</p>\n<p>Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。</p>\n<p><strong>1.创建一个screen窗口</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen</span><br></pre></td></tr></table></figure>\n<p>这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。</p>\n<p><strong>2.创建窗口+执行命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim</span><br></pre></td></tr></table></figure>\n<p>screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。</p>\n<p><strong>3.一个窗口中再有一个窗口中再有一个窗口中…</strong></p>\n<p>你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。</p>\n<p><strong>4.screen的暂时断开(detach)和重新链接(attach)</strong></p>\n<p>比如在screen窗口下用vim编辑C++源文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen vim test.cpp</span><br></pre></td></tr></table></figure>\n<p>但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached).</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/detachedInfo.png\" alt=\"挂起提示\"></p>\n<p>当你做完其他事你就可以找回该会话，进行重新连接:</p>\n<p>找到会话</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -ls</span><br><span class=\"line\">There are screens on:</span><br><span class=\"line\">        17944.pts-4.EvanLinux   (Detached)</span><br><span class=\"line\">        14290.server    (Detached)</span><br><span class=\"line\">2 Sockets in /run/screens/S-evanmeek.</span><br></pre></td></tr></table></figure>\n<p>重新连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[evanmeek＠Evan-PC]# screen- r 17944</span><br></pre></td></tr></table></figure>\n<p>这样就可以恢复pts这个会话的窗口了．</p>\n<hr>\n<h1 id=\"配置你的Screen\"><a href=\"#配置你的Screen\" class=\"headerlink\" title=\"配置你的Screen\"></a>配置你的Screen</h1><p>前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符.</p>\n<p>可通过如下键绑定查看所有键绑定．</p>\n<p><strong>C-a ?</strong></p>\n<p>常用的键绑定有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">键绑定</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">C-a ?</td>\n<td style=\"text-align:center\">显示所有键绑定信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a w</td>\n<td style=\"text-align:center\">显示所有窗口列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a C-a</td>\n<td style=\"text-align:center\">切换到之前显示的窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a c</td>\n<td style=\"text-align:center\">创建一个新的运行shell的窗口并切换到该窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a n</td>\n<td style=\"text-align:center\">切换到下一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a p</td>\n<td style=\"text-align:center\">切换到前一个窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a 0~9</td>\n<td style=\"text-align:center\">切换到0~9窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a a</td>\n<td style=\"text-align:center\">发送C-a到当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a d</td>\n<td style=\"text-align:center\">暂时断开screen会话</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a k</td>\n<td style=\"text-align:center\">杀掉当前窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C-a [</td>\n<td style=\"text-align:center\">进入拷贝/回滚模式</td>\n</tr>\n</tbody>\n</table>\n<p>我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a;</p>\n<p><img src=\"/2019/05/09/终端多窗口神器——Screen/DefalutCommandKey.png\" alt=\"默认的命令字符\">;</p>\n<p>我们可以修改它，通过如下格式:</p>\n<p><strong>-exy</strong></p>\n<p>x:命令字符</p>\n<p>y:转义字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[evanmeek@Evan-PC]#</span> screen -e^oo</span><br></pre></td></tr></table></figure>\n<p>这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．</p>\n<hr>"},{"title":"C++函数探幽","date":"2019-04-23T22:38:43.000Z","copyright":true,"_content":"<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->\n<!--more-->\n\n**本章内容**\n- 内联函数\n- 引用变量\n- 如何按引用传递函数参数\n- 默认参数\n- 函数重载\n- 函数模板\n- 函数模板具体化\n\n本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．\n\n---\n\n## C++内联函数\n\n> ### **说明**\n\n内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．\n\n那么，我们现在就深入到程序内部．\n\n首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．\n\n当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．\n\n执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．\n\n那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．\n\n\n**所以**\n\nC++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．\n\n相当于编译器将使用相应的函数代码替换函数调用．\n\n对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．\n\n**但是**\n\n虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．\n\n**结论**\n\n我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．\n\n另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．\n\n_除非_　:该函数被经常调用\n\n> ### **使用**\n\n使用内联函数只需要做到以下两点即可：\n\n- 在函数声明前加上关键字**inline**;\n\n- 在函数定义前加上关键字**inline**;\n\n通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．\n\n**可能遇到的问题**\n\n在我们编写函数为内联函数时，编译器不一定满足这种要求．\n\n- 编译器认为该函数过大或识别到函数调用了自己 ***(内联函数不能递归)*** .\n\n- 有些编译器没有启动或实现这种特性．\n\n> ### **案例**\n\n~~~C++\n\n#include <iostream>\n\nusing namespace std;\n\ninline double square(double x) { return x * x; }\n\nint main() {\n    double a(2.0), b(5.0), c(0);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \" \\tc=\" << c << endl;\n    square(a);\n    b = square(b);\n    c = square(7 + 1);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \"\\tc=\" << c << endl;\n    return 0;\n}\n\n~~~\n\n该程序的输出为:\n\n~~~\n此时a=2\tb=5\tc=0\n此时a=4\tb=25\tc=64\n~~~\n\n看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．\n\n也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.\n\n**这使得C++的内联功能远远胜过C语言的宏定义**\n\n__尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.__\n\n__这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参__\n\n### 内联与宏\n\ninline是C++新增的特性.\n\nC语言使用预处理语句#define来提供宏－－内联代码的原始实现．\n\n例如下面这个例子.\n\n~~~C\n#define SQUARE(X) X*X\n\na = SQUARE(2.0);\nb = SQUARE(3.2++);\nc = SQUARE(1+2.3);\n~~~\n\n上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．\n\n---\n\n## 引用变量\n\n引用变量是C++新增的一种复合类型.\n\n引用是为已定义的变量创建了一个别名．\n\n例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.\n\n引用变量通常的使用场景是作为函数的形参．\n\n通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．\n\n---\n\n### 创建引用变量\n\nC++使用 **&** 用于声明引用，但是它还有另外一个作用：地址运算符。\n\n当&为声明引用时可有这样的一个例子:\n\n~~~C++\nint a;\nint & b = a;\n~~~\n\n是否感觉跟指针有点相像呢？\n\n是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&是指指向int的引用。\n\n上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。\n\n下面再看一个例子，你将懂得C++中使用&时引用和地址运算符的区别。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a=1;\n\tint & b = a;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n\tb = 2;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n        cout<<\"a-address:\"<<&a<<endl;\n        cout<<\"b-address:\"<<&b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:1\nb:1\na:2\nb:2\na-address:0x7ffdd4c4ae74\nb-address:0x7ffdd4c4ae74\n~~~\n\n首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。\n\n然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。\n\n再然后，我们输出的不是a和b的值了而是输出它们的地址:\n\n~~~C++\ncout<<\"a-address:\"<<&a<<endl;\n~~~\n\n此时的&代表的就是地址运算符。\n\n经过上面的一些小例子，读者们可能认为C++中&为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a,*p;\n\tint b,*p2(&b);\n\t*p = a;\n\treturn 0;\n}\n~~~\n\n上述代码是可以编译通过的。\n\n**指针在声明时编译器允许不为其进行初始化值**\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int a,&b;\n    b = a;\n    return 0;\n}\n~~~\n\n如果代码是这样，那么则编译不通过。\n\n**我们可以把引用看成cosnt指针**，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。\n\n也就是说：\n\n~~~C++\nint a,&b(a);\n~~~\n\n**仅在表示上等同于**\n\n~~~C++\nint a;\nconst int *p(&a);\n~~~\n\n上面提到“仅在表示上等同于“为什么呢，请看下面的例子。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a(10),&b(a);\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\tint c(20);\n\tb = c;\n\tcout<<\"c:\"<<c<<endl;\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:10\nb:10\nc:20\na:20\nb:20\n~~~\n\n可以看到最初b引用的是a，但随后b作为c的引用：\n\n~~~C++\nb = c;\n~~~\n\n**这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.**\n\n我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:\n\n~~~C++\na = c;\n~~~\n\n也就是说，这意味着”将c变量的值赋给a变量“。\n\n简而言之，**可以通过初始化声明来设置引用，但不能通过赋值来设置。**\n\n下面有一段有趣的代码，你们可以看看。\n\n~~~C++\nint a(10);\nint *p =&a;\nint &b = *p;\nint c(20);\n*p = &c;\n~~~\n\n上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。\n\n### 将\n","source":"_posts/C-函数探幽.md","raw":"---\ntitle: C++函数探幽\ndate: 2019-04-24 06:38:43\ncategories: 学习笔记\ntags:\n  - C++\n  - 编程\ncopyright: true\n---\n<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->\n<!--more-->\n\n**本章内容**\n- 内联函数\n- 引用变量\n- 如何按引用传递函数参数\n- 默认参数\n- 函数重载\n- 函数模板\n- 函数模板具体化\n\n本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．\n\n---\n\n## C++内联函数\n\n> ### **说明**\n\n内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．\n\n那么，我们现在就深入到程序内部．\n\n首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．\n\n当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．\n\n执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．\n\n那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．\n\n\n**所以**\n\nC++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．\n\n相当于编译器将使用相应的函数代码替换函数调用．\n\n对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．\n\n**但是**\n\n虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．\n\n**结论**\n\n我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．\n\n另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．\n\n_除非_　:该函数被经常调用\n\n> ### **使用**\n\n使用内联函数只需要做到以下两点即可：\n\n- 在函数声明前加上关键字**inline**;\n\n- 在函数定义前加上关键字**inline**;\n\n通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．\n\n**可能遇到的问题**\n\n在我们编写函数为内联函数时，编译器不一定满足这种要求．\n\n- 编译器认为该函数过大或识别到函数调用了自己 ***(内联函数不能递归)*** .\n\n- 有些编译器没有启动或实现这种特性．\n\n> ### **案例**\n\n~~~C++\n\n#include <iostream>\n\nusing namespace std;\n\ninline double square(double x) { return x * x; }\n\nint main() {\n    double a(2.0), b(5.0), c(0);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \" \\tc=\" << c << endl;\n    square(a);\n    b = square(b);\n    c = square(7 + 1);\n    cout << \"此时a=\" << a << \"\\tb=\" << b << \"\\tc=\" << c << endl;\n    return 0;\n}\n\n~~~\n\n该程序的输出为:\n\n~~~\n此时a=2\tb=5\tc=0\n此时a=4\tb=25\tc=64\n~~~\n\n看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．\n\n也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.\n\n**这使得C++的内联功能远远胜过C语言的宏定义**\n\n__尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.__\n\n__这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参__\n\n### 内联与宏\n\ninline是C++新增的特性.\n\nC语言使用预处理语句#define来提供宏－－内联代码的原始实现．\n\n例如下面这个例子.\n\n~~~C\n#define SQUARE(X) X*X\n\na = SQUARE(2.0);\nb = SQUARE(3.2++);\nc = SQUARE(1+2.3);\n~~~\n\n上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．\n\n---\n\n## 引用变量\n\n引用变量是C++新增的一种复合类型.\n\n引用是为已定义的变量创建了一个别名．\n\n例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.\n\n引用变量通常的使用场景是作为函数的形参．\n\n通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．\n\n---\n\n### 创建引用变量\n\nC++使用 **&** 用于声明引用，但是它还有另外一个作用：地址运算符。\n\n当&为声明引用时可有这样的一个例子:\n\n~~~C++\nint a;\nint & b = a;\n~~~\n\n是否感觉跟指针有点相像呢？\n\n是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&是指指向int的引用。\n\n上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。\n\n下面再看一个例子，你将懂得C++中使用&时引用和地址运算符的区别。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a=1;\n\tint & b = a;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n\tb = 2;\n\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\n        cout<<\"a-address:\"<<&a<<endl;\n        cout<<\"b-address:\"<<&b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:1\nb:1\na:2\nb:2\na-address:0x7ffdd4c4ae74\nb-address:0x7ffdd4c4ae74\n~~~\n\n首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。\n\n然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。\n\n再然后，我们输出的不是a和b的值了而是输出它们的地址:\n\n~~~C++\ncout<<\"a-address:\"<<&a<<endl;\n~~~\n\n此时的&代表的就是地址运算符。\n\n经过上面的一些小例子，读者们可能认为C++中&为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a,*p;\n\tint b,*p2(&b);\n\t*p = a;\n\treturn 0;\n}\n~~~\n\n上述代码是可以编译通过的。\n\n**指针在声明时编译器允许不为其进行初始化值**\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int a,&b;\n    b = a;\n    return 0;\n}\n~~~\n\n如果代码是这样，那么则编译不通过。\n\n**我们可以把引用看成cosnt指针**，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。\n\n也就是说：\n\n~~~C++\nint a,&b(a);\n~~~\n\n**仅在表示上等同于**\n\n~~~C++\nint a;\nconst int *p(&a);\n~~~\n\n上面提到“仅在表示上等同于“为什么呢，请看下面的例子。\n\n~~~C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint a(10),&b(a);\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\tint c(20);\n\tb = c;\n\tcout<<\"c:\"<<c<<endl;\n\tcout<<\"a:\"<<a<<endl;\n\tcout<<\"b:\"<<b<<endl;\n\treturn 0;\n}\n~~~\n\n输出结果为:\n\n~~~\na:10\nb:10\nc:20\na:20\nb:20\n~~~\n\n可以看到最初b引用的是a，但随后b作为c的引用：\n\n~~~C++\nb = c;\n~~~\n\n**这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.**\n\n我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:\n\n~~~C++\na = c;\n~~~\n\n也就是说，这意味着”将c变量的值赋给a变量“。\n\n简而言之，**可以通过初始化声明来设置引用，但不能通过赋值来设置。**\n\n下面有一段有趣的代码，你们可以看看。\n\n~~~C++\nint a(10);\nint *p =&a;\nint &b = *p;\nint c(20);\n*p = &c;\n~~~\n\n上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。\n\n### 将\n","slug":"C-函数探幽","published":1,"updated":"2019-05-09T14:55:10.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0spa210032xcvv3j5e1g2f","content":"<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->\n<a id=\"more\"></a>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>内联函数</li>\n<li>引用变量</li>\n<li>如何按引用传递函数参数</li>\n<li>默认参数</li>\n<li>函数重载</li>\n<li>函数模板</li>\n<li>函数模板具体化</li>\n</ul>\n<p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p>\n<hr>\n<h2 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h2><blockquote>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3></blockquote>\n<p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p>\n<p>那么，我们现在就深入到程序内部．</p>\n<p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p>\n<p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p>\n<p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p>\n<p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p>\n<p><strong>所以</strong></p>\n<p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p>\n<p>相当于编译器将使用相应的函数代码替换函数调用．</p>\n<p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p>\n<p><strong>但是</strong></p>\n<p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p>\n<p><strong>结论</strong></p>\n<p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p>\n<p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p>\n<p>_除非_　:该函数被经常调用</p>\n<blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h3></blockquote>\n<p>使用内联函数只需要做到以下两点即可：</p>\n<ul>\n<li><p>在函数声明前加上关键字<strong>inline</strong>;</p>\n</li>\n<li><p>在函数定义前加上关键字<strong>inline</strong>;</p>\n</li>\n</ul>\n<p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p>\n<p><strong>可能遇到的问题</strong></p>\n<p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p>\n<ul>\n<li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p>\n</li>\n<li><p>有些编译器没有启动或实现这种特性．</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a><strong>案例</strong></h3></blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    double a(2.0), b(5.0), c(0);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\" \\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    square(a);</span><br><span class=\"line\">    b = square(b);</span><br><span class=\"line\">    c = square(<span class=\"number\">7</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\"\\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该程序的输出为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">此时a=2\tb=5\tc=0</span><br><span class=\"line\">此时a=4\tb=25\tc=64</span><br></pre></td></tr></table></figure>\n<p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p>\n<p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p>\n<p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p>\n<p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p>\n<p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p>\n<h3 id=\"内联与宏\"><a href=\"#内联与宏\" class=\"headerlink\" title=\"内联与宏\"></a>内联与宏</h3><p>inline是C++新增的特性.</p>\n<p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p>\n<p>例如下面这个例子.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SQUARE(X) X*X</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = SQUARE(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">b = SQUARE(<span class=\"number\">3.2</span>++);</span><br><span class=\"line\">c = SQUARE(<span class=\"number\">1</span>+<span class=\"number\">2.3</span>);</span><br></pre></td></tr></table></figure>\n<p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p>\n<hr>\n<h2 id=\"引用变量\"><a href=\"#引用变量\" class=\"headerlink\" title=\"引用变量\"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p>\n<p>引用是为已定义的变量创建了一个别名．</p>\n<p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p>\n<p>引用变量通常的使用场景是作为函数的形参．</p>\n<p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p>\n<hr>\n<h3 id=\"创建引用变量\"><a href=\"#创建引用变量\" class=\"headerlink\" title=\"创建引用变量\"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p>\n<p>当&amp;为声明引用时可有这样的一个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure>\n<p>是否感觉跟指针有点相像呢？</p>\n<p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p>\n<p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p>\n<p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp; b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b-address:\"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:1</span><br><span class=\"line\">b:1</span><br><span class=\"line\">a:2</span><br><span class=\"line\">b:2</span><br><span class=\"line\">a-address:0x7ffdd4c4ae74</span><br><span class=\"line\">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure>\n<p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p>\n<p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p>\n<p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>此时的&amp;代表的就是地址运算符。</p>\n<p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a,*p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b,*p2(&amp;b);</span><br><span class=\"line\">\t*p = a;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是可以编译通过的。</p>\n<p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,&amp;b;</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果代码是这样，那么则编译不通过。</p>\n<p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p>\n<p>也就是说：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure>\n<p><strong>仅在表示上等同于</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"title\">p</span><span class=\"params\">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tint a(10),&amp;b(a);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">\tb = c;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"c:\"</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:10</span><br><span class=\"line\">b:10</span><br><span class=\"line\">c:20</span><br><span class=\"line\">a:20</span><br><span class=\"line\">b:20</span><br></pre></td></tr></table></figure>\n<p>可以看到最初b引用的是a，但随后b作为c的引用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = c;</span><br></pre></td></tr></table></figure>\n<p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p>\n<p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = c;</span><br></pre></td></tr></table></figure>\n<p>也就是说，这意味着”将c变量的值赋给a变量“。</p>\n<p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p>\n<p>下面有一段有趣的代码，你们可以看看。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p =&amp;a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;b = *p;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">*p = &amp;c;</span><br></pre></td></tr></table></figure>\n<p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p>\n<h3 id=\"将\"><a href=\"#将\" class=\"headerlink\" title=\"将\"></a>将</h3>","site":{"data":{}},"excerpt":"<!--\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=544070223&auto=1&height=66\"></iframe>\n-->","more":"<p><strong>本章内容</strong></p>\n<ul>\n<li>内联函数</li>\n<li>引用变量</li>\n<li>如何按引用传递函数参数</li>\n<li>默认参数</li>\n<li>函数重载</li>\n<li>函数模板</li>\n<li>函数模板具体化</li>\n</ul>\n<p>本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步．</p>\n<hr>\n<h2 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h2><blockquote>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3></blockquote>\n<p>内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部．</p>\n<p>那么，我们现在就深入到程序内部．</p>\n<p>首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成．</p>\n<p>当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令．</p>\n<p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处．</p>\n<p>那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销．</p>\n<p><strong>所以</strong></p>\n<p>C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来．</p>\n<p>相当于编译器将使用相应的函数代码替换函数调用．</p>\n<p>对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销．</p>\n<p><strong>但是</strong></p>\n<p>虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快．</p>\n<p><strong>结论</strong></p>\n<p>我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间．</p>\n<p>另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大．</p>\n<p>_除非_　:该函数被经常调用</p>\n<blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h3></blockquote>\n<p>使用内联函数只需要做到以下两点即可：</p>\n<ul>\n<li><p>在函数声明前加上关键字<strong>inline</strong>;</p>\n</li>\n<li><p>在函数定义前加上关键字<strong>inline</strong>;</p>\n</li>\n</ul>\n<p>通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方．</p>\n<p><strong>可能遇到的问题</strong></p>\n<p>在我们编写函数为内联函数时，编译器不一定满足这种要求．</p>\n<ul>\n<li><p>编译器认为该函数过大或识别到函数调用了自己 <strong><em>(内联函数不能递归)</em></strong> .</p>\n</li>\n<li><p>有些编译器没有启动或实现这种特性．</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a><strong>案例</strong></h3></blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    double a(2.0), b(5.0), c(0);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\" \\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    square(a);</span><br><span class=\"line\">    b = square(b);</span><br><span class=\"line\">    c = square(<span class=\"number\">7</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"此时a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\"\\tb=\"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\"\\tc=\"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该程序的输出为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">此时a=2\tb=5\tc=0</span><br><span class=\"line\">此时a=4\tb=25\tc=64</span><br></pre></td></tr></table></figure>\n<p>看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的．</p>\n<p>也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递.</p>\n<p><strong>这使得C++的内联功能远远胜过C语言的宏定义</strong></p>\n<p><strong>尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型.</strong></p>\n<p><strong>这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参</strong></p>\n<h3 id=\"内联与宏\"><a href=\"#内联与宏\" class=\"headerlink\" title=\"内联与宏\"></a>内联与宏</h3><p>inline是C++新增的特性.</p>\n<p>C语言使用预处理语句#define来提供宏－－内联代码的原始实现．</p>\n<p>例如下面这个例子.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SQUARE(X) X*X</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = SQUARE(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">b = SQUARE(<span class=\"number\">3.2</span>++);</span><br><span class=\"line\">c = SQUARE(<span class=\"number\">1</span>+<span class=\"number\">2.3</span>);</span><br></pre></td></tr></table></figure>\n<p>上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的．</p>\n<hr>\n<h2 id=\"引用变量\"><a href=\"#引用变量\" class=\"headerlink\" title=\"引用变量\"></a>引用变量</h2><p>引用变量是C++新增的一种复合类型.</p>\n<p>引用是为已定义的变量创建了一个别名．</p>\n<p>例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同.</p>\n<p>引用变量通常的使用场景是作为函数的形参．</p>\n<p>通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径．</p>\n<hr>\n<h3 id=\"创建引用变量\"><a href=\"#创建引用变量\" class=\"headerlink\" title=\"创建引用变量\"></a>创建引用变量</h3><p>C++使用 <strong>&amp;</strong> 用于声明引用，但是它还有另外一个作用：地址运算符。</p>\n<p>当&amp;为声明引用时可有这样的一个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure>\n<p>是否感觉跟指针有点相像呢？</p>\n<p>是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。</p>\n<p>上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。</p>\n<p>下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp; b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b-address:\"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:1</span><br><span class=\"line\">b:1</span><br><span class=\"line\">a:2</span><br><span class=\"line\">b:2</span><br><span class=\"line\">a-address:0x7ffdd4c4ae74</span><br><span class=\"line\">b-address:0x7ffdd4c4ae74</span><br></pre></td></tr></table></figure>\n<p>首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。</p>\n<p>然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。</p>\n<p>再然后，我们输出的不是a和b的值了而是输出它们的地址:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a-address:\"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>此时的&amp;代表的就是地址运算符。</p>\n<p>经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a,*p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b,*p2(&amp;b);</span><br><span class=\"line\">\t*p = a;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是可以编译通过的。</p>\n<p><strong>指针在声明时编译器允许不为其进行初始化值</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,&amp;b;</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果代码是这样，那么则编译不通过。</p>\n<p><strong>我们可以把引用看成cosnt指针</strong>，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。</p>\n<p>也就是说：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,&amp;b(a);</span><br></pre></td></tr></table></figure>\n<p><strong>仅在表示上等同于</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"title\">p</span><span class=\"params\">(&amp;a)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>上面提到“仅在表示上等同于“为什么呢，请看下面的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tint a(10),&amp;b(a);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">\tb = c;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"c:\"</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"a:\"</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"b:\"</span>&lt;&lt;b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:10</span><br><span class=\"line\">b:10</span><br><span class=\"line\">c:20</span><br><span class=\"line\">a:20</span><br><span class=\"line\">b:20</span><br></pre></td></tr></table></figure>\n<p>可以看到最初b引用的是a，但随后b作为c的引用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = c;</span><br></pre></td></tr></table></figure>\n<p><strong>这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的.</strong></p>\n<p>我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = c;</span><br></pre></td></tr></table></figure>\n<p>也就是说，这意味着”将c变量的值赋给a变量“。</p>\n<p>简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p>\n<p>下面有一段有趣的代码，你们可以看看。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p =&amp;a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;b = *p;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">*p = &amp;c;</span><br></pre></td></tr></table></figure>\n<p>上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。</p>\n<h3 id=\"将\"><a href=\"#将\" class=\"headerlink\" title=\"将\"></a>将</h3>"},{"title":"C++读写文件","copyright":true,"date":"2019-05-22T03:20:45.000Z","_content":"\n一些简单的读写文件的操作。\n\n<!--more-->\n\n**本篇文章使用C++```fstream```头文件提供的库函数进行读写操作**\n\n\n> 请引入#include \\<fstream\\>进行下面的操作。\n\n# **写入**\n\n写入文件步骤如下:\n\n1. 实例化ofstream对象，或者fstream对象.\n\n    > ofstream ofs;\n2. 打开文件流\n    \n    > ofs.open(const std::string &__s,ios_base::open__mode=ios_base::out);\n\n3. 写入文件\n\n    > ofs<<;\n\n4. 关闭文件流\n\n    > ofs.close();\n\n**注意打开文件流函数的参数分别为`路径`和`打开方式`.**\n\n常用的打开方式如下:\n\n|模式标识|适用对象|描述|\n|:-:|:-----:|:-:|\n|ios::int|ifstream,fstream|打开输入,默认用于`ifstream`和`fstream`|\n|ios::out|ofstream,fstream|打开输出，默认用于`ofstream`和`fstream`|\n|ios::trunc|ofstream|打开输入，默认用户`ofstream`|\n|ios::ate|ifstream|打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错|\n|ios::app|ostream,fstream|打开输出，并且将数据输出至文件末尾，相当与追加|\n|iso::binary|ifstream,ofstream,fstream|以二进制的方式打开文件，进行输入或输出|\n\n以上所有的打开方式可以通过或`|`运算符进行联合使用，例如:\n\n~~~C++\n//以二进制的方式打开输出\nofstream ofs(path,ios::out|ios::binary);\n~~~\n\n**不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作**\n\n好的，下面可以看例子了，我们将写入一些数据到一个文件内。\n\n## **以文本写入**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n~~~C++\n/**\n * 写入文件\n * @param path 文件路径\n * @param context 内容\n */\nvoid writeFile(string path,string context){\n    //实例化写入对象\n    ofstream ofs;\n    //打开输出\n    ofs.open(path,ios::out);\n    //向文件写入数据\n    ofs<<context<<endl;\n    //关闭输出\n    ofs.close();\n}\n\nint main(){\n    //调用\n    writeFile(\"./test.txt\",\"测试\");\n}\n~~~\n\n这样我们就将`测试`这个段文本信息，写入到当前目录下`test.txt`文件内了.\n\n## **以二进制文件写入**\n\n\n以二进制文件方式写入，C++提供了`write()`库函数,它的函数原型是:\n\n> `write(const _CharT* __s, streamsize __n);`\n\n其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。\n\n~~~C++\nclass Student {\nprivate:\n    char name[64];\n    int age;\npublic:\n    Student(char name[64], int age) {\n        for (int i = 0; i < sizeof(name); ++i)\n            this->name[i] = name[i];\n        this->age = age;\n    }\n};`\n/**\n * 写入二进制文件\n * @param path \n */\nvoid writeFileByBinary(string path) {\n    //创建输出流对象，并且指定路径和文件打开方式\n    ofstream ofs(path, ios::out | ios::binary);\n    Student *student = new Student(\"张三\", 18);\n\n    //写入文件\n    ofs.write((const char *) student, sizeof(Student));\n\n    ofs.close();\n\n    delete (student);\n}\nint main(){\n    writeFileByBinary(\"student.bin\");\n}\n~~~\n\n这里我们将类成员属性的值以二进制的方式写入进一个文件内。\n\n最终文件内的内容人类是看不大懂的。\n\n![二进制写](C-读写文件/二进制文件.png)\n\n**注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.**\n\n# **读取**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n## **以文本文件读取**\n\n读取有很多种方式，下面将会演示三种，分别是:\n\n- 逐行读取\n\n- 逐词读取\n\n- 逐字符读取\n\n---\n\n### **逐字符读取(不推荐)**\n\n**逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。**\n\n~~~C++\n/**\n * 逐字符读取\n * @param path 路径\n */\nvoid readFile04(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储变量\n    char cbuffer;\n    //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.\n    while ((cbuffer = ifs.get()) != EOF) {\n        cout << cbuffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n```EOF```代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。\n\n### **逐行读取(有两种方式，但都是逐行读取)**\n\n第一种：\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile02(string path) {\n    //实例化\n    fstream fs;\n    //打开文件\n    fs.open(path, ios::in);\n    //用字符数组进行缓存\n    char buffer[1024] = {0};\n    //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)\n    while (fs.getline(buffer, sizeof(buffer))) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    fs.close();\n}\n~~~\n\n使用`字符数组`作为数据存储容器，用`fstream`对象的`getline()`函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用`sizeof()`是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。\n\n第二种:\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile03(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储容器\n    string buffer;\n    //使用全局函数getline(输入流，可存储的容器)进行逐行读取\n    while (getline(ifs, buffer)) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数`getline(输入对象,数据存储容器)`,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。\n\n### **逐词读取(以空格区分)**\n\n逐词读取，将会已空格进行区分每个词汇，再读取。\n\n~~~C++\n/**\n * 逐词读取文件\n * @param path 文件路径\n */\nvoid readFile01(string path) {\n    //实例化读取文件对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //判断文件是否能打开\n    if (!ifs.is_open()) {\n        cout << \"文件打开失败!\" << endl;\n        return;\n    }\n    //字符数组缓存\n    char buffer[1024] = {0};\n    //将读取的数据放入缓存区\n    while (ifs >> buffer)\n        cout << buffer << endl;\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。\n\n这种逐词读取的方式是`读取对象`通过`右移运算符`把读取的数据存入容器之中，但是是以空格区分每个词汇。\n\n## **以二进制的方式读取**\n\n前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。\n\n\n~~~C++\n/**\n * 以二进制的方式读取文件\n * @param path 路径\n */\nvoid readFileByBinary(string path) {\n    //创建输入流对象，并且指定路径和文件打开方式\n    ifstream ifs(path, ios::in | ios::binary);\n    char * c = new char[64];\n    ifs.read(c, sizeof(c));\n    cout<<c<<endl;\n}\nint main(){\n    readFileByBinary(\"Student.smi\");\n}\n~~~\n\n输出结果:\n\n~~~\n张三\n\nProcess finished with exit code 0\n~~~\n\n这里我们将`Student.smi`这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。\n\n# **总结**\n\n读取文件创建`ifstream`对象,写入文件创建`ofstream`对象，`fstream`对象既可以读又可以写。\n\n操作文件得先`打开文件`\n\n操作文件完毕得`关闭文件`\n\n二进制文件读取需要读取二进制格式的文件\n","source":"_posts/C-读写文件.md","raw":"---\ntitle: C++读写文件\ncopyright: true\ndate: 2019-05-22 11:20:45\ncategories: 学习笔记\ntags:\n - C++\n---\n\n一些简单的读写文件的操作。\n\n<!--more-->\n\n**本篇文章使用C++```fstream```头文件提供的库函数进行读写操作**\n\n\n> 请引入#include \\<fstream\\>进行下面的操作。\n\n# **写入**\n\n写入文件步骤如下:\n\n1. 实例化ofstream对象，或者fstream对象.\n\n    > ofstream ofs;\n2. 打开文件流\n    \n    > ofs.open(const std::string &__s,ios_base::open__mode=ios_base::out);\n\n3. 写入文件\n\n    > ofs<<;\n\n4. 关闭文件流\n\n    > ofs.close();\n\n**注意打开文件流函数的参数分别为`路径`和`打开方式`.**\n\n常用的打开方式如下:\n\n|模式标识|适用对象|描述|\n|:-:|:-----:|:-:|\n|ios::int|ifstream,fstream|打开输入,默认用于`ifstream`和`fstream`|\n|ios::out|ofstream,fstream|打开输出，默认用于`ofstream`和`fstream`|\n|ios::trunc|ofstream|打开输入，默认用户`ofstream`|\n|ios::ate|ifstream|打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错|\n|ios::app|ostream,fstream|打开输出，并且将数据输出至文件末尾，相当与追加|\n|iso::binary|ifstream,ofstream,fstream|以二进制的方式打开文件，进行输入或输出|\n\n以上所有的打开方式可以通过或`|`运算符进行联合使用，例如:\n\n~~~C++\n//以二进制的方式打开输出\nofstream ofs(path,ios::out|ios::binary);\n~~~\n\n**不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作**\n\n好的，下面可以看例子了，我们将写入一些数据到一个文件内。\n\n## **以文本写入**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n~~~C++\n/**\n * 写入文件\n * @param path 文件路径\n * @param context 内容\n */\nvoid writeFile(string path,string context){\n    //实例化写入对象\n    ofstream ofs;\n    //打开输出\n    ofs.open(path,ios::out);\n    //向文件写入数据\n    ofs<<context<<endl;\n    //关闭输出\n    ofs.close();\n}\n\nint main(){\n    //调用\n    writeFile(\"./test.txt\",\"测试\");\n}\n~~~\n\n这样我们就将`测试`这个段文本信息，写入到当前目录下`test.txt`文件内了.\n\n## **以二进制文件写入**\n\n\n以二进制文件方式写入，C++提供了`write()`库函数,它的函数原型是:\n\n> `write(const _CharT* __s, streamsize __n);`\n\n其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。\n\n~~~C++\nclass Student {\nprivate:\n    char name[64];\n    int age;\npublic:\n    Student(char name[64], int age) {\n        for (int i = 0; i < sizeof(name); ++i)\n            this->name[i] = name[i];\n        this->age = age;\n    }\n};`\n/**\n * 写入二进制文件\n * @param path \n */\nvoid writeFileByBinary(string path) {\n    //创建输出流对象，并且指定路径和文件打开方式\n    ofstream ofs(path, ios::out | ios::binary);\n    Student *student = new Student(\"张三\", 18);\n\n    //写入文件\n    ofs.write((const char *) student, sizeof(Student));\n\n    ofs.close();\n\n    delete (student);\n}\nint main(){\n    writeFileByBinary(\"student.bin\");\n}\n~~~\n\n这里我们将类成员属性的值以二进制的方式写入进一个文件内。\n\n最终文件内的内容人类是看不大懂的。\n\n![二进制写](C-读写文件/二进制文件.png)\n\n**注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.**\n\n# **读取**\n\n> 下面将读取两种不同类型的文件以作为案例进行讲解。\n\n## **以文本文件读取**\n\n读取有很多种方式，下面将会演示三种，分别是:\n\n- 逐行读取\n\n- 逐词读取\n\n- 逐字符读取\n\n---\n\n### **逐字符读取(不推荐)**\n\n**逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。**\n\n~~~C++\n/**\n * 逐字符读取\n * @param path 路径\n */\nvoid readFile04(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储变量\n    char cbuffer;\n    //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.\n    while ((cbuffer = ifs.get()) != EOF) {\n        cout << cbuffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n```EOF```代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。\n\n### **逐行读取(有两种方式，但都是逐行读取)**\n\n第一种：\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile02(string path) {\n    //实例化\n    fstream fs;\n    //打开文件\n    fs.open(path, ios::in);\n    //用字符数组进行缓存\n    char buffer[1024] = {0};\n    //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)\n    while (fs.getline(buffer, sizeof(buffer))) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    fs.close();\n}\n~~~\n\n使用`字符数组`作为数据存储容器，用`fstream`对象的`getline()`函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用`sizeof()`是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。\n\n第二种:\n\n~~~C++\n/**\n * 逐行读取\n * @param path 路径\n */\nvoid readFile03(string path) {\n    //实例化读取操作对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //数据存储容器\n    string buffer;\n    //使用全局函数getline(输入流，可存储的容器)进行逐行读取\n    while (getline(ifs, buffer)) {\n        cout << buffer << endl;\n    }\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数`getline(输入对象,数据存储容器)`,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。\n\n### **逐词读取(以空格区分)**\n\n逐词读取，将会已空格进行区分每个词汇，再读取。\n\n~~~C++\n/**\n * 逐词读取文件\n * @param path 文件路径\n */\nvoid readFile01(string path) {\n    //实例化读取文件对象\n    ifstream ifs;\n    //打开文件\n    ifs.open(path, ios::in);\n    //判断文件是否能打开\n    if (!ifs.is_open()) {\n        cout << \"文件打开失败!\" << endl;\n        return;\n    }\n    //字符数组缓存\n    char buffer[1024] = {0};\n    //将读取的数据放入缓存区\n    while (ifs >> buffer)\n        cout << buffer << endl;\n    //关闭文件\n    ifs.close();\n}\n~~~\n\n这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。\n\n这种逐词读取的方式是`读取对象`通过`右移运算符`把读取的数据存入容器之中，但是是以空格区分每个词汇。\n\n## **以二进制的方式读取**\n\n前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。\n\n\n~~~C++\n/**\n * 以二进制的方式读取文件\n * @param path 路径\n */\nvoid readFileByBinary(string path) {\n    //创建输入流对象，并且指定路径和文件打开方式\n    ifstream ifs(path, ios::in | ios::binary);\n    char * c = new char[64];\n    ifs.read(c, sizeof(c));\n    cout<<c<<endl;\n}\nint main(){\n    readFileByBinary(\"Student.smi\");\n}\n~~~\n\n输出结果:\n\n~~~\n张三\n\nProcess finished with exit code 0\n~~~\n\n这里我们将`Student.smi`这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。\n\n# **总结**\n\n读取文件创建`ifstream`对象,写入文件创建`ofstream`对象，`fstream`对象既可以读又可以写。\n\n操作文件得先`打开文件`\n\n操作文件完毕得`关闭文件`\n\n二进制文件读取需要读取二进制格式的文件\n","slug":"C-读写文件","published":1,"updated":"2019-05-23T15:12:22.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw0spa230033xcvvs7j89pjb","content":"<p>一些简单的读写文件的操作。</p>\n<a id=\"more\"></a>\n<p><strong>本篇文章使用C++<code>fstream</code>头文件提供的库函数进行读写操作</strong></p>\n<blockquote>\n<p>请引入#include \\&lt;fstream>进行下面的操作。</p>\n</blockquote>\n<h1 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a><strong>写入</strong></h1><p>写入文件步骤如下:</p>\n<ol>\n<li><p>实例化ofstream对象，或者fstream对象.</p>\n<blockquote>\n<p>ofstream ofs;</p>\n</blockquote>\n</li>\n<li><p>打开文件流</p>\n<blockquote>\n<p>ofs.open(const std::string &amp;<strong>s,ios_base::open</strong>mode=ios_base::out);</p>\n</blockquote>\n</li>\n<li><p>写入文件</p>\n<blockquote>\n<p>ofs&lt;&lt;;</p>\n</blockquote>\n</li>\n<li><p>关闭文件流</p>\n<blockquote>\n<p>ofs.close();</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>注意打开文件流函数的参数分别为<code>路径</code>和<code>打开方式</code>.</strong></p>\n<p>常用的打开方式如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模式标识</th>\n<th style=\"text-align:center\">适用对象</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ios::int</td>\n<td style=\"text-align:center\">ifstream,fstream</td>\n<td style=\"text-align:center\">打开输入,默认用于<code>ifstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::out</td>\n<td style=\"text-align:center\">ofstream,fstream</td>\n<td style=\"text-align:center\">打开输出，默认用于<code>ofstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::trunc</td>\n<td style=\"text-align:center\">ofstream</td>\n<td style=\"text-align:center\">打开输入，默认用户<code>ofstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::ate</td>\n<td style=\"text-align:center\">ifstream</td>\n<td style=\"text-align:center\">打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::app</td>\n<td style=\"text-align:center\">ostream,fstream</td>\n<td style=\"text-align:center\">打开输出，并且将数据输出至文件末尾，相当与追加</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iso::binary</td>\n<td style=\"text-align:center\">ifstream,ofstream,fstream</td>\n<td style=\"text-align:center\">以二进制的方式打开文件，进行输入或输出</td>\n</tr>\n</tbody>\n</table>\n<p>以上所有的打开方式可以通过或<code>|</code>运算符进行联合使用，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以二进制的方式打开输出</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作</strong></p>\n<p>好的，下面可以看例子了，我们将写入一些数据到一个文件内。</p>\n<h2 id=\"以文本写入\"><a href=\"#以文本写入\" class=\"headerlink\" title=\"以文本写入\"></a><strong>以文本写入</strong></h2><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> * @param context 内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(<span class=\"built_in\">string</span> path,<span class=\"built_in\">string</span> context)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化写入对象</span></span><br><span class=\"line\">    ofstream ofs;</span><br><span class=\"line\">    <span class=\"comment\">//打开输出</span></span><br><span class=\"line\">    ofs.open(path,ios::out);</span><br><span class=\"line\">    <span class=\"comment\">//向文件写入数据</span></span><br><span class=\"line\">    ofs&lt;&lt;context&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭输出</span></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用</span></span><br><span class=\"line\">    writeFile(<span class=\"string\">\"./test.txt\"</span>,<span class=\"string\">\"测试\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就将<code>测试</code>这个段文本信息，写入到当前目录下<code>test.txt</code>文件内了.</p>\n<h2 id=\"以二进制文件写入\"><a href=\"#以二进制文件写入\" class=\"headerlink\" title=\"以二进制文件写入\"></a><strong>以二进制文件写入</strong></h2><p>以二进制文件方式写入，C++提供了<code>write()</code>库函数,它的函数原型是:</p>\n<blockquote>\n<p><code>write(const _CharT* __s, streamsize __n);</code></p>\n</blockquote>\n<p>其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Student(<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>], <span class=\"keyword\">int</span> age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(name); ++i)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;name[i] = name[i];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;`</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入二进制文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输出流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path, ios::out | ios::binary)</span></span>;</span><br><span class=\"line\">    Student *student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"张三\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//写入文件</span></span><br><span class=\"line\">    ofs.write((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *) student, <span class=\"keyword\">sizeof</span>(Student));</span><br><span class=\"line\"></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> (student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    writeFileByBinary(<span class=\"string\">\"student.bin\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们将类成员属性的值以二进制的方式写入进一个文件内。</p>\n<p>最终文件内的内容人类是看不大懂的。</p>\n<p><img src=\"/2019/05/22/C-读写文件/二进制文件.png\" alt=\"二进制写\"></p>\n<p><strong>注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.</strong></p>\n<h1 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a><strong>读取</strong></h1><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<h2 id=\"以文本文件读取\"><a href=\"#以文本文件读取\" class=\"headerlink\" title=\"以文本文件读取\"></a><strong>以文本文件读取</strong></h2><p>读取有很多种方式，下面将会演示三种，分别是:</p>\n<ul>\n<li><p>逐行读取</p>\n</li>\n<li><p>逐词读取</p>\n</li>\n<li><p>逐字符读取</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"逐字符读取-不推荐\"><a href=\"#逐字符读取-不推荐\" class=\"headerlink\" title=\"逐字符读取(不推荐)\"></a><strong>逐字符读取(不推荐)</strong></h3><p><strong>逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐字符读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile04</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储变量</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> cbuffer;</span><br><span class=\"line\">    <span class=\"comment\">//逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((cbuffer = ifs.get()) != EOF) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; cbuffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>EOF</code>代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。</p>\n<h3 id=\"逐行读取-有两种方式，但都是逐行读取\"><a href=\"#逐行读取-有两种方式，但都是逐行读取\" class=\"headerlink\" title=\"逐行读取(有两种方式，但都是逐行读取)\"></a><strong>逐行读取(有两种方式，但都是逐行读取)</strong></h3><p>第一种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile02</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化</span></span><br><span class=\"line\">    fstream fs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    fs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//用字符数组进行缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fs.getline(buffer, <span class=\"keyword\">sizeof</span>(buffer))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    fs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>字符数组</code>作为数据存储容器，用<code>fstream</code>对象的<code>getline()</code>函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用<code>sizeof()</code>是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。</p>\n<p>第二种:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile03</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储容器</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> buffer;</span><br><span class=\"line\">    <span class=\"comment\">//使用全局函数getline(输入流，可存储的容器)进行逐行读取</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getline(ifs, buffer)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数<code>getline(输入对象,数据存储容器)</code>,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。</p>\n<h3 id=\"逐词读取-以空格区分\"><a href=\"#逐词读取-以空格区分\" class=\"headerlink\" title=\"逐词读取(以空格区分)\"></a><strong>逐词读取(以空格区分)</strong></h3><p>逐词读取，将会已空格进行区分每个词汇，再读取。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐词读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile01</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取文件对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//判断文件是否能打开</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ifs.is_open()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"文件打开失败!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//字符数组缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//将读取的数据放入缓存区</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ifs &gt;&gt; buffer)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。</p>\n<p>这种逐词读取的方式是<code>读取对象</code>通过<code>右移运算符</code>把读取的数据存入容器之中，但是是以空格区分每个词汇。</p>\n<h2 id=\"以二进制的方式读取\"><a href=\"#以二进制的方式读取\" class=\"headerlink\" title=\"以二进制的方式读取\"></a><strong>以二进制的方式读取</strong></h2><p>前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 以二进制的方式读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输入流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(path, ios::in | ios::binary)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>];</span><br><span class=\"line\">    ifs.read(c, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    readFileByBinary(<span class=\"string\">\"Student.smi\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">张三</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>这里我们将<code>Student.smi</code>这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>读取文件创建<code>ifstream</code>对象,写入文件创建<code>ofstream</code>对象，<code>fstream</code>对象既可以读又可以写。</p>\n<p>操作文件得先<code>打开文件</code></p>\n<p>操作文件完毕得<code>关闭文件</code></p>\n<p>二进制文件读取需要读取二进制格式的文件</p>\n","site":{"data":{}},"excerpt":"<p>一些简单的读写文件的操作。</p>","more":"<p><strong>本篇文章使用C++<code>fstream</code>头文件提供的库函数进行读写操作</strong></p>\n<blockquote>\n<p>请引入#include \\&lt;fstream>进行下面的操作。</p>\n</blockquote>\n<h1 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a><strong>写入</strong></h1><p>写入文件步骤如下:</p>\n<ol>\n<li><p>实例化ofstream对象，或者fstream对象.</p>\n<blockquote>\n<p>ofstream ofs;</p>\n</blockquote>\n</li>\n<li><p>打开文件流</p>\n<blockquote>\n<p>ofs.open(const std::string &amp;<strong>s,ios_base::open</strong>mode=ios_base::out);</p>\n</blockquote>\n</li>\n<li><p>写入文件</p>\n<blockquote>\n<p>ofs&lt;&lt;;</p>\n</blockquote>\n</li>\n<li><p>关闭文件流</p>\n<blockquote>\n<p>ofs.close();</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>注意打开文件流函数的参数分别为<code>路径</code>和<code>打开方式</code>.</strong></p>\n<p>常用的打开方式如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模式标识</th>\n<th style=\"text-align:center\">适用对象</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ios::int</td>\n<td style=\"text-align:center\">ifstream,fstream</td>\n<td style=\"text-align:center\">打开输入,默认用于<code>ifstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::out</td>\n<td style=\"text-align:center\">ofstream,fstream</td>\n<td style=\"text-align:center\">打开输出，默认用于<code>ofstream</code>和<code>fstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::trunc</td>\n<td style=\"text-align:center\">ofstream</td>\n<td style=\"text-align:center\">打开输入，默认用户<code>ofstream</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::ate</td>\n<td style=\"text-align:center\">ifstream</td>\n<td style=\"text-align:center\">打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ios::app</td>\n<td style=\"text-align:center\">ostream,fstream</td>\n<td style=\"text-align:center\">打开输出，并且将数据输出至文件末尾，相当与追加</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iso::binary</td>\n<td style=\"text-align:center\">ifstream,ofstream,fstream</td>\n<td style=\"text-align:center\">以二进制的方式打开文件，进行输入或输出</td>\n</tr>\n</tbody>\n</table>\n<p>以上所有的打开方式可以通过或<code>|</code>运算符进行联合使用，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以二进制的方式打开输出</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作</strong></p>\n<p>好的，下面可以看例子了，我们将写入一些数据到一个文件内。</p>\n<h2 id=\"以文本写入\"><a href=\"#以文本写入\" class=\"headerlink\" title=\"以文本写入\"></a><strong>以文本写入</strong></h2><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> * @param context 内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(<span class=\"built_in\">string</span> path,<span class=\"built_in\">string</span> context)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化写入对象</span></span><br><span class=\"line\">    ofstream ofs;</span><br><span class=\"line\">    <span class=\"comment\">//打开输出</span></span><br><span class=\"line\">    ofs.open(path,ios::out);</span><br><span class=\"line\">    <span class=\"comment\">//向文件写入数据</span></span><br><span class=\"line\">    ofs&lt;&lt;context&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭输出</span></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用</span></span><br><span class=\"line\">    writeFile(<span class=\"string\">\"./test.txt\"</span>,<span class=\"string\">\"测试\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就将<code>测试</code>这个段文本信息，写入到当前目录下<code>test.txt</code>文件内了.</p>\n<h2 id=\"以二进制文件写入\"><a href=\"#以二进制文件写入\" class=\"headerlink\" title=\"以二进制文件写入\"></a><strong>以二进制文件写入</strong></h2><p>以二进制文件方式写入，C++提供了<code>write()</code>库函数,它的函数原型是:</p>\n<blockquote>\n<p><code>write(const _CharT* __s, streamsize __n);</code></p>\n</blockquote>\n<p>其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Student(<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>], <span class=\"keyword\">int</span> age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(name); ++i)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;name[i] = name[i];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;`</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 写入二进制文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writeFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输出流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(path, ios::out | ios::binary)</span></span>;</span><br><span class=\"line\">    Student *student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"张三\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//写入文件</span></span><br><span class=\"line\">    ofs.write((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *) student, <span class=\"keyword\">sizeof</span>(Student));</span><br><span class=\"line\"></span><br><span class=\"line\">    ofs.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> (student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    writeFileByBinary(<span class=\"string\">\"student.bin\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们将类成员属性的值以二进制的方式写入进一个文件内。</p>\n<p>最终文件内的内容人类是看不大懂的。</p>\n<p><img src=\"/2019/05/22/C-读写文件/二进制文件.png\" alt=\"二进制写\"></p>\n<p><strong>注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码.</strong></p>\n<h1 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a><strong>读取</strong></h1><blockquote>\n<p>下面将读取两种不同类型的文件以作为案例进行讲解。</p>\n</blockquote>\n<h2 id=\"以文本文件读取\"><a href=\"#以文本文件读取\" class=\"headerlink\" title=\"以文本文件读取\"></a><strong>以文本文件读取</strong></h2><p>读取有很多种方式，下面将会演示三种，分别是:</p>\n<ul>\n<li><p>逐行读取</p>\n</li>\n<li><p>逐词读取</p>\n</li>\n<li><p>逐字符读取</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"逐字符读取-不推荐\"><a href=\"#逐字符读取-不推荐\" class=\"headerlink\" title=\"逐字符读取(不推荐)\"></a><strong>逐字符读取(不推荐)</strong></h3><p><strong>逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐字符读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile04</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储变量</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> cbuffer;</span><br><span class=\"line\">    <span class=\"comment\">//逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((cbuffer = ifs.get()) != EOF) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; cbuffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>EOF</code>代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。</p>\n<h3 id=\"逐行读取-有两种方式，但都是逐行读取\"><a href=\"#逐行读取-有两种方式，但都是逐行读取\" class=\"headerlink\" title=\"逐行读取(有两种方式，但都是逐行读取)\"></a><strong>逐行读取(有两种方式，但都是逐行读取)</strong></h3><p>第一种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile02</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化</span></span><br><span class=\"line\">    fstream fs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    fs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//用字符数组进行缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fs.getline(buffer, <span class=\"keyword\">sizeof</span>(buffer))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    fs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>字符数组</code>作为数据存储容器，用<code>fstream</code>对象的<code>getline()</code>函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用<code>sizeof()</code>是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。</p>\n<p>第二种:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐行读取</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile03</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取操作对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//数据存储容器</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> buffer;</span><br><span class=\"line\">    <span class=\"comment\">//使用全局函数getline(输入流，可存储的容器)进行逐行读取</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getline(ifs, buffer)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数<code>getline(输入对象,数据存储容器)</code>,它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。</p>\n<h3 id=\"逐词读取-以空格区分\"><a href=\"#逐词读取-以空格区分\" class=\"headerlink\" title=\"逐词读取(以空格区分)\"></a><strong>逐词读取(以空格区分)</strong></h3><p>逐词读取，将会已空格进行区分每个词汇，再读取。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 逐词读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFile01</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化读取文件对象</span></span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    ifs.open(path, ios::in);</span><br><span class=\"line\">    <span class=\"comment\">//判断文件是否能打开</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ifs.is_open()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"文件打开失败!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//字符数组缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//将读取的数据放入缓存区</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ifs &gt;&gt; buffer)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。</p>\n<p>这种逐词读取的方式是<code>读取对象</code>通过<code>右移运算符</code>把读取的数据存入容器之中，但是是以空格区分每个词汇。</p>\n<h2 id=\"以二进制的方式读取\"><a href=\"#以二进制的方式读取\" class=\"headerlink\" title=\"以二进制的方式读取\"></a><strong>以二进制的方式读取</strong></h2><p>前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 以二进制的方式读取文件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param path 路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFileByBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建输入流对象，并且指定路径和文件打开方式</span></span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(path, ios::in | ios::binary)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>];</span><br><span class=\"line\">    ifs.read(c, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    readFileByBinary(<span class=\"string\">\"Student.smi\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">张三</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p>这里我们将<code>Student.smi</code>这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>读取文件创建<code>ifstream</code>对象,写入文件创建<code>ofstream</code>对象，<code>fstream</code>对象既可以读又可以写。</p>\n<p>操作文件得先<code>打开文件</code></p>\n<p>操作文件完毕得<code>关闭文件</code></p>\n<p>二进制文件读取需要读取二进制格式的文件</p>"}],"PostAsset":[{"_id":"source/_posts/如何自学编程/群组.png","slug":"群组.png","post":"cjw0sp9xp0015xcvvz3j6xnhj","modified":0,"renderable":0},{"_id":"source/_posts/C-内存四区之代码区与全局区/代码区示意图.png","slug":"代码区示意图.png","post":"cjw0sp9ws0000xcvvazn1yhs5","modified":0,"renderable":0},{"_id":"source/_posts/C-内存四区之堆区/test.png","slug":"test.png","post":"cjw0sp9x40006xcvvlrr8nd63","modified":0,"renderable":0},{"_id":"source/_posts/C-指针-基础02/指针位偏移.png","slug":"指针位偏移.png","post":"cjw0sp9x9000fxcvvfjd73gu7","modified":0,"renderable":0},{"_id":"source/_posts/我儿子的博客/预览.png","slug":"预览.png","post":"cjw0sp9xp0013xcvve10zxbct","modified":0,"renderable":0},{"_id":"source/_posts/hexo-next插入网易云音乐/01.png","slug":"01.png","post":"cjw0sp9xe000qxcvvkmgic6kc","modified":0,"renderable":0},{"_id":"source/_posts/hexo-next插入网易云音乐/插哪.png","slug":"插哪.png","post":"cjw0sp9xe000qxcvvkmgic6kc","modified":0,"renderable":0},{"_id":"source/_posts/终端多窗口神器——Screen/DefalutCommandKey.png","slug":"DefalutCommandKey.png","post":"cjw0sp9xu001kxcvvnts8ipqz","modified":0,"renderable":0},{"_id":"source/_posts/终端多窗口神器——Screen/detachedInfo.png","slug":"detachedInfo.png","post":"cjw0sp9xu001kxcvvnts8ipqz","modified":0,"renderable":0},{"_id":"source/_posts/2008年5月12日14时28分04秒/操场.webp","slug":"操场.webp","post":"cjw0sp9x00002xcvv5nx30yan","modified":0,"renderable":0},{"_id":"source/_posts/2008年5月12日14时28分04秒/流量图.webp","slug":"流量图.webp","post":"cjw0sp9x00002xcvv5nx30yan","modified":0,"renderable":0},{"_id":"source/_posts/2008年5月12日14时28分04秒/空降.webp","slug":"空降.webp","post":"cjw0sp9x00002xcvv5nx30yan","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/分区.png","slug":"分区.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/分区标识.png","slug":"分区标识.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/安装选择界面.png","slug":"安装选择界面.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/开始安装.png","slug":"开始安装.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/摘要.png","slug":"摘要.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/桌面.png","slug":"桌面.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/ManjaroLinux的安装过程/编辑文章时截图.png","slug":"编辑文章时截图.png","post":"cjw0sp9xo000zxcvvx4fve5yx","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/deploy.png","slug":"deploy.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/hexoinit.png","slug":"hexoinit.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/ssh目录.png","slug":"ssh目录.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/创建仓库.png","slug":"创建仓库.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/导入密钥.png","slug":"导入密钥.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/打开设置.png","slug":"打开设置.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/本地部署.png","slug":"本地部署.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/设置SSH.png","slug":"设置SSH.png","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/如何用hexo-github-pages搭建博客/逆光.jpg","slug":"逆光.jpg","post":"cjw0sp9xl000xxcvvc122kaa5","modified":0,"renderable":0},{"_id":"source/_posts/C-读写文件/二进制文件.png","slug":"二进制文件.png","post":"cjw0spa230033xcvvs7j89pjb","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjw0sp9x50008xcvvpmfg6c2o","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xa000gxcvv4fh7zskk"},{"post_id":"cjw0sp9ws0000xcvvazn1yhs5","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xc000lxcvv8h4tnspw"},{"post_id":"cjw0sp9x60009xcvvraqenlrf","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xd000oxcvv0fi3yqkh"},{"post_id":"cjw0sp9x8000dxcvvjg0pnlos","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xf000rxcvv1qin9yaw"},{"post_id":"cjw0sp9x00002xcvv5nx30yan","category_id":"cjw0sp9x7000axcvv0uqs68ot","_id":"cjw0sp9xh000vxcvvvp12aa74"},{"post_id":"cjw0sp9x9000fxcvvfjd73gu7","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xl000yxcvvfrx9d1s8"},{"post_id":"cjw0sp9xb000kxcvv284yfi6p","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xo0011xcvv52inihc0"},{"post_id":"cjw0sp9x40006xcvvlrr8nd63","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xp0014xcvvmkoof8pf"},{"post_id":"cjw0sp9xd000nxcvv27ujf3bn","category_id":"cjw0sp9xh000txcvvzidh6o55","_id":"cjw0sp9xq0016xcvvhgt07l5s"},{"post_id":"cjw0sp9xo000zxcvvx4fve5yx","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xr0019xcvvyazlqppu"},{"post_id":"cjw0sp9xp0013xcvve10zxbct","category_id":"cjw0sp9xh000txcvvzidh6o55","_id":"cjw0sp9xs001dxcvvi3axwdmt"},{"post_id":"cjw0sp9xe000qxcvvkmgic6kc","category_id":"cjw0sp9xo0010xcvv6hlb82h6","_id":"cjw0sp9xt001hxcvv8uil3591"},{"post_id":"cjw0sp9xh000uxcvvvzbqvchv","category_id":"cjw0sp9xo0010xcvv6hlb82h6","_id":"cjw0sp9xu001mxcvvhl9po88j"},{"post_id":"cjw0sp9xr001cxcvv9bwouweh","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xv001pxcvv6chjz433"},{"post_id":"cjw0sp9xt001gxcvv7l889s47","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0sp9xv001rxcvv6cnb7drn"},{"post_id":"cjw0sp9xl000xxcvvc122kaa5","category_id":"cjw0sp9xo0010xcvv6hlb82h6","_id":"cjw0sp9xw001uxcvvzfmvssvw"},{"post_id":"cjw0sp9xp0015xcvvz3j6xnhj","category_id":"cjw0sp9xu001lxcvvmqps63zh","_id":"cjw0sp9xw001yxcvvwexky733"},{"post_id":"cjw0sp9xq0018xcvvgn675dlg","category_id":"cjw0sp9xu001lxcvvmqps63zh","_id":"cjw0sp9xx0021xcvvwwxfhuhj"},{"post_id":"cjw0sp9xu001kxcvvnts8ipqz","category_id":"cjw0sp9xw001xxcvvccm88ito","_id":"cjw0sp9xx0024xcvvpamp2nsm"},{"post_id":"cjw0spa210032xcvv3j5e1g2f","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0spa270036xcvv1sbjo6by"},{"post_id":"cjw0spa230033xcvvs7j89pjb","category_id":"cjw0sp9x20004xcvvwp70aysd","_id":"cjw0spa270037xcvvb7g60m09"}],"PostTag":[{"post_id":"cjw0sp9x50008xcvvpmfg6c2o","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9x8000cxcvvyer7nnsz"},{"post_id":"cjw0sp9ws0000xcvvazn1yhs5","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9x9000excvv2x2r5gwo"},{"post_id":"cjw0sp9x8000dxcvvjg0pnlos","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9xb000jxcvvjqyrv7qk"},{"post_id":"cjw0sp9x00002xcvv5nx30yan","tag_id":"cjw0sp9x7000bxcvv74nah1zh","_id":"cjw0sp9xd000mxcvvineos4b7"},{"post_id":"cjw0sp9x40006xcvvlrr8nd63","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9xf000sxcvv0gse9nhc"},{"post_id":"cjw0sp9x60009xcvvraqenlrf","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9xr001bxcvvnmarxr5y"},{"post_id":"cjw0sp9x60009xcvvraqenlrf","tag_id":"cjw0sp9xe000pxcvvzg0lltxt","_id":"cjw0sp9xs001fxcvvhtnb3wch"},{"post_id":"cjw0sp9x60009xcvvraqenlrf","tag_id":"cjw0sp9xl000wxcvv6x30mums","_id":"cjw0sp9xu001jxcvvv6ooxohm"},{"post_id":"cjw0sp9x60009xcvvraqenlrf","tag_id":"cjw0sp9xp0012xcvvtk9oiea6","_id":"cjw0sp9xv001nxcvvhsj2hg6g"},{"post_id":"cjw0sp9x9000fxcvvfjd73gu7","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9xv001qxcvvrp3n9yfb"},{"post_id":"cjw0sp9x9000fxcvvfjd73gu7","tag_id":"cjw0sp9xe000pxcvvzg0lltxt","_id":"cjw0sp9xw001txcvvo5516k2g"},{"post_id":"cjw0sp9x9000fxcvvfjd73gu7","tag_id":"cjw0sp9xl000wxcvv6x30mums","_id":"cjw0sp9xw001wxcvvao2jo8ga"},{"post_id":"cjw0sp9xb000kxcvv284yfi6p","tag_id":"cjw0sp9xv001oxcvvz9vq6qj7","_id":"cjw0sp9xw001zxcvvucq2lmyt"},{"post_id":"cjw0sp9xd000nxcvv27ujf3bn","tag_id":"cjw0sp9xw001vxcvviojlgbic","_id":"cjw0sp9xx0023xcvvjin07rue"},{"post_id":"cjw0sp9xd000nxcvv27ujf3bn","tag_id":"cjw0sp9xv001oxcvvz9vq6qj7","_id":"cjw0sp9xx0025xcvvbqdfuf8h"},{"post_id":"cjw0sp9xe000qxcvvkmgic6kc","tag_id":"cjw0sp9xx0022xcvvn4x6k5wu","_id":"cjw0sp9xy0028xcvvu630e1zb"},{"post_id":"cjw0sp9xe000qxcvvkmgic6kc","tag_id":"cjw0sp9xx0026xcvvjy4rvpx5","_id":"cjw0sp9xy0029xcvvxahj2n5r"},{"post_id":"cjw0sp9xh000uxcvvvzbqvchv","tag_id":"cjw0sp9xx0022xcvvn4x6k5wu","_id":"cjw0sp9xz002bxcvv1ep23xko"},{"post_id":"cjw0sp9xl000xxcvvc122kaa5","tag_id":"cjw0sp9xx0022xcvvn4x6k5wu","_id":"cjw0sp9xz002excvvgf4lz1jl"},{"post_id":"cjw0sp9xl000xxcvvc122kaa5","tag_id":"cjw0sp9xz002cxcvvgludsjsg","_id":"cjw0sp9y0002fxcvv5f4fj0zd"},{"post_id":"cjw0sp9xo000zxcvvx4fve5yx","tag_id":"cjw0sp9xv001oxcvvz9vq6qj7","_id":"cjw0sp9y1002jxcvvuvrf160j"},{"post_id":"cjw0sp9xo000zxcvvx4fve5yx","tag_id":"cjw0sp9y0002gxcvv1rvn5qdn","_id":"cjw0sp9y1002kxcvvam9q8nm9"},{"post_id":"cjw0sp9xo000zxcvvx4fve5yx","tag_id":"cjw0sp9y0002hxcvvm3hrr5c1","_id":"cjw0sp9y1002mxcvv1wvncgvh"},{"post_id":"cjw0sp9xp0013xcvve10zxbct","tag_id":"cjw0sp9y1002ixcvvrlh6eh8h","_id":"cjw0sp9y1002nxcvvqvgh9yz7"},{"post_id":"cjw0sp9xp0015xcvvz3j6xnhj","tag_id":"cjw0sp9y1002lxcvv7snplgtn","_id":"cjw0sp9y2002pxcvvu7kzxod2"},{"post_id":"cjw0sp9xq0018xcvvgn675dlg","tag_id":"cjw0sp9xv001oxcvvz9vq6qj7","_id":"cjw0sp9y3002rxcvv49rprc2q"},{"post_id":"cjw0sp9xr001cxcvv9bwouweh","tag_id":"cjw0sp9xv001oxcvvz9vq6qj7","_id":"cjw0sp9y3002uxcvv8rplcnt7"},{"post_id":"cjw0sp9xr001cxcvv9bwouweh","tag_id":"cjw0sp9y3002sxcvvt4xdxa1e","_id":"cjw0sp9y3002vxcvv2n4l4e0z"},{"post_id":"cjw0sp9xt001gxcvv7l889s47","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0sp9y4002xxcvvq2nktmp3"},{"post_id":"cjw0sp9xt001gxcvv7l889s47","tag_id":"cjw0sp9y3002txcvv4abqmwwa","_id":"cjw0sp9y4002yxcvvzyll3f1o"},{"post_id":"cjw0sp9xu001kxcvvnts8ipqz","tag_id":"cjw0sp9xv001oxcvvz9vq6qj7","_id":"cjw0sp9y50030xcvv7rnaz00s"},{"post_id":"cjw0sp9xu001kxcvvnts8ipqz","tag_id":"cjw0sp9y4002zxcvvwxent66p","_id":"cjw0sp9y50031xcvvweeviyjl"},{"post_id":"cjw0spa230033xcvvs7j89pjb","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0spa270035xcvvbi4730nh"},{"post_id":"cjw0spa210032xcvv3j5e1g2f","tag_id":"cjw0sp9x30005xcvv57hi4eyn","_id":"cjw0spa280038xcvvn8nkrlgf"},{"post_id":"cjw0spa210032xcvv3j5e1g2f","tag_id":"cjw0spa250034xcvv88fjud9d","_id":"cjw0spa280039xcvv1cacn0sb"}],"Tag":[{"name":"C++","_id":"cjw0sp9x30005xcvv57hi4eyn"},{"name":"社会事件","_id":"cjw0sp9x7000bxcvv74nah1zh"},{"name":"指针","_id":"cjw0sp9xe000pxcvvzg0lltxt"},{"name":"学习笔记","_id":"cjw0sp9xl000wxcvv6x30mums"},{"name":"基础","_id":"cjw0sp9xp0012xcvvtk9oiea6"},{"name":"Linux","_id":"cjw0sp9xv001oxcvvz9vq6qj7"},{"name":"Telegram","_id":"cjw0sp9xw001vxcvviojlgbic"},{"name":"hexo","_id":"cjw0sp9xx0022xcvvn4x6k5wu"},{"name":"网易云音乐","_id":"cjw0sp9xx0026xcvvjy4rvpx5"},{"name":"博客","_id":"cjw0sp9xz002cxcvvgludsjsg"},{"name":"折腾","_id":"cjw0sp9y0002gxcvv1rvn5qdn"},{"name":"软件使用","_id":"cjw0sp9y0002hxcvvm3hrr5c1"},{"name":"欢乐时光","_id":"cjw0sp9y1002ixcvvrlh6eh8h"},{"name":"个人感想","_id":"cjw0sp9y1002lxcvv7snplgtn"},{"name":"KDE","_id":"cjw0sp9y3002sxcvvt4xdxa1e"},{"name":"经典案例","_id":"cjw0sp9y3002txcvv4abqmwwa"},{"name":"软件折腾","_id":"cjw0sp9y4002zxcvvwxent66p"},{"name":"编程","_id":"cjw0spa250034xcvv88fjud9d"}]}}