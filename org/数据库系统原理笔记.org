* 数据库系统概述
** 数据库的基本概念:
   1>数据(Data)
	 1)含义:数据是描述事物的 符号记录 ,是指利用物理符号记录下来的,可以鉴别的信息;
	 2)数据的语义(表头):数据是信息存在的一种形式,只有通过解释或处理的数据才能成为有用的信息;

   2>数据库
	 1)含义:数据库(Database,DB)是指长期存储在计算机中的有组织的,可共享的数据的集合;
	 2)原则:
	   *1.数据库要按照一定的 数据模型 组织,描述和存储,
	   *2.具有 较小的冗余度 ,较高的 数据独立性 , //不必要的多次重复存储(冗余度)
	   *3.系统 易于扩展 ,并可以被 多个用户分享 ;

	 3)三个基本特点:
	   *1.永久存储
	   *2.有组织
	   *3.可共享;

	 4)数据库定义(解答题)
	    数据库是长期存储在计算机中有组织的可共享的数据集合,且数据库中的数据按一定的数据模型组织,
	    描述和存储,具有较小的冗余度,较高的数据独立性,系统易于扩展,并可以被多个用户分享;

   3>数据库管理系统(DBMS))(Database Management System)
	 1)含义:是专门用于 建立 和 管理 数据库 的一套软件,介于 应用程序 和 操作系统 之间;
	   *DBMS 没有图形化界面(不是应用程序),也不是操作系统 如mysql;
	 2)功能
	   *1.数据定义 功能
	   *2.数据操纵 功能
	   *3.数据库的 运行管理 功能;
	   *4.数据库的 建立 和 维护 功能;
   	   *5.数据组织、存储 和 管理 功能;
	   *6.其他功能;(与其他软件的 网络通信 功能,不同数据库管理系统之间 数据传输 及 相互访问 功能)。

	 3)数据库系统(DBS)的构成
	    *1.数据库(DB);
		*2.数据库管理系统(DBMS)以及相关实用工具;
	    *3.应用程序;
		*4.数据库管理员(DBA)(DataBase Administrator);
	    *5.用户(程序员或数据库终端用户);

        DBS构成示意图:

	        用户(程序员)     用户(数据库终端用户)
	           ↘            ↙
	               应用程序
	                  ↓
	            数据库管理系统--->数据库管理员(DBA)
	               (DBMS)
	                  ↓
	               数据库
	                (DB)

** 数据库管理技术发展
	*1数据的组织
	  分为逻辑组织和物理组织两种，这二者可以相互独立的
	  数据的逻辑组织是用户或应用程序所使用的数据结构形式，
	  数据的物理组织是数据在物理存储设备上的结构形式。

	*2.数据管理的任务
       就是进行数据收集、组织、控制、存储、选取、维护，实现在适当的时刻、
       以适当的形式、给适当的人、提供适当的数据,它是数据处理的中心问题;
       而数据处理则是指对各种数据进行收集、存储、加工和传播的一系列活动的总和。

    *3.检索
       为了备用，需要将数据归类进行存储；为了向用户提供信息，
       存储的数据要能够方便地被选择提取，这称作检索。


   1>数据库管理技术的发展
	 1)人工管理阶段
		*1.数据不保存
		*2.应用程序管理数据
		*3.数据面向应用程序

	 2)文件系统阶段(将应用程序与数据隔离)
	   含义:文件系统是将数据的逻辑结构和物理结构分离，由“存放方法”实现逻辑结构与物理结构之间的映射。

	            应用程序1       应用程序2 ... 应用程序n
	                    ╲          │        ╱
	                    |---------------------|
	                    |       文件系统       |
	                    |---------------------|
                        ╱          │        ╲
	                数据1         数据2 ...  数据n

	  *1.数据独立
       	 *含义:数据定义与使用数据的应用程序分离称为数据独立

       	  *分类:
       	    1)逻辑独立性:数据定义的修改,在一定范围内不会引起应用程序的修改,这种独立称为数据的逻辑独立;

       		2)物理独立性:当物理结构发生改变时,不会导致应用程序的修改,这称为数据的物理独立性;

     *逻辑结构与物理结构相分离,物理数据独立性
	   *2.优点:
		  具有数据可长期保存和专门管理的特点，它还提供了物理数据独立性，
		  使应用程序脱离数据物理结构,提高适用性,从而使编程人员不必关心数据的
		  物理存储细节,提高了生产效率.并通过数据的抽取，而使数据共享成为可能;

	   *3.缺点:
		  但是在文件系统中不能实现数据的普通共享,只能实现文件级的共享，
		  而不能数据项级实现数据的共享。文件的逻辑结构是根据它的应用而设计的，
		  数据的逻辑结构与应用程序之间相互依赖。当不同应用程序使用的数据大部分相同时，
		  还必须构造各自的文件，这样仍然还存在大量的数据冗余。

	 3)数据库系统阶段(选择填空)
		*1.数据的集成  (是数据库管理系统的主要目的)(将不同数据集中在一起来操作管理)
		*2.数据共享性高  (不只是同一数据可以被多个不同用户存取,还包含了并发共享);
		*3.数据冗余小  (并非所有的冗余都可以或者应该被消除)
		*4.数据一致性  (通过消除或控制数据冗余可以在一定范围内避免数据的不一致性,引起不一致的)
		*5.数据的独立性高 (数据定义与使用数据的应用程序分离)
		*6.实施统一管理与控制 (通过数据库保护实现)
		*7.减少应用程序开发与维护的工作  (表现在应用方面的优点)

	 4)数据库保护(安全完整控制恢复)
	   数据库管理系统具有对数据的统一管理和控制功能;主要包括:
	   *1.数据的安全性；
	   *2.数据的完整性；(定义了属性,并将该属性值域定义完整)
	   *3.并发控制；(两个事务同时存取一个数据,造成并发)
	   *4.故障恢复。(恢复回故障发生前的状态)

** 数据库系统的结构
  1>数据库系统的结构分类(识记)
	1)从DBA(数据库管理员)的视角看:
	  *1.内部系统结构:
		 1.采用三级模式(模式(数据库核心),内模式,外模式)
		   #1.模式:称概念模式或逻辑模式,是数据在逻辑上的视图,即概念视图;描述数据库中全部数据的整体逻辑结构

		   #2.外模式:
		      也称子模式或用户模式,数据视图或用户视图(面向应用),
		      它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述,
		      是与某一应用有关的数据的逻辑表示,所以外模式用来描述数据库的局部逻辑结构。

	       #3.内模式:也称为存储模式,是内部视图或存储视图(面向数据库).(物理存储),只有数据库管理员(DBA能见到)

      三级模式示意图:

         应用A    应用B     应用C    应用D    应用E
            \      /         |        \       /
             外模式1       外模式2       外模式3 (子模式或用户模式:数据视图或用户视图)
                ↑____________↑___________↑
                             ↑
                            模式 (概念模式或逻辑模式:概念视图或逻辑视图)
                             ↑
                           内模式 (存储模式:内部视图或存储视图)
                             ↑
                           数据库
		 2.三级结构的两层映像与数据独立性

           映像:就是一种对应规则,它指出映像双方是如何进行转换的.(双向)

           #1.外模式/模式映像:保证了数据与程序的逻辑独立性.(逻辑-->外模式) (保持外模式不变,提高用户体验)

           #2.模式/内模式映像:保证了数据与程序的物理独立性.(物理-->内模式)
              (因为内模式是唯一的,所以模式/内模式的映射也是唯一的)

           #3.两层映像意义:
              两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性,
              简化应用程序的开发,减少了维护应用程序的工作量;

	  *2.外部系统结构:
		 #1.集中式结构,(将系统所有功能的处理工作都集中到中心结点终端上)
		 #2.分布式结构,(将系统的功能都分布到各个终端机上)
		 #3.并行结构;(并行处理各系统功能)

	  *3.简述常规文件系统与分步式文件系统(HDFS)的不同;
		 分布式文件管理系统与常规文件系统不同的是,它以大粒度数据块的方式存储文件,从而减少元数据的数量,
	     这些数据块则通过随机方式选择不同的节点并存储在各个地方;

	2)从数据库应用的用户的视角
	  *1.客户/服务器结构(client/Server,C/S)
		 客户/服务器结构中:
		 ("客户端","前台"或"表示层")主要完成与数据库使用者的交互任务;
		 ("服务器","后台"或"数据层")主要负责数据管理;
		 表示层<--->数据层
		 #1.单机方式(数据层与数据层在一台机器上)
		 #2.网络方式(不在一台机器上))

	  *2.浏览器/服务器结构(Browser/Server,B/S) (减轻客户端工作负担)
	     是一种基于Web应用的客户/服务器结构,也称为三层客户/服务器结构.
	     三层:表示层,处理层(中间层),数据层.
		 表示层<---->处理层<---->数据层
	    (浏览器)     (.exe)   (对数据库操作)

** 数据模型
   1>数据模型(Data Model)
	 含义:是现实世界数据特征的抽象,描述的是数据的共性内容,它是模型化数据和信息的工具,
	      也是数据库系统的核心和基础;

   2>数据的特征
	  1)静态特征:
	    *1.数据的基本结构,
	    *2.数据间的联系,
	    *3.数据取值范围的约束

	  2)动态特征:
	    指对数据可以进行符合一定规则的操作;(增删改查)

   3>数据模型组成的三大要素:

	  1)数据结构:
	    描述的是系统静态特征,
	    即数据对象的数据类型,内容,属性以及数据对象之间的联系.(层次(树状),网状结构,关系);

	  2)数据操作:
	    描述的是系统的动态特征;
	    主要分为更新和检索两大类,增删改查

	  3)数据约束:
	    描述数据结构中数据间的语法和语义关联(正确性,相容性和有效性);

   4>数据模型的分类
	 简述概念模型,逻辑模型,物理模型的关系(既相互独立,有存在的联系)
	 *现实世界-(抽象)(数据库设计人员完成)
		 ->概念模型(抽象)(信息世界)-(组织,转换)(数据库设计工具协助人员完成)
		 ->逻辑模型和物理模型(机器世界)

	 1)概念层数据模型:
	   概念层是数据抽象级别的最高层,概念层数据模型,也称为数据的概念模型或信息模型,
	   这类模型主要用于数据库的设计阶段;(它用来描述现实世界的事物,与具体的计算机系统无关;)

	  *1.信息世界涉及的基本概念

		#1.实体(Entity):客观存在，并可相互区别的事物称为实体(实体可以是实际的事物,也可以是抽象的概念或联系)

		#2.属性(Attribute):实体所具有的某种特性称为实体的属性,一个实体可以由多个属性来描述;

		#3.码或键(Key):可唯一标识实体的属性集(具有唯一性的属性)

		#4.域(Domain):属性的取值范围

		#5.实体型(Entity Type):相同属性组成的实体必然具有共同的特征和性质

		#6.实体集(Entity Set):相同实体的集合称为实体集;

		#7.联系(Relationship):实体内部的联系通常是指实体各属性之间的联系,实体之间的联系是指不同实体之间的联系;

		#8.型(type):对一类属性的说明;

		#9.值(value):对一类属性具体赋值;

	  *2.E-R图(概念模型的表示方法)
	     Entity-Relationship(实体关系图)
		 #1.实体型:用矩形表示,矩形框内写明实体的名称;
	     #2.属性:用椭圆形表示,并用无向边将其与相应的实体连接起来;
	     #3.联系:用菱形表示,菱形框内写明联系的名称,并用无向边分别与有关实体连接起来,
		   同时在无向边旁标上联系的类型(1:1,1:N或M:N),如果一个联系具有属性,
		   则这些属性也要用无向边与该联系连接起来;

		   ○:属性; □实体; ◇联系; □实体  -无向边
		     姓名---职工---属于---单位

	  *3说明概念模型的表示方法(***解答题***)
		 概念模型表示方法是用E-R图来描述现实世界的概念模型,实体用矩形表示,属性用椭圆表示,联系用菱形表示;


	 2)逻辑层数据模型

	   *1.逻辑层是抽象级别的中间层,逻辑层数据模型,也称为数据的逻辑模型,任何DBMS都是基于逻辑数据模型.
		    (既要考虑用户又要考虑DBMS的实现)

	   *2.逻辑模型的类型

		  (1).层次模型:(树状)

			#1.是最早使用的一种数据模型;

			#2.有且仅有一个结点没有父结点,称作根结点;

			#3.其他结点有且只有一个父结点;

		  (2).网状模型(图)

			 #1.以网状结构表示实体与实体间的联系;

			 #2.允许结点有多于一个父结点;

			 #3可以有一个以上的结点没有父结点;

		   (3).关系模型(二维表格结构来表示实体间的联系);

			 #1.建立在严格的数学概念的基础上;

			 #2.概念单一;

			 #3.存储路径对用户透明,有更高的数据独立性,更好的安全保密性;

		   (4).面向对象模型
			  既是概念模型又是逻辑模型,表达力丰富,对象可复用,维护方便;

	 3)物理层数据模型
	   *1.物理层数据模型,也称为数据的物理模型,描述数据在存储介质上的组织结构,
	      是逻辑模型的物理实现,是数据库最底层的抽象;
	   *2.设计目标是提高数据库性能和有效利用存储空间;

	 *简述概念模型,逻辑模型,物理模型的关系(既相互独立,又存在的联系)
	  三个不同的数据模型之间既相互独立又存在着关联,
	  从现实世界到概念模型的转换是由数据库设计人员完成的;
	  从概念模型到逻辑模型的转换可以有数据库设计人员完成,也可以用数据库设计工具协助设计人员完成;
	  从逻辑模型到物理模型的转换主要由数据库管理系统完成的;

* 关系数据模型（重点）
** 关系数据库的概述:
   1>关系数据库的产生历史:
	 1)关系代数--->关系模型(1970年)
	 2)关系方法理论研究和软件系统的研究取得重大突破(20世纪70年代末)
	 3)出现了比较成熟的关系数据库管理技术,证实了关系数据库的优点,高级的非过程语言接口,较好的数据独立性;(1981年)
	 4)网络模型和层次模型与底层实现紧密结合,关系模型具有坚实理论基础成为主流数据模型;
	 *.关系数据库的优点:高级的非过程语言接口,较好的数据独立性

** 关系数据库模型:
    1>关系模型的组成要素(****)
	  1)关系数据结构;
	  2)关系操作集合;
	  3)关系完整性约束;(表内各属性的值必须赋值)

	2>关系数据结构(简单应用)
	  1)表(Table):是一个二维的数据结构,由表名,列及若干行数据组成也称关系;
	  2)关系(relationship):
	    一个关系逻辑上对应一张二维表,可以为每个关系取一个名称进行表示;
		(某种程度上关系等同于表,表是关系的呈现,表名唯一);

	  3)关系数据库中关系的三种类型:(***解答题***)
		 #1.基本关系:又称基本表或基表,是实际存在数据库中的表,它是实际存储数据的逻辑表示 (实表)
		 #2.查询表:依据某种条件查询后,得到的查询结果生成的表 (虚表)
		 #3.视图表:是由基本表或其他视图表导出的表,不对应实际存储的数据;(虚表)

	3>列(Column)
	  1)概念:也称为字段(Filed)或属性(Attribute);
	  2)列名,字段名,属性名,数据类型相同,(属性(attribute)=列)
	  3)在同一表中表名与字段名必须唯一,不能重复.但不同表中可以出现相同列名
	  4)属性(列)的个数称为关系的元或度(表有8个属性=8元(度)关系)
	  5)列的值称为属性值
	  6)属性值取值范围称为值域

	4>行(Row)
	  1)概念:也称为元组(Tuple)或记录(Record).表中的数据按行存储;
	  2)分量(Component)具体的数据项:元组中的一个属性值;

	 5>码或键(Key)
	   1)概念:
	      属性(或属性组)的值都能用来唯一标识该关系的元组,
		  (属性或属性组的值能唯一标识出该表的该行 关系==表)
		  则称这些属性(或属性组)为该关系的码或键;

	   2)超码或超键(super key):
		  在码中去除某个属性,它任然是这个关系的码;
		  判断超码:
		  #1.是不是码;
		  #2.属性组中去掉一个码后的属性组是否是码;

	   3)候选码或候选键(Candidate key):
		  在码中不能从中移除任何一个属性,否则它就不再是这个关系的码或键;
		  候选码是最小的超码;(再减属性就不能称为码了)(候选码不一定是属性组)
		  判断候选码:就是在属性组中移除任意一个属性,就不能标识出主对象

	   4)主属性(Primary attribute):
		  包含在任何一个候选码中的属性称为主属性或码属性;

	   5)非主属性(Non Primary attribute):
		  不再候选码中的属性;(不能唯一标识出)
		  判断:是不是码->是不是候选码->如果都成立那候选码中的属性就是主属性

	   6)主码或主键(Primary Key):
		  在若干个候选码中指定一个唯一标识关系的元组(行);[主观指定]

	   7)全码或全键(All Key):
		  一个关系模式的所有属性集合是这个关系的主键或主码,这样的主键或主码称为全码或全键;

	   8)外码或外键(Foreign Key)(涉及两个表格)
		  关系中的某个属性(或属性组)不是这个关系的主码或候选码,
		  而是另一个关系的主码时,称该属性为这个关系的外键;

	   9)表的参照关系(Referencing Relation)和被参照关系(Referenced Relation)
		  在关系数据结构中,参照关系也称为从关系(有外键),被参照关系称为主关系(外码是主键),
		  被参照关系和参照关系是通过外码联系的,这种联系通常是一对多的关系;

		  *注
		   #1.一个关系逻辑上对应一张二维表:关系==表;
		   #2.属性是字段,而键是属性的值;
		   #3.范围:属性或属性组>键>超键>候选键(多个)>主键(一个)>全键>外码

	   10)值域(Domain):
		   表示属性的取值范围;

	   11)数据类型(Data Type)
		   每个列都有相应的数据类型,它用于限制(或容许)该列中存储的数据;

	   12)关系模式与关系(Relation Schema):(**解答题**)
		   同数据库模型一样,数据库也有型和值之分,在关系数据库中关系模式是型(Type),
		   关系是值(Value),即关系模式是对关系的描述,关系模式是静态的,稳定的,
           关系是动态的,随时间不断变化的,这是因为关系操作在不断更新数据库中的数据;

	   13)关系数据库(Relation Database)
		   关系数据库以关系模型作为数据的逻辑模型,并采用关系作为组织方式的一类数据库,
		   其数据库操作建立在关系代数的基础上,在一个给定的应用领域中,所有关系的集合构成一个关系数据库;

	   14）.关系数据库对关系的限定/要求(重点和难点)
			#1.每一个属性都是不可分解的(不允许表中有表)
			#2.每一个关系仅仅只有一种关系模式;(存储的数据要对应表头)
			#3.每一个关系模式中的属性必须命名,在同一个关系模式中属性名必须不同;(唯一)
			#4.同一个关系中不允许出现候选码或候选键完全相同的元组;(不能有重复元祖(行))
			#5.在关系中元组的顺序(即行序)是无关紧要的,可以任意交换;
			#6.在关系中属性的顺序(即列序)是无关紧要的,可以任意交换;

		*1.简述主属性和非主属性的区别
           关系中包含在任何一个候选吗中的属性称为主属性或码属性,不包含在任何一个候选键中的属性称为非主属性;

        *2.简述Mysql中候选键与主键之间的区别
           #1.一个表中只能创造一个主键,但可以定义若干个候选键.
           #2.定义主键约束时,系统会自动产生Primary key 索引,而定义候选键约束时,系统自动产生UNIQUE索引.

        *3.简述外键声名的两种方式
           #1.在表中某个列的属性定义后直接加上"reference_definition"语法项.(主键就加PRIMARY KEY)
           #2.定义主键约束时,系统会自动产生Primary Key索引,而定义候选键约束时,系统自动产生UNIQUE索引;



	6>基本的操作关系(选择,投影,并,差,笛卡尔积)
	  关系操作的特点:集合的操作方式(一次一集合)
	  关系模型中常用的关系操作包括两大部分:
	   1) 查询(Query)操作
	   2) 插入(insert),删除(Delete),更新(update)操作;
	  1)查询(Query)(代数五种基本操作)
		  #1.选择

		  #2.投影

		  #3.并(去重且列数相同)
		    假设有两个关系R1和R2,R1和R2的并运算产生一个新关系R3,
		    R3是由属于关系R1或关系R2的所有不同的元祖组成的,记为R3=R1UR2


		  #4.差(R1-R2就是把R1表中与R2表中相同的数据去掉)
		    假设有两个关系R1和R2，R1和R2的差运算产生一个新关系R3。R3是由属于关系R1，
			但不属于R2的元组组成，记为R3=R1-R2。即设关系R1和R2具有相同的关系模式，
			R1和R2的差是由属于R1但不属于R2的元组构成的集合。

		  #5.笛卡尔积
		    假设有两个关系R1和R2,且R1为m个元组,R2为n个元组, R1的元数为r，R2的元数为s，
		    R1和R2的笛卡尔积产生一个新关系R3,记做R3=R1*R2,则R3是由R1和R2的所有元组连接而成的
		    具有(m*n)个元组和（r+s）和属性列组成;


	  2)关系数据语言的分类(***解答题***)
		  *1.关系代数语言(*)
		  *2.关系演算语言(元组关系演算,域关系演算)
		  *3.兼具两者双重特点的语言(SQL语言)
			共同特点:语言具备完备的表达能力,是非过程化的集合操作语言,
			         功能强,能够独立使用也可以嵌入高级语言中使用;
        *关系语言的特点:
         高度非过程化,即:用户不必请求数据库管理员为其建立特殊的存储路径,
         存储路径的选择由DBMS的优化机制来完成;
         用户也不必求助于循环和递归来完成数据的重复操作;

	  3)关系代数的运算符
        *1关系集合运算归类
           1)传统关系运算(并,差,交,笛卡尔积);
           2)基本的关系操作(选择,投影,并,差,笛卡尔积);
           3)专门的关系运算(选择,投影,连接,除)

	    *2.任何一种操作都包含三大要素
		   #1.操作对象

		   #2.操作符(集合运算符和关系运算符,比较操作符和逻辑操作符(辅助))
			  以下是传统的集合运算:
			  并(R1 ∪ R2);两个关系必须有相同的属性个数(去重合并)
			  差(R1 - R2);两个关系必须有相同的属性个数(去重剩下R1表中仅有的属性)
			  交(R1 ∩ R2);两个关系必须有相同的属性个数(取重)
			  笛卡尔积(CARTESIAN PRODUCT)(R1 x R2) (矩阵操作)(元祖数 m*n,属性数 s+r)

		   #3.操作结果

	  4)专门的关系运算(选择,投影,连接,除)

		  *1.选择(SELECT)
		     σ f(R)  SELECT 表名 WHERE 条件(如性别="男")
		     水平分解出表中符合条件的行(选行)(水平分解);

		    示例:
		    选择关系表S1中性别为男的元祖
            σ性别="男"(S1)

		    关系表S1
		    学号(SNO)   姓名(SNAME)   性别(SSEX)
		     01          钟义          男
		     02          海燕          女
		     03          赵越          男

		    学号(SNO)   姓名(SNAME)   性别(SSEX)
		     01          钟义          男
		     03          赵越          男

		  *2.投影(PROJECTION)
		     πR(A) :A为属性
		     π(属性名1,属性名2,...属性名n) (表名)
			 将表格中的对应属性摘除建成新表作为原表的投影;(选列)(垂直分解)

             示例:投影出表S1中的学号和姓名
		     Π 学号,姓名(S1)
		     学号(SNO)   姓名(SNAME)
		      01          钟义
		      02          海燕
		      03          赵越

		  *3.连接(JOIN),也称θ连接: JOIN 表名1 AND 表名2 Where 条件
		     R∞S
		     等值连接: R.B=S.B
			 其他自然连接:特殊的等值连接

             表R            表S
			 A   B   C      B   E
			 a1  b1  5      b1  3
			 a1  b2  6      b2  7
			 a2  b3  8      b2  10
			 a2  b4  12     b3  2
			                b5  2
			 示例:根据上图,连接表R和表S;
			  #1 笛卡尔积 并做 等值连接 (只留属性值相等的)
			    A  R.B  C  S.B   E
			    a1  b1  5   b1   3
			    a1  b2  6   b2   7
			    a1  b2  6   b2   10
			    a2  b3  8   b3   2

              #2去掉重复列(自然连接)(利用了投影)
			      A   B   C   E
			      a1  b1  5   3
			      a1  b2  6   7
			      a1  b2  6   10
			      a2  b3  8   2

          综合实例:
          设有两个关系:学生关系S(学号,姓名,年龄,性别)和选课关系SC(学号,课号,成绩),
          试用关系代数表达式检索没有选修B5课程的学生姓名;
          π姓名(S)-π姓名(σ课号='B5'(S∞SC))


		  *4.除(DIVISION): 表R÷表S
			*1投影:将两个表中不同的列(字段)投影出表πAB
			*2笛卡尔积:表S×表πAB得出表S×πAB
			*3全部相同:表S×πAB与表R比较得出完全相同的表Q
			*4得出除表:表Q中的列去除表S中的列得出表R÷S表

		 *关系代数表达式是先运算()里的,在运算括号外的;
		   Π SNO,SCORE(σAGE>22(SC))
		   含义:*1从表SC中筛选出AGE>22的行,
		        *2在这些行中投影出SNO和SCORE列建出原表的投影

		 *其中一元专门关系操作包括投影和选择；二元专门关系操作包括连接和除。


	7>关系的完整性约束
	  1)数据完整性约束(解答题)
	    *1.数据库的数据完整性是指数据的正确性,相容性,一致性.其中包含两个方面:
	       #1.与现实世界中应用需求的数据的正确性,相容性和一致性,
	       #2.数据库内数据之间的正确性,相容性和一致性.
	          正确性:主键唯一,各属性值符合值域
	          相容性和一致性:两个表有参照关系,参照表的外键值要对应被参照表的主键值或为NULL;

	    *2.数据完整性约束是为 了防止数据库中存在不符合语义的数据,为了维护数据的完整性.
	       DBMS必须提供一种机制来检查数据库中的数据,以判断其是否满足语义规定的条件,
	       这些加在数据库数据之上的语义约束条件就是数据完整性约束;

	  2)关系完整性约束具体定义
		 *1.实体完整性约束(Entity Integrity Constraint)关系-->实体集
		    主键 的组成 不能为空 ,主键中的 主属性 不能是空值NULL;

		 *2.参照完整性约束(Referential Integrity Constraint)
		    就是定义外码和主码之间的引用规则;是对关系间引用数据的一种限制,
		    具体来说就是若属性F是关系R的外键, 它与基本关系S的主键K相对应,
		    则对应R中每个元祖在F上的值只允许两种可能,要么取空值(NULL),
		    要么等于S中某个元祖的K值,

		    (要么外码等于被参照表主码中某个元组的主码值,要么为空值(NULL))
		    *.参照表的外键值与被参照表的主键值要对应(外键=被参照表的主键值或NULL)

		 *3.用户完整性约束(User-defined Integrity Constraint )
		    #1.域的完整性约束(针对某一应用环境的完整性约束)
			#2.其他;

	  3)关系完整性约束的检验(增,删,改)
		 *1.执行插入操作
		    #1.检查实体完整性约束->检查表中主键是否为空
		    #2.检查参照完整性约束->检查要插入的外键是否对应被参照表主键值(向参照关系插入)
		    #3.检查用户定义完整性约束;

	     *2.执行删除操作(是否被引用)
		    一般只需要对被参照关系检查参照完整性操作;
		    也就是要被删除的操作是否被其他表格所引用;(具有参照关系)

		 *3.执行更新操作
		    上述两种情况的综合;

** 关系数据库的规范化理论(范式)

   1>关系模式中可能存在的冗余和异常问题(简单应用)

	   1)数据冗余:指同一数据被反复存储的情况;

	   2)更新异常:数据冗余造成的,(数据重复会只改其中一条,其他没改)

	   3)插入操作异常:

	   4)删除异常:关键字的删除异常使相关表没有意义;

   2>函数依赖和关键字
	 1)概念:f: A->B, y=f(x)

		设R为任一给定关系,如果对R中属性X的每一个值,R中的属性Y只有唯一一值与之对应,
		则称X函数决定Y或称Y函数依赖于X,记做X->Y,其中X称为决定因素;(如学号X->姓名Y)
		反之Y-/->X
	 2)分类
		*1.完全函数依赖(解答题)
			设R为任一给定关系,X,Y为其属性集,若X->Y,且对X中的任何真子集X',
			都有X'-/->Y,则称Y完全函数依赖于X;

			示例:
		    学生课程表SC
		    SNO(学号)   CNO(课程号)   CTITLE(课程名)  GRADE(成绩)
		     01          11           数据库原理       80
		     01          12           数据结构导论     90
		     02          11           数据库原理       95
		     02          12           数据结构导论     85

			SC( SNO, CNO,  CTITLE, GRADE)
			    学号 课程号  课程名  成绩
			其中(SNO,CNO)->GRADE; 且SNO-/->GRADE; CNO-/->GRADE;
			则GRADE完全依赖于(SNO,CNO);

		*2.部分函数依赖
		    设R为任一给定关系,X,Y为其属性集,若X->Y,且对X中
		    存在一个真子集X'满足X'->Y,则称Y部分函数依赖于X.

			示例:
		    学生表ST
		    SNO(学号)   SNAME(姓名)   SSEX(性别)
		     01          钟义          男
		     02          海燕          女
		     03          赵月          男

			ST(SNO,SNAME,SSEX)
			其中(SNO,SNAME)->SSEX,且 SNO->SSEX;SNAME->SSEX;
			则SSEX部分依赖于(SNO,SNAME);

		*3.传递函数依赖
		    设R为任一给定关系,X,Y,Z为其不同属性子集,若X->Y,Y-/->X,Y->Z,则有X->Z,
			则称Z传递函数依赖于X.

			示例:
		    图书表BOOKS
		    BNO(书号)   PNAME(出版社名)   PADRESS(出版社地址)
		     01         北京大学出版社        北京
		     02         复旦大学出版社        上海
		     03         北京大学出版社        北京

            BOOKS(BNO,PNAME,PADRESS)
            其中 BNO->PNAME, PNAME->PADRESS;
            则有BNO->PADRESS,称PADRESS传递函数依赖于BNO;

	   *真子集:如果A包含于B,且A不等于B,就说集合A是集合B的真子集(去除本身的子集)。

	 3)关键字
		  设R为任一给定关系,U为其所含的全部属性集合,X为U的子集,若有完全依赖函数X->U,
		  则X为R的一个候选关键字(X是候选码)
		  SC( SNO, CNO,  CTITLE, GRADE)    U{SNO, CNO,  CTITLE, GRADE}//U全部属性集合
		  (SNO,CNO)->CTITLE, (SNO,CNO)->GRADE   //(SNO,CNO)为候选关键字

   3>范式与规范化过程(综合应用)
	一个 低一级 范式的关系通过 模式分解 可以转换为若干个 高一级范式 的关系模式的集合,
	这种过程就叫 规范化

	1)第一范式(表中属性不能再分)(1NF)
	  设R为任一给定关系,如果R中每个 列与行的交点处 的取值,都是 不可再分 的 基本元素,
	  则称R为第一范式的,简称1NF
	  *缺点:会造成冗余高->更新异常,插入操作异常,删除异常

	2)第二范式(2NF):
	  设R为任一给定关系,若R为1NF,若R中,且其所有 非主属性 都 完全函数依赖 候选关键字(候选码),
	  则称R为第二范式的,简称2NF;

	3)第三范式(3NF):
      设R为任一给定关系,若R为2NF,且其每一个 非主属性 都不 传递函数依赖 候选关键字,
      则称R为第三范式的,简称3NF;

	4)巴斯范式(BCNF)
	 设R为任一给定关系,X,Y为其属性集,F为其函数依赖集,若R为3NF且其F中所有函数依赖
	 X->Y(Y属于X)中的X必须包含候选关键字,则R为BCNF;

   4>低级范式向高级范式转换方法
     *1.由不符合范式规范的关系表,符合第一范式(1NF)
        规范方法:拆分行和列
        #1.使每列属性不可再分,属性值只代表一个属性(课程+讲师)->(课程名) (讲师)
        #2.使每行分量不可再分,一个分量包括多行元祖->一个分量只对应一个元祖(行)

        示例:
                    学生选课表SC
        SNO    SNAME   CUS_INFO      IPLACE  GRADE
        901001 C01    操作系统(王中)    东     70
        901002 C01    操作系统(王中)    东     78
               C02    数据库(高国)      东     85
               C03    数据结构(王中)    东     80
                       ↓1NF
        SNO    CNO  CTITLE    INAME  IPLACE GRADE
        901001 C01  操作系统   王中    东      70
        901002 C01  操作系统   王中    东      78
        901002 C02  数据库     高国    北      85
        901002 C03  数据结构   王中    东      80

     *2.1NF->2NF
        规范方法:拆分表
        #1.找到候选关键字,看其余的属性是否完全依赖候选关键字;
        #2.是的,与候选关键字一同抄下来形成一个表格;
        #3.不是的,查下来,形成第二个表格,并且将候选关键字里能唯一
           决定表格2的属性组抄在第一列;
        示例:
        SC的候选关键字为(SNO,CNO),将其变为第二范式
        解题思路:
        除GRADE外,CTITLE,INAME,IPLACE,都可以有CNO确定,所以将表SC
        拆分为表一(SNO,CNO,GRADE)和表二(CNO,CTITLE,INAME,IPLACE);

                           学生选课表SC(1NF)
                SNO    CNO  CTITLE    INAME  IPLACE GRADE
                901001 C01  操作系统   王中    东     70
                901002 C01  操作系统   王中    东     78
                901002 C02  数据库     高国    北     85
                901002 C03  数据结构   王中    东     80
                                ↓2NF
                  表一                        表二
        SNO     CNO   GRADE   |   CNO   CTITLE   INAME  IPLACE
        901001  C01    70     |   C01   操作系统  王中   东
        901002  C01    78     |   C02   数据库    高国   北
        901002  C02    85     |   C03   数据结构  王中   东
        901002  C03    80     |

     *3.2NF->3NF
        规范方法:拆分表
        #1.找到表中的传递依赖函数关系的三个属性组,设为x,y,z
        #2.将这三个属性组拆成二个表格,表一为x,y 表二为y,z
       示例:
       表TC的候选关键字为CNO,使表TC符合3NF;
        解题思路:CNO->CTITLE,CTITLE-/->CNO,CTITLE->INAME,
                CNO->INAME,INAME-/->CNO,INAME->IPLACE,
               所以IPLACE传递函数依赖于CNO,
               拆分:没有传递函数依赖的表(CNO,CTITLE)
                    有传递函数依赖的表(CTITLE  INAME)
                    有传递函数依赖的表(INAME  IPLACE)

                      教师授课表TC
              CNO   CTITLE   INAME  IPLACE
              C01   操作系统  王中   东
              C02   数据库    高国   北
              C03   数据结构  王中   东

                          ↓3NF
            表1                 表2               表3
        CNO   CTITLE   |   CTITLE  INAME  |  INAME  IPLACE
        C01   操作系统      操作系统  王中     王中   东
        C02   数据库        数据库    高国     高国   北
        C03   数据结构  |   数据结构  王中  |

     *4.3NF->BCNF
        规范方法:
        列出表格中的所有函数依赖关系,每个关系拆出一个表
        SNO CTITLE INAME           SNO INAME        INAME CTITLE
        S01  英语   王华            S01 王华          王华  英语
        S01  数学   沈飞   BCNF     S01 沈飞          沈飞  数学
        S02  物理   高俊  -----→    S02 高俊    和    高俊  物理
        S03  语文   袁晓            S03 袁晓          袁晓  语文
        S04  英语   王华            S04 王华

* 数据库设计
** 数据库设计概述
	1>数据库的生命周期(选择,填空和解答)
	  *.从数据库演变过程的角度来看,数据库的生命周期可分为两个阶段:

	       数据库 分析 与 设计 阶段      和    数据库 实现 和 操作 阶段
	       /      |     |     \               /         |        \
      需求分析 概念设计 逻辑设计 物理设计      实现     操作与监督   修改与调整

	  1)数据库分析与设计阶段
	    #1.需求分析
		#2.概念设计
		#3.逻辑设计
		#4.物理设计

	  2)数据库实现与操作阶段
		#1.实现
		#2.操作与监督
		#3.修改与调整

	2>数据库设计的目标(解答题)
	  1) 满足应用功能需求 (存取删改)(增删改查)
	  2) 良好的数据库性能 (填空解答题)
         主要是指对数据的 高效率存取 和 空间的节省，
         并具有良好的数据 共享性、完整性、一致性 及 安全保密性。

    3>数据库设计的内容
      数据库设计的特点是 结构设计 与 行为设计 分离。

	  1)数据库 结构设计(静态)
        *1.概念:
           是针对给定的应用环境进行数据库的 模式 或 子模式 的设计，
           包括数据库的 概念结构设计、逻辑结构设计 和 物理结构设计。
           模式定义并给出各应用程序共享的结构,结构设计是 静态的，
           一经形成通常不会改变。

        *2.分类
	       #1.概念结构设计
		   #2.逻辑结构设计
	   	   #3.物理结构设计

	 2)数据库 行为设计(动态操作)
       *1.概念:
          是确定数据库用户的 行为 和 动作，而用户的行为和动作
          是对数据库的操作，它们通常是通过应用程序来实现的。
          行为设计是动态的。

       *2.分类
		  #1.功能设计
		  #2.事务设计
		  #3.程序设计

     数据库设计分类示意图:
              ╭
              |         ╭#1.概念结构设计
	          │ 结构设计< #2.逻辑结构设计
	          │         ╰#3.物理结构设计
	          │
	数据库设计 │         ╭#1.功能设计
	          │ 行为设计< #2.事务设计
	          │         ╰#3.程序设计
	          ╰

	4>数据库设计的方法(识记)
	  1)直观设计法(最原始的数据库设计方法)

	  2)规范设计法
	    #1.新奥尔良设计方法:需求分析,概念结构设计,逻辑结构设计,物理结构设计
		#2.基于E-R模型的数据库设计方法

		               ╭         ╭属性域冲突;
                       │ 属性冲突<
                       │         ╰属性取值单位冲突;
                       |
                       │         ╭同名异义
		   各局部E-R图 <  命名冲突<
		   之间的冲突   |         ╰异名同义
                       |
                       |          ╭同一对象在一个局部E-R图中作为实体,而在另一个局部E-R图中作为属性;
                       |  结构冲突< 同一实体在不同 E-R图中属性个数和类型不同
                       ╰          ╰实体间联系在不同的E-R图中是不同的类型;


		#3.基于第三范式的设计方法,是一类结构化设计方法

	  3)计算机辅助设计法(在数据库设计过程中，以领域专家的知识或经验为主导，模拟某一规范化设计的方法，
	    通常通过人机交互的方式来完成设计的某些过程。)

	5>数据库设计过程(识记)
                                    ╭ #1.确定数据范围(支持哪些应用)
                                    │ #2.分析数据应用过程:
                        *1.需求分析 <
	                                │ #3.收集与分析数据
	                                ╰ #4.编写需求分析报告
	                   ↙         ↘
	 #1概念结构设计╮                       ╭#1.功能设计
  *2.#2逻辑结构设计->结构设计       行为设计<-#2.事务设计
     #3物理结构设计╯  (静态)        (动态)  ╰#3.程序设计
                       ↘         ↙
                                  ╭#1.加载数据库数据
                    *3.数据库实施 < #2.应用程序设计
                           ↓      ╰#3.数据库试运行
                           ↓
                   *4.数据库运行与维护---->系统维护中最困难的工作是数据库重组与重构

** 数据库设计的基本步骤
	1>需求分析(领会)
	  1)目标:(解答题)
	    是了解与分析用户的信息及应用处理的要求,
	    并将结果按一定的格式整理而形成的需求分析报告;
	    *需求分析报告是后续概念设计,逻辑设计,物理设计,数据库建立与维护的依据;

	  2)分析过程:
	             ╭#1.确定数据范围
                 │#2.分析数据应用过程
        需求分析 <
                 │#3.收集与分析数据
                 ╰#4.编写需求分析报告

		1.确定数据范围(是需求分析的第一项工作)
		  *1.有效的利用计算机设备及数据库系统的潜在能力;
		  *2.提高数据库的应变能力;
		  *3.避免应用过程中对数据库做太多或太大的修改;
		  *4.延长数据库的生命周期;

	    2.分析数据应用过程(解答题)
		  *1.用到那些数据;
		  *2.数据使用的顺序;
		  *3.对数据作何处理和处理的策略以及结果;
		  *为了了解并分析数据与数据处理间的关系
		  *应用过程分析结果是数据库结构设计的重要依据

		3.收集与分析数据
	                    ╭#1.静态结构:不施加应用操作于其上时数据的原始状态;
          收集与分析数据 <#2.动态结构:将应用操作施加于数据之上后数据的状况;
                        ╰#4.数据约束:使用数据时的特殊要求;

		  *1.数据分类表---用于数据的总体描述(静态结构)
		     |数据ID|数据名|用途|主人|用户|来源|去向|存档时间|数据量|

		  *2.数据元素表---指通常意义下的数据项或属性(静态结构)
		     |数据ID|数据元素ID|元素名|意义|类型|长度|算法|备注|

		  *3.数据任务表---一个任务指为完成某一特定处理功能的相对独立的操作序列;(动态结构)
		     |任务ID|名称|功能|类型|主人|用户|执行日期|频率|操作过程|备注|

		  *4.数据特征操作表--用于描述任务和数据之间的关系,它包括不同任务对数据执行不同操作的频率;(动态结构)
		     |任务ID|数据ID|建立|查询|插入|修改|删除|数据量|

		  *5.数据约束
		     #1.数据的安全保密性;
			 #2.数据的完整性;
			 #3.响应时间;
			 #4.数据恢复;

          *数据收集与分析的任务:
           了解并分析数据的组成格式及操作特征,每个数据元素的语义及关系等,并将它们收集起来整理归档;

		4.编写需求分析报告:
		  *1.数据库的应用功能目标;
		  *2.标明不同用户视图范围;
		  *3.应用处理过程需求说明:
		      ╭#1.数据流程图;
		      |#2.任务分类表;
		  包括<
		      |#3.数据操作特征表;
		      ╰#4.操作过程说明书;

		  *4.数据字典,
		     是数据库系统中存储三级结构定义的数据库,通常指的是数据库系统中各类数据详细描述的集合,
		     功能是存储和检索各种数据描述,即元数据, 通常包括以下数据:

		             ╭#1.数据分类表;
		     数据字典< #2.数据元素表;
		             ╰#3.各类原始资料;
		  *5.数据量;
		  *6.数据约束;

	2>概念结构设计(领会)(E-R图)
	  概念结构设计的常用方法
      有实体分析法和属性综合法两种，它们也分别称为自顶向下法和自底向上法。

	  *概念模型(自顶向下,逐步求精)
	  1)顶层设计->中层设计->底层设计
	  2)独立于任何软件与硬件,主要目标:最大限度的满足应用需求;
	  3)任务:在需求分析中产生的需求分析报告的基础上,按特定的方法设计满足应用需求的用户信息结构;

	3>逻辑结构设计(领会)(关系模型)
	  1)层次模型-->网状模型-->关系模型-->面向对象模型
	  2)概念设计->模型转换->子模式设计/应用程序设计说明->设计评价->物理设计

	4>物理设计(领会)(存储)
	  具体任务主要是确定数据库在存储设备上的存储结构及存取方法,
	  因DBMS的不同还可能包括建立索引和聚集,以及物理块大小,缓冲区个数和大小,数据压缩的选择等;

	5>数据库实施
	 1)加载数据:收集,分类,整理校验,输入等;

	 2)应用程序设计
	   具有较高稳定性,并具有试运行的数据基础,也具备了应用程序编制与调试的必要条件.
	   这样编写的应用程序具有较高的稳定性和实用性.

	 3)数据库试运行
	   #1.有利于工作人员掌握并熟悉系统;
	   #2.有利于正式运行时避免人为的操作不当等损害;

	6>数据库运行与维护
	  1)系统维护中最困难的工作是数据库的重组与重构;
	  2)目的:保证数据库的正常运行

** 关系数据库设计方法
	1>关系数据库设计过程与各级模式(识记)
	  应用要求->概念模式->逻辑模式(外模式)->内模式(物理模式)

                          ╭#1.实体分析法(自顶向下法);
		          概念设计< #2.属性综合法(自底向上法);
                     ↓ 	  ╰*概念模型(自顶向下,逐步求精);
------------------逻辑设计--------------------------------------------------------------------------

		          模型转换 -------将概念模型等价转换为特定DBMS支持的关系模型,网状模型或层次模型;
抽取或导出   ╮     ↓      ↓
模式的子集,  │     ↓      ↓
以构造不同用户>子模式设计  应用程序设计说明---为可实际运行的应用程序设计提供依据与指导,并作为设计评价的基础;
使用的局部   │       ↓    ↓
数据逻辑结构 ╯       设计评价---------分析并检验模式及子模式的正确性与合理性;

----------------------------------------------------------------------------------------------------
		               ↓    ╭任务:确定数据库在存储设备上的存储结构及存取方法
		            物理设计<
		                    ╰因DBMS的不同还可能包括建立索引和聚集,以及物理块大小,缓冲区个数和大小,数据压缩的选择;


	2>概念结构设计方法(综合应用)
	  1)E-R图的表示方法
	   #1.系(□)-隶属(◇)-系主任(□) 1:1
	   #2.班级(□)-包含(◇)-学生(□) 1:N
	   #3.学生(□)-选课(◇)-课程(□) N:M
	   #4.供应商(□)-供应(◇)-项目(□)-零件(□) M:N:P
	   #5.职工(□)-领导(◇) 1:N(单个实体的1对多联系)

	  2)局部信息结构设计
	   *1.定义:根据需求分析报告中标明的不同用户视图范围所建立的满足该范围内用户需求的信息结构，
	     称为局部信息结构。

	   *2.局部信息结构设计的步骤(***解答题***)
	   ╭ #1.确定局部范围:
	   |    局部范围的主要依据需求分析报告中标明的用户视图范围来确定,往往与子模式范围相对应
       |
	   | #2.选择实体:
	   |    数据分类表是选择实体的直接依据;
	   |	*实体与属性的最大困难是如何区分实体与属性
       |
	  <  #3.选择实体的关键字属性:
	   |    *实体的存在依赖于其关键字的存在;
       |
	   | #4.确定实体之间的联系
	   |    *数据间的联系必须在概念设计时确定;
       |
	   | #5.确定实体的属性
	   ╰    *属性分为标识属性(主属性)和说明属性(一般属性)

	3>逻辑设计方法(综合应用)
	  *逻辑结构设计方法的三项具体工作:
	   *1.将E-R图转化为关系模型;
	   *2.对关系数据模型进行优化;
	   *3.设计面向用户的子模式;

	  1)将E-R图转化为关系模型(解答题**)
	    #1.一个实体转换为一个关系模型,实体的属性作为关系的属性,实体的码作为关系的码;
		#2.一个一对一联系可以转换为一个独立的关系模式,也可以与任意一端对应的关系模式合并;
		#2.一个一对多联系可以转换为一个独立的关系模式,也可以与任意N端对应的关系模式合并;
		#3.一个多对多联系转换为一个关系模式
		#4.三个或以上实体间的一个多元联系可以转换为一个关系模式;
		#5.具有相同码的关系模式可合并;

		步骤：
		 *1.实体名->表名,在对应表名后把图中相连接的属性名依次抄下来;
		    #1.将E-R按实体拆分,列出实体;(找□)用户,
		    #2.将实体的属性,列在实体后面;(归类○)用户:用户id,年龄,用户名

		 *2.确定实体与实体之间的联系是1:N还是M:N:
		    #1.当两个实体是1:N(一对多):在多的关系表后,写上一的关系表的主属性;
		       1的表中的主键是N的那个实体表中的外键
		       (找◇)用户:id,所属用户组(1:N或1:1 用户(N):用户组(1) )

		    #2.当两个实体是M:N(多对多)的关系:
		       就不能在其中一个实体中建外码而是建立一个 中间表 ;
               #1.以两表之间的联系为实体(表名);
               #2.将两边表中的主码作为该表的联合主键
               #3.同联系的属性一起作为该表的属性;
                  *若联系无属性则定义一个属性作为该关系的键(一般定义联系名+ID);

	  2)对关系数据模型进行优化
	    *1.目的:
	       数据库逻辑设计的结果,不是唯一的,
	       要进一步提高数据库应用系统的性能,
	       根据需要适当的修改,调整数据模型的结构;

		*2.优化方法:
	       #1.确定各属性间的函数依赖关系;

		   #2.对于各个关系模式之间的数据依赖进行极小化处理,消除冗余的联系.

	       #3.判断每个关系模式的范式,根据实际需要确定最合适的范式;

		   #4.按照需求分析阶段得到的处理要求,分析这些模式对于这样的应用环境是否合适,
		      确定是否对某些模式进行合并和分解;

		   #5.对关系模式进行必要的分解,提高数据操作的效率和存储空间的利用率;

	  3)设计面向用户的子模式
	    #1.可以通过视图机制在设计用户视图时,重新定义某些属性的别名,使其更符合用户的习惯,以方便使用.
		#2.可以对不同级别的用户定义不同的视图,以保证系统的安全性;
		#3.简化用户对系统的使用;

	4>物理设计方法(识记)
	 1)建立索引(逻辑连接)
	   *1静态建立索引(长期)
	   *2动态建立索引(临时)

	 2)建立聚集(物理聚集)
	   *1.聚集是将相关数据集中存放的物理存储及技术
	   *2.数据聚集结构的一种有效方式是块结构方式
	   *3.数据聚集在一个或多个关系上建立;

	5>简述数据库应用软件设计与实现的基本步骤
	  数据库应用软件设计与开发过程可由
	  需求分析、
	  系统功能与数据库的设计,
	  系统功能与数据库实现,
	  测试与维护等阶段构成;

	6>简述系统测试与维护的作用
	  完成系统的实现工作后,在正式交付用户使用之前,需要对所开发的系统进行必要的测试,验证其是否满足用户的功能要求
	  并根据测试的结果,以及用户的反馈意见,对该系统进行进一步的修改,完善和维护工作;


    7>模式,外模式和内模式的基本对象包括:
      *1.数据库模式
      *2.表
      *3.索引
      *4.视图

* SQL与关系数据库基本操作
** SQL概述
   1>SQL的概念(Structured Query Language, SQL)(选择填空)
     结构化查询语言是专门用来与数据库通信的语言,它可以帮助用户操作关系数据库;
     实现数据库行为是实现数据库行为设计的结果,主要是通过SQL语言完成与本应用功能相关的增、删、改、查等数据库操作，
	 包括为提高数据库操作效率或保护数据库安全而创建的各种数据库对象，
	 例如子查询、视图、触发器(不能施加完整性约束)、存储过程或存储函数等。

   2>SQL的特点(选择填空)
	     ╭#1.SQL不是某个特定数据库供应商专有的语言;
	 特点<#2.SQL简单易学;
	     ╰#3.SQL强大,灵活,可以进行非常复杂和高级的数据库操作;

   3>SQL的组成(数据查询,定义,操纵,控制)

              ╭
              |                           ╭#1.create :创建数据库或数据库对象
              | *1.数据定义语言(DDL)       <#2.alter : 对数据库或数据库对象进行修改;    (对数据库)
              |(Data Definition Language) ╰#3.drop :  删除数据库或数据库对象;
              |
              |
              |                             ╭#1.insert : 将数据插入到表或视图中;(增)
              |                             |#2.delete : 从表或视图中删除数据;(删)
    SQL的组成 <  *2.数据操纵语言(DML)        <                                        (对表中数据项)
              |(Data Manipulation Language) |#3.update : 修改表或视图中的数据;(改)
              |                             ╰#4.select : 从表或视图中检索数据;(查)
              |
              |
              |                         ╭#1.grant : 用于授予权限;
              | *3.数据控制语言(DCL)    <                             (数据库的控制权限)
              |(Data Control Language)  ╰#2.revoke : 用于收回权限;
              ╰

   4>SQL的安装及配置:
      ╭	mysql的启动:
      |	cmd->mysql -u root -p
      |	Enter password: root
     < 	SHOW DATABASES;
      |	//修改密码
      |	ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';
      ╰	*命令不分大小写,但结束时必须用";",退出用/q;或exit;或quit;如果->是换行,结束时输入";"就可以了;

** MySQL预备知识

   1>MySQL使用基础(选择填空)
	 1)关系数据库管理系统(RDBMS)
       优点:体积小,速度快,开放源代码,遵循GPL

   2>架构方式
	 #1.LAMP-->Linux(系统) :  Apache(web服务器) MySQL(数据库管理系统) PHP,Perl,Python(服务器端脚本解释器)
	 #2.WAMP-->windows(系统) :Apache(web服务器) MySQL(数据库管理系统) PHP,Perl,Python(服务器端脚本解释器)

   3>MySQL扩展语言要素(领会)
	 1)常量(不变的值)
	 	 ╭ #1.字符串常量:称为字面值或标量值,用单引号或双引号括起来的字符序列
     	 |    分为ASCII字符串常量(0-255)和Unicode字符串常量(汉字);
         |
     	 | #2.数值常量:整数常量 浮点数常量
     	 |
     	 | #3.十六进制常量:每对十六进制数字被转换为一个字符,其最前面有一个字母'X'(或"x")
        <
     	 | #4.时间日期常量: 用单引号将表示时间的字符串括起来而构成的,例如'2018-06-05'
     	 |
         | #5.位字段值:格式: b'value'->二进制
     	 |
     	 | #6.布尔值: true->1, false->0
     	 |
     	 ╰ #7.NULL值: 无数据

	 2)变量
	    ╭#1.用户变量:用户变量前常添加一个符号@,用于将其与列名区分开;
       <
		╰#2.系统变量:大多数系统变量应用于其他SQL语句中时,必须在系统变量前加两个@

	 3)运算符

	   ╭#1.算术运算符:  +(加),-(减),*(乘),/(除)(取整),%(求模)(取余)
       |
	   |#2.位运算符:  &(位与),|(位或),^(位异或),~(位取反),>>,(位右移),<<(位左移).
      <
	   |#3.比较运算符:=(等于),>(大于),<(小于),>=(大于等于),<=(小于等于),<>(不等于),!=(不等于),<=>(相等或都等于空);
	   |
	   ╰#4.逻辑运算符: NOT或!(逻辑非),AND或&&(逻辑与),OR或||(逻辑或),XOR(逻辑异或)

	 4)表达式
		*表达式是常量,变量,列名,复杂计算,运算符和函数的组合

		╭ #1.字符型表达式:SNO
        |
	    | #2.数值型表达式:
        |
	    | #3.日期型表达式:'2018-07-19'
        |
        |             ╭*1.数学函数------>ABS()
       <              |*2.聚合函数------>COUNT()
        |             |*3.字符串函数---->ASCII()
        |             |*4.时间日期函数-->NOW()
        | #4.内置函数 < *5.加密函数------>ENCODE()
        |             |*6.控制流程函数-->IF()
        |             |*7.格式化函数---->FORMAT()
        |             | *8.类型转换函数-->CAST()
        ╰             ╰*9.系统信息函数-->USER()


	 *.SQL集数据查询、数据定义、数据操纵和数据控制四大功能于一体，
	  其核心主要包含有以下几个部分：

	   *1.数据定义语言

	   *2.数据操纵语言

	   *3.数据控制语言

	   *4.嵌入式和动态SQL规则:规定了SQL语句在高级程序设计语言中使用的规范方法，
	      以便适应较为复杂的应用。

	   *5.SQL调用和会话规则 ：SQL调用包括SQL例程和调用规则，
	      以便提高SQL的灵活性有效性、共享性以及使SQL具有更多的高级语言的特征；
	      SQL会话规则 可使应用程序连接到 多个SQL服务器 中的某一个，并与之交互。

	   *6.基本表是本身独立存在的表，MySQL中一个关系对应一个基本表，
	      一个或多个基本表对应一个存储文件，一个表可以有若干索引，
	      索引也存放在存储文件中。视图是从一个或几个基本表导出的表。

** 数据定义

   1>数据库模型定义(简答题)

	  *只有成功创建数据库之后,才能在数据库中创建数据表,
	   数据表被定义为字段集合数据在表中是按照行和列的格式来存储的,
	   每一行代表一条记录，每一列代表记录中一个字段的取值。

	  1)创建数据库
	   mysql> create database if not exists db_name;

	   使用Create database;或Create schema;语句
	   create {database|schema}[if not exists] db_name  (数据库名)
	   [default]character set[=]charset_name		   (字符集名)
	   [default]collate[=]collation_name			   (排序规则)

	   []表示其内容为可选项;|用于分割花括号中的选项;
	   create database mysql_test;创建mysql_test数据库
	   show databases;查看数据库

	  2)选择数据库
	    use db_name; 从一个数据库跳转到另一个数据库;

	  3)修改数据库
	    alter database db_name;修改数据库名字

		mysql> alter database mysql_test
			-> default character set gb2312       修改字符集
			-> default collate gb2312_chinese_ci; 修改校对规则

        mysql> show variables like '%char%';检查字符集是否修改成功

		mysql> show collation; 检查校对规则是否修改成功

	  4)删除数据库

		mysql> drop database if exists db_name;

	  5)查看数据库
	    show{databases|schemas} [like 'pattem'|where]

		where 查找符合条件

		like  查找关键字:

		mysql> show databases like 'mysql_test';

		mysql> show databases like 'm%';模糊匹配(%->通配符)



	 2>定义表(解答题)
	  1)创建表语句
	    create [temporary(临时表)]table tbl_name(字段名1数据类型,符合完整性约束);

		mysql> use mysql_test;
        Database changed
        mysql> create table if not exists customers
			-> (
			-> cust_id int not null auto_increment,(自增:auto_increment)
			-> cust_name char(50) not null,
			-> cust_gender char(1) not null,
			-> cust_address char(50) null,
			-> cust_contact char(50) null,
			-> primary key(cust_id)                 (主键:primary key(属性名))
			-> );

		mysql> show tables like 'customers';

	  2)更新表
	   *alter table db_name.tbl_name  (选择表)

	   *1 往表中增加一列
   	      add column column_name type limit default value position (操作表)

	      mysql> alter table mysql_test.customers
			  -> add column cust_city char(10) not null default 'Wuhan'after cust_gender;

          *注意:MySQL增加列指定位置时没有BEFORE的用法,第一列可以使用FIRST,非第一列使用AFTER。

	   *2.更改表的列名
	      change column old_name new_name type limit default value ;

		  mysql> alter table mysql_test.customers
			  -> change column cust_gender gender char(1) not null default 'M';

	   *3.修改指定列的默认值
	      alter column column_name set default 'value';

		  mysql> alter table mysql_test.customers
			  -> alter column cust_city set default 'Beijing';

	   *4.更改表中指定列的数据类型,不干涉它的列名.
	      modify column column_name type(数据类型);

		  mysql> alter table mysql_test.customers
			  -> modify column cust_name char(20) first;(首列)

	   *5.删除列表中指定的列
          drop column column_name;

		  mysql> alter table mysql_test.customers
			  -> drop column cust_contact;

	   *6.为表重命名
		 rename to db_name.new_tbl_name;

		 mysql> alter table mysql_test.customers
			 -> rename to mysql_test.backup_customers;

	     rename table db_name.old_tbl_name to db_name.new_tbl_name;(不用alter table)

	  3).删除表
	     drop table if exists tbl_name1,tbl_name2;

		 mysql> drop table if exists backup_customers;

      4).查看表及表中的各列
		show tables like 'tbl_name';(查看表)
		show columns from db_name.tbl_name;(查看指定表的各列)
		desc mysql_test.customers;(这个功能同上) (desc-->describe)

		mysql> show columns from mysql_test.customers;
		mysql> desc mysql_test.customers;

	 3>定义索引(解答题)

	  1)定义
		所谓索引,就是DBMS根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表;

	  2)索引存在的弊端:
	    *1.索引是以文件的形式存储的,DBMS会将一个表的所有索引保存在同一个索引文件中,索引需要占用大量磁盘空间;
		*2.索引在提高查询速度的同时,会降低更新表的速度;

	  3)分类
	    *1.普通索引(Index或key)
		*2.唯一索引(unique) :与普通索引类型不同的是唯一索引的列值必须唯一，但允许为空值。
		*3.主键(primary key)

		*索引通常被创建成单列索引和组合索引;

	  4)索引的创建

	    *1.单列索引:
	    create index index_name
	    ->on db_name.tbl_name(column_name(Length) asc/desc);

        示例:
        在数据库mysql_test的表
		create index index_customers
        -> on mysql_test.customers(cust_name(3) asc);

		*2.组合索引:
		 create index index_name on db_name.tbl_name(column1,column2)

		 mysql> create index index_cust
			 -> on mysql_test.customers(cust_name,cust_id);

		*3.使用create table 语句创建
		 #1.[constraint[symbol]]primary key(index_col_name,....),
		   用于表示在创建新表的同时创建该表的主键;

		 #2.{index|key}index_name(index_col_name,...),
		    用于表示在创建新表的同时创建该表的索引;

		 #3.[constraint][symbol] unique index_name (index_col_name,...);
		   用于表示在创建新表的同时创建该表的唯一性索引

		 #4.[constraint][symbol] foreign key index_name(index_col_name,.);
		   用于表示在创建新表的同时创建该表的外键

		 mysql> create table if not exists seller
			 -> (
			 -> seller_id int not null auto_increment,
			 -> seller_name char(50) not null,
			 -> seller_address char(50) null,
			 -> seller_contact char(50) null,
			 -> product_type int(5) null,
			 -> sales int null,
			 -> primary key(seller_id,product_type),
			 -> index index_seller(sales)
			 -> );

		*4.使用alter table语句创建
		 #1.add{index\key}[index_name](index_col_name,..)
		   用于表示在修改表的同时为该表添加索引

		   mysql> alter table mysql_test.seller
			   -> add index index_seller_name(seller_name);

		 #2.add[constraint[symbol]Primary Key(index_col_name,...)
		   用于表示在修改表的同时为该表添加主键

		 #3.add unique[index|key][index_name](index_col_name,...)
		   用于表示在修改表的同时为该表添加唯一性索引

		 #4.add[constraint[symbol]] foreign key(col_name) references tab2(col_name)
		   用于表示在创建新表的同时为该表添加外键

		 *index_col_name==>column_name

		*5.索引的查看(show index)

		  show{index|indexes|keys}
		  {from|in}tbl_name[{from|in}db_name]
		  [where expr]

		  mysql> show keys from seller;

	    *6.索引的删除

		  #1.drop index index_name on tbl_name;

 		    mysql> drop index index_cust on mysql_test.customers;

		  #2.alter table tbl_name drop primary key 删主键

			mysql> alter table mysql_test.customers
				-> drop primary key,
				-> drop index index_customers;

		  #2.alter table tbl_name drop index index_name  删普通索引

		  #3.alter table tbl_name drop foreign key 删外键

	4.数据更新

	 1>插入数据(解答题)(insert)

	  1)插入行完整列值数据(insert..values)
	   insert tbl_name(col_name,...){values}(expr|Default,...),(..),

	   mysql> insert mysql_test.customers
		   -> values(901,'zhansan','F','beijing','chaoyang');

	  2)插入行部分列值数据(insert..set)
	   insert[into]tbl_name set col_name=expr|Default,...

	   mysql> insert into mysql_test.customers
		   -> set cust_name='lisi',cust_address='wuhai',gender=default;

	  3)插入子查询数据(insert...select)
        //选择值赋给对应字段
        insert into tbl_name2(col_name1,...) select value1,...;
        示例:
        insert mysql_test.infos(user_name,user_city)select 'LiLi','HeBei';
        //将表1中部分数据复制插入到表2中
        insert into tbl_name2(a,c,b...) select a,c,5... from tbl_name1;

	 2>删除一行或多行数据(解答题)(delete)
	   delete from tbl_name
	   where where_condition
	   order by... limit row_count

	   mysql> delete from mysql_test.customers
		   -> where cust_name='lisi';

	 3>修改数据(解答题)(update)
	   update tbl_name
	   set col_name=expr|Default,col_name2=expr|Default,....
	   where where_condition
	   order by... limit row_count

	   mysql> update mysql_test.customers
		   -> set cust_address='wuhanshi'
		   -> where cust_name='zhansan';

	5.数据查询

	 1>select语句
	   select select_expr(要查的值)
			  from table_references (数据来源),
			  where where_condition(数据的选择条件)
			  group by col_name|expr|position(对检索到的记录进行分组)
			  ASC|DESC, with rollup
			  having where_condition (指定组的选择条件)
			  order by col_name|expr|position(对查询结果进行排序)
			  asc/desc,...
			  limit offset row_count|row_count Offset (限制行数)

	  1)列的选择和指定

	    select col_name,col_name2,... from db_name.tbl_name;(查询某表指定列)

		select * from db_name.tbl_name;(查询表中所有列)

		mysql> select cust_name,cust_address,gender
			-> from mysql_test.customers;

		mysql> select * from mysql_test.customers;


	  2)定义并使用列的别名

		col_name as col_alias (列的别名)(这个查询的只是虚表,表中真实的col_name没有变)

		mysql> select cust_address as dizhi
			-> from mysql_test.customers;

	  3)替换查询结果集中的数据(case)

	    case when 条件1 then 表达式1
		       when 条件2 then 表达式2

			 else 表达式

			 end as col_alias;

	    mysql> select cust_name,
			-> case
			-> when gender='F'then 'nan'
			-> else 'nv'
			-> end as sex
			-> from mysql_test.customers;

	  4)计算列值

		mysql> select cust_id+199
			-> from mysql_test.customers;

	 2>聚合函数(系统内置函数)

	  1)count        求组中项数,返回int类型整数

	  2)max   		 求最大值

	  3)min	  		 求最小值

	  4)sum	  	     返回表达式中所有值的和

	  5)avg          求组中值的平均值

	  6)std或stdDev  返回给定表达式中所有值的标准值

	  7)variance	 返回给定表达式中所有值的方差

	  8)group_concat 返回由属于一组的列值连接组合而成的结果

	  9)bit_and       逻辑与

	  10)bir_or		  逻辑或

	  11)bit_xor	  逻辑异或

	  *聚合函数经常与group by联合使用;

	 3>from子句与多表连接查询(综合应用)
	  1)交叉连接,又称笛卡尔积;
		select * from tab1 cross join tbl2;
		select * from tab1,tab2;
		mysql> select * from tab1,tab2;

	  2)内连接
	    tab1 col_name1 比较运算符 tab2 col_name2
	    select some columns(列名)
		from table1
		inner join (内连接)
		table2
		on some conditions(条件)

		mysql> select * from student
			-> inner join tbl_score
			-> on student.studentno=tbl_score.studentno;

		内连接分类:
		*1.等值连接:使用运算符=(*这个是考点)
		*2.非等值连接:使用除=之外的其他比较运算符(>,<,!=)
		*3.自连接:将一个表与它自身进行连接

	   内连接含义:(解答题)
	    内连接是一种最常用的连接类型,它是通过在查询中设置连接条件的方式,
	    来移除查询结果集中某些数据行之后的交叉连接.

	  3)外连接
	   *1.左外连接:在from子句中使用关键字left outer join或left join;(以左表为基表)

		   mysql> select * from student left join tbl_score
			   -> on student.studentno=tbl_score.studentno;  (student是基表)

	   *2.右外连接:在from子句中使用关键字right outer join或right join;(以右表为基表)

		  mysql> select * from student right join tbl_score
			  -> on student.studentno=tbl_score.studentno;   (tbl_score是基表)


	 4>where子句与条件查询

	  1)比较运算: 比较两方有null值除<=>这个符号.,其他返回unknown.<=>返回true/false;

	  2)条件查询:
	    mysql> select * from mysql_test.customers
			-> where gender='F';

	  3)查询范围(between and)
	    *1.当查询的过滤条件被限定在值的某个范围时,可以使用关键字"between"
		   expression [NOT] BETWEEN expression1 AND expression2
		   当不使用关键字“NOT”时，值在表达式expression1和expression2之间（包括这两个值）
		   如果使用关键字“NOT”时，其返回值正好相反。<expression1 或 >expression2

		   mysql> select * from mysql_test.customers
		       -> where cust_id between 900 and 901;

		*2.使用关键字"in" 可以指定一个值的枚举表,该表中会列出所有可能的值.
		  mysql> select * from mysql_test.customers
			  -> where cust_id in(900,901,908);

	  4)判定空值
	    *is null
		 mysql> select cust_name from mysql_test.customers
			 -> where cust_contact is null;

	  5)子查询
		*1.根据返回结果分类:(***解答题***)

	       #1.表子查询:返回的结果集是一个表。

		   #2.行子查询:返回的结果集是带有一个或多个值的一行数据。

		   #3.列子查询:返回的结果集是一列数据，该列可以有一行或多行，但每行只有一个值。

		   #4.标量子查询:返回的结果集仅仅是一个值。

		*2.子查询结合关键字"in" 使用的子查询,主要用于判断一个给定的值是否存在于子查询的结果集中.

		   语法: expression(表达式) in subquery(子查询集)

		   mysql> select studentno,student_name
			   -> from student where studentno in    (找到外键,用外键连接两个表)
			   -> (select studentno from tbl_score where score>80); (循环嵌套选择列)


		   取反  (<=80)
		   mysql> select studentno,student_name
			   -> from student
			   -> where studentno not in(select studentno from tbl_score where score>90);

		*3.结合比较运算符使用子查询

			语法:expression{=|<=|>|>=|<=>|<>|!=}{all|some|any}(subquery)(子查询语句)

			*:in-> =any-> =some;
			mysql> select studentno,student_name
				-> from student
				-> where studentno =any(select studentno from tbl_score where score>80);

			mysql> select studentno,student_name
				-> from student
				-> where studentno =some(select studentno from tbl_score where score>80);

			*:not in-><>all
			mysql> select studentno,student_name
				-> from student
				-> where studentno <>all(select studentno from tbl_score where score>90);

			*:=(精确到条目)
			mysql> select studentno,student_name
				-> from student
				-> where studentno =(select studentno from tbl_score where score=90);

		*4.结合关键字"exists"使用的子查询
		   语法:exists(subquery)
		   mysql> select studentno,student_name
			   -> from student
			   -> where exists(select studentno from tbl_score where student.studentno=tbl_score.studentno);

		*5.指定查询条件的WHERE子句

	      在指定查询条件的WHERE子句中，可以使用子查询的结果集作为过滤条件的一部分，
		  并且子查询通常会与关键字“IN”“EXIST”和比较运算符结合使用。

		  #1.结合关键字“IN”使用的子查询：主要用于判定一个给定值是否存在于子查询的结果集中。

		  #2.结合比较运算符使用的子查询：主要用于将表达式的值和子查询的结果进行比较运算。

		  #3.结合关键字“EXISTS”使用的子查询：主要用于判定子查询的结果集是否为空。

	 5>group by子句与分组数据(综合应用)
	1)语法:
	  /**
	   * col_name1   指定聚合函数的条件依据
	   * col_name2   指定用于分组的选择列
	   * expr        指定用于分组的表达式
	   * position    指定用于分组的列在SELECT语句结果集中的位置，通常是一个正整数
       * asc|desc    ASC表示升序排列， DESC表示降序。默认ASC
       * with rollup 可选项，指定在结果集中不仅包含由GROUP BY子句分组后的数据行，
       * 还包含各分组的汇总行，以及所有分组的整体汇总行，可以得到每个分组以及每个分组汇总级别的值
       * 作用:去重复,查找表CT中有多少讲师记录(按姓名分组,排重)
	   */
	  select col_name1,...,from tbl_name
	  group by{col_name2|expr|position}[asc|desc],...[with rollup]

      示例:将表TC按课程和讲师姓名分组,根据讲师姓名获取每位讲师的授课项数;
       mysql> select CName,count(*) as '授课项数'
           -> from CT group by CName,CTitle;
           +-------+--------+
           | CName | 授课项数|
           +-------+--------+
           | 小涵  |      1 |
           | 爱敏  |      2 |
           | 王月  |      1 |
           +-------+--------+

      示例:将表TC按课程和讲师姓名分组,根据讲师姓名获取每位讲师的授课项数及授课汇总;
      mysql> select CTitle,CName,count(*) as '授课项数'
          -> from CT group by CName,CTitle with rollup;//(汇总)(有总字就加这个)

          +----------+-------+----------+
          | CTitle   | CName | 授课项数 |
          +----------+-------+----------+
          | C++      | 爱敏  |        1 |
          | 数据结构  | 爱敏  |        1 |
          | NULL     | 爱敏  |        2 |--->爱敏授课数总计2项
          | 信息系统  | 王月  |        1 |
          | NULL     | 王月  |        1 |--->王月授课数总计1项
          | 数据库    | 小涵  |        1 |
          | NULL     | 小涵  |        1 |--->小涵授课数总计1项
          | NULL     | NULL  |        4 |--->全部授课数共计4项
          +----------+-------+----------+

      *简述对于 GROUP BY 子句的使用，需要注意哪些内容？
** GROUP BY 子句可以包含任意数目的列，使得其可对分组进行嵌套，为数据分组提供更加细致的控制。
** 如果在 GROUP BY 子句中嵌套了分组，那么将按 GROUP BY 子句中列的排列顺序的逆序方式依次进行汇总，
         并将在最后规定的分组上进行一个完全汇总。

** GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式，但不能是聚合函数。

** 除聚合函数之外， SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。

** 如果用于分组的列中含有 NULL 值，则 NULL 将作为一个单独的分组返回；
         如果该列中存在多个 NULL 值，则将这些 NULL 值所在的行分为一组。

	 6>having子句(综合应用)

	  1)having子句 过滤分组;可以包含聚合函数,在数据分组后进行过滤;

	  2)where子句 过滤数据行,不可以包含聚合函数,在数据分组前进行过滤;

	  mysql> select cust_name,cust_address
		  -> from mysql_test.customers
		  -> group by cust_address,cust_name
		  -> having count(*)<=3; (count是计算行数的)
	  HAVING 子句与 WHERE 子句两者之间存在哪些差异？：
** WHERE 子句主要用于过滤数据行，而 HAVING 子句主要用于过滤分组，
        即 HAVING 子句可基于分组的聚合值而不是特定行的值来过滤数据。

** HAVING 子句中的条件可以包含聚合函数，而 WHERE 子句中则不可以。

** WHERE 子句会在数据分组前进行过滤， HAVING 子句则会在数据分组后进行过滤。因而，
        WHERE 子句排除的行不包含在分组中，这就会可能改变计算值，从而影响 HAVING 子句基于
        这些值过滤掉的分组。

	 7>order by子句(指定排序的列)(聚合函数要用(如人数))

		order by col_name|expr|position ASC|DESC

		mysql> select cust_name,gender from mysql_test.customers
			-> order by cust_name desc,cust_address desc;

	 8>limit子句
       /*
        * 使用limit子句限制select语句返回的行数
        * limit row_count: 取row_count行,从第一行开始(起始行的位置0代表第1行)
        * row_count offset:取row_count行,从offset+1行起,
        */
        limit {row_count | row_count offset}

        示例:从表CT的第1行起取2行数据;
        mysql> select CNO,CTitle from CT order by CNO
            -> limit 2 offset 0;(或写成 limit 2,0)

            +-----+----------+
            | CNO | CTitle   |
            +-----+----------+
            |   1 | 数据库    |
            |   2 | 数据结构  |
            +-----+----------+

     9> Order by 和Group by子句的差别汇总
             +---------------+-------------------------------------+
             | Order by子句  |           Group  by子句              |
             +---------------+-------------------------------------+
             | 排序产生的输出 |     分组行,但输出可能不是分组的排序    |
             +---------------+-------------------------------------+
             |任意列都可以使用|     只可能使用选择列或列表达式         |
             +---------------+-------------------------------------+
             | 不一定需要     |若与聚合函数一起使用列或表达式,则必须使用|
             +---------------+-------------------------------------+
	6.视图

	 1>视图概念:

	  1)视图是数据库中的一个对象,它是数据库管理系统提供给用户的以多种角度观察数据库中数据的一种重要机制.

	  2)视图不是数据库中真实的表,而是一张虚拟表,其自身并不存储数据.

	 2>使用视图的优点:

	  1)集中分散数据

	  2)简化查询语句

	  3)重用SQL语句

	  4)保护数据安全

	  5)共享所需数据

	  6)更改数据格式

	 3>创建视图(综合应用)

	  create or replace view_name[(col_list)]
	  as select statement(条件)
	  [with check option] 可选项,指定在可更新视图上必须符合..条件时使用 (不常用)

	  mysql> create or replace view mysql_test.customers_view
		  -> as select * from mysql_test.customers
		  -> where gender='M'
		  -> with check option;

	 4>删除视图(综合应用)

	  drop view[if exists]
	  view_name [,view_name]...
	  [restrict|cascade] 限制条件 可选项

	  mysql> drop view if exists
		  -> mysql_test.coustomers_view;

	 5>修改视图定义(综合应用)

	  alter view view_name[(col_list)]
	  as select statement(条件)
	  [with check option] 可选项,指定在可更新视图上必须符合..条件时使用 (不常用)

	 6>查看视图定义(综合应用)
	  show create view view_name

	 7>更新视图数据(综合应用)

	  1)插入行完整列值数据(insert..values)
	   insert view_name(col_name,...){values}(expr|Default,...),(..),

	   mysql> insert mysql_test.customers_view
		   -> values(901,'zhansan','F','beijing','chaoyang');

	  2)更新表数据(insert..set)
	   update view_name
	   set col_name=expr|Default,col_name2=expr|Default,....
	   where where_condition
	   order by... limit row_count

	   mysql> update mysql_test.customers_view
		   -> set cust_address='wuhanshi'
		   -> where cust_name='zhansan';

	  3)删除视图表数据(delete..from)

		delete from view_name
	    where where_condition
	    order by... limit row_count

	    mysql> delete from mysql_test.customers_view
		    -> where cust_name='lisi';


	 8>查询视图数据(综合应用)

		mysql>select cust_name,cust_address
			-> from mysql_test.customers_view
			-> where cust_id =905;

     9>视图用于查询检索的主要体现
       *1.利用视图简化复杂的表连接
       *2.使用视图重新格式化检索出的数据
       *3.使用视图过滤不想要的数据

* 数据库编程
** 存储过程

	 1>存储过程的基本概念(填空)

	   1)存储过程是一组为了完成某项特定功能的SQL语句集,
	     其实质就是一段存储在数据库中的代码.
		 它可以由声明式的sql语句和过程式的sql语句组成.

		  *1.声明式的sql语句:create,update,select;

		  *2.过程式的sql语句:case if else

		2)优点

		 *1.可增强SQL语言的功能和灵活性;

		 *2.良好的封装性;

		 *3.高能性;

		 *4.可减少网络流量;

		 *5.可作为一种安全机制来确保数据的安全性和数据的完整性;

	 2>创建存储过程(解答题)

	  1)delimiter命令(分隔符)

	    delimiter$$-->用户自己定义结束符(替换";"告诉系统语集中的";",并不是结束)
		   mysql> delimiter $$  (使用$$替换成$$)
		   mysql> show databases;
			   -> $$

	  2)使用create procedure语句创建存储过程;

		create procedure sp_name (在默认数据库中创建)
		([proc_parameter[,...]]) (指定存储过程的参数结果)
		routine_body (存储过程的主体部分,也称存储过程体)

		[in|out|inout]param_name type(设置参数)

		mysql> use mysql_test;(指定默认数据库)
		Database changed
		mysql> delimiter $$(设定结束符)
		mysql> create procedure sp_update_sex (in cid int,csex char(1))
			-> begin (语句集开始)
			-> update coustomers set gender=csex where cust_id=cid;(根据id号修改性别)
			-> end $$ (语句集结束)

	 3>存储过程体(选择填空)

	  1)使用declare语句声明局部变量

		declare var_name[,...] type [default value] (名字,类型及默认值)

		->begin
		  declare cid int(10);(存储过程的开头处声明,作用范围仅限于begin..end内)
		->end

	  2)使用set语句为局部变量赋值

		set var_name=expr[,var_name=expr]
		set cid=910;

	  3)使用select..into语句把选定列的值直接存储到局部变量中

		select col_name[,...](指定列名)
		into var_name[,...](指定要赋值的变量名)
		table_expr	(表示select语句中的from子句及后面的语法部分)

		*.存储过程体中的SELECT…INTO语句返回的结果集只能有一行数据。

	  4)流程控制语句

	   *1.条件判断语句
	    if...then...else语句--> if 条件 then 表达式1 else 表达式2

		case语句--> case 条件1 when 条件 then

	   *2.循环语句

	    while语句--> while 条件 表达式(累加/减) end while

		repeat语句--> repeat 表达式   end repeat

		loop语句--> loop 表达式  end loop

		iterate语句--> 用于表示退出当前循环,进行下一次循环(同continue)


	  5)使用declare cursor语句---声明游标

	   declare cursor_name  (指定要创建的游标名称)
	   cursor for select_statement

	  6)使用open语句--------------打开游标
	    open cursor_name (指定要打开的游标)

	  7)使用fetch...into语句------读取数据
		fetch cursor_name (读取被指定的已打开的游标)
		into var_name[,var_name]...(指定存放数据的变量名)

	  8)使用close-----------------关闭游标
	    close cursor_name

      简述在 MySQL 中使用游标的过程(解答题)
      #1.声明游标：用 DECLARE CURSOR 语句创建游标;
      #2.打开游标：用 OPEN 语句打开游标;
      #3.读取数据：用 FETCH...INTO 语句从中读取数据。
         FETCH 语句是将游标指向的一行数据赋给一些变量，
         这些变量的数目必须等于声明游标时 SELECT 子句中选择列的数目。
         游标相当于一个指针，它指向当前的一行数据;
      #4.关闭游标：用 CLOSE 语句关闭游标;

	 4>调用存储过程(解答题)

	   使用call语句调用存储过程
	   call sp_name([palameter[,...]]) (指定被调用的存储过程的名称及当下要用的参数)
	   call sp_name[()]

	   call sp_update_sex(909,'M');

	 5>删除存储过程(选择填空)
	   使用drop procedure语句删除存储过程

	   drop procedure [if exists] sp_name;
** 存储函数

	 1>存储函数的基本概念(填空选择)

	   存储函数与存储过程一样,是由SQL语句和过程式语句的代码片段.

	   1)简述存储函数和存储过程的区别

	    *1.存储函数不能输出参数,这是因为存储函数自身就是输出参数;存储过程可以拥有输出参数
	    *2.存储函数可以直接调用,不需要call语句,存储过程的调用需要call语句进行
	    *3.存储函数必须包含一条return语句,存储过程不允许有return语句

	 2>创建存储函数(解答题)
		create function sp_name([func_parameter[,...]]) (指定存储函数的参数)
		returns type  (声明存储函数返回值的数据类型,type指定返回值的数据类型)
		routine_body (指定函数的主体部分)

		param_name type

		mysql> use mysql_test

		Database changed
		mysql> delimiter $$
		mysql> create function fn_search(cid int)
			-> returns char(20)
			-> deterministic
			-> begin
			-> declare sex char(20);
			-> select gender into sex from customers
			-> where cust_id=cid;
			-> if sex is null then
			-> return(select'meiyou');
			-> else if sex='F' then
			-> return(select 'nvhai');
			-> end if
			-> ;
			-> end if;
			-> end $$

	 3>调用存储函数(填空选择)
	  select sp_name([func_parameter[,...]])

	  select fn_search(903)


	 4>删除存储函数(填空选择)

	   drop function[if exists] sp_name;

* 数据库安全与保护
** 数据库完整性

	 1>数据库完整性(选择填空)
	  数据库完整性是指数据库中数据的正确性和相容性.

	 2>完整性约束条件作用对象(选择填空)
	   1)列级约束:对列的类型,取值范围,精度等的约束
	   2)元组约束:元组(行)中各个字段之间的相互约束
	   3)表级约束:若干元组(行),关系(表)之间的联系的约束;

	 3>定义与实现完整性约束(解答题)

	   1)实体完整性约束
	     在mysql,实体完整性是通过主键约束和后选键约束实现的

		 主键列必须遵守的规则
		  *1.每一个表只能定义一个主键;
		  *2.主键的值(键值)必须能够唯一标志表中的每一行记录,且不能为NULL;
		  *3.复合主键不能包含不必要的多余列;
		  *4.一个列名在复合主键的列表中只能出现一次;

	   2)参照完整性约束
		 references tbl_name(指定外键所参照的表名)
		 (index_col_name,...)(指定外键名)
		 [on delete reference_option(restrict|cascade|set null|no action)]
		 [on update restrict|cascade|set null|no action](指定实现完整性约束的策略)

		 reference_option:(限制语句包括以下几种)
		 *1.restrict :限制策略(限制删除和更新主键或外键)
		 *2.cascade  :级联策略(将被参照表的外键删除)
		 *3.set null :置空策略(将参照表的主键设为空,被参照表才能删除外键)
		 *4.no action:不采取实施策略(不允许操作)

		 mysql> use mysql_test       (指定数据库mysql_test)
				Database changed
		 mysql> create table orders  (创建表orders)
			 -> (					 (以下指定orders表中的各属性列)
			 -> order_id int not null auto_increment,
			 -> order_product char(50) not null,
			 -> order_product_type char(50) not null,
			 -> cust_id int not null,
			 -> order_date datetime not null,
			 -> order_price double not null,
			 -> order_amount int not null,
			 -> primary key(order_id),       (给orders表设置主键)
			 -> foreign key(cust_id)		 (给orders表设置外键)
			 -> references customers(cust_id)(开始参照完整性约束,指定参照表)
			 -> on delete restrict			 (不允许删除外键)
			 -> on update restrict			 (不允许更换外键)
			 -> );

			*unique key index_name 候选键

	     简述在指定外键时，需要遵守的规则(解答题)
         *1.被参照表必须已经用一条 CREATE TABLE 语句创建了，或者必须是当前正在创建的表。
            如若是后一种情形，则被参照表与参照表是同一个表，这样的表称为自参照表，
            这种结构称为自参照完整性。

         *2.必须为被参照表定义主键。

         *3.必须在被参照表的表名后面指定列名或列名的组合。这个列或列组合必须是这个被参照表的主键或候选键。

         *4.尽管主键是不能够包含空值的，但允许在外键出现一个空值。这意味着，
            只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。

         *5.外键中的列的数目必须和被参照表的主键中的列的数目相同。

         *6.外键中的列的数据类型必须和被参照表的主键中的对应列的数据类型相同。

	   3)用户完整性约束

	     *1.not null:非空约束

		 *2.check :检查约束

		 *3.触发器

	   4)命名完整性约束(选择填空)
	     语法格式是：constraint[symbol]指定的约束名字

		 其中，语法项“symbol”是指定的约束名字，
		 这个名字是在完整性约束说明的前面被定义，其在数据库里必须是唯一的。
		 倘若没有明确给出约束的名字，则MySQL自动创建一个约束名字。需要注意的是，
		 只能给基于表的完整性约束指定名字，而无法给基于列的完整性约束指定名字。
		 因此，基于表的完整性约束比基于列的完整性约束更受欢迎.

		 *1.只能给基于表的完整性约束指定名字
		 *2.无法给基于列的完整性约束指定名字

	   5)更新完整性约束(解答填空)
	     使用alter table语句更新与列或表有关的各种约束.

		 *1.完整性约束不能直接被修改.(先删除,再增加)

		 *2.使用alter table语句,可以独立地删除完整性约束,而不会删除表本身.
		    (drop table语句删除一个表,则表中所有的完整性约束都会被自动删除);
** 触发器
	  1>创建触发器

		1)概念:是用户定义在关系表上的一类由事件驱动的数据库对象,
		  也是一种保证数据完整性的方法,任何对表的修改操作均为数据库服务器 自动激活 相应的触发器,
		  触发器与表的关系十分密切,其主要作用是实现主键和外键不能保证的复杂的参照完整性和数据的一致性，
		  从而有效地保护表中的数据;(例:更新被参照表,参照表就会自动更新)

	    2)使用create trigger语句创建触发器

		  create trigger
		  trigger_name  (指定触发器名字)
		  trigger_time  (指定触发时间)
		  trigger_event (指定触发事件)
		  on table_name (指定触发对象(触发器相关的表名))
		  for each row  (指定对于受触发事件影响的每一行都要激活触发器的动作)
		  trigger_body; (指定触发器动作的主体)

		  mysql> create trigger customers_insert_trigger
			  -> after insert
			  -> on mysql_test.customers for each row
			  -> set @str='one customer added!';

		  select @str


	  2>使用触发器(解答实操)

	   1)insert 触发器
	     在insert触发器代码内,可引用一个名为new的虚表,来访问被插入的行
		 在before insert触发器中,new中的值可以被更新;

		 例:在mysql_test的表customers中重新创建触发器customers_insert_trigger,
		    用于每次向表customers插入一行数据时,将用户变量str的值设为新插入客户的id号;

		 mysql> create trigger mysql_test.customers_insert_trigger
			-> after insert on mysql_test.customers for each row
			-> set @str=new.cust_id;

         INSERT触发器可在INSERT语句执行之前或之后执行,使用该触发器时,需要注意以下几点:
         *1.在INSERT触发器代码内，可引用一个名为NEW（不区分大小写）的虚拟表，来访问被插入的行。
         *2.在BEFORE INSERT触发器中，NEW中的值也可以被更新，即允许更改被插入的值。
         *3.对于AUTO_INCREMENT列，NEW在INSERT执行之前包含的是0值，在INSERT执行之后将包含新的自动生成值。

	   2)delete 触发器

		 在delete触发器代码内,可引用一个名为old的虚表,来访问被删除的行

		 mysql> create trigger mysql_test.customers_insert_trigger
			 -> after delete on mysql_test.customers for each row
			 -> set @str=old.cust_id;

	   3)update 触发器
	     在update触发器代码内,可以引用old的虚表来访问执行前的值,也可以用new虚表来访问更新后的值;

		 注:UPDATE触发器可在UPDATE语句执行之前或之后执行。
		    使用该触发器时，需要注意：当触发器涉及对触发表自身的更新操作时，
			只能使用BEFORE UPDATE触发器，而AFTER UPDATE触发器将不被允许。

		  mysql> create trigger mysql_test.customers_update_trigger
			 -> before update on mysql_test.customers for each row
			 -> set new.cust_address=old.cust_contact;

	  3>使用drop语句删除触发器
	    drop trigger[if exists]
		database_name.trigger_name);(指定触发器所在数据库和触发器的名称

		mysql> drop trigger if exists mysql_test.customers_insert_trigger;
** 安全性与访问控制

	 1>用户账号管理(选择填空)

	   1)root用户:
	     mysql> select user from mysql.user;

	   2)使用create user语句来创建一个或多个 MySQL 账户，并设置相应的口令

	     CREATE USER user[identified by [PASSWORD]'password'] (可选项,指定用户账号对应口令通过密码识别)

         *语法格式介绍如下：
         *1."user"指定创建用户账号,其格式为'user_name'@'host_name'其中user_name表示用户名
            host_name表示主机名,及用户连接MySql时所在的主机的名字,如果在创建的过程中,
            只给出账户中的用户名,而没有指定主机名,则主机名会默认为'%',其表示一组主机.

         *2."identified by子句"是可选项,用于指定用户账号对应的口令,若该用户账号无口令,则可省略;

         *3.关键字 "PASSWORD"是可选项,用于指定散列口令,及若使用明文设置口令时,可忽略password关键字;

         *4.语法项 password指定用户账号的口令,其在identified by或PASSWORD关键字之后,
            设定的口令值可以是只有字母和数字组成的明文,也可以是通过PASSWORD()函数得到的散列值;

		3)使用select password(num) 获取散列值
		  mysql> select password(456);


		4)使用drop user 'user_name'@'host name'删除用户
		  mysql> drop user zhangsan@NorthStar;

	    例:在Mysql服务器中添加两个新用户,其用户名分别为zhangsan和lisi,
	       他们的主机名为localhost(这个操作时必须是真实主机名),
		   用户zhangsan的口令为123,用户lisi的口令为对明文456
		   使用password()函数加密返回的散列值;

		   mysql> select password(456);(获取456的散列值)
		   mysql> create user 'zhangsan'@'NorthStar' identified by '123',
			   -> 'lisi'@'NorthStar'identified by password
			   -> '*531E182E2F72080AB0740FE2F2D689DBE0146E04';

	    5)使用rename user语句修改一个或多个已经存在的用户账号。
		  rename user old_user (已存在的名字)
		  to new_user (修改后的名字)
		  [,old_user to new_user]...

		  mysql> rename user 'zhangsan'@'NorthStar' to 'wangwu'@'NorthStar';

		6)使用set password 语句修改用户登录口令
		  update set password for 'user_name'@'localhost'
		  =password('new_password')|'encrypted password'

		  mysql> set password for 'wangwu'@'NorthStar'=password('123');

	    *1.MySQL的用户账号及相关信息都存储在一个名为mysql的MySQL数据库中,
		   这个数据库里有一个名为user的数据表,包含了所有用户账号.
		   并且它用一个名为user的列存储用户的登录名。

		*2.mysql安装时，设置用户名为“root”，作为一个新安装的系统，当前只有一个名为root的用户。
		   这个用户是在成功安装MySQL服务器后，由系统创建的，并且被赋予了操作和管理MySQL的所有权限。
		   因此，root用户拥有对整个MySQL服务器完全控制的能力。

	 2>账号权限管理(选择填空)
	   1)使用grant语句为用户授权(grant...to)

		 grant priv_type(用于指定权限名称)
		 [column_list](用于指定授权表中具体的列)
		 [,priv_type[col_list]]
		 on[object_type] priv_level(指定类别及级别)
		 to user_specification[,user-specification](用于设定用户口令与密码[1])
		 [with grant option] (实现权限的转移和限制)(可以授权给别人)

	     [1]user[identified by [password]'password']

		 mysql> grant select(cust_id,cust_name)  --列级授权
		  	 -> on mysql_test.customers
			 -> to 'wangwu'@'NorthStar';

	   2)在grant语句中使用with子句实现权限转移(grant...to(授权用户)...with(授权转移)

	     例:授予当前系统中一个不存在的用户zhou在数据库mysql_test表customers上拥有select和update的权限,
		    并允许其可以将自身的这个权限授予其他用户;

		 mysql> grant select,update				 --表级权限
			 -> on mysql_test.customers
			 -> to'zhou''NorthStar'identified by '123'
			 -> with grant option;


		 mysql> grant all						 --数据库级别权限
		 	 -> on mysql_test.*
			 -> to'wangwu'@'NorthStar';

		例:授予系统中已存在的wangwu拥有创建用户的权限


	  3)在此语法格式中:语法项“priv_level”:用于指定权限的级别，其可以授予的权限有这样几个：
	    列权限、表权限、数据库权限和用户权限。

		*1.授予表权限时，可授予的权限有：
		   SELECT、INSERT、DELETE、UPDATE、REFERENCES、CREATE、ALTER、INDEX、DROP、ALL。
		*2.授予列权限时,只可授予SELECT、INSERT和UPDATE这三种权限,同时权限的后面要加上列名column_list。
		*3.授予数据库权限时，可授予的权限除了可以指定为授予表权限时的所有值之外，还可以是下面这些值:
		   REATE TEMPORARY TABLES、CREATE VIEW、SHOW VIEW、CREATE ROUTINE、
		   ALTER ROUTINE、EXECUTE ROUTINE、LOOK TABLES。

		*4.最有 效率 的权限是 用户权限 ,授予用户权限时,除了可以指定为授予数据库权限时的所有值之外
		   还可以是下面这些值：CREATE USER、SHOW DATABASES。


		mysql> grant create user
			-> on *.*
		    -> to 'wangwu'@'NorthStar';

	  3)使用revoke语句撤销用户权限
        *使用Revoke语句必须拥有mysql数据库的全局 create user权限或 update 权限;
		revoke priv_type(用于指定要收回权限名称)
		 [column_list](用于指定要收回权限列)
		 [,priv_type[col_list]]
		 on[object_type] priv_level(指定要收回权限类别及级别)
		 from user_specification[,user-specification](用于设定被收回权限的用户)

		 mysql> revoke select
			 -> on mysql_test.customers
			 -> from 'wangwu'@'NorthStar';


** 事物与并发处理
	 1>事务的概念
	    事务是用户定义的一个数据操作序列,这些操作可作为一个完整的工作单元,
		要么全部执行,要么全部不执行,是一个不可分割的工作单位.
		事务中的操作一般是对数据的更新操作,包括增,删,改.

		程序(静止)-执行->事务(动态);

		*.用户显示定义事务的语句

		以begin transaction语句开始;

		以commit(提交)语句或rollback(回滚)语句结束;

	 2>事务的特征(ACID)(解答题)

	   1)原子性：事务的原子性保证事务包含的一组更新操作是原子不可分的,
	             即事务是不可分割的最小工作单位，所包含的这些操作是一个整体;(原子不可分)

	   2)一致性:要求事务必须满足数据库的完整性约束,且事务执行完毕后将数据库由一个一致性状态
	            转变到另一个一致性状态。其中，数据库的一致性状态是一种以一致性规则为基础的逻辑属性。

	   3)隔离性:隔离性要求事物是彼此独立的,隔离的,即一个事务的执行不能被其他事务所打扰.
	            一个事务对数据库变更的结果必须在commit后,另一个事务才能存取.

	   4)持续性:持续性也称为永久性，是指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，
	            且接下来的其他操作或故障不应该对其执行结果有任何影响。

	 3>并发操作问题

	   1)丢失更新问题
	     事务T2的提交结果会破坏T1提交的结果;

	   2)不可重复读
	    *1.事务T1读取某一数据后,事务T2对其做了修改,当事务T1再次读该数据时,得到与前一次不同的值。

		*2.事务T1按一定条件从数据库中读取了某些数据记录后,事务T2删除了其中部分记录，
		   当事务T1再次按相同条件读取数据时，发现某些记录神秘地消失了。

		*3.事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，
		   当事务T1再次按相同条件读取数据时，发现多了一些记录。

	   3)读"脏"数据
	     *.设有两个事务T1和T2,读"脏数据"是指,事务T1修改某一数据,并将其写回磁盘,
		   事务T2读取同一数据后,事务T1由于某种原因被撤销,这时事务T1已经修改过的数据恢复原值,
		   事务T2读取到的数据就与数据库中的数据不一致,则事务T2读到的数据就为"脏数据",
		   即不正确的数据,所以在DB技术中,"脏数据"是指已提交随后又被撤销的数据;

	   4)并发控制(***解答题***)
	    DBMS必须对并发操作提供一定的控制,以防止它们彼此干扰,从而保证数据库的正确性不被破坏,
	    避免数据库的不一致性,这种机制就称为"并发控制"

	  4>封锁

	   *含义:
	   一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权

	   事物需要封锁时,事物通过向系统请求对它所希望的数据对象加锁,以确保它不被非预期改变.

	   1)排他锁(X锁),用于写操作;(阻止其他事务进行写操作)

	   2)共享锁(S锁),用于读操作;(所有事务都可以读)

	   我们通常以粒度来描述封锁的数据单元的大小

	   数据单元越大,粒度越小,,并发性就越高,软件的复杂性和系统开销也就越大;

	   3)在多个用户同时使用 MySQL 数据库的情况下，为了得到一个一致的备份，
	     需要在指定的表上使用 LOCK TABLES table_name READ 语句做一个读锁定,
		 以防止在备份过程中表被其他用户更新；

		 而当恢复数据时，则需要使用 LOCK TABLES table_name WRITE语句做一个写锁定，
		 以避免发生数据冲突.在数据库备份或恢复完毕之后需要使用 UNLOCK TABLES 语句
		 对该表进行解锁。


	   3)封锁的级别(隔离度)

	    0级封锁:不重写其他非0级封锁事务的未提交的更新的数据(实用价值低)

		1级封锁:不允许重写未提交的更新数据,防止了丢失更新的发生;

		2级封锁:既不重写也不读未提交的更新数据(防止了读脏数据);

		3级封锁:不读未提交的更新数据,不写任何(包括读操作)未提交数据;


	   4)封锁引起的问题(死锁和活锁)(***解答题***)

	     封锁带来的一个重要问题是可能引起"活锁"和"死锁"

	     在并发事物处理过程中,由于锁会使一事物处于等待状态而调度其他事物处理,因而该事物可能会因优先级低而永远
	     等待下去,这种现象称为"活锁",活锁问题的解决与调度算法有关每一种最简单的办法就是"先来先服务",(优先级问题)

	     两个以上事物循环等待被同组中另一事物锁住的数据单元的情形,称为"死锁"(一个用户A 访问表A(锁住了表A),
	     然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，
	     它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了.)(互访,但互不释放锁)

	     活锁--先来先服务

		 死锁--预防

		  *1.一次性锁请求;

		  *2.锁请求排序;

		  *3.序列化处理;

	      *4.资源剥夺;

	   5)造成数据库运行事务异常中断的因素
	     *1.计算机硬件故障
	     *2.计算机软件故障
	     *3.病毒
	     *4.人为无操作
	     *5.自然灾害
	     *6.盗窃

      6)客串行性
        在数据库系统中,可串行性就是并发执行的正确性准则,即当且仅当一组事物的并发执行调度是可串行的,
        才认为是正确的;

	  7)简述封锁的工作原理(解答题)
        *1.若事务 T 对数据 D 加了 X 锁，则所有别的事务对数据 D 的锁请求都必须等待直到事务 T 释放锁。
        *2.若事务 T 对数据 D 加了 S 锁，则别的事务还可对数据 D 请求 S 锁，
          而对数据 D 的 X锁请求必须等待直到事务 T 释放锁。
        *3.事务执行数据库操作时都要先请求相应的锁，即对读请求 S 锁，对更新请求 X 锁。
          这个过程一般是由 DBMS 在执行操作时自动隐含地进行。
        *4.事务一直占有获得的锁直到结束时释放。

      7)两段封锁法(Tow-Phase Locking,2PL)
        封锁时一种并发控制技术,而可串行是并发控制的正确性标准,其中两段封锁法(2PL)
        是一种最简单而有效的保障封锁其调度是可串行性的方法;

	 5>备份与恢复

	    1)数据备份是指通过导出数据或者复制表文件的方式来制作数据库的复本;

		2)数据库恢复则是当数据库主线故障或遭到破坏时,将备份的数据库加载到系统,
		  从而使数据库从错误状态恢复到备份时的正确状态.

		  数据库的恢复是以备份为基础的,它是与备份相对应的系统维护和管理操作;

		3)使用select into...outFile语句备份数据(拷出)
		  select * into outFile 'file_name' (文件名称)
		  export_options  (配置文件表达式[1])
		  | into dumpfile 'file_name'
		  [1]
		  [field (决定数据行在备份文件中存储的格式)
				[terminated by 'string']  (指定字段间分隔符)
				[optionally enclosed by 'char']  (指定包裹文件中字符值的符号)
				[escaped by 'char']]  (指定转义字符)

		  [lines terminated by 'string']  (指定数据行结束的标志)

		  *.表备份
		  mysql> select * from mysql_test.customers
			  -> into outfile 'E/:BACKUP/backupfile.txt'
			  -> fields terminated by ','
			  -> optionally enclosed by ""
			  -> lines terminated by'?';

		 4)使用load data...infile语句恢复数据
		   *1.将备份导入空表中
            LOAD DATA INFILE ‘file_name.txt’ //指定待导入的数据库备份文件名,文件中保持了待载入数据库的所有数据行;
            INTO TABLE tb1_name       //指定需要导入的表名.
            [FIELDS                   //用于判断字段之间和数据行之间的分割符合;
            [TERMINATED BY ’string’]
            [OPTIONALLY] ENCLOSED BY ’char’]
            [ESCAPED BY ’char’]
            ]
            [LINES
            [STARTING BY ’string’]  //指定一个前缀,导入数据行时,忽略数据行中的该前缀和前缀之间的内容,
                                      如果某行不包括该前缀,则整个数据行被跳过;
            [TERMINATED BY ’string’] //指定一行结束的标志
            ]

		  示例:将备份导入空表中
	      mysql> load data infile 'E/:BACKUP/backupfile.txt'
			  -> into table mysql_test.customers_copy
			  -> fields terminated by ','
			  -> optionally enclosed by ""
			  -> lines terminated by'?';

* 数据库应用设计与开发实例(高校在线选课系统)
** 需求描述与分析(选择填空)
   1>功能性需求:分功能模块(管理员后台模块  学生使用模块  教师使用模块)
   2>非功能需求:在线:B-S:web服务器,浏览器/服务器结构,网卡 wamp(windows(系统) Apache(web服务器) MySQL,PHP)
   3>质量要求:
	   1)可靠性
	   2)正确性
	   3)兼容性
	   4)健壮性(容错性)

** 系统设计(解答实操)

   1>功能模块设计
	  1)登录验证模块

   2>概念设计
	  1)确认实体(局部设计)
		 *1.学生
		 *2.教师
		 *3.课程
		 *4.院系
		 *5.系统管理员
		 *6.管理学生
		 *7.管理教师
		 *8.管理课程
		 *9.管理院系

	  2)将实体转换成E-R图(整体设计)

	       *1.学生(学号,姓名,性别,密码)
		   *2.教师(教师工号,姓名,性别,年龄,职称,密码)
		   *3.课程(课程号,课程名,学分,时间,地点,类别,开课学院,限选人数)
		   *4.院系(院系名称,办公地点,教师人数)
		   *5.系统管理员(姓名,ID号,密码)

	     *.在数据库设计时，实体的描述信息可根据实际需求进行增加或删减，如果实体的属性较多，
		   在构建E-R模型时不一定需要把所有的属性都标识在E-R模型上，可以另外用文字说明，
		   这样也使得E-R模型简明清晰，便于分析。

		 3)联系(1:N和N:M)
		  *1.学生--课程  (选修(N:M))
		  *2.教师--课程  (授课(1:N))
		  *3.教师--院系  (属于(N:1))
		  *4.学生--院系	 (属于(N:1))
		  *5.系统管理员--学生 (管理(M:N))
		  *6.系统管理员--教师 (管理(M:N))
		  *7.系统管理员--课程 (管理(M:N))
		  *8.系统管理员--院系 (管理(M:N))


   3>逻辑结构设计

	     1)逻辑结构设计的任务是把在概念结构设计产生的概念模型转换为具体的DBMS所支持的逻辑数据模型,
	       也就是导出特定的DBMS可以处理的数据库逻辑结构;(***解答题***)

		 2)将E-R图变为关系表

		  *1.学生(学号,性别,姓名,密码,院系编号)
		  *2.教师(工号,性别,姓名,年龄,职称,密码,院系编号)
		  *3.课程(课程号,课程名,学分,地点,类别,时间,开课学院,限选人数,工号)
		  *4.院系(院系编号,系名,学生人数,教师人数)
		  *5.系统管理员(id号,姓名,密码)
		  *6.管理学生(管理员id,学号,操作时间)(中间表(M:N))
		  *7.管理教师(管理员id,学号,操作时间)(中间表(M:N))
		  *8.管理课程(管理员id,课程号,操作时间)(中间表(M:N))
		  *9.管理院系(管理员id,院系编号,操作时间)(中间表(M:N))

   4>规范化设计
		   1:N关系 在多的(N)表中添加1的表中的主键作为N关系表的外键

		   N:M关系 :建立一个中间表,以两表之间的联系为实体,
		            将两边表中的主码作为该表的主键同联系的属性一起作为该表的属性;

	  5>物理结构设计

		1)使用SQL语言创建数据库
		  mysql> create database db_xuanke;

		2)创建关系表,创建(索引)主键.外键

		  增删改查:
		  删改:数据项的用update和delete  表/数据库/视图/索引:alter和drop
		  增查:create和select

		3)设置完整性约束
** 系统实现(解答实操)

	  1>实现数据库行为
	    1)安全控制(限制权限)

		2)数据库保护(触发器trigger)

		3)事物与并发控制(事务配合锁)

		4)数据查询与统计报表(视图)

	  2>应用软件的业务逻辑

	    1)设计可视化页面 html/css实现系统登录验证页面

		2)WAMP--使用PHP编程相应的服务端代码,完成登录验证页面与后台数据库的操作交互
** 系统测试与维护(选择填空)

	  1>登录验证测试

	  2>管理员后台主要功能测试

	  3>各模块测试;
* 数据库管理技术的发展
** 数据库技术发展阶段概述(选择填空)
	  1>人工管理阶段

	  2>文件系统阶段

	  3>数据库系统阶段
		1)第一代数据库系统
		  *1.层次模型数据库管理系统
		  *2.网状模型数据库管理系统(*1是*2的特例)
		  *核心和基础:数据模型;
		          ╭ #1.支持三级模式(外模式,模式,内模式)的体系结构
		          | #2.用存取路径来表示数据之间的联系
		  共同特点<
                  | #3.独立的数据定义语言
                  ╰ #4.导航的数据操纵语言;
		2)第二代数据库系统
		  关系数据库系统
		  *核心和基础:关系模型

		 优点:
		  *1.模型简单清晰
		  *2.理论基础好
		  *3.数据独立性强
		  *4.数据库语言非过程化
		  *5.标准化

		3)第三代数据库系统的特征(OODBS)
		  *1.应支持数据管理,对象管理和知识管理;
		  *2.必须保持或继承第二代数据库系统的技术;
		  *3.必须对其他系统开放;

	    * NoSQL系统支持的数据存储模型。
          *1.键值（Key-Value）存储。常见的键值存储数据库包括Tokyo Cabinet/Tyrant、Redis和Oracle BDB等。
          *2.文档存储。常见的文件型数据库有CouchDB、MongoDB等。
          *3.列存储。常见的列存储数据库有Cassandra、HBase等。
          *4.图存储。图存储数据库是基于图理论构建的，使用结点、属性和边的概念。

        *图灵奖获得者:c.w.Bachman (巴赫曼), E.F.Codd(科德), james Gray(格雷);
** 数据库仓库与数据挖掘

	  1>数据仓库及其特征

	    1)与传统的数据库技术的区别:

		  传统的数据库:操作型处理服务(联机事务处理),数据仓库:分析型处理服务(联机分析处理);

		2)数据仓库(Data Warehouse, DW)是面向主题的,集成的,稳定的,随时间变化的数据集合,
		  用于支持管理决策的过程;(***解答题***)

		  *数据仓库不是可以买到的产品,而是一种面向分析的数据存储方案;

		3)数据仓库特征:
		  *1.面向主题
		  *2.集成性
		  *3.数据的非易失性
		  *4.数据的时变性;

	  2>数据仓库的三个概念

	    1)粒度
		  *是指数据仓库的数据单位中保存数据的细化或综合程度的级别,数据细化的越高,
		   粒度就越小,反之,细化程度越低,粒度级就越大;

		2)分割(切片)

		3)维(度):是人们观察数据的特定角度,是考虑问题时一类属性,此类属性的集合构成了一个维度,例如时间维等;


	 3>数据挖掘

	   1)从大量的,不完全的,有噪声的,模糊的,随机的实际应用数据中发现并提取隐藏在其中的
	     人们事先不知道的,但又是潜在有用信息和知识的一种技术,又称为知识发现;

	   2)功能(***解答题***)

	     *1.概念描述
		 *2.关联分析
		 *3.分类与预测
		 *4.聚类
		 *5.孤立点测试
		 *6.趋势和演变分析

	   3)简述在实际使用中,数据挖掘的过程(***解答题***)

	     *1.确定业务对象
	     *2.数据的选择
	     *3.数据的预处理
	     *4.建模
	     *5.模型评估
	     *6.模型部署
** 大数据管理技术
	  1>大数据及其特征(2008年提出)
		1)大数据是指无法在可容忍的时间内用现有信息技术和软,硬件工具符其进行感知,
		  获取,管理,处理的服务的数据集合;

		2)特征
		 *1.数据量大,即大量化
		 *2.数据种类繁多,即多样化
		 *3.处理速度快,即快速化
		 *4.价值密度低

		3)大数据管理技术的典型代表:
		  1>分布式文件系统;
		  2>key/value非关系数据模型
		  3>MapReduce并行编程模型为代表的众多新技术和新系统;
		    MapReduce技术是Google公司于2004年提出的大规模并行计算解决方案，
		    主要应用于大规模廉价集群上的大数据并行处理。MapReduce以Key/Value的分布式存储系统为基础，
		    通过元数据集中存储、数据以chunk为单位分布存储和数据chunk冗余复制来保证其高可用性。


数据库系统原理PHP部分
** 通过PHP编程语言编写相应的服务端代码,完成前台页面与后台数据的交互操作,
   具体建立与MYSQL数据库服务器的链接.

** PHP内置了许多函数,通过使用内置函数 mysql,PHP程序可以很好地与MYSQL数据库进行交互.

** PHP操作MYSQL数据库的基本步骤如下:
   1>首先建立与MYSQL数据库服务器的连接;
   2>然后要对其进行操作的数据库;
   3>再执行相应的数据库操作,包括对数据的添加,删除,修改和查询等
   4>最后关闭与MYSQL数据库服务器的连接

** 建立数据库连接的方法(mysql()函数的用法)
   //localhost:3306表示连接本地主机中的MYSQL数据库服务器
   mysql_php程序名("localhost:3306","用户名","密码");

   示例:
   编写一个数据库服务器的连接示例程序connect.php,要求以超级用户root及其密码123456
   连接本地主机的MYSQL数据库服务器,并使用$con保存连接的结果,其过程如下:
   connect.php //文件名,用文本编辑器打开编辑

   <?php //php程序时被包含在标记符<?php  ?>之间的代码
     /**
      * php 连接数据库三要素：数据库服务器ip地址、数据库用户名、数据库密码。
      * mysql_connect();连接数据库,返回布尔值,
      * $conn:true:连接成功,false连接失败
      */
     $conn=mysql_connect("localhost:3306","root","123456");//定义变量以$开头
     if(!$conn){
        echo"连接失败!<br>"; //echo语句返回信息
        echo"错误编号: "mysql_errno()"!<br>"; //<br>为换行标记符
        echo"错误信息:"mysql_err()"<br>"; //echo语句返回信息
        die(); //终止程序运行
     }
        echo"连接成功!<br>";
   ?>

